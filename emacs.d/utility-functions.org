# -*- org-insert-tilde-language: emacs-lisp; -*-
#+TITLE: Utility Functions
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+STARTUP: showall
#+OPTIONS: toc:3
#+PROPERTY: header-args:emacs-lisp :comments link

This file contains utility functions that facilitate tasks that are common but not routine.  These functions help provide a consistency in interaction as well as creating common short-cuts to tasks I regularly have performed.

* Prerequisites

Throughout these functions, I make use of the ~grab-mac-link-safari-1~ function.

#+begin_src emacs-lisp
  (use-package grab-mac-link
    :straight t
    :commands (grab-mac-link-safari-1))
#+end_src

* TODO Future Considerations

I’m thinking about how I often reference Github issues or PRs in branches, other issues, other pull requests, daily notes, internal working, and weekly reports.  I want some tools to quickly help me move through those tasks.

Some additional features could be:

- [ ] When in ~markdown-mode~, convert the URL to a Markdown URL
- [X] When in ~org-mode~, convert the  URL to an OrgMode style link (see ~jf/org-insert-link-dwim~).
- [ ] Creating OrgRoam node for an issue, qo that I have a local place to write up any working notes; and reference in my daily journal entries.  However, I'm waiting for [[https://github.com/org-roam/org-roam/issues/2220][some input on a feature request]] before I proceed with a workaround.
- [ ] Jump to my notes for the given branch (created in the above task)
- [-] Assemble things into a gigantic function to:

  - [X] Create a branch from an issue
  - [X] Add a Journal entry saying "Started work on /#"
  - [ ] Create an OrgRoam node for that issue (which would then have a back link to my daily journal entry)

All of this is to help me better navigate throughout my somewhat normalized workflow.

And why do all of this? To sharpen my tools. Practice extending my text editor to facilitate my ever emerging workflow.

* Interactive Functions

- ~jf/abbreviate-url~ :: For the given URL (or prompted URL), convert that URL into an abbreviation.  A todo item is to replace the URL with a mode appropriate link.

#+begin_src emacs-lisp
  (defun jf/abbreviate-url (url)
      "Abbreviate the given URL; prompt if not provided."
      (interactive (list (jf/prompt-for-url-dwim)))
      (let ((abbr (jf/github-abbreviation-for :url url :fallback url)))
	(if (thing-at-point-url-at-point)
	    (apply 'replace-string-in-region
		   (flatten-list
		    (list url
			  abbr
			  (thing-at-point-bounds-of-url-at-point))))
	  (insert abbr))))
#+end_src

- ~jf/git-branch-create~ :: This is the function that gathers the data.  It’s responsible for prompting for the correct project, verifying that Safari’s URL is correct, and then calling the non-interactive function ~jf/git-branch-create~.

#+begin_src emacs-lisp
  (defun jf/git-branch-create (directory url)
    "Create a git branch in project DIRECTORY from URL.

  Call `jf/prompt-for-url-dwim' if no URL is given."
    (interactive (list (projectile-completing-read
			"Project name: "
			projectile-known-projects)
		       (jf/prompt-for-url-dwim)))
    (catch 'not-a-github-repository
      (let* ((suffix (jf/github-abbreviation-for :url url))
	     (prefix (format "%s/%s" jf/github-username "issue"))
	     (branch-name (concat prefix "---" suffix)))
	(message (jf/git-branch-create- :branch-name branch-name :directory directory)))))
#+end_src

- ~jf/git-github-issue-short-ref~ :: Open the current branch’s corresponding issue in Github.  Assumes the branch was constructed in the following format =<github-username>/issues---<owner>/<repo>\#<number>=, which is how ~jf/git-branch-create~ does it.

#+begin_src emacs-lisp
  (cl-defun jf/git-github-issue-short-ref (parg &key (url-template "https://github.com/%s/issues/%s" ))
    "This function will parse the current branch and open the Github issue.

  'With no universal PARG, browse to the associated github issue.
  With universal PARG, insert github short ref.

  Regardless, add the github short ref to the kill ring.

  Plays nicely with `jf/git-branch-create'"
    (interactive "P")
    (let* ((prefix (car parg))
	   (branch (magit-get-current-branch))
	   (gh-short-ref (cadr (s-split "---" branch)))
	   (parts (s-split "#" gh-short-ref))
	   (repo (car parts))
	   (number (cadr parts))
	   (url (format url-template repo number)))
      (kill-new gh-short-ref)
      (message "\"%s\" added to kill-ring" gh-short-ref)
      (if (not prefix)
	  (browse-url url)
	(insert gh-short-ref))))
#+end_src

- ~jf/org-roam-dailies--add-entry-for-url~ :: Take the URL and write an entry for today.

#+begin_src emacs-lisp
  (defun jf/org-roam-dailies--add-entry-for-url (url)
    "Add URL to today's org-roam-dailies entry."
    (interactive (list (jf/prompt-for-url-dwim)))
    (let* ((abbr (jf/github-abbreviation-for :url url :fallback t)))
      (org-roam-dailies-capture-today)
      (insert (format "Started [[%s][%s]]" url abbr))))
#+end_src

- ~jf/prompt-for-url-dwim~ :: Not an interactive function, but used as the prompt for an ~interactive~ function.  It will make a few “guesses” on where to look for the URL (at point, kill-ring, given function).

#+begin_src emacs-lisp
  (cl-defun jf/prompt-for-url-dwim (&key (url-regexp "^https?://"))
    "Prompt and return a url.

      If the `thing-at-point-url-at-point' use that, otherwise
      check the `kill-ring' matches the given URL-REGEXP.  And if
      not that, apply the given `fn' (which should return a url and
      title."
    (read-string "URL: "
		 (or (thing-at-point-url-at-point)
		     (let ((car-of-kill-ring (substring-no-properties (car kill-ring))))
		       (if (string-match url-regexp car-of-kill-ring)
			   car-of-kill-ring
			 (car (grab-mac-link-safari-1)))))))
#+end_src

- ~jf/start-work-on-url~ :: With the given URL, start “working” on it:
  - Prompt for a URL
  - Create an ~org-roam~ node for the URL

#+begin_src emacs-lisp
  (defun jf/start-work-on-url (url)
    (interactive (list (jf/prompt-for-url-dwim)))
    (let* ((abbr (jf/github-abbreviation-for :url url :fallback t))
	   ;; The refs do not have their schemes
	   (node (org-roam-ref-read (replace-regexp-in-string "^[[:alpha:]]+:" "" url))))
      (if node
	  (message "Node \"%s\" already exists" (org-roam-node-title node))
	(progn
	  ;; Create a node
	  ;; Insert ref
	  ;; Insert alias (if any)
	  ;; Re-find ref
	  ;; Capture daily item
	  ))))
#+end_src

* Support Functions

- ~jf/auto-create-missing-dirs~ :: Ensure that we create the directories along the path of a new file I’m creating.  See [[https://emacsredux.com/blog/2022/06/12/auto-create-missing-directories/][Auto-create Missing Directories]].

#+begin_src emacs-lisp
  (defun jf/auto-create-missing-dirs ()
    (let ((target-dir (file-name-directory buffer-file-name)))
      (unless (file-exists-p target-dir)
	(make-directory target-dir t))))

  (add-to-list 'find-file-not-found-functions #'jf/auto-create-missing-dirs)
#+end_src

- ~jf/git-branch-create-~ :: This function manipulates the git repository.  We have a valid (enough) directory and a new branch-name, now let’s do the file system work to ensure we can safely do this work.

#+begin_src emacs-lisp
  (cl-defun jf/git-branch-create- (&key branch-name directory (starting-branch "main"))
    "Create BRANCH-NAME from STARTING-BRANCH in DIRECTORY.  Ensure clean state."
    (catch 'dirty-branch
      (let* ((default-directory directory))
	(unless (eq 0 (length (shell-command-to-string "git status --porcelain")))
	  (throw 'dirty-branch
		 (format
		  "Repository \"%s\" is dirty repository."
		  default-directory)))

	(magit-branch-checkout starting-branch)

	(magit-pull-from-upstream "--rebase")

	(unless (eq 0 (length (shell-command-to-string "git status --porcelain")))
	  (throw 'dirty-branch
		 (format
		  "After updating from remote, repository \"%s\" is dirty repository."
		  default-directory)))

	(magit-branch-create branch-name starting-branch)
	(magit-branch-checkout branch-name))
      (format "Created branch on %s" directory)))
#+end_src

- ~jf/github-abbreviation-for~ :: This function converts a Github URL into it’s abbreviation (e.g. ~<owner>/<repo>#<number>~).  If the given URL is not a Github URL we have a few options:  Fallback to the URL /or/ throw an exception.

#+begin_src emacs-lisp
  (cl-defun jf/github-abbreviation-for (&key url fallback)
    "Convert the URL to a github abbreviation"
    (if (string-match "^https://github\\.com/[^/]+/[^/]+/\\(issues\\|pull\\)/[[:digit:]]+" url)
	(let ((slugs (split-string url "/")))
	  (format  "%s/%s#%s" (nth 3 slugs) (nth 4 slugs) (nth 6 slugs)))
      (if fallback
	  url
	(throw 'not-a-github-repository (message "Expected URL \"%s\" to be a Github Issue or Pull URL." url)))))
#+end_src

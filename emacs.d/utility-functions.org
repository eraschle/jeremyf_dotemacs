# -*- org-insert-tilde-language: emacs-lisp; -*-
#+TITLE: Utility Functions
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+STARTUP: showall
#+OPTIONS: toc:3
#+PROPERTY: header-args:emacs-lisp :comments link

This file contains utility functions that facilitate tasks that are common but not routine.  These functions help provide a consistency in interaction as well as creating common short-cuts to tasks I regularly have performed.

* Prerequisites

Throughout these functions, I make use of the ~grab-mac-link-safari-1~ function.

#+begin_src emacs-lisp
  (use-package grab-mac-link
    :straight t
    :commands (grab-mac-link-safari-1))
#+end_src

* TODO Future Considerations

I’m thinking about how I often reference Github issues or PRs in branches, other issues, other pull requests, daily notes, internal working, and weekly reports.  I want some tools to quickly help me move through those tasks.

Some additional features could be:

- [ ] When in ~markdown-mode~, convert the URL to a Markdown URL
- [X] When in ~org-mode~, convert the  URL to an OrgMode style link (see ~jf/org-insert-link-dwim~).
- [ ] Creating OrgRoam node for an issue, qo that I have a local place to write up any working notes; and reference in my daily journal entries.  However, I'm waiting for [[https://github.com/org-roam/org-roam/issues/2220][some input on a feature request]] before I proceed with a workaround.
- [ ] Jump to my notes for the given branch (created in the above task)
- [-] Assemble things into a gigantic function to:

  - [X] Create a branch from an issue
  - [X] Add a Journal entry saying "Started work on /#"
  - [ ] Create an OrgRoam node for that issue (which would then have a back link to my daily journal entry)

All of this is to help me better navigate throughout my somewhat normalized workflow.

And why do all of this? To sharpen my tools. Practice extending my text editor to facilitate my ever emerging workflow.

* Interactive Functions

#+begin_src emacs-lisp
  ;; For the given URL (or prompted URL), convert that URL into an abbreviation.
  ;; A todo item is to replace the URL with a mode appropriate link.
  (defun jf/abbreviate-url (url)
    "Abbreviate the given URL; prompt if not provided."
    (interactive (list (jf/prompt-for-url-dwim)))
    (let ((abbr (jf/github-abbreviation-for :url url :fallback url)))
      (if (thing-at-point-url-at-point)
	  ;; Replace the URL of the thing at point
	  (apply 'replace-string-in-region
		 (flatten-list
		  (list url
			abbr
			(thing-at-point-bounds-of-url-at-point))))
	;; Else insert the URL at point
	(insert abbr))))
#+end_src

#+begin_src emacs-lisp
  ;; This function advices several “at point” functions to find org nodes by
  ;; their ID.
  (defun jf/follow-thing-at-point (fn &rest args)
    "Lookup org-id for `thing-at-point'.  If it exists, open it.

  Otherwise apply FN with ARGS."
    (let* ((node-id (format "%s" (thing-at-point 'symbol)))
	   (node (jf/org-id-find-id-file node-id)))
      (if node
	  (find-file node)
	(apply fn args))))

  (defun jf/org-id-find-id-file (id)
    "Query the id database for the file in which ID is located.

  Unlike `org-id-find-id-file' this does not fallback to the current file."
    (unless org-id-locations (org-id-locations-load))
    (and org-id-locations
	     (hash-table-p org-id-locations)
	     (gethash id org-id-locations)))

  (advice-add #'org-open-at-point :around #'jf/follow-thing-at-point '((name . "wrapper")))
  (advice-add #'markdown-follow-thing-at-point :around #'jf/follow-thing-at-point '((name . "wrapper")))
  (advice-add #'xref-find-definitions :around #'jf/follow-thing-at-point '((name . "wrapper")))
  (advice-add #'org-open-at-point-global :around #'jf/follow-thing-at-point '((name . "wrapper")))
#+end_src

#+begin_src emacs-lisp
  (defun jf/git-branch-create (directory url)
    "Create a git branch in project DIRECTORY from URL.

  Call `jf/prompt-for-url-dwim' if no URL is given."
    (interactive (list
		  ;; Prompt for the project's DIRECTORY
		  (projectile-completing-read
		   "Project name: "
		   projectile-known-projects)
		  ;; Prompt for the URL
		  (jf/prompt-for-url-dwim)))
    (catch 'not-a-github-repository
      (let* ((suffix (jf/github-abbreviation-for :url url))
	     (prefix (format "%s---%s" jf/github-username "issue"))
	     (branch-name (concat prefix "---" suffix)))
	;; Create the branch and "report" back.
	(message (jf/git-branch-create- :branch-name branch-name :directory directory)))))
#+end_src

#+begin_src emacs-lisp
  (cl-defun jf/git-github-issue-short-ref (parg &key (url-template "https://github.com/%s/issues/%s" ))
    "This function will parse the current branch and open the Github issue.

  'With no universal PARG, browse to the associated github issue.
  With universal PARG, insert github short ref.

  Regardless, add the github short ref to the kill ring.

  Plays nicely with `jf/git-branch-create'"
    (interactive "P")
    (let* ((prefix (car parg))
	   (branch (magit-get-current-branch))
	   (gh-short-ref (cadr (s-split "---" branch)))
	   (parts (s-split "#" gh-short-ref))
	   (repo (car parts))
	   (number (cadr parts))
	   (url (format url-template repo number)))
      (kill-new gh-short-ref)
      (message "\"%s\" added to kill-ring" gh-short-ref)
      (if (not prefix)
	  (browse-url url)
	(insert gh-short-ref))))
#+end_src

#+begin_src emacs-lisp
  ;; Take the URL and write an entry for today.
  (defun jf/org-roam-dailies--add-entry-for-url (url)
    "Add URL to today's org-roam-dailies entry."
    (interactive (list (jf/prompt-for-url-dwim)))
    (let* ((abbr (jf/github-abbreviation-for :url url :fallback t)))
      (org-roam-dailies-capture-today)
      (insert (format "Started [[%s][%s]]" url abbr))))
#+end_src

#+begin_src emacs-lisp
  ;; Not an interactive function, but used as the prompt for an `interactive'
  ;; function.  It will make a few “guesses” on where to look for the URL (at
  ;; point, kill-ring, given function).
  (cl-defun jf/prompt-for-url-dwim (&key (url-regexp "^https?://"))
    "Prompt and return a url.

      If the `thing-at-point-url-at-point' use that, otherwise
      check the `kill-ring' matches the given URL-REGEXP.  And if
      not that, apply the given `fn' (which should return a url and
      title."
    (read-string "URL: "
		 (or (thing-at-point-url-at-point)
		     (let ((car-of-kill-ring (substring-no-properties (car kill-ring))))
		       (if (string-match url-regexp car-of-kill-ring)
			   car-of-kill-ring
			 (car (grab-mac-link-safari-1)))))))
#+end_src

- ~jf/start-work-on-url~ :: With the given URL, start “working” on it:
  - Prompt for a URL
  - Create an ~org-roam~ node for the URL

#+begin_src emacs-lisp
  (defun jf/start-work-on-url (url)
    (interactive (list (jf/prompt-for-url-dwim)))
    (let* ((abbr (jf/github-abbreviation-for :url url :fallback t))
	   ;; The refs do not have their schemes
	   (node (org-roam-ref-read (replace-regexp-in-string "^[[:alpha:]]+:" "" url))))
      (if node
	  (message "Node \"%s\" already exists" (org-roam-node-title node))
	(progn
	  ;; Create a node
	  ;; Insert ref
	  ;; Insert alias (if any)
	  ;; Re-find ref
	  ;; Capture daily item
	  ))))
#+end_src

* Support Functions

#+begin_src emacs-lisp
  ;; This function manipulates the git repository.  We have a valid (enough)
  ;; directory and a new branch-name, now let’s do the file system work to ensure
  ;; we can safely do this work.
  (cl-defun jf/git-branch-create- (&key branch-name directory (starting-branch "main"))
    "Create BRANCH-NAME from STARTING-BRANCH in DIRECTORY.  Ensure clean state."
    (catch 'dirty-branch
      (let* ((default-directory directory))
	(unless (eq 0 (length (shell-command-to-string "git status --porcelain")))
	  (throw 'dirty-branch
		 (format
		  "Repository \"%s\" is dirty repository."
		  default-directory)))

	(magit-branch-checkout starting-branch)

	(magit-pull-from-upstream "--rebase")

	(unless (eq 0 (length (shell-command-to-string "git status --porcelain")))
	  (throw 'dirty-branch
		 (format
		  "After updating from remote, repository \"%s\" is dirty repository."
		  default-directory)))

	(magit-branch-create branch-name starting-branch)
	(magit-branch-checkout branch-name))
      (format "Created branch on %s" directory)))
#+end_src

#+begin_src emacs-lisp
  ;; This function converts a Github URL into it’s abbreviation
  ;; (e.g. ~<owner>/<repo>#<number>~).  If the given URL is not a Github URL we
  ;; have a few options: Fallback to the URL /or/ throw an exception.
  (cl-defun jf/github-abbreviation-for (&key url fallback)
    "Convert the URL to a github abbreviation"
    (if (string-match "^https://github\\.com/[^/]+/[^/]+/\\(issues\\|pull\\)/[[:digit:]]+" url)
	(let ((slugs (split-string url "/")))
	  (format  "%s/%s#%s" (nth 3 slugs) (nth 4 slugs) (nth 6 slugs)))
      (if fallback
	  url
	(throw 'not-a-github-repository (message "Expected URL \"%s\" to be a Github Issue or Pull URL." url)))))
#+end_src

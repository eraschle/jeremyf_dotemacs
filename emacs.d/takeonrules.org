# -*- lexical-binding: t; org-insert-tilde-language: emacs-lisp; -*-
:PROPERTIES:
:ID:       C6186B18-0AEC-4863-B9D6-46BE400815F1
:END:
#+TITLE: Take on Rules
#+SUBTITLE: Or How I Want to Test This Thing Out
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+FILETAGS: :takeonrules:
#+STARTUP: showall
#+OPTIONS: toc:3

* Org Export

I want to add a custom org exporter for [[id:C8741E14-55FB-4250-A43B-2CCFB74A7A59][Take on Rules]].  First, I need to ensure
that I have required ~ox~.

#+BEGIN_SRC emacs-lisp
  (require 'ox)

  (use-package ox-hugo
    :straight t
    :custom (org-hugo-paired-shortcodes "marginnote sidenote")
    :after ox)

  (setq org-hugo-base-dir "~/git/takeonrules.source")

  (defvar jf/org-macros-setup-filename
    "~/git/dotemacs/lib/org-macros.setup"
    "The path to the file that has inline org macros.")

  (with-eval-after-load 'ox-hugo
    (add-to-list 'org-hugo-special-block-type-properties '("sidenote" . (:trim-pre t :trim-post t))))
#+END_SRC

I use ~org-roam~ for my organization, so I’m assuming I’ll be exporting one
file at a time.  I have considered using [[https://ox-hugo.scripter.co/][ox-hugo]], but it’s not quite what I’m
after.  In [[id:23288DD9-9559-4870-A0BE-E01087A8EC5D][Migrating from Hugo to Org]], a private file, I considered what to do.
/Note: When I use org’s export for this file, there shouldn’t be a link for
Migrating from Hugo to Org.  However, those of you reading this file outside of
the export will have a link to a Not Found resource/

** Extending the Ox

When I’m exporting an ~org~ file, it likely includes links to files on my file-system.  However, in that export, it’s not overly helpful to provide links to those personal files.

Instead, I want to leverage [[https://www.orgroam.com/manual.html#Refs-1][org-roam ~ROAM_REFS~ property]].  During export, if the link is an ~id~ link, I’ll assume it’s an internal reference.  When that internal reference has a ~ROAM_REFS~ property, I’ll use that as the URL.  Otherwise, I’ll assume I haven’t “exported” that document, and will instead render the description.

In the following ~jf/org-tor-link~, when the given link is an ~ID~ type link, I call my custom link handler (e.g. ~jf/org-md-link-by-id~).  Otherwise, I use the given funtion.

#+begin_src emacs-lisp
  (defun jf/org-tor-link (fn link desc &rest rest)
    "Conditional LINK and DESC rendering for ID-based links.

    Otherwise `apply' the FN with the REST of the parameters."
    (if (string= "id" (org-element-property :type link))
	(jf/org-md-link-by-id link desc)
      (apply fn link desc rest)))

  (advice-add #'org-md-link :around #'jf/org-tor-link '((name . "wrapper")))
  (advice-add #'org-hugo-link :around #'jf/org-tor-link '((name . "wrapper")))
#+end_src

The ~jf/org-md-link-by-id~ function checks the link to see if the node in ~org-roam~ database has an associated URL.

When it does, use that URL.

When it does not have a URL, then I assume the node is an internal node and wrap the description in a ~span~ tag.

#+begin_src emacs-lisp
    (defun jf/org-md-link-by-id (link desc)
      "With an \"id\" type LINK render the markdown.

    If the node for the given \"id\" has a ROAM_REF, use that as a markdown URL.
    Otherwise render a span with DESC.

    This prevents links to non-world accessible files."
      (let* ((filepath (org-id-find-id-file (org-element-property :path link)))
	     (url (jf/org-file-get-roam-refs filepath)))
	(if url (format "[%s](%s)" desc url)
	  (format "<span class=\"ref\">%s</span>" desc))))
#+end_src

For a given filepath, the ~jf/org-file-get-roam-refs~ finds the first [[https://www.orgroam.com/manual.html#Refs][ROAM_REFS]].  In my implementation, the ROAM_REFS is often one URL for which the ~org-roam~ node is a proxy for that URL.

#+begin_src emacs-lisp
  (cl-defun jf/org-file-get-roam-refs (filepath)
    "Return first ROAM_REFS property in the FILEPATH."
    (with-current-buffer (find-file-noselect filepath)
      (car (org-property-values "ROAM_REFS"))))
#+end_src

** Wrapping Ox Exporter

While the org export dispatcher is quite nice, I’m going to write
~jf/export-org-to-tor~ to handle the export.  That function is responsible for
two concerns:

1. Ensuring that I have all of the necessary front-matter.
2. Performing the export.

/Note: at present my blog assumes Markdown front-matter./

#+begin_src emacs-lisp
  (cl-defun jf/export-org-to-tor (&key (buffer (current-buffer)))
    "Export current org buffer for TakeOnRules post."
    (interactive)
    ;; Ensure that we have an ID property.
    (with-current-buffer buffer
      (save-excursion
	(let* ((org_id (jf/export-org-to-tor--ensure-org-id-property))
	       (drawer (jf/export-org-to-tor--ensure-drawer "HUGO"))
	       (export-global-plist (jf/org-global-props-as-plist))
	       ;; Note this will be added after the :PROPERTIES::END:
	       (section (jf/export-org-to-tor--global-buffer-prop-ensure
			 :key "HUGO_SECTION"
			 :plist export-global-plist
			 :drawer drawer
			 :default (format-time-string "posts/%Y")))
	       (base_dir (jf/export-org-to-tor--global-buffer-prop-ensure
			  :key "HUGO_BASE_DIR"
			  :plist export-global-plist
			  :drawer drawer
			  :default "~/git/takeonrules.source"))
	       (format (jf/export-org-to-tor--global-buffer-prop-ensure
			:key "HUGO_FRONT_MATTER_FORMAT"
			:plist export-global-plist
			:drawer drawer
			:default "yaml"))
	       (subtitle (jf/export-org-to-tor--global-buffer-prop-ensure
			  :key "SUBTITLE"
			  :plist export-global-plist))
	       (title (jf/export-org-to-tor--global-buffer-prop-ensure
		       :key "TITLE"
		       :plist export-global-plist)))
	  (save-buffer)
	  (jf/export-org-to-tor--inject-additional-front-matter
	   :subtitle subtitle
	   :title title
	   :org_id org_id
	   :drawer drawer)
	  ;; Write metadata
	  (save-buffer)
	  (unless org-transclusion-mode (org-transclusion-mode))
	  (org-open-file (org-hugo-export-wim-to-md nil nil t))))))

  (defun jf/export-org-to-tor--ensure-org-id-property ()
    "Ensure the current buffer has an ID property."
    (beginning-of-buffer)
    (org-id-get-create))

  (defun jf/export-org-to-tor--ensure-drawer (name)
    "Ensure that a top-level drawer with the given NAME."
    (beginning-of-buffer)
    (if (search-forward-regexp
	 (format ":%s:\n\\(.\\|\n\\)+?:END:\n" (upcase name))
	 nil t)
	(upcase name)
      (progn
	(beginning-of-buffer)
	(search-forward-regexp ":PROPERTIES:\n\\(.\\|\n\\)+?:END:\n")
	(insert (format ":%s:\n:END:\n" (upcase name)))
	(upcase name))))

  (cl-defun jf/export-org-to-tor--inject-additional-front-matter (&key org_id subtitle title drawer)
    "Export additional front matter.

    We want to ensure that we export the ORG_ID, SUBTITLE, and TITLE.
    And add relevant metadata.
    When DRAWER is not nil, put the front-matter in the drawer."
    (beginning-of-buffer)
    (search-forward-regexp "#\\+HUGO_FRONT_MATTER_FORMAT: yaml")
    (insert (concat
	     "\n#+HUGO_CUSTOM_FRONT_MATTER: :slug " (jf/tor-convert-text-to-slug title)
	     "\n#+HUGO_CUSTOM_FRONT_MATTER: :headline " subtitle
	     ;; 2022-02-26 07:46:15.000000000 -04:00
	     "\n#+HUGO_CUSTOM_FRONT_MATTER: :date " (format-time-string "%Y-%m-%d %H:%M:%S %z")
	     "\n#+HUGO_CUSTOM_FRONT_MATTER: :type post"
	     "\n#+HUGO_CUSTOM_FRONT_MATTER: :layout post"
	     "\n#+HUGO_CUSTOM_FRONT_MATTER: :licenses '(all-rights-reserved)"
	     "\n#+HUGO_CUSTOM_FRONT_MATTER: :draft true"
	     "\n#+HUGO_CUSTOM_FRONT_MATTER: :org_id " org_id
	     "\n#+INCLUDE: " jf/org-macros-setup-filename)
	    )
    (let ((date (car (org-property-values "SESSION_REPORT_DATE"))))
      (when date
	(let ((game (car (org-property-values "SESSION_REPORT_GAME")))
	      (location (car (org-property-values "SESSION_REPORT_LOCATION"))))
	  (insert
	   (format
	    "\n#+HUGO_CUSTOM_FRONT_MATTER: :sessionReport '((date . \"%s\") (game . \"%s\") (location . \"%s\"))"
	    date game location))))))

  (cl-defun jf/export-org-to-tor--global-buffer-prop-ensure (&key key plist (default nil) drawer)
    "Ensure the current buffer has the given KEY in the global PLIST, if not set the DEFAULT or prompt for it."
    (let ((value (lax-plist-get plist key)))
      (if value value
	(jf/export-org-to-tor--global-buffer-prop-set
	 :key key
	 :drawer drawer
	 :value (or default (read-from-minibuffer (format "%s: " key)))))))

  (cl-defun jf/export-org-to-tor--global-buffer-prop-set (&key key value drawer)
    "Set the global property named KEY to the VALUE for the current buffer"
    (beginning-of-buffer)
    (if drawer
	(search-forward-regexp (format "^:%s:\n" drawer))
      (search-forward-regexp ":PROPERTIES:\n\\(.\\|\n\\)+?:END:\n"))
    (insert (format "#+%s: %s\n" (upcase key) value)))

  (defvar jf/tor-session-report-location
    '("around the table" "via Zoom" "via Discord and Roll20")
    "TakeOnRules session report locations")

  (cl-defun jf/org-tag-as-session-report (&key (buffer (current-buffer)))
    "Set the current BUFFER as a \"session-report\".

    This involves adding a FILETAG and metadata around the details of the session report."
    (interactive)
    (with-current-buffer buffer
      (save-excursion
	(beginning-of-buffer)
	(jf/export-org-to-tor--ensure-org-id-property)
	(org-roam-tag-add '("session-report"))
	(let* ((date (org-read-date nil nil nil "Session Date"))
	       (game (completing-read "Game: " (jf/tor-game-list)))
	       (location (completing-read "Location: " jf/tor-session-report-location)))
	  (org-set-property "SESSION_REPORT_DATE" date)
	  (org-set-property "SESSION_REPORT_GAME" game)
	  (org-set-property "SESSION_REPORT_LOCATION" location)))))

  (defun jf/org-global-props-as-plist ()
    (-flatten (mapcar (lambda (prop)
			(list (org-element-property :key prop)
			      (org-element-property :value prop)))
		      (jf/org-global-props "\\(FILETAGS\\|HUGO_FRONT_MATTER_FORMAT\\|HUGO_SECTION\\|HUGO_BASE_DIR\\|TITLE\\|SUBTITLE\\)"))))

  (defun jf/org-global-props (&optional property)
    "Get the plists of global org properties of current buffer."
    (unless property (setq property "PROPERTY"))
    (org-element-map
	(org-element-parse-buffer)
	'keyword
      (lambda (el)
	(when (string-match property (org-element-property :key el)) el))))
#+end_src

** Jumping from the Blog Markdown File to Org File

Given that I have files in my [[id:1173D588-E239-4B13-BFA6-0C670DCE484A][Hugo]] source directory, I want a way to jump to the corresponding [[id:1D7B007F-C257-412E-B329-3E85AB8BC43E][Org-Mode]] file.

#+begin_src emacs-lisp
  (cl-defun jf/jump_to_corresponding_org_file (&key (buffer (current-buffer)))
    "Find the org id in the BUFFER and jump to corresponding file."
    (interactive)
    (with-current-buffer buffer
      (save-excursion
	(beginning-of-buffer)
	(save-match-data
	  (if (re-search-forward "\norg_id: \\(.+\\)\n" nil t)
	      (find-file (org-id-find-id-file (match-string 1)))
	    (message "Unable to find org_id: in document"))))))
#+end_src

** Creating a Scene for Session Notes

#+begin_quote
YOU CAN NOT HAVE A MEANINGFUL CAMPAIGN IF STRICT TIME RECORDS ARE NOT KEPT.
--- Dungeon Master’s Guide (1979)
#+end_quote

In [[https://takeonrules.com/2017/04/30/heeding-gygaxs-admonition/][Heeding Gygax's Admonition]] I spent time crafting up a calendar.  For various session notes, I want to start attaching dates to scenes.

#+begin_src emacs-lisp
  (cl-defun jf/org-tag-session-scene-with-date (date &key (tags '("scene")) (buffer (current-buffer)))
    "Tag the BUFFER with the TAGS and prompt for the DATE in which the scene occurred."
    (interactive (list (completing-read "Scene Date: " (jf/org-macro-value-list "scene-date"))))
    (save-excursion
      (org-roam-tag-add tags)
      (beginning-of-buffer)
      (search-forward "#+FILETAGS:")
      (next-line)
      (insert (concat "\n{{{scene-date(" date ")}}}\n"))))
#+end_src

** Extracting a Blockquote Mechanism

As I’ve moved towards blogging in org-mode, I’ve started capturing more information in ~org-roam~ nodes.  This includes quotes.  My goal is to structure each quote that I can declare it as an epigraph /or/ a blockquote.

These functions with ~./lib/org-macros.setup~.

#+begin_src emacs-lisp
  (defun jf/blockquote-hugo (node-id)
    "Export the blockquote for the given NODE-ID"
    (let ((data (jf/org-mode-extract-body-and-properties node-id)))
      (concat
       "\n{{{< blockquote " (jf/hugo-blockquote-attributes-for (plist-get data :properties)) ">}}}\n"
       (format "%s" (plist-get data :body))
       "\n{{{< /blockquote >}}}\n")))

  (defun jf/hugo-blockquote-attributes-for (properties)
    "Map the PROPERTIES to attributes."
    (seq-mapcat (lambda (element)
		  (let ((key (car element))
			(text (cadr element)))
		    (pcase key
		      ("ID" (format "orgId=\"%s\" " text))
		      ("TITLE" (format "cite=\"%s\" " text))
		      ("CITE_URL" (format "citeUrl=\"%s\" " text))
		      ("AUTHOR" (format "pre=\"%s\" " text))
		      ("CITE_POST" (format "post=\"%s\" " text))
		      (_ ""))))
		properties))

  (defun jf/org-mode-get-keyword-key-value (kwd)
    "Map KWD to list."
    (let ((data (cadr kwd)))
      (list (plist-get data :key)
	    (plist-get data :value))))

  (cl-defun jf/org-mode-extract-body-and-properties (node-id)
    "Extract quotable body and properties from NODE-ID."
    (with-current-buffer (find-file-noselect (org-id-find-id-file node-id))
      (list :properties (org-element-map (org-element-parse-buffer 'object)
			    '(keyword node-property)
			  #'jf/org-mode-get-keyword-key-value)
	    :body (jf/org-mode-extract-body-from-current-buffer))))


  (defun jf/org-mode-extract-body-from-current-buffer ()
    "Extract the body from the current org-mode body"
    (buffer-substring (save-excursion
			(jf/org-mode-find-point-that-starts-body t)
			(point))
		      (org-entry-end-position)))

  (defun jf/org-mode-find-point-that-starts-body (&optional unsafe)
    "Skip headline, planning line, and all drawers in current entry.
    If UNSAFE is non-nil, assume point is on headline."
    (unless unsafe
      ;; To improve performance in loops (e.g. with `org-map-entries')
      (org-back-to-heading))
    (cl-loop for element = (org-element-at-point)
	     for pos = (pcase element
			 (`(headline . ,_) (org-element-property :contents-begin element))
			 (`(,(or 'planning 'property-drawer 'node-property 'keyword 'drawer) . ,_) (org-element-property :end element)))
	     while pos
	     do (goto-char pos)))
#+end_src

Some helper methods for to aid in opening files.

#+begin_src emacs-lisp
  (defun jf/follow-thing-at-point (fn &rest args)
    "Lookup org-id for `thing-at-point'.  If it exists, open it.

  Otherwise apply FN with ARGS."
    (let* ((node-id (format "%s" (thing-at-point 'symbol)))
	   (node (jf/org-id-find-id-file node-id)))
      (if node
	  (find-file node)
	(apply fn args))))

  (defun jf/org-id-find-id-file (id)
    "Query the id database for the file in which ID is located.

  Unlike `org-id-find-id-file' this does not fallback to the current file."
    (unless org-id-locations (org-id-locations-load))
    (or (and org-id-locations
	     (hash-table-p org-id-locations)
	     (gethash id org-id-locations))
	nil))

  (advice-add #'org-open-at-point :around #'jf/follow-thing-at-point '((name . "wrapper")))
  (advice-add #'markdown-follow-thing-at-point :around #'jf/follow-thing-at-point '((name . "wrapper")))
  (advice-add #'xref-find-definitions :around #'jf/follow-thing-at-point '((name . "wrapper")))
#+end_src

#+RESULTS:

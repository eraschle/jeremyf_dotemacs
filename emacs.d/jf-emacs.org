#+title: Emacs configuration
#+author: Jeremy Friesen
#+email: jeremy@jeremyfriesen.com
#+language: en
#+options: ':t toc:nil author:t email:t num:t
#+startup: content
#+macro: latest-export-date (eval (format-time-string "%F %T %z"))
#+macro: word-count (eval (count-words (point-min) (point-max)))

This is my Emacs configuration; drawing inspiration from [[https://protesilaos.com/emacs/dotemacs][Protesilaos Stavrou‚Äôs GNU Emacs configuration]].

To update the Emacs setup either:

- Evaluate the following code block
- Invoke =M-x org-babel-tangle= (default key-binding of =C-c C-v C-t=)

#+begin_src emacs-lisp :tangle no :results none
(org-babel-tangle)
#+end_src

#+toc: headlines 3 insert TOC here, with three headline levels

* About

I once had a literate configuration, however I found iterating on it to be a bit more challenging.  Given that Prot maintains numerous packages, and uses a literate config, I figured I would begin once again exploring the literate approach.

My current strategy, as of <2023-12-20 Wed>, is to move my files into source code blocks and then begin the documentation process.

* Early Initializiation (=early-init.el=)

#+begin_src emacs-lisp :tangle "early-init.el" :results none
  ;; Warning this `most-positive-fixnum' should not be the "resting" value.  After
  ;; we're done with initialization we want to set it to something more agreeable
  ;; (e.g. 20 MB or so)
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6)

  ;; Same idea as above for the `file-name-handler-alist' and the
  ;; `vc-handled-backends' with regard to startup speed optimisation.
  ;; Here I am storing the default value with the intent of restoring it
  ;; via the `emacs-startup-hook'.
  (defvar jf-emacs--file-name-handler-alist file-name-handler-alist)
  (defvar jf-emacs--vc-handled-backends vc-handled-backends)
  (setq file-name-handler-alist nil
        vc-handled-backends nil)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 1024 1024 20)
                    gc-cons-percentage 0.2
                    file-name-handler-alist prot-emacs--file-name-handler-alist
                    vc-handled-backends prot-emacs--vc-handled-backends)))

  ;; From straight.el, "Users of Emacs versions >= 27 will want to add
  ;; the following:"
  (setq package-enable-at-startup nil)
#+end_src

* Initialization (=init.el=)

** =init.el=
#+begin_src emacs-lisp :tangle "init.el" :results none
    ;;; init.el --- Summary:
    ;;; -*- lexical-binding: t; -*-
  ;;
  ;;  Emacs configuration for Jeremy Friesen
  ;;
    ;;; Commentary:
  ;;
  ;;  This is my journey into Emacs.  Let's see where we go!
  ;;
    ;;; CODE:
  (add-to-list 'load-path "~/git/dotemacs/emacs.d")
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file :noerror)

  (require 'jf-launching)
  (require 'jf-minor-mode-maker)
  (require 'jf-illuminating)
  (require 'jf-navigating)
  (require 'jf-fonts-and-iconography)
  (require 'jf-windows)
  (require 'jf-utility)
  (require 'jf-completing)
  (require 'jf-coding)
  (require 'jf-organizing)
  (require 'jf-framing)
  (require 'jf-utility)
  (require 'jf-writing)
  (require 'jf-communicating)
  (require 'jf-org-mode)
  (require 'jf-denote)
  (require 'jf-reading)
  (require 'jf-versioning)
  (require 'jf-quick-help)
  (require 'jf-gaming)
  (require 'jf-blogging)
  (require 'jf-project)
  (require 'jf-menus)
  (require 'jf-capf-hacking)
  (require 'jf-experiments)
  (require 'git-related)
  (require 'dig-my-grave)
  ;; (require 'jf-project-theme-colors)
  (load "~/git/dotemacs/emacs.d/random-tables-data.el")

  (setq jf/artist-mode-spraycan "üûÑ‚Åõ‚óåüûÜ‚äñ‚äó‚Åõ‚óè‚óØ‚¶ø‚¨§")
  (load (concat user-emacs-directory "hide-comnt.el") :noerror)

  (require 'server)
  (setq server-client-instructions nil)
  (unless (server-running-p)
    (server-start))

  (add-hook 'after-init-hook #'jf/enable-indent-for-tab-command)

  (provide 'init)
    ;;; init.el ends here
#+end_src


* Packages

** =dig-my-grave.el=
#+begin_src emacs-lisp :tangle "dig-my-grave.el" :results none
  ;;; dig-my-grave --- Expand triple backtick/grave character -*- lexical-binding: t -*-

  ;; Copyright (C) 2023 Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.

  ;;; License

  ;; Copyright 2023 Jeremy Friesen <jeremy@jeremyfriesen.com>
  ;;
  ;; Licensed under the Apache License, Version 2.0 (the "License");
  ;; you may not use this file except in compliance with the License.
  ;; You may obtain a copy of the License at
  ;;
  ;;    http://www.apache.org/licenses/LICENSE-2.0
  ;;
  ;; Unless required by applicable law or agreed to in writing, software
  ;; distributed under the License is distributed on an "AS IS" BASIS,
  ;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ;; See the License for the specific language governing permissions and
  ;; limitations under the License.

  ;;; Commentary:

  ;; I used to write a lot of Markdown.  And the triple grave character
  ;; (e.g. ‚Äú```‚Äù) is a wonderful convenience for indicating code blocks.  This
  ;; package builds on that idea and repurposes the triple backtick to a quick
  ;; prompt that feels idiomatic to Markdown's triple backtick.

  ;;; Code:

  (require 'org)

  (defvar dig-my-grave/templates-alist/org-mode
    '(("Bash" . "#+begin_src bash :results scalar replace :exports both :tangle yes\n#+end_src")
       ("Blockquote" . jf/org-mode/insert-block/quote_block)
       ("Details and Summary" . "#+begin_details\n#+begin_summary\n\n#+end_summary\n#+end_details")
       ("Emacs Lisp" . "#+begin_src emacs-lisp\n#+end_src")
       ("Gherkin" . "#+begin_src gherkin\n#+end_src")
       ("Org Structure" . org-insert-structure-template)
       ("Plant UML (puml)" . "#+begin_src plantuml\n@startuml\n!theme amiga\n\n@enduml\n#+end_src")
       ("Ruby" . "#+begin_src ruby\n#+end_src")
       ("Update" . tempel-insert-update_block))

    "A list of `cons' cells used for `dig-my-grave' `completing-read'.
  The `car' as the label and `cdr' as the value that we'll insert.")

  (defun jf/org-mode/insert-block/quote_block (author cite cite_url)
    (interactive (list (read-string "Author: ")
                   (read-string "Cite: ")
                   (read-string "Cite URL: ")))
    ;; TODO Extract the attr_shortcode functionality to be able to insert this.
    (insert (when (or (s-present? author) (s-present? cite) (s-present? cite_url)) "#+attr_shortcode:")
      (if (s-present? author) (concat " :pre " author) "")
      (if (s-present? cite) (concat " :cite " cite) "")
      (if (s-present? cite_url) (concat " :cite_url " cite_url) "")
      "\n#+begin_quote\n\n#+end_quote")
    (re-search-backward "^$"))

  (define-key org-mode-map (kbd "`") #'dig-my-grave)
  (defun dig-my-grave ()
    "Prompt to `insert' block when 3 consecutive graves (e.g. ‚Äú`‚Äù) start line.

  See `dig-my-grave/templates-alist/org-mode'."
    (interactive)
    (if (and (= (current-column) 2) (looking-back "``" (- (point) 2)))
      ;; We have just hit our third backtick at the beginning of the line.
      (progn
        (delete-char -2)
        ;; I use the alist-get pattern a lot...perhaps a function?
        (let ((value (alist-get (completing-read "Block Type: "
                                    dig-my-grave/templates-alist/org-mode nil t)
                       dig-my-grave/templates-alist/org-mode nil nil #'string=)))
          (cond
            ;; Let's assume that we're dealing with registered org blocks.
            ((stringp value)
              (insert value) (forward-line -1) (org-edit-special))
            ;; Trust the function
            ((commandp value) (call-interactively value))
            ((functionp value) (funcall value))
            ;; Time for a pull request
            (t (error "Unprocessable value %s for #'dig-my-grave" value)))))
      (setq last-command-event ?`)
      (call-interactively #'org-self-insert-command)))

  (provide 'dig-my-grave)
  ;;; dig-my-grave.el ends here
#+end_src

** =gherkin-mode.el=
#+begin_src emacs-lisp :tangle "gherkin-mode.el" :results none
  ;;; gherkin-mode --- Font locks for gherkin syntax -*- lexical-binding: t -*-

  ;; Copyright (C) 2023 Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.

  ;;; License

  ;; Copyright 2023 Jeremy Friesen <jeremy@jeremyfriesen.com>
  ;;
  ;; Licensed under the Apache License, Version 2.0 (the "License");
  ;; you may not use this file except in compliance with the License.
  ;; You may obtain a copy of the License at
  ;;
  ;;    http://www.apache.org/licenses/LICENSE-2.0
  ;;
  ;; Unless required by applicable law or agreed to in writing, software
  ;; distributed under the License is distributed on an "AS IS" BASIS,
  ;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ;; See the License for the specific language governing permissions and
  ;; limitations under the License.

  ;;; Commentary

  ;; A simple package for providing font-locks for Gherkin syntax.  I find myself
  ;; writing Gherkin Mode inside Org-Mode code blocks.
  ;;
  ;; https://cucumber.io/docs/gherkin/

  ;;; Code

  (define-derived-mode gherkin-mode prog-mode
    "Gherkin"
    "A mode for writing Gherkin syntax documentation."
    :group 'gherkin-mode
    (make-local-variable 'comment-start)
    (setq comment-start "# "))

  (font-lock-add-keywords 'gherkin-mode
    '(("^[[:space:]]*\\(Given\\|When\\|Then\\|But\\|And\\)" . 'font-lock-keyword-face)
       ("^[[:space:]]*\\(Feature\\|Background\\|Scenario\\|Scenario Outline\\|Examples?\\|Scenarios\\):.*" . 'font-lock-doc-face)
       ("<[^>]*>" . 'font-lock-variable-name-face)
       ("^[[:space:]]*@.*"  . 'font-lock-preprocessor-face)
       ("^[[:space:]]*#.*"  . 'font-lock-comment-face)))

  (provide 'gherkin-mode)
  ;;; gherkin-mode.el ends here
#+end_src

** =git-related.el=
#+begin_src emacs-lisp :tangle "git-related.el" :results none
  ;;; git-related.el --- Find related files through commit history analysis -*- lexical-binding: t -*-

  ;; Copyright (C) 2023 Nthcdr

  ;; Author: Nthcdr <nthcdr@macroexpand.net>
  ;; Maintainer: Nthcdr <nthcdr@macroexpand.net>
  ;; Contributions: Jeremy Friesen <jeremy@jeremyfriesen.com>
  ;; URL: https://macroexpand.net/el/git-related.el
  ;; Version: 1.0
  ;; Package-Requires: ((emacs "28.1"))

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

  ;;; Commentary:

  ;; Find files by recommendation based on git commit history.

  ;; Usage: Visiting a git versioned file run once (and then only when
  ;; you feel the need to refresh) `consult-git-related-update' than you will get
  ;; suggestions based on the current file through invocations to
  ;; `consult-git-related-find-file'

  ;;; Todo:

  ;; Test that the graph exists, if not, run the command for the graph then
  ;; proceed.

  ;;; Code:

  (require 'cl-lib)
  (require 'subr-x)
  (require 'project)
  (require 'vc-git)
  (require 'consult)

  (defvar git-related--graphs nil)

  (cl-defstruct git-related--graph files commits)
  (cl-defstruct git-related--file (name "" :type string) (commits nil :type list))
  (cl-defstruct git-related--commit (sha "" :type string) (files nil :type list))

  (defun git-related--new-graph ()
    "Create an empty graph."
    (make-git-related--graph
      :files (make-hash-table :test 'equal :size 2500)
      :commits (make-hash-table :test 'equal :size 2500)))

  (defun git-related--record-commit (graph sha filenames)
    "Record in the GRAPH the relation between SHA and FILENAMES."
    (let ((commit (make-git-related--commit :sha sha)))
      (dolist (filename filenames)
        (let* ((seen-file (gethash filename (git-related--graph-files graph)))
                (file-found (not (null seen-file)))
                (file (or seen-file (make-git-related--file :name filename))))

          (cl-pushnew commit (git-related--file-commits file))
          (cl-pushnew file (git-related--commit-files commit))

          (unless file-found
            (setf (gethash filename (git-related--graph-files graph)) file))))

      (setf (gethash sha (git-related--graph-commits graph)) commit)))

  (defun git-related--replay (&optional graph)
    "Replay git commit history into optional GRAPH."
    (let ((graph (or graph (git-related--new-graph))))
      (with-temp-buffer
        (process-file vc-git-program nil t nil "log" "--name-only" "--format=%x00%H")
        (let* ((commits (split-string (buffer-string) "\0" t))
                (replay-count 0)
                (progress-reporter (make-progress-reporter "Building commit-file graph..." 0 (length commits))))
          (dolist (commit commits)
            (let* ((sha-and-paths (split-string commit "\n\n" t (rx whitespace)))
                    (sha (car sha-and-paths))
                    (paths (when (cadr sha-and-paths)
                             (split-string (cadr sha-and-paths) "\n" t (rx whitespace)))))
              (git-related--record-commit graph sha paths)
              (progress-reporter-update progress-reporter (cl-incf replay-count))))
          (progress-reporter-done progress-reporter)))
      graph))

  (cl-defun git-related--similar-files (&key graph filename)
    "Return files in GRAPH that are similar to FILENAME."
    (unless (git-related--graph-p graph)
      (user-error "You need to index this project first"))
    (when-let ((file (gethash filename (git-related--graph-files graph))))

      (let ((file-sqrt (sqrt (length (git-related--file-commits file))))
             (neighbor-sqrts (make-hash-table :test 'equal :size 100))
             (hits (make-hash-table :test 'equal :size 100)))

        (dolist (commit (git-related--file-commits file))
          (dolist (neighbor (remove file (git-related--commit-files commit)))
            (let ((count (cl-incf (gethash (git-related--file-name neighbor) hits 0))))
              (when (= count 1)
                (setf (gethash (git-related--file-name neighbor) neighbor-sqrts)
                  (sqrt (length (git-related--file-commits neighbor))))))))

        (let (ranked-neighbors)
          (maphash
            (lambda (neighbor-name neighbor-sqrt)
              (let ((axb (* file-sqrt neighbor-sqrt))
                     (n (gethash neighbor-name hits)))
                (push (list (if (cl-plusp axb) (/ n axb) 0.0) neighbor-name) ranked-neighbors)))
            neighbor-sqrts)
          ;; We want to sort in descending score order.  Thus the more "related"
          ;; files are at the beginning of the list.
          (cl-sort
            (cl-remove-if-not #'git-related--file-exists-p ranked-neighbors :key #'cadr)
            #'> :key #'car)))))

  (defun git-related--file-exists-p (relative-filename)
    "Determine if RELATIVE-FILENAME currently exists."
    (file-exists-p
      (expand-file-name relative-filename
        (project-root (project-current)))))

  (defun consult-git-related--propertize-hit (hit)
    "Given the cons HIT return a rendered representation for completion."
    (propertize
      (cadr hit)
      'score (car hit)
      'path (cadr hit)))

  ;;;###autoload
  (defun consult-git-related-update ()
    "Update graph for the current project."
    (interactive)
    (let* ((default-directory (project-root (project-current)))
            (project-symbol (intern (project-name (project-current))))
            (graph (cl-getf git-related--graphs project-symbol)))
      (setf (cl-getf git-related--graphs project-symbol)
        (git-related--replay graph))))

  ;;;###autoload
  (defun consult-git-related-find-file ()
    "Find files related through commit history."
    (interactive)
    (if (buffer-file-name)
      (let ((default-directory (project-root (project-current))))
        (find-file
          (when-let ((selection (consult-git-related--read)))
            (format "%s"  selection))))
      (user-error "Current buffer has no file")))

  (defun consult-git-related--read ()
    "A completing read function leveraging `consult-read'."
    (consult--read
      (consult--slow-operation "Building Git Relationships..."
        (mapcar #'consult-git-related--propertize-hit
          (git-related--similar-files
            :graph (cl-getf git-related--graphs (intern (project-name (project-current))))
            :filename (file-relative-name (buffer-file-name) (project-root (project-current))))))
      :prompt "Related files in Git history: "
      :category 'consult-git-related
      ;; This should be nil so we leverage the sort of the `git-related--similar-files'
      :sort nil
      :annotate #'consult-git-related--annotator
      :require-match t
      :history t))

  (defun consult-git-related--annotator (cand)
    "Annotate the given CAND with it's score and modified date."
    (consult--annotate-align cand
      (format "%3.3f ¬∑ %s"
        (get-text-property 0 'score cand)
        (format-time-string "%Y-%m-%d" (f-change-time cand)))))

  (provide 'git-related)

  ;;; git-related.el ends here
#+end_src

** =hide-comnt.el=
#+begin_src emacs-lisp :tangle "hide-comnt.el" :results none
  ;;; hide-comnt.el --- Hide/show comments in code.
  ;;
  ;; Filename: hide-comnt.el
  ;; Description: Hide/show comments in code.
  ;; Author: Drew Adams
  ;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
  ;; Copyright (C) 2011-2019, Drew Adams, all rights reserved.
  ;; Created: Wed May 11 07:11:30 2011 (-0700)
  ;; Version: 0
  ;; Package-Requires: ()
  ;; Last-Updated: Thu Nov 21 08:18:51 2019 (-0800)
  ;;           By: dradams
  ;;     Update #: 232
  ;; URL: https://www.emacswiki.org/emacs/download/hide-comnt.el
  ;; Doc URL: https://www.emacswiki.org/emacs/HideOrIgnoreComments
  ;; Keywords: comment, hide, show
  ;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
  ;;
  ;; Features that might be required by this library:
  ;;
  ;;   None
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Commentary:
  ;;
  ;;    Hide/show comments in code.
  ;;
  ;;  Comments are hidden by giving them an `invisible' property with
  ;;  value `hide-comment'.
  ;;
  ;;
  ;;  Macros defined here:
  ;;
  ;;    `with-comments-hidden'.
  ;;
  ;;  Commands defined here:
  ;;
  ;;    `hide/show-comments', `hide/show-comments-toggle'.
  ;;
  ;;  User options defined here:
  ;;
  ;;    `hide-whitespace-before-comment-flag', `ignore-comments-flag',
  ;;    `show-invisible-comments-shows-all'.
  ;;
  ;;  Non-interactive functions defined here:
  ;;
  ;;    `hide/show-comments-1'.
  ;;
  ;;
  ;;  Put this in your init file (`~/.emacs'):
  ;;
  ;;   (require 'hide-comnt)
  ;;
  ;;
  ;;  Note for Emacs 20: The commands and option defined here DO NOTHING
  ;;  IN EMACS 20.  Nevertheless, the library can be byte-compiled in
  ;;  Emacs 20 and `hide-comnt.elc' can be loaded in later Emacs
  ;;  versions and used there.  This is the only real use of this
  ;;  library for Emacs 20: it provides macro `with-comments-hidden'.
  ;;
  ;;  Note for Emacs 21: It lacks the `comment-forward' function, so we
  ;;  rely on the `comment-end' variable to determine the end of a
  ;;  comment. This means that only one type of comment terminator is
  ;;  supported.  For example, `c++-mode' sets `comment-end' to "",
  ;;  which is the convention for single-line comments ("// COMMENT").
  ;;  So "/* */" comments are treated as single-line commentsonly the
  ;;  first line of such comments is hidden.  The "*/" terminator is not
  ;;  taken into account.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Change Log:
  ;;
  ;; 2017/01/16 dadams
  ;;     hide/show-comments-1: ((add-to|remove-from)-invisibility-spec 'hide-comment).
  ;;     See https://github.com/syl20bnr/spacemacs/issues/8123.
  ;; 2016/12/27 dadams
  ;;     Added: show-invisible-comments-shows-all.
  ;;     hide/show-comments(-1): Respect show-invisible-comments-shows-all.
  ;;     NOTE: Default behavior has changed: other invisible text is no longer made visible.
  ;; 2015/08/01 dadams
  ;;     Added hide/show-comments-1.  (And removed save-excursion around looking-back etc.)
  ;;     hide/show-comments:
  ;;       Use with-silent-modifications if available.  Use hide/show-comments-1.
  ;; 2015/07/31 dadams
  ;;     hide/show-comments:
  ;;       Bind buffer-file-name to nil to inhibit ask-user-about-supersession-threat.
  ;; 2015/07/29 dadams
  ;;     hide/show-comments:
  ;;       No-op if no comment-start.  Pass NOERROR arg to comment-normalize-vars.
  ;; 2014/11/05 dadams
  ;;     hide/show-comments:
  ;;       Use comment-forward even for "", so handle setting CEND correctly, e.g., for C++,
  ;;       where comment-end is "" but multi-line comments are also OK.
  ;;       Do not hide newline after single-line comments.
  ;;       hide-whitespace-before-comment-flag non-nil no longer hides empty lines.
  ;;       Prevent infloop for comment at bol.
  ;;       Thx to Hinrik Sigurosson.
  ;; 2014/02/06 dadams
  ;;     Added: hide-whitespace-before-comment-flag.
  ;;     hide/show-comments:
  ;;       Go to start of comment before calling comment-forward.
  ;;       Hide whitespace preceding comment, if hide-whitespace-before-comment-flag.
  ;; 2013/12/26 dadams
  ;;     hide/show-comments: Update START to comment end or END.
  ;; 2013/10/09 dadams
  ;;     hide/show-comments: Use save-excursion.  If empty comment-end go to CBEG.
  ;;                         Use comment-forward if available.
  ;; 2012/10/06 dadams
  ;;     hide/show-comments: Call comment-normalize-vars first.  Thx to Stefan Monnier.
  ;;     hide/show-comments-toggle: Do nothing if newcomment.el not available.
  ;; 2012/05/10 dadams
  ;;     Added: hide/show-comments-toggle.  Thx to Denny Zhang for the suggestion.
  ;; 2011/11/23 dadams
  ;;     hide/show-comments: Bug fix - ensure CEND is not past eob.
  ;; 2011/05/11 dadams
  ;;     Created: moved code here from thing-cmds.el.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;; This program is free software; you can redistribute it and/or
  ;; modify it under the terms of the GNU General Public License as
  ;; published by the Free Software Foundation; either version 3, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  ;; General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program; see the file COPYING.  If not, write to
  ;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  ;; Floor, Boston, MA 02110-1301, USA.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Code:


  (defvar comment-start)                  ; In `newcomment.el'.

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;;;###autoload
  (defcustom ignore-comments-flag t
    "*Non-nil means macro `with-comments-hidden' hides comments."
    :type 'boolean :group 'matching)

  ;;;###autoload
  (defcustom hide-whitespace-before-comment-flag t
    "*Non-nil means `hide/show-comments' hides whitespace preceding a comment.
  It does not hide empty lines (newline chars), however."
    :type 'boolean :group 'matching)

  ;;;###autoload
  (defcustom show-invisible-comments-shows-all nil
    "Non-nil means `(hide/show-comments 'show ...)' shows all invisible text.
  The default value, nil, means it shows only text that was made
  invisible by `(hide/show-comments 'hide ...)'."
    :type 'boolean :group 'matching)


  (defmacro with-comments-hidden (start end &rest body)
    "Evaluate the forms in BODY while comments are hidden from START to END.
  But if `ignore-comments-flag' is nil, just evaluate BODY,
  without hiding comments.  Show comments again when BODY is finished.

  See `hide/show-comments', which is used to hide and show the comments.
  Note that prior to Emacs 21, this never hides comments."
    (let ((result  (make-symbol "result"))
          (ostart  (make-symbol "ostart"))
          (oend    (make-symbol "oend")))
      `(let ((,ostart  ,start)
             (,oend    ,end)
             ,result)
        (unwind-protect (setq ,result  (progn (when ignore-comments-flag
                                                (hide/show-comments 'hide ,ostart ,oend))
                                              ,@body))
          (when ignore-comments-flag (hide/show-comments 'show ,ostart ,oend))
          ,result))))

  ;;;###autoload
  (defun hide/show-comments (&optional hide/show start end)
    "Hide or show comments from START to END.
  Interactively, hide comments, or show them if you use a prefix arg.
  \(This is thus *NOT* a toggle command.)

  If option `hide-whitespace-before-comment-flag' is non-nil, then hide
  also any whitespace preceding a comment.

  Interactively, START and END default to the region limits, if active.
  Otherwise, including non-interactively, they default to `point-min'
  and `point-max'.

  Uses `save-excursion', restoring point.

  Option `show-invisible-comments-shows-all':

  ,* If non-nil then using this command to show invisible text shows
    ,*ALL* such text, regardless of how it was hidden.  IOW, it does not
    just show invisible text that you previously hid using this command.

  ,* If nil (the default value) then using this command to show invisible
    text makes visible only such text that was previously hidden by this
    command.  (More precisely, it makes visible only text whose
    `invisible' property has value `hide-comment'.)

  From Lisp, a HIDE/SHOW value of `hide' hides comments.  Other values
  show them.

  This command does nothing in Emacs versions prior to Emacs 21, because
  it needs `comment-search-forward'."

    (interactive
     (cons (if current-prefix-arg 'show 'hide)
           (if (or (not mark-active)  (null (mark))  (= (point) (mark)))
               (list (point-min) (point-max))
             (if (< (point) (mark)) (list (point) (mark)) (list (mark) (point))))))
    (when (and comment-start              ; No-op if no comment syntax defined.
               (require 'newcomment nil t)) ; `comment-search-forward', Emacs 21+.
      (comment-normalize-vars 'NO-ERROR)  ; Must call this first.
      (unless start (setq start  (point-min)))
      (unless end   (setq end    (point-max)))
      (unless (<= start end) (setq start  (prog1 end (setq end  start)))) ; Swap.
      (if (fboundp 'with-silent-modifications)
          (with-silent-modifications      ; Emacs 23+.
              (restore-buffer-modified-p nil) (hide/show-comments-1 hide/show start end))
        (let ((bufmodp           (buffer-modified-p)) ; Emacs < 23.
              (buffer-read-only  nil)
              (buffer-file-name  nil))    ; Inhibit `ask-user-about-supersession-threat'.
          (set-buffer-modified-p nil)
          (unwind-protect (hide/show-comments-1 hide/show start end)
            (set-buffer-modified-p bufmodp))))))

  ;; Used only so that we can use `hide/show-comments' with older Emacs releases that do not
  ;; have macro `with-silent-modifications' and built-in `restore-buffer-modified-p', which
  ;; it uses.
  (defun hide/show-comments-1 (hide/show start end)
    "Helper for `hide/show-comments'."
    (let (cbeg cend)
      (if (eq 'hide hide/show)
          (add-to-invisibility-spec 'hide-comment)
        (remove-from-invisibility-spec 'hide-comment))
      (save-excursion
        (goto-char start)
        (while (and (< start end)  (save-excursion
                                     (setq cbeg  (comment-search-forward end 'NOERROR))))
          (goto-char cbeg)
          (save-excursion
            (setq cend  (cond ((fboundp 'comment-forward) ; Emacs 22+
                               (if (comment-forward 1)
                                   (if (= (char-before) ?\n) (1- (point)) (point))
                                 end))
                              ((string= "" comment-end) (min (line-end-position) end))
                              (t (search-forward comment-end end 'NOERROR)))))
          (when hide-whitespace-before-comment-flag ; Hide preceding whitespace.
            (if (fboundp 'looking-back)   ; Emacs 22+
                (when (looking-back "\n?\\s-*" nil 'GREEDY)
                  (setq cbeg  (match-beginning 0)))
              (while (memq (char-before cbeg) '(?\   ?\t ?\f)) (setq cbeg  (1- cbeg)))
              (when (eq (char-before cbeg) ?\n) (setq cbeg  (1- cbeg))))
            ;; First line: Hide newline after comment.
            (when (and (= cbeg (point-min))  (= (char-after cend) ?\n))
              (setq cend  (min (1+ cend) end))))
          (when (and cbeg  cend)
            (if show-invisible-comments-shows-all
                (put-text-property cbeg cend 'invisible (and (eq 'hide hide/show)
                                                             'hide-comment))
              (while (< cbeg cend)
                ;; Do nothing to text that is already invisible for some other reason.
                (unless (and (get-text-property cbeg 'invisible)
                             (not (eq 'hide-comment (get-text-property cbeg 'invisible))))
                  (put-text-property cbeg (1+ cbeg) 'invisible (and (eq 'hide hide/show)
                                                                    'hide-comment)))
                (setq cbeg  (1+ cbeg)))))
          (goto-char (setq start  (or cend  end)))))))

  (defun hide/show-comments-toggle (&optional start end)
    "Toggle hiding/showing of comments in the active region or whole buffer.
  If the region is active then toggle in the region.  Otherwise, in the
  whole buffer.

  This command does nothing in Emacs versions prior to Emacs 21, because
  it needs `comment-search-forward'.

  Interactively, START and END default to the region limits, if active.
  Otherwise, including non-interactively, they default to `point-min'
  and `point-max'.

  See `hide/show-comments' for more information."
    (interactive (if (or (not mark-active)  (null (mark))  (= (point) (mark)))
                     (list (point-min) (point-max))
                   (if (< (point) (mark)) (list (point) (mark)) (list (mark) (point)))))
    (when (require 'newcomment nil t)     ; `comment-search-forward', Emacs 21+.
      (comment-normalize-vars)            ; Must call this first.
      (if (save-excursion
            (goto-char start)
            (and (comment-search-forward end 'NOERROR)
                 (if show-invisible-comments-shows-all
                     (get-text-property (point) 'invisible)
                   (eq 'hide-comment (get-text-property (point) 'invisible)))))
          (hide/show-comments 'show start end)
        (hide/show-comments 'hide start end))))

  ;;;;;;;;;;;;;;;;;;;;;;;;

  (provide 'hide-comnt)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; hide-comnt.el ends here
#+end_src

** =jf-blogging.el=
#+begin_src emacs-lisp :tangle "jf-blogging.el" :results none
  ;;; jf-blogging.el --- Blogging related functions -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;; Packages specifically here for helping with my writing activities.

  ;;; Code:
  (require 'ox)

  (require 'jf-formatting)

  (use-package ox-hugo
    :straight t
    :custom
    ;; - blockquote :: for chunks of text that I attribute to other folks.
    ;; - marginnote :: a "dangling" note that is only partially part of the
    ;;                 conversation.
    ;; - poem :: because poetic spacing is critical.
    ;; - inline_comments :: a concession that I need different comments based on
    ;;                      context; and that marginalia may be too much in some
    ;;                      cases.
    ;; - update :: I write updates for my blog posts; corrections or additions
    ;;             based on new information.
    (org-hugo-paired-shortcodes "blockquote marginnote poem inlinecomment update")
    (hugo-use-code-for-kbd t)
    :config
    ;; I want to have backticks instead of indentations;  The backticks also
    (advice-add #'org-md-example-block :override #'org-blackfriday-src-block)
    :after ox)

  ;; These functions work too aggressively.  The types of lists (ordered,
  ;; definition, and unordered) are co-mingled.  This co-mingling means that I'm
  ;; not getting the behavior I want.  So I'll proceed with the default ox-hugo
  ;; behavior.
  ;;
  ;; (advice-add #'org-blackfriday-plain-list :override #'org-html-plain-list '((name . "wrapper")))
  ;; (advice-add #'org-blackfriday-item :override #'org-html-item '((name . "wrapper")))

  ;; Convert footnote to sidenote for HTML export
  (defun jf/org-hugo-sidenote (footnote-reference _contents info)
    "Transcode a FOOTNOTE-REFERENCE element from Org to Hugo sidenote shortcode.
  CONTENTS is nil.  INFO is a plist holding contextual information."
    (let* ((element (car (org-export-get-footnote-definition footnote-reference info)))
            (beg (org-element-property :contents-begin element))
            (end (org-element-property :contents-end element))
            (content (s-trim
                       (org-export-string-as
                         (buffer-substring-no-properties beg end)
                         'md t '(:with-toc nil)))))
      (format "{{< sidenote >}}%s{{< /sidenote >}}" content)))


  (advice-add #'org-blackfriday-footnote-reference
    :override #'jf/org-hugo-sidenote
    '((name . "wrapper")))
  (advice-add #'org-blackfriday-footnote-section
    :override (lambda (&rest rest) ())
    '((name . "wrapper")))

  (defun jf/org-md-quote-block (quote-block contents info)
    "Render a QUOTE-BLOCK with CONTENTS and INFO.

  Either render via the standard markdown way or when exporting to
  Take on Rules using the \"blockquote\" special block."
    (if jf/exporting-org-to-tor
      (progn
        (org-element-put-property quote-block :type "blockquote")
        (org-hugo-special-block quote-block contents info))
      ;; The original md quote block method; probably a better way to do this.
      (replace-regexp-in-string
        "^" "> "
        (replace-regexp-in-string "\n\\'" "" contents))))
  (advice-add #'org-md-quote-block :override #'jf/org-md-quote-block)

  (setq org-hugo-base-dir "~/git/takeonrules.source")

  (defvar jf/org-macros-setup-filename
    "~/git/dotemacs/lib/org-macros.setup"
    "The path to the file that has inline org macros.")

  (defvar jf/exporting-org-to-tor nil
    "Not nil while performing the export of org file to Take on Rules.")

  (cl-defun jf/export-org-to-tor (&key (buffer (current-buffer)))
    "Export current org BUFFER for TakeOnRules post."
    (interactive)
    ;; Ensure that we have an ID property.
    (setq jf/exporting-org-to-tor t)
    (with-current-buffer buffer
      (save-excursion
        (let* ((export-global-plist (jf/org-keywords-as-plist))
                (section (jf/export-org-to-tor--global-buffer-prop-ensure
                           :key "HUGO_SECTION"
                           :plist export-global-plist
                           :default (format-time-string "posts/%Y")))
                (base_dir (jf/export-org-to-tor--global-buffer-prop-ensure
                            :key "HUGO_BASE_DIR"
                            :plist export-global-plist
                            :default "~/git/takeonrules.source"))
                (format (jf/export-org-to-tor--global-buffer-prop-ensure
                          :key "HUGO_FRONT_MATTER_FORMAT"
                          :plist export-global-plist
                          :default "yaml"))
                (title (lax-plist-get export-global-plist "TITLE"))
                (identifier (lax-plist-get export-global-plist "IDENTIFIER")))
          (save-buffer)
          (jf/export-org-to-tor--inject-additional-front-matter
            :title title
            :identifier identifier)
          ;; Write metadata
          (save-buffer)
          (unless org-transclusion-mode (org-transclusion-mode))
          (org-open-file (org-hugo-export-wim-to-md nil nil t)))))
    (setq jf/exporting-org-to-tor nil))

  (fset 'jf/tidy-ox-hugo-header-export
    (kmacro-lambda-form [?\C-c ?\C-n ?\s-f ?\{ return ?\C-b ?\C-b ?\C-k] 0 "%d"))

  (cl-defun jf/export-org-to-tor--inject-additional-front-matter (&key identifier title)
    "Export additional front matter.

      We want to ensure that we export the IDENTIFIER and TITLE.
      And add relevant metadata."
    (goto-char (point-min))
    (search-forward-regexp "#\\+HUGO_FRONT_MATTER_FORMAT: yaml")
    (insert (concat
              "\n#+HUGO_CUSTOM_FRONT_MATTER: :slug " (jf/tor-convert-text-to-slug title)
              ;; 2022-02-26 07:46:15.000000000 -04:00
              "\n#+HUGO_CUSTOM_FRONT_MATTER: :date " (format-time-string "%Y-%m-%d %H:%M:%S %z")
              "\n#+HUGO_CUSTOM_FRONT_MATTER: :type post"
              "\n#+HUGO_CUSTOM_FRONT_MATTER: :layout post"
              "\n#+HUGO_CUSTOM_FRONT_MATTER: :licenses '(all-rights-reserved)"
              "\n#+HUGO_CUSTOM_FRONT_MATTER: :draft true"
              "\n#+HUGO_CUSTOM_FRONT_MATTER: :org_id " identifier
              "\n#+INCLUDE: " jf/org-macros-setup-filename))
    (when-let ((kw-plist (jf/org-keywords-as-plist
                           :keywords-regexp "\\(SESSION_REPORT_DATE\\|SESSION_REPORT_LOCATION\\|SESSION_REPORT_GAME\\)")))
      (insert
        (format
          "\n#+HUGO_CUSTOM_FRONT_MATTER: :sessionReport '((date . \"%s\") (game . \"%s\") (location . \"%s\"))"
          (plist-get kw-plist "SESSION_REPORT_DATE")
          (plist-get kw-plist "SESSION_REPORT_GAME")
          (plist-get kw-plist "SESSION_REPORT_LOCATION")))))

  (cl-defun jf/export-org-to-tor--global-buffer-prop-ensure (&key key plist (default nil))
    "Ensure the current buffer has the given KEY in the global PLIST, if not set the DEFAULT or prompt for it."
    (let ((value (plist-get plist key #'string=)))
      (if value value
        (jf/export-org-to-tor--global-buffer-prop-set
          :key key
          :value (or default (read-from-minibuffer (format "%s: " key)))))))

  (cl-defun jf/export-org-to-tor--global-buffer-prop-set (&key key value)
    "Set the global property named KEY to the VALUE for the current buffer."
    (goto-char (point-min))
    (forward-line 4)
    (insert (format "\n#+%s: %s" (upcase key) value)))

  (defvar jf/tor-session-report-location
    '("around the table" "via Zoom" "via Discord and Roll20" "via Discord" "in my living room")
    "TakeOnRules session report locations.")

  (cl-defun jf/org-keywords-as-plist (&key (keywords-regexp "\\(IDENTIFIER\\|FILETAGS\\|HUGO_FRONT_MATTER_FORMAT\\|HUGO_SECTION\\|HUGO_BASE_DIR\\|TITLE\\|SUBTITLE\\)"))
    (-flatten (mapcar (lambda (prop)
                        (list (org-element-property :key prop)
                          (org-element-property :value prop)))
                (jf/org-global-props keywords-regexp))))

  (defun jf/org-global-props (&optional property)
    "Get the plist of global org PROPERTY of current buffer."
    (unless property (setq property "PROPERTY"))
    (org-element-map
      (org-element-parse-buffer)
      'keyword
      (lambda (el)
        (when (string-match property (org-element-property :key el)) el))))

  (cl-defun jf/jump_to_corresponding_hugo_file (&key (buffer (current-buffer)))
    "Find the TakeOnRules.com url in the BUFFER and jump to corresponding Hugo file."
    (interactive)
    (with-current-buffer buffer
      (save-excursion
        (goto-char (point-min))
        (save-match-data
          (if (re-search-forward "\n:ROAM_REFS:.+\\(https?://takeonrules\.com[^ \n]*\\)" nil t)
            (jf/tor-find-hugo-file-by-url (match-string 1))
            (message "Unable to find Take on Rules URL in buffer."))))))

  (defun jf/org-mode-get-keyword-key-value (kwd)
    "Map KWD to list."
    (let ((data (cadr kwd)))
      (list (plist-get data :key)
        (plist-get data :value))))

  (cl-defun jf/org-mode-extract-body-and-properties (node-id)
    "Extract quotable body and properties from NODE-ID."
    (with-current-buffer (find-file-noselect (org-id-find-id-file node-id))
      (list :properties (org-element-map (org-element-parse-buffer 'object)
                          '(keyword node-property)
                          #'jf/org-mode-get-keyword-key-value)
        :body (jf/org-mode-extract-body-from-current-buffer))))


  (defun jf/org-mode-extract-body-from-current-buffer ()
    "Extract the body from the current `org-mode' body."
    (buffer-substring (save-excursion
                        (jf/org-mode-find-point-that-starts-body t)
                        (point))
      (org-entry-end-position)))

  (defun jf/org-mode-find-point-that-starts-body (&optional unsafe)
    "Skip headline, planning line, and all drawers in current entry.

  If UNSAFE is non-nil, assume point is on headline."
    (unless unsafe
      ;; To improve performance in loops (e.g. with `org-map-entries')
      (org-back-to-heading))
    (cl-loop for element = (org-element-at-point)
      for pos = (pcase element
                  (`(headline . ,_) (org-element-property :contents-begin element))
                  (`(,(or 'planning 'property-drawer 'node-property 'keyword 'drawer) . ,_) (org-element-property :end element)))
      while pos
      do (goto-char pos)))
  ;;******************************************************************************
  ;;
  ;;; BEGIN Non-Interactive Utility Functions
  ;;
  ;;******************************************************************************
  (defun jf/tor-convert-text-to-post-title (title)
    "Convert TITLE to correct format."
    (message "Titleizing...")
    (replace-regexp-in-string
      ;; Replace "Hello World" with ‚ÄúHello World‚Äù
      "\"\\([^\"]+\\)\""
      "‚Äú\\1‚Äù"
      (s-replace "'" "‚Äô" title)))

  (defun jf/tor-convert-text-to-slug (&optional string)
    "Convert STRING to appropriate slug."
    (s-replace "'" "" (s-dashed-words (s-downcase string))))
  ;;******************************************************************************
  ;;
    ;;; END Non-Interactive Utility Functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
    ;;; BEGIN Interactive Non-Wrapping Functions
  ;;
  ;;******************************************************************************
  (cl-defun jf/tor-toggle-hugo-server (&key
                                        (directory jf/tor-home-directory)
                                        (buffer-name "*Hugo Server*"))
    "This will start or stop a Hugo server in the given DIRECTORY.

    The BUFFER-NAME is where we'll run the Hugo process."
    (interactive)
    (if (get-buffer buffer-name)
      (progn
        (kill-buffer buffer-name)
        (message (concat "Stopping Hugo in \"" buffer-name "\" buffer‚Ä¶")))
      (let* ((default-directory directory))
        (start-process "hugo-server" buffer-name "hugo" "server" "-D")
        (message (concat "Starting Hugo in \"" buffer-name "\" buffer‚Ä¶")))))

  (defvar jf/tor-hostname-regexp
    "^https?://takeonrules\.com"
    "A regular expression for checking if it's TakeOnRules.com.")

  (defvar jf/tor-hugo-regexp-for-post-path
    (concat jf/tor-hostname-regexp
      "/[0-9]\\{4\\}/[0-9]\\{2\\}/[0-9]\\{2\\}/\\([^/]+\\)/?$")
    "A regular expression for matching blog posts.")

  (defvar jf/tor-hugo-regexp-for-pages-path
    (concat jf/tor-hostname-regexp "/\\([^z-a]*[^/]\\)/?$")
    "A regular expression for matching pages.")

  (defun jf/tor-find-hugo-file-by-url (url)
    "Find the associated TakeOnRules.com file for the given URL."
    (interactive (list
                   (jf/prompt-for-url-dwim
                     :url-regexp jf/tor-hostname-regexp)))
    (cond
      ;; Blog post
      ((string-match jf/tor-hugo-regexp-for-post-path url)
        (let* ((slug (match-string-no-properties 1 url))
                (filename (car
                            (jf/list-filenames-with-file-text
                              :matching (concat "^slug: " slug "$")
                              :in "content"))))
          (find-file (f-join jf/tor-home-directory "content" filename))))
      ;; Pages
      ((string-match jf/tor-hugo-regexp-for-pages-path url)
        (let* ((permalink (match-string-no-properties 1 url))
                (filename (car
                            (jf/list-filenames-with-file-text
                              :matching (concat "^permalink: ['\\\"]?/?"
                                          permalink "/?['\\\"]?$")
                              :in "content"))))
          (find-file (f-join jf/tor-home-directory "content" filename))))
      ;; No match found
      (t (message "Unable to find post for \"%s\"" url))))

  (defun jf/tor-find-changelog-and-insert-entry ()
    "Find TakeOnRules glossary and begin entering a changelog entry."
    (interactive)
    (find-file (f-join jf/tor-home-directory "data" "changelog.yml"))
    ;; The changelog is structured in date descending order.  The first
    ;; line is the YAML preamble indicating a data object (e.g. "---")
    (goto-char (point-min))
    (end-of-line)
    (insert (concat "\n- date: "
              (format-time-string "%Y-%m-%d")
              "\n  entries:\n    - ")))

  (defun jf/tor-find-series-and-insert-entry (title)
    "Find TakeOnRules series and add an entry with TITLE."
    (interactive "sSeries Entry's Title: ")
    (find-file (f-join jf/tor-home-directory "data" "series.yml"))
    (let ((key (downcase (s-dashed-words title))))
      (goto-char (point-max))
      (insert (concat
                (if (looking-at-p "^$") "" "\n")
                "- title: " title
                "\n  key: " key))))

  ;; Note: I needed to use `fboundp' because if I invoked this functions
  ;; before other consult functions I got a method void error.
  (cl-defun jf/find-file-via-matching (&key prompt matching in (switch "--files-with-matches"))
    "PROMPT for files IN the directory with MATCHING content with given SWITCH.

  If `consult--read' is defined, use that.  Otherwise fallback to
  `completing-read'."
    (if (fboundp 'consult--read)
      (consult--read
        (consult--with-increased-gc
          (jf/list-full-filenames-with-file-text
            :matching matching
            :in in
            :switch switch))
        :prompt prompt
        :sort nil
        :require-match t
        :category 'file
        :history 'file-name-history
        :state (consult--file-preview))
      (list (completing-read
              prompt
              (jf/list-filenames-with-file-text
                :matching matching
                :in in)))))


  ;;******************************************************************************
  ;;
      ;;; END Interactive Non-Wrapping Functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
      ;;; BEGIN Listing functions for TakeOnRules.com data
  ;;
  ;;******************************************************************************
  (defun jf/tor-tags-list ()
    "Return a list of tags from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "tag" :filename "data/glossary.yml"))

  (defun jf/tor-epigraph-list ()
    "Return a list of epigraph keys from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "key" :filename "data/epigraphs.yml"))

  (defun jf/tor-game-list ()
    "Return a list of games from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "game" :filename "data/glossary.yml"))

  (defun jf/tor-glossary-title-list ()
    "Return a list of titles from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "title" :filename "data/glossary.yml"))

  (defun jf/tor-glossary-key-list ()
    "Return a list of keys from TakeOnRules.com glossary."
    (jf/tor-list-by-key-from-filename :key "key" :filename "data/glossary.yml"))

  (defun jf/tor-series-list ()
    "Return a list of series from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "key" :filename "data/series.yml"))

  (defun jf/tor-licenses-list ()
    "Return a list of available licenses for TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "Key" :filename "data/licenses.yml"))
  ;;******************************************************************************
  ;;
      ;;; END Listing functions for TakeOnRules.com data
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
      ;;; BEGIN querying and list generation functions
  ;;
  ;;******************************************************************************
  (cl-defun jf/tor-list-by-key-from-filename (&key
                                               key
                                               filename
                                               (directory jf/tor-home-directory))
    "Build a list of entries of the KEY from the FILENAME in DIRECTORY."
    (split-string-and-unquote
      (shell-command-to-string
        (concat
          "rg \"^[- ] " key ": .*$\" "
          (f-join directory filename)
          " --only-matching --no-filename | sed 's/^[ -] " key ": //' | sort | tr '\n' '@'"))
      "@"))

  (cl-defun jf/list-filenames-with-file-text (&key matching in)
    "Build a list of filenames MATCHING the pattern IN the given directory."
    (let ((default-directory (f-join jf/tor-home-directory in)))
      (split-string-and-unquote
        (shell-command-to-string
          (concat
            "rg \""
            matching "\" --only-matching --files-with-matches --sortr modified"
            "| tr '\n' '@'"))
        "@")))

  (cl-defun jf/list-full-filenames-with-file-text (&key matching in (switch "--files-with-matches"))
    "List of filenames MATCHING with SWITCH the pattern IN the given directory."
    (split-string-and-unquote
      (shell-command-to-string
        (concat
          "rg \""
          matching "\" " in " --only-matching " switch " --sortr modified"
          "| tr '\n' '@'"))
      "@"))

  (defun jf/tor-page-relative-pathname-list ()
    "Return a list of pages for TakeOnRules.com."
    (jf/list-filenames-with-file-text :matching "^title: " :in "content"))

  (defun jf/tor-asset-relative-pathname-list ()
    "Return a list of image filenames for TakeOnRules.com."
    (let ((default-directory (f-join jf/tor-home-directory "assets" "images")))
      (split-string-and-unquote
        (shell-command-to-string "ls"))))

  (defun jf/matches-in-buffer (regexp &optional buffer)
    "Return a list of matches of REGEXP in BUFFER or the current buffer if not given."
    (let ((matches))
      (save-match-data
        (save-excursion
          (with-current-buffer (or buffer (current-buffer))
            (save-restriction
              (widen)
              (goto-char 1)
              (while (search-forward-regexp regexp nil t 1)
                (push (match-string 0) matches)))))
        matches)))

  (defun jf/kill-new-markdown-heading-as-slug (heading)
    "Push onto the `kill-ring' a slugified version of HEADING."
    (interactive
      (list (completing-read
              "Heading: "
              (jf/matches-in-buffer "^#+ +.*$"))))
    (kill-new (jf/tor-convert-text-to-slug
                (replace-regexp-in-string "^#+ +" "" heading))))

  ;;******************************************************************************
  ;;
      ;;; END querying and list generation functions
  ;;
  ;;******************************************************************************


  (fset 'jf/tidy-ox-hugo-header-export
    (kmacro-lambda-form [?\C-c ?\C-n ?\s-f ?\{ return ?\C-b ?\C-b ?\C-k] 0 "%d"))

  (provide 'jf-blogging)
  ;;; jf-blogging.el ends here
#+end_src

#+RESULTS:
: jf-blogging

** =jf-capf-hacking.el=
#+begin_src emacs-lisp :tangle "jf-capf-hacking.el" :results none
  ;;; jf-capf-hacking ---  -*- lexical-binding: t -*-

  ;; Copyright (C) 2023 Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.

  ;;; Commentary:

  ;; Allow for completion of projects and then issues.  Likely something I want to
  ;; include in commit messages.  This behaves in a two step fashion:

  ;; - Type in the project (/project)
  ;; - Tab and select the project
  ;; - It fills in /project#
  ;; - Then type a number (e.g. /project#123)
  ;; - Tab and it will unfurl to a github issue URL

  ;;; Code:

  ;;;; Dependencies

  (require 'project)
  (require 'projectile)

  ;;;; Primary Functions:

  (defun jf/version-control/project-capf ()
    "Complete project links."
    ;; While I'm going to replace "/project" I want to make sure that I don't
    ;; have any odd hits (for example /path/to/file)
    (when (looking-back "[^[:word:]]/[[:word:][:digit:]_\-]+"
            (jf/capf-max-bounds))
      (let ((right (point))
             (left (save-excursion
                     (search-backward-regexp "/[[:word:][:digit:]_\-]+"
                       (jf/capf-max-bounds) t)
                     (point))))
        (list left right
          (jf/version-control/known-project-names)
          :exit-function
          (lambda (text _status)
            (delete-char (- (length text)))
            (insert text "#"))
          :exclusive 'no))))

  (defun jf/version-control/issue-capf ()
    "Complete project issue links."
    ;; While I'm going to replace "/project" I want to make sure that I don't
    ;; have any odd hits (for example /path/to/file)
    (when (looking-back "[^[:word:]]/[[:word:][:digit:]_\-]+#[[:digit:]]+"
            (jf/capf-max-bounds))
      (let ((right (point))
             (left (save-excursion
                     (search-backward-regexp
                       "/[[:word:][:digit:]_\-]+#[[:digit:]]+"
                       (jf/capf-max-bounds) t)
                     (point))))
        (list left right
          (jf/version-control/text)
          :exit-function
          #'jf/version-control/unfurl-issue-to-url
          :exclusive 'no))))

  (add-to-list 'completion-at-point-functions #'jf/version-control/issue-capf)
  (add-to-list 'completion-at-point-functions #'jf/version-control/project-capf)

  ;;;; Service functions

  (cl-defun jf/capf-max-bounds (&key (window-size 40))
    "Return the max bounds for `point' based on given WINDOW-SIZE."
    (let ((boundary (- (point) window-size)))
      (if (> 0 boundary) (point-min) boundary)))

  (cl-defun jf/version-control/known-project-names (&key (prefix "/"))
    "Return a list of project, prepending PREFIX to each."
    (mapcar (lambda (proj)
              (concat prefix (f-base proj)))
      projectile-known-projects))

  (cl-defun jf/version-control/unfurl-project-as-issue-url-template (project &key (prefix "/"))
    "Return the issue URL template for the given PROJECT.

  Use the provided PREFIX to help compare against `projectile-known-projects'."
    (let* ((project-path
             (car (seq-filter (lambda (el)
                                (or
                                  (s-ends-with? (concat project prefix) el)
                                  (s-ends-with? project el)))
                    projectile-known-projects)))
            (remote
              (s-trim (shell-command-to-string
                        (format "cd %s && git remote get-url origin" project-path)))))
      (if (s-ends-with? ".git" remote)
        (s-replace ".git" "/issues/%s" remote)
        (concat remote "/issues/%s"))))

  (defun jf/version-control/text ()
    "Find all matches for project and issue."
    (s-match-strings-all "/[[:word:][:digit:]_\-]+#[[:digit:]]+" (buffer-string)))

  (defun jf/version-control/unfurl-issue-to-url (text _status)
    "Unfurl the given TEXT to a URL.

  Ignoring _STATUS."
    (delete-char (- (length text)))
    (let* ((parts (s-split "#" text))
            (issue (cadr parts))
            (project (or (car parts) (cdr (project-current)))))
      (insert (format
                (jf/version-control/unfurl-project-as-issue-url-template project)
                issue))))

  (provide 'jf-capf-hacking)
  ;;; jf-capf-hacking.el ends here
#+end_src

** =jf-coding.el=
#+begin_src emacs-lisp :tangle "jf-coding.el" :results none
  ;;; jf-coding.el --- Packages related to "coding" -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.

  ;;; Commentary:

  ;; Coding is writing, but not all writing is coding.  This configures and
  ;; extends packages specifically here for helping with my coding activities.

  ;;; Code:

  ;;;; Pre-requisites
  (require 'jf-writing)

  (use-package treesit
    :straight (:type built-in)
    :init
    (setq treesit-font-lock-level 4)
    :preface
    (defun jf/treesit/function-select ()
      "Select the current function at point."
      (interactive)
      (if-let ((func (treesit-defun-at-point)))
        (progn
          (goto-char (treesit-node-start func))
          (call-interactively #'set-mark-command)
          (goto-char (treesit-node-end func)))
        (user-error "No function to select")))

    (defun jf/treesit/wrap-rubocop (&optional given-cops)
      "Wrap the current ruby active region or function by disabling/enabling the GIVEN-COPS."
      (interactive)
      (if (derived-mode-p 'ruby-ts-mode 'ruby-mode)
        (if-let ((beg (if (use-region-p)
                                 (region-beginning)
                                 (treesit-node-start (treesit-defun-at-point))))
                  (end (if (use-region-p)
                                (region-end)
                                 (treesit-node-end (treesit-defun-at-point)))))
          (let ((cops (or given-cops
                        (completing-read-multiple "Cops to Disable: "
                          jf/rubocop/list-all-cops nil t))))
            (save-excursion
              (goto-char beg)
              (let ((indentation (s-repeat (current-column) " ")))
                (kill-region beg end)
                (beginning-of-line)
                (insert
                  (s-join "\n"
                    (mapcar (lambda (cop)
                              (concat indentation "# rubocop:disable " cop))
                      cops))
                  "\n" indentation)
                (yank)
                (insert "\n"
                  (s-join "\n"
                    (mapcar (lambda (cop)
                              (concat indentation "# rubocop:enable " cop))
                      cops))))))
          (user-error "Not a region nor a function"))
        (user-error "%s is not derived from a ruby mode" major-mode)))

    ;; This function, tested against Ruby, will return the module space qualified
    ;; method name (e.g. Hello::World#method_name).
    (cl-defun jf/treesit/yank-qualified-method-fname ()
      "Return the fully qualified name of method at point.  If not on a
  method, get the containing class."
      (if-let ((func (treesit-defun-at-point)))
        ;; Instance method or class method?
        (let* ((method_type (if (string= "method"
                                  (treesit-node-type func))
                              "#" "."))
                (method_name (treesit-node-text
                               (car (treesit-filter-child
                                      func
                                      (lambda (node)
                                        (string= "identifier"
                                          (treesit-node-type node)))))))
                (module_space (s-join "::" (jf/treesit/module_space func))))
          (if current-prefix-arg
            module_space
            (concat module_space method_type method_name)))
        (let ((current-node (treesit-node-at (point))))
          (s-join "::" (jf/treesit/module_space current-node)))))
    ;; Handles the following Ruby code:
    ;;
    ;;   module A::B
    ;;     module C
    ;;     end
    ;;     C::D = Struct.new do
    ;;       def call
    ;;       end
    ;;     end
    ;;   end
    ;; Special thanks to https://eshelyaron.com/posts/2023-04-01-take-on-recursion.html
    (defun jf/treesit/module_space (node &optional acc)
      (if-let ((parent (treesit-parent-until
                         node
                         (lambda (n) (member (treesit-node-type n)
                                       '("class" "module" "assignment")))))
                (parent_name (treesit-node-text
                               (car
                                 (treesit-filter-child
                                   parent
                                   (lambda (n)
                                     (member (treesit-node-type n)
                                       '("constant" "scope_resolution"))))))))
        (jf/treesit/module_space parent (cons parent_name acc))
        acc)))


  (use-package treesit-auto
    :straight (:host github :repo "renzmann/treesit-auto")
    :config (setq treesit-auto-install 'prompt)
    (global-treesit-auto-mode))

  (use-package scopeline
    ;; Show the scope info of methods, blocks, if/case statements.  This is done
    ;; via an overlay for "blocks" that are more than 5 (default) lines
    :straight (:host github :repo "jeremyf/scopeline.el")
    :hook ((ruby-mode ruby-ts-mode) . scopeline-mode))

  ;;;; Other packages and their configurations
  (use-package bundler
    ;; For Ruby package management
    :straight (bundler :type git :host github :repo "endofunky/bundler.el"))

  (use-package csv-mode
    :straight t
    ;; By default I want to show the separator character.
    :custom (csv-invisibility-default nil)
    ;; Always enter CSV mode in align mode; makes it easier to read.
    :hook (csv-mode . csv-align-mode))

  ;; https://github.com/Silex/docker.el
  (use-package docker
    ;; A reality of modern development is that things happen in Docker.
    :straight t)

  (use-package dockerfile-mode
    ;; Given that I interact with docker files, I should have some syntax
    ;; awareness.
    :straight t)

  (use-package editorconfig
    ;; ‚ÄúEditorConfig helps maintain consistent coding styles for multiple
    ;; developers working on the same project across various editors and IDEs.‚Äù
    ;; See https://editorconfig.org/#overview for more details.
    :straight t
    :config
    (editorconfig-mode 1))

  (use-package eglot
    :straight (:host github :repo "joaotavora/eglot")
    ;; The Language Server Protocol (LSP) is a game changer; having access to that
    ;; tooling is very much a nice to have.
    :hook ((css-mode css-ts-mode
             ruby-mode ruby-ts-mode
             ;; yaml-mode yaml-ts-mode
             html-mode html-ts-mode
             js-mode js-ts-mode
             json-mode json-ts-mode
             scss-mode scss-ts-mode)
            . eglot-ensure)
    :hook ((eglot-managed-mode . jf/eglot-eldoc)
            (eglot-managed-mode . jf/eglot-capf))
    :preface
    (defun jf/eglot-eldoc ()
      ;; https://www.masteringemacs.org/article/seamlessly-merge-multiple-documentation-sources-eldoc
      (setq eldoc-documentation-strategy
        'eldoc-documentation-compose-eagerly))
    :config
    (setq eglot-events-buffer-size 0)
    ;; (use-package eglot-tempel
    ;; ;; I use `tempel' and I use `eglot'; having some glue between those helps.
    ;; :straight (eglot-tempel :host github :repo "fejfighter/eglot-tempel"))
    (add-to-list 'eglot-stay-out-of 'flymake)
    (setq completion-category-overrides '((eglot (styles orderless))))
    (add-to-list 'eglot-server-programs
      `(ruby-mode . ("solargraph" "socket" "--port" :autoport)))
    (add-to-list 'eglot-server-programs
      `(ruby-ts-mode . ("solargraph" "socket" "--port" :autoport)))
    (defun jf/eglot-capf ()
      ;; I don't want `eglot-completion-at-point' to trample my other completion
      ;; options.
      ;;
      ;; https://stackoverflow.com/questions/72601990/how-to-show-suggestions-for-yasnippets-when-using-eglot
      (setq-local completion-at-point-functions
        (list (cape-capf-super
                #'jf/version-control/project-capf
                #'jf/version-control/issue-capf
                #'eglot-completion-at-point
                #'tempel-expand
                #'cape-keyword)))))

  (use-package eldoc
    ;; Helps with rendering documentation
    ;; https://www.masteringemacs.org/article/seamlessly-merge-multiple-documentation-sources-eldoc
    :config
    (add-to-list 'display-buffer-alist
      '("^\\*eldoc for" display-buffer-at-bottom
         (window-height . 4)))
    (setq eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
    :straight t)

  ;; I don't use this package (I think...):
  ;; (use-package emmet-mode
  ;;   :straight t
  ;;   :bind (("C-c C-e" . emmet-expand-yas ))
  ;;   :hook ((sgml-mode . emmet-mode)
  ;;          (html-mode . emmet-mode)
  ;;          (css-mode . emmet-mode)))

  (require 'gherkin-mode)

  (use-package ruby-mode
    ;; My language of choice for professional work.
    :straight (:type built-in)
    :custom (ruby-flymake-use-rubocop-if-available nil)
    :bind
    (:map ruby-mode-map (("C-M-h" . jf/treesit/function-select)
                          ("C-c y f" . jf/treesit/yank-qualified-method-fname)
                          ("C-c w r" . jf/treesit/wrap-rubocop)))
    :hook ((ruby-mode ruby-ts-mode) .
            (lambda ()
              (eldoc-mode)
              (setq fill-column 100))))

  ;; An odd little creature, hide all comment lines.  Sometimes this can be a
  ;; useful tool for viewing implementation details.
  (require 'hide-comnt)

  (use-package json-mode
    ;; The web's data structure of choice is JSON.
    :straight t)

  (use-package json-reformat
    ;; Because JSON can be quite ugly, I want something to help tidy it up.
    :straight t
    :after json-mode
    :init (setq json-reformat:indent-width 2))

  (use-package hl-todo
    :straight t
    :config (global-hl-todo-mode)
    (setq hl-todo-keyword-faces
      '(("TODO"   . "#7f0000") ;; red-intense
         ("FIXME"  . "#7f0000")))) ;; red-intense

  ;;
  ;; https://github.com/alphapapa/magit-todos.git
  (use-package magit-todos
    :config (magit-todos-mode)
    :commands (magit-todos-list)
    :custom (magit-todos-exclude-globs '(".git/" "public/"))
    :straight (:host github :repo "alphapapa/magit-todos"))

  (use-package lua-mode
    ;; For working with https://www.hammerspoon.org; which provides me the
    ;; wonderful https://github.com/dmgerman/editWithEmacs.spoon/
    :straight t)

  (use-package markdown-mode
    :straight t
    :hook (((markdown-mode markdown-ts-mode) . turn-on-visual-line-mode))
    :mode (("README\\.md\\'" . gfm-mode)
            ("\\.md\\'" . markdown-mode)
            ("\\.markdown\\'" . markdown-mode))
    :preface
    (defun jf/markdown-toc (&optional depth)
      "Extract DEPTH (default 3) of headings from the current Markdown buffer.
     The generated and indented TOC will be inserted at point."
      (interactive "P")
      (let ((max-depth (or depth 3)) toc-list)
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward "^\\(##+\\)\\s-+\\(.*\\)" nil t)
            (let* ((level (length (match-string 1)))
                    (heading-text (match-string 2))
                    (heading-id (downcase (replace-regexp-in-string "[[:space:]]+" "-" heading-text))))
              (when (<= level max-depth)
                (push (cons level (cons heading-text heading-id)) toc-list)))))
        (setq toc-list (reverse toc-list))
        (dolist (item toc-list)
          (let* ((level (car item))
                  (heading-text (cadr item))
                  (heading-id (cddr item))
                  (indentation (make-string (- (* 2 (1- level)) 2) ?\ ))
                  (line (format "- [%s](#%s)\n" heading-text heading-id)))
            (setq markdown-toc (concat markdown-toc (concat indentation line)))))
        (insert markdown-toc)))
    :init
    (setq markdown-command "/opt/homebrew/bin/pandoc")
    (font-lock-add-keywords 'markdown-mode
      '(("{{[^}]+}}" . 'font-lock-function-name-face))))

  (use-package plantuml-mode
    ;; A mode for working with PlantUML.  See https://plantuml.com
    ;;
    ;;
    :config (setq plantuml-executable-path (concat
                                             (getenv "HB_PATH")
                                             "/bin/plantuml")
              plantuml-default-exec-mode 'executable
              org-plantuml-executable-path (concat
                                             (getenv "HB_PATH")
                                             "/bin/plantuml")
              org-plantuml-exec-mode 'executable)
    :mode (("\\.plantuml\\'" . plantuml-mode))
    :mode (("\\.puml\\'" . plantuml-mode))
    :straight t)

  (defun jf/require-debugger ()
    "Determine the correct debugger based on the Gemfile."
    (let ((gemfile-lock (f-join (projectile-project-root) "Gemfile.lock")))
      (if-let* ((f-exists? gemfile-lock)
                 (debuggers
                   (s-split "\n"
                     (shell-command-to-string
                       (concat
                         "rg \"^ +(byebug|debugger|pry-byebug|debug) \" "
                         gemfile-lock
                         " -r '$1' --only-matching | uniq")))))
        (cond
          ((member "byebug" debuggers) "require 'byebug'; byebug")
          ((member "debug" debuggers) "require 'debug'; binding.break")
          ((member "debugger" debuggers) "require 'debugger'; debugger")
          ((member "pry-byebug" debuggers) "require 'pry-byebug'; binding.pry")
          (t "require 'debug'; binding.break"))
        "require 'debug'; binding.break")))

  ;; (unbind-key "C-x C-r")
  ;; (use-package repl-driven-development
  ;;   ;; Type C-u and the command to print to the buffer.
  ;;   :straight t
  ;;   :config
  ;;   (repl-driven-development [C-x C-r b] "bash")
  ;;   (repl-driven-development [C-x C-r r] "irb --inf-ruby-mode" :prompt "irb(main):.*>"))

  (use-package rspec-mode
    ;; I write most of my Ruby tests using rspec.  This tool helps manage that
    ;; process.
    :straight t
    ;; Ensure that we‚Äôre loading ruby-mode before we do any rspec loading.
    :after ruby-mode
    :custom
    (rspec-docker-container "web")
    (rspec-use-spring-when-possible t)
    (rspec-use-docker-when-possible t)
    (rspec-docker-cwd "./")
    (rspec-docker-command "docker compose exec")
    :hook ((dired-mode . rspec-dired-mode)
            (ruby-mode . rspec-mode)
            (ruby-ts-mode . rspec-mode))
    ;; Dear reader, make sure that you can jump from spec and definition.  And in
    ;; Ruby land when you have lib/my_file.rb, the corresponding spec should be in
    ;; spec/my_file_spec.rb; and when you have app/models/my_file.rb, the spec
    ;; should be in spec/models/my_file_spec.rb
    :bind (:map rspec-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :bind (:map ruby-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :preface
    (defun jf/rspec-spring-p ()
      "Check the project for spring as part of the Gemfile.lock."
      (let ((gemfile-lock (f-join (projectile-project-root) "Gemfile.lock")))
        (and (f-exists? gemfile-lock)
          (s-present?
            (shell-command-to-string
              (concat "rg \"^ +spring-commands-rspec \" " gemfile-lock))))))
    ;; Out of the box, for my typical docker ecosystem, the `rspec-spring-p'
    ;; function does not work.  So I'm overriding the default behavior to match my
    ;; ecosystem.
    (advice-add #'rspec-spring-p :override #'jf/rspec-spring-p))

  (use-package ruby-interpolation
    ;; Nice and simple package for string interpolation.
    :straight t
    :hook (ruby-mode . ruby-interpolation-mode))

  (use-package sql-indent
    ;; SQL, oh how I love thee and wish I worked more with thee.
    :straight t
    :hook (sql-mode . sqlind-minor-mode))

  (use-package string-inflection
    ;; A quick way to change case and separators for words.
    :straight t)

  (use-package typescript-mode
    ;; I have this for the work I once did a few years ago.  I am happiest when
    ;; I'm not working in Javascript.
    :straight t)

  (use-package vterm
    ;; A terminal in Emacs.
    :straight t)

  (use-package web-mode
    ;; Help consistently edit web documents of SGML markup dialetcs.
    :straight t
    :config (setq web-mode-markup-indent-offset 2
              web-mode-css-indent-offset 2
              web-mode-code-indent-offset 2)
    :init
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list `auto-mode-alist '("\\.svg\\'" . xml-mode)))

  (use-package xml-format
    ;; Encountering unformatted XML is jarring; this package helps formatt it for
    ;; human legibility.
    :straight t
    :after nxml-mode)

  (use-package yaml-mode
    ;; Oh yaml, I once thought you better than XML.  Now, you are ubiquitous and a
    ;; bit imprecise.  Still better than JSON; which doesn't allow for comments.
    :straight t)

  (use-package yard-mode
    ;; My prefered Ruby documentation syntax
    :straight t
    :preface
    ;; This is not working as I had tested; it's very dependent on the little
    ;; details.  I think I may want to revisit to just work on the current line.
    (defun jf/ruby-mode/yank-yardoc ()
      "Add parameter yarddoc stubs for the current method."
      (interactive)
      (save-excursion
        (when-let* ((func (treesit-defun-at-point))
                     (method_parameters_text
                       (treesit-node-text (car
                                            (treesit-filter-child
                                              func
                                              (lambda (node)
                                                (string= "method_parameters"
                                                  (treesit-node-type node))))))))
          (goto-char (treesit-node-start func))
          ;; Grab the parameter names.
          (let* ((identifiers (mapcar (lambda (token)
                                        (replace-regexp-in-string
                                          "[^a-z|_]" ""
                                          (car (s-split " "
                                                 (s-trim token)))))
                                (s-split "," method_parameters_text)))
                  (indentation (s-repeat (current-column) " ")))
            (previous-line)
            (end-of-line)
            (insert
              (concat "\n" indentation "##\n")
              (s-join "\n" (mapcar
                             (lambda (param)
                               (concat indentation "# @param "
                                 param
                                 " [Object]"))
                             identifiers)))))))
    :bind* (:map ruby-mode-map (("C-c y f" . jf/yank-current-scoped-function-name)
                                 ("C-c y y" . jf/ruby-mode/yank-yardoc)))
    :hook ((ruby-mode ruby-ts-mode) . yard-mode))

  ;; I didn't know about `add-log-current-defun-function' until a blog reader
  ;; reached out.  Now, I'm making a general function for different modes.
  (defun jf/yank-current-scoped-function-name ()
    "Echo and kill the current scoped function name.

  See `add-log-current-defun-function'."
    (interactive)
    (if-let ((text (funcall add-log-current-defun-function)))
      (progn
        (message "%s" text)
        (kill-new (substring-no-properties text)))
      (user-error "Warning: Point not on function")))
  (bind-key "C-c y f" #'jf/yank-current-scoped-function-name prog-mode-map)
  (bind-key "C-c y f" #'jf/yank-current-scoped-function-name emacs-lisp-mode-map)

  (use-package devdocs
    ;; Download and install documents from https://devdocs.io/
    ;; Useful for having local inline docs.  Perhaps not always in the format that
    ;; I want, but can't have everything.
    :straight t
    :commands (devdocs-install))

  (use-package flymake
    :straight t
    ;; Don't be so hasty in syntax checking.
    :custom (flymake-no-changes-timeout 2))

  (use-package prog-mode
    :straight (:type built-in)
    :hook (prog-mode . jf/prog-mode-configurator)
    :preface
    (defun jf/prog-mode-configurator ()
      "Do the configuration of all the things."
      ;; I'll type my own parenthesis thank you very much.
      ;; (electric-pair-mode)
      (flymake-mode 1)
      (which-function-mode)))

  (use-package copilot
    ;; I want to explore this a bit, but by default want it "off" and to be
    ;; as unobtrusive.
    :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
    :bind (:map copilot-mode-map (("C-c 0 <return>" . copilot-accept-completion)
                                   ("C-c 0 <down>" .  copilot-next-completion)
                                   ("C-c 0 <up>" . copilot-previous-completion)
                                   ("C-c 0 DEL" . copilot-clear-overlay)
                                   ("C-c 0 TAB" . copilot-panel-complete)
                                   ("C-c 0 ESC" . copilot-mode)))
    :bind ("C-c 0 ESC" . copilot-mode)
    :custom
    ;; Copilot...never give me code comment recommendations.
    (copilot-disable-predicates '(er--point-is-in-comment-p))
    (copilot-idle-delay 1.5)
    :ensure t)

  (defvar jf/comment-header-regexp/major-modes-alist
    '((emacs-lisp-mode . "^;;;;*")
       (ruby-mode . "^[[:space:]]*###*$")
       (ruby-ts-mode . "^[[:space:]]*###*$"))
    "AList of major modes and their comment headers.")

  (defun jf/commend-header-forward ()
    "Move to next line matching `jf/comment-header-regexp/ruby-mode'."
    (interactive)
    (let ((regexp (alist-get major-mode jf/comment-header-regexp/major-modes-alist)))
      (when (string-match-p
              regexp
              (buffer-substring-no-properties
                (line-beginning-position)
                (line-end-position)))
        (forward-line))
      (condition-case err
        (progn
          (search-forward-regexp regexp)
          (beginning-of-line)
          (recenter scroll-margin t)
          (pulsar-pulse-line))
        (error (goto-char (point-max))))))

  (defun jf/comment-header-backward ()
    (interactive)
      (let ((regexp (alist-get major-mode jf/comment-header-regexp/major-modes-alist)))
    (when (string-match-p
            regexp
            (buffer-substring-no-properties
              (line-beginning-position)
              (line-end-position)))
      (previous-line)
      (recenter scroll-margin t)
      (pulsar-pulse-line))
    (condition-case err
      (progn
        (search-backward-regexp regexp)
        (beginning-of-line)
        (recenter scroll-margin t)
        (pulsar-pulse-line))
      (error (goto-char (point-min))))))

  (define-key ruby-mode-map (kbd "s-ESC") #'jf/comment-header-backward)
  (define-key emacs-lisp-mode-map (kbd "s-ESC") #'jf/comment-header-backward)
  (define-key ruby-mode-map (kbd "C-s-]") #'jf/commend-header-forward)
  (define-key emacs-lisp-mode-map (kbd "C-s-]") #'jf/commend-header-forward)

  (defun jf/ruby-ts-mode-configurator ()
    "Configure the `treesit' provided `ruby-ts-mode'."
    ;; I encountered some loading issues where ruby-ts-mode was not available
    ;; during my understanding of the use-package life-cycle.
    (setq-local add-log-current-defun-function #'jf/treesit/yank-qualified-method-fname)
    (define-key ruby-ts-mode-map (kbd "C-M-h") #'jf/treesit/function-select)
    (define-key ruby-ts-mode-map (kbd "C-c y f") #'jf/yank-current-scoped-function-name)
    (define-key ruby-ts-mode-map (kbd "C-c y y") #'jf/ruby-mode/yank-yardoc)
    (define-key ruby-ts-mode-map (kbd "s-ESC") #'jf/comment-header-backward)
    (define-key ruby-ts-mode-map (kbd "C-s-]") #'jf/commend-header-forward)
    (define-key ruby-ts-mode-map (kbd "C-c w r") #'jf/treesit/wrap-rubocop))
  (add-hook 'ruby-ts-mode-hook #'jf/ruby-ts-mode-configurator)

  ;; From https://emacs.dyerdwelling.family/emacs/20230414111409-emacs--indexing-emacs-init/
  ;;
  ;; Creating some outline modes.  Which has me thinking about an outline mode for
  ;; my agenda file.
  (add-hook 'emacs-lisp-mode-hook
    (lambda ()
      (setq imenu-sort-function 'imenu--sort-by-name)
      (setq imenu-generic-expression
        '((nil "^;;[[:space:]]+-> \\(.*\\)$" 1)
           ("defvar" "^([[:space:]]*\\(cl-\\)?defvar[[:space:]]+\\([^ ]*\\)$" 2)
           ("defconst" "^([[:space:]]*\\(cl-\\)?defconst[[:space:]]+\\([^ ]*\\)$" 2)
           ("defcustom" "^([[:space:]]*\\(cl-\\)?defcustom[[:space:]]+\\([^ ]*\\)$" 2)
           ("defun" "^([[:space:]]*\\(cl-\\)?defun[[:space:]]+\\([^(]+\\)" 2)
           ("macro" "^([[:space:]]*\\(cl-\\)?defmacro[[:space:]]+\\([^(]+\\)" 2)
           ("struct" "^([[:space:]]*\\(cl-\\)?defstruct[[:space:]]+\\([^(]+\\)" 2)
           ("use-package" "^.*([[:space:]]*use-package[[:space:]]+\\([[:word:]-]+\\)" 1)))
      (imenu-add-menubar-index)))

  (defvar jf/rubocop/list-all-cops
    ;; rubocop --show-cops | rg "^([A-Z][\w/]+):" -r '$1' | pbcopy
    '("Bundler/DuplicatedGem"
       "Bundler/GemComment"
       "Bundler/GemFilename"
       "Bundler/GemVersion"
       "Bundler/InsecureProtocolSource"
       "Bundler/OrderedGems"
       "Gemspec/DependencyVersion"
       "Gemspec/DeprecatedAttributeAssignment"
       "Gemspec/DevelopmentDependencies"
       "Gemspec/DuplicatedAssignment"
       "Gemspec/OrderedDependencies"
       "Gemspec/RequireMFA"
       "Gemspec/RequiredRubyVersion"
       "Gemspec/RubyVersionGlobalsUsage"
       "Layout/AccessModifierIndentation"
       "Layout/ArgumentAlignment"
       "Layout/ArrayAlignment"
       "Layout/AssignmentIndentation"
       "Layout/BeginEndAlignment"
       "Layout/BlockAlignment"
       "Layout/BlockEndNewline"
       "Layout/CaseIndentation"
       "Layout/ClassStructure"
       "Layout/ClosingHeredocIndentation"
       "Layout/ClosingParenthesisIndentation"
       "Layout/CommentIndentation"
       "Layout/ConditionPosition"
       "Layout/DefEndAlignment"
       "Layout/DotPosition"
       "Layout/ElseAlignment"
       "Layout/EmptyComment"
       "Layout/EmptyLineAfterGuardClause"
       "Layout/EmptyLineAfterMagicComment"
       "Layout/EmptyLineAfterMultilineCondition"
       "Layout/EmptyLineBetweenDefs"
       "Layout/EmptyLines"
       "Layout/EmptyLinesAroundAccessModifier"
       "Layout/EmptyLinesAroundArguments"
       "Layout/EmptyLinesAroundAttributeAccessor"
       "Layout/EmptyLinesAroundBeginBody"
       "Layout/EmptyLinesAroundBlockBody"
       "Layout/EmptyLinesAroundClassBody"
       "Layout/EmptyLinesAroundExceptionHandlingKeywords"
       "Layout/EmptyLinesAroundMethodBody"
       "Layout/EmptyLinesAroundModuleBody"
       "Layout/EndAlignment"
       "Layout/EndOfLine"
       "Layout/ExtraSpacing"
       "Layout/FirstArgumentIndentation"
       "Layout/FirstArrayElementIndentation"
       "Layout/FirstArrayElementLineBreak"
       "Layout/FirstHashElementIndentation"
       "Layout/FirstHashElementLineBreak"
       "Layout/FirstMethodArgumentLineBreak"
       "Layout/FirstMethodParameterLineBreak"
       "Layout/FirstParameterIndentation"
       "Layout/HashAlignment"
       "Layout/HeredocArgumentClosingParenthesis"
       "Layout/HeredocIndentation"
       "Layout/IndentationConsistency"
       "Layout/IndentationStyle"
       "Layout/IndentationWidth"
       "Layout/InitialIndentation"
       "Layout/LeadingCommentSpace"
       "Layout/LeadingEmptyLines"
       "Layout/LineContinuationLeadingSpace"
       "Layout/LineContinuationSpacing"
       "Layout/LineEndStringConcatenationIndentation"
       "Layout/MultilineArrayBraceLayout"
       "Layout/MultilineArrayLineBreaks"
       "Layout/MultilineAssignmentLayout"
       "Layout/MultilineBlockLayout"
       "Layout/MultilineHashBraceLayout"
       "Layout/MultilineHashKeyLineBreaks"
       "Layout/MultilineMethodArgumentLineBreaks"
       "Layout/MultilineMethodCallBraceLayout"
       "Layout/MultilineMethodCallIndentation"
       "Layout/MultilineMethodDefinitionBraceLayout"
       "Layout/MultilineMethodParameterLineBreaks"
       "Layout/MultilineOperationIndentation"
       "Layout/ParameterAlignment"
       "Layout/RedundantLineBreak"
       "Layout/RescueEnsureAlignment"
       "Layout/SingleLineBlockChain"
       "Layout/SpaceAfterColon"
       "Layout/SpaceAfterComma"
       "Layout/SpaceAfterMethodName"
       "Layout/SpaceAfterNot"
       "Layout/SpaceAfterSemicolon"
       "Layout/SpaceAroundBlockParameters"
       "Layout/SpaceAroundEqualsInParameterDefault"
       "Layout/SpaceAroundKeyword"
       "Layout/SpaceAroundMethodCallOperator"
       "Layout/SpaceAroundOperators"
       "Layout/SpaceBeforeBlockBraces"
       "Layout/SpaceBeforeBrackets"
       "Layout/SpaceBeforeComma"
       "Layout/SpaceBeforeComment"
       "Layout/SpaceBeforeFirstArg"
       "Layout/SpaceBeforeSemicolon"
       "Layout/SpaceInLambdaLiteral"
       "Layout/SpaceInsideArrayLiteralBrackets"
       "Layout/SpaceInsideArrayPercentLiteral"
       "Layout/SpaceInsideBlockBraces"
       "Layout/SpaceInsideHashLiteralBraces"
       "Layout/SpaceInsideParens"
       "Layout/SpaceInsidePercentLiteralDelimiters"
       "Layout/SpaceInsideRangeLiteral"
       "Layout/SpaceInsideReferenceBrackets"
       "Layout/SpaceInsideStringInterpolation"
       "Layout/TrailingEmptyLines"
       "Layout/TrailingWhitespace"
       "Lint/AmbiguousAssignment"
       "Lint/AmbiguousBlockAssociation"
       "Lint/AmbiguousOperator"
       "Lint/AmbiguousOperatorPrecedence"
       "Lint/AmbiguousRange"
       "Lint/AmbiguousRegexpLiteral"
       "Lint/AssignmentInCondition"
       "Lint/BigDecimalNew"
       "Lint/BinaryOperatorWithIdenticalOperands"
       "Lint/BooleanSymbol"
       "Lint/CircularArgumentReference"
       "Lint/ConstantDefinitionInBlock"
       "Lint/ConstantOverwrittenInRescue"
       "Lint/ConstantResolution"
       "Lint/Debugger"
       "Lint/DeprecatedClassMethods"
       "Lint/DeprecatedConstants"
       "Lint/DeprecatedOpenSSLConstant"
       "Lint/DisjunctiveAssignmentInConstructor"
       "Lint/DuplicateBranch"
       "Lint/DuplicateCaseCondition"
       "Lint/DuplicateElsifCondition"
       "Lint/DuplicateHashKey"
       "Lint/DuplicateMagicComment"
       "Lint/DuplicateMatchPattern"
       "Lint/DuplicateMethods"
       "Lint/DuplicateRegexpCharacterClassElement"
       "Lint/DuplicateRequire"
       "Lint/DuplicateRescueException"
       "Lint/EachWithObjectArgument"
       "Lint/ElseLayout"
       "Lint/EmptyBlock"
       "Lint/EmptyClass"
       "Lint/EmptyConditionalBody"
       "Lint/EmptyEnsure"
       "Lint/EmptyExpression"
       "Lint/EmptyFile"
       "Lint/EmptyInPattern"
       "Lint/EmptyInterpolation"
       "Lint/EmptyWhen"
       "Lint/EnsureReturn"
       "Lint/ErbNewArguments"
       "Lint/FlipFlop"
       "Lint/FloatComparison"
       "Lint/FloatOutOfRange"
       "Lint/FormatParameterMismatch"
       "Lint/HashCompareByIdentity"
       "Lint/HeredocMethodCallPosition"
       "Lint/IdentityComparison"
       "Lint/ImplicitStringConcatenation"
       "Lint/IncompatibleIoSelectWithFiberScheduler"
       "Lint/IneffectiveAccessModifier"
       "Lint/InheritException"
       "Lint/InterpolationCheck"
       "Lint/LambdaWithoutLiteralBlock"
       "Lint/LiteralAsCondition"
       "Lint/LiteralInInterpolation"
       "Lint/Loop"
       "Lint/MissingCopEnableDirective"
       "Lint/MissingSuper"
       "Lint/MixedRegexpCaptureTypes"
       "Lint/MultipleComparison"
       "Lint/NestedMethodDefinition"
       "Lint/NestedPercentLiteral"
       "Lint/NextWithoutAccumulator"
       "Lint/NoReturnInBeginEndBlocks"
       "Lint/NonAtomicFileOperation"
       "Lint/NonDeterministicRequireOrder"
       "Lint/NonLocalExitFromIterator"
       "Lint/NumberConversion"
       "Lint/NumberedParameterAssignment"
       "Lint/OrAssignmentToConstant"
       "Lint/OrderedMagicComments"
       "Lint/OutOfRangeRegexpRef"
       "Lint/ParenthesesAsGroupedExpression"
       "Lint/PercentStringArray"
       "Lint/PercentSymbolArray"
       "Lint/RaiseException"
       "Lint/RandOne"
       "Lint/RedundantCopDisableDirective"
       "Lint/RedundantCopEnableDirective"
       "Lint/RedundantDirGlobSort"
       "Lint/RedundantRequireStatement"
       "Lint/RedundantSafeNavigation"
       "Lint/RedundantSplatExpansion"
       "Lint/RedundantStringCoercion"
       "Lint/RedundantWithIndex"
       "Lint/RedundantWithObject"
       "Lint/RefinementImportMethods"
       "Lint/RegexpAsCondition"
       "Lint/RequireParentheses"
       "Lint/RequireRangeParentheses"
       "Lint/RequireRelativeSelfPath"
       "Lint/RescueException"
       "Lint/RescueType"
       "Lint/ReturnInVoidContext"
       "Lint/SafeNavigationChain"
       "Lint/SafeNavigationConsistency"
       "Lint/SafeNavigationWithEmpty"
       "Lint/ScriptPermission"
       "Lint/SelfAssignment"
       "Lint/SendWithMixinArgument"
       "Lint/ShadowedArgument"
       "Lint/ShadowedException"
       "Lint/ShadowingOuterLocalVariable"
       "Lint/StructNewOverride"
       "Lint/SuppressedException"
       "Lint/SymbolConversion"
       "Lint/Syntax"
       "Lint/ToEnumArguments"
       "Lint/ToJSON"
       "Lint/TopLevelReturnWithArgument"
       "Lint/TrailingCommaInAttributeDeclaration"
       "Lint/TripleQuotes"
       "Lint/UnderscorePrefixedVariableName"
       "Lint/UnexpectedBlockArity"
       "Lint/UnifiedInteger"
       "Lint/UnmodifiedReduceAccumulator"
       "Lint/UnreachableCode"
       "Lint/UnreachableLoop"
       "Lint/UnusedBlockArgument"
       "Lint/UnusedMethodArgument"
       "Lint/UriEscapeUnescape"
       "Lint/UriRegexp"
       "Lint/UselessAccessModifier"
       "Lint/UselessAssignment"
       "Lint/UselessElseWithoutRescue"
       "Lint/UselessMethodDefinition"
       "Lint/UselessRescue"
       "Lint/UselessRuby2Keywords"
       "Lint/UselessSetterCall"
       "Lint/UselessTimes"
       "Lint/Void"
       "Metrics/AbcSize"
       "Metrics/BlockLength"
       "Metrics/BlockNesting"
       "Metrics/ClassLength"
       "Metrics/CollectionLiteralLength"
       "Metrics/CyclomaticComplexity"
       "Metrics/LineLength"
       "Metrics/MethodLength"
       "Metrics/ModuleLength"
       "Metrics/ParameterLists"
       "Metrics/PerceivedComplexity"
       "Migration/DepartmentName"
       "Naming/AccessorMethodName"
       "Naming/AsciiIdentifiers"
       "Naming/BinaryOperatorParameterName"
       "Naming/BlockForwarding"
       "Naming/BlockParameterName"
       "Naming/ClassAndModuleCamelCase"
       "Naming/ConstantName"
       "Naming/FileName"
       "Naming/HeredocDelimiterCase"
       "Naming/HeredocDelimiterNaming"
       "Naming/InclusiveLanguage"
       "Naming/MemoizedInstanceVariableName"
       "Naming/MethodName"
       "Naming/MethodParameterName"
       "Naming/PredicateName"
       "Naming/RescuedExceptionsVariableName"
       "Naming/VariableName"
       "Naming/VariableNumber"
       "Performance/AncestorsInclude"
       "Performance/ArraySemiInfiniteRangeSlice"
       "Performance/BigDecimalWithNumericArgument"
       "Performance/BindCall"
       "Performance/BlockGivenWithExplicitBlock"
       "Performance/Caller"
       "Performance/CaseWhenSplat"
       "Performance/Casecmp"
       "Performance/ChainArrayAllocation"
       "Performance/CollectionLiteralInLoop"
       "Performance/CompareWithBlock"
       "Performance/ConcurrentMonotonicTime"
       "Performance/ConstantRegexp"
       "Performance/Count"
       "Performance/DeletePrefix"
       "Performance/DeleteSuffix"
       "Performance/Detect"
       "Performance/DoubleStartEndWith"
       "Performance/EndWith"
       "Performance/FixedSize"
       "Performance/FlatMap"
       "Performance/InefficientHashSearch"
       "Performance/IoReadlines"
       "Performance/MapCompact"
       "Performance/MethodObjectAsBlock"
       "Performance/OpenStruct"
       "Performance/RangeInclude"
       "Performance/RedundantBlockCall"
       "Performance/RedundantEqualityComparisonBlock"
       "Performance/RedundantMatch"
       "Performance/RedundantMerge"
       "Performance/RedundantSortBlock"
       "Performance/RedundantSplitRegexpArgument"
       "Performance/RedundantStringChars"
       "Performance/RegexpMatch"
       "Performance/ReverseEach"
       "Performance/ReverseFirst"
       "Performance/SelectMap"
       "Performance/Size"
       "Performance/SortReverse"
       "Performance/Squeeze"
       "Performance/StartWith"
       "Performance/StringIdentifierArgument"
       "Performance/StringInclude"
       "Performance/StringReplacement"
       "Performance/Sum"
       "Performance/TimesMap"
       "Performance/UnfreezeString"
       "Performance/UriDefaultParser"
       "RSpec/AlignLeftLetBrace"
       "RSpec/AlignRightLetBrace"
       "RSpec/AnyInstance"
       "RSpec/AroundBlock"
       "RSpec/Be"
       "RSpec/BeEq"
       "RSpec/BeEql"
       "RSpec/BeNil"
       "RSpec/BeforeAfterAll"
       "RSpec/ChangeByZero"
       "RSpec/ContextMethod"
       "RSpec/ContextWording"
       "RSpec/DescribeClass"
       "RSpec/DescribeMethod"
       "RSpec/DescribeSymbol"
       "RSpec/DescribedClass"
       "RSpec/DescribedClassModuleWrapping"
       "RSpec/Dialect"
       "RSpec/EmptyExampleGroup"
       "RSpec/EmptyHook"
       "RSpec/EmptyLineAfterExample"
       "RSpec/EmptyLineAfterExampleGroup"
       "RSpec/EmptyLineAfterFinalLet"
       "RSpec/EmptyLineAfterHook"
       "RSpec/EmptyLineAfterSubject"
       "RSpec/ExampleLength"
       "RSpec/ExampleWithoutDescription"
       "RSpec/ExampleWording"
       "RSpec/ExcessiveDocstringSpacing"
       "RSpec/ExpectActual"
       "RSpec/ExpectChange"
       "RSpec/ExpectInHook"
       "RSpec/ExpectOutput"
       "RSpec/FilePath"
       "RSpec/Focus"
       "RSpec/HookArgument"
       "RSpec/HooksBeforeExamples"
       "RSpec/IdenticalEqualityAssertion"
       "RSpec/ImplicitBlockExpectation"
       "RSpec/ImplicitExpect"
       "RSpec/ImplicitSubject"
       "RSpec/InstanceSpy"
       "RSpec/InstanceVariable"
       "RSpec/ItBehavesLike"
       "RSpec/IteratedExpectation"
       "RSpec/LeadingSubject"
       "RSpec/LeakyConstantDeclaration"
       "RSpec/LetBeforeExamples"
       "RSpec/LetSetup"
       "RSpec/MessageChain"
       "RSpec/MessageExpectation"
       "RSpec/MessageSpies"
       "RSpec/MissingExampleGroupArgument"
       "RSpec/MultipleDescribes"
       "RSpec/MultipleExpectations"
       "RSpec/MultipleMemoizedHelpers"
       "RSpec/MultipleSubjects"
       "RSpec/NamedSubject"
       "RSpec/NestedGroups"
       "RSpec/NotToNot"
       "RSpec/OverwritingSetup"
       "RSpec/Pending"
       "RSpec/PredicateMatcher"
       "RSpec/ReceiveCounts"
       "RSpec/ReceiveNever"
       "RSpec/RepeatedDescription"
       "RSpec/RepeatedExample"
       "RSpec/RepeatedExampleGroupBody"
       "RSpec/RepeatedExampleGroupDescription"
       "RSpec/RepeatedIncludeExample"
       "RSpec/ReturnFromStub"
       "RSpec/ScatteredLet"
       "RSpec/ScatteredSetup"
       "RSpec/SharedContext"
       "RSpec/SharedExamples"
       "RSpec/SingleArgumentMessageChain"
       "RSpec/StubbedMock"
       "RSpec/SubjectDeclaration"
       "RSpec/SubjectStub"
       "RSpec/UnspecifiedException"
       "RSpec/VariableDefinition"
       "RSpec/VariableName"
       "RSpec/VerifiedDoubleReference"
       "RSpec/VerifiedDoubles"
       "RSpec/VoidExpect"
       "RSpec/Yield"
       "RSpec/Capybara/CurrentPathExpectation"
       "RSpec/Capybara/FeatureMethods"
       "RSpec/Capybara/VisibilityMatcher"
       "RSpec/FactoryBot/AttributeDefinedStatically"
       "RSpec/FactoryBot/CreateList"
       "RSpec/FactoryBot/FactoryClassName"
       "RSpec/FactoryBot/SyntaxMethods"
       "RSpec/Rails/AvoidSetupHook"
       "RSpec/Rails/HttpStatus"
       "Rails/ActionControllerTestCase"
       "Rails/ActionFilter"
       "Rails/ActiveRecordAliases"
       "Rails/ActiveRecordCallbacksOrder"
       "Rails/ActiveRecordOverride"
       "Rails/ActiveSupportAliases"
       "Rails/AddColumnIndex"
       "Rails/AfterCommitOverride"
       "Rails/ApplicationController"
       "Rails/ApplicationJob"
       "Rails/ApplicationMailer"
       "Rails/ApplicationRecord"
       "Rails/ArelStar"
       "Rails/AssertNot"
       "Rails/AttributeDefaultBlockValue"
       "Rails/BelongsTo"
       "Rails/Blank"
       "Rails/BulkChangeTable"
       "Rails/CompactBlank"
       "Rails/ContentTag"
       "Rails/CreateTableWithTimestamps"
       "Rails/Date"
       "Rails/DefaultScope"
       "Rails/Delegate"
       "Rails/DelegateAllowBlank"
       "Rails/DeprecatedActiveModelErrorsMethods"
       "Rails/DotSeparatedKeys"
       "Rails/DuplicateAssociation"
       "Rails/DuplicateScope"
       "Rails/DurationArithmetic"
       "Rails/DynamicFindBy"
       "Rails/EagerEvaluationLogMessage"
       "Rails/EnumHash"
       "Rails/EnumUniqueness"
       "Rails/EnvironmentComparison"
       "Rails/EnvironmentVariableAccess"
       "Rails/Exit"
       "Rails/ExpandedDateRange"
       "Rails/FilePath"
       "Rails/FindBy"
       "Rails/FindById"
       "Rails/FindEach"
       "Rails/HasAndBelongsToMany"
       "Rails/HasManyOrHasOneDependent"
       "Rails/HelperInstanceVariable"
       "Rails/HttpPositionalArguments"
       "Rails/HttpStatus"
       "Rails/I18nLazyLookup"
       "Rails/I18nLocaleAssignment"
       "Rails/I18nLocaleTexts"
       "Rails/IgnoredSkipActionFilterOption"
       "Rails/IndexBy"
       "Rails/IndexWith"
       "Rails/Inquiry"
       "Rails/InverseOf"
       "Rails/LexicallyScopedActionFilter"
       "Rails/LinkToBlank"
       "Rails/MailerName"
       "Rails/MatchRoute"
       "Rails/MigrationClassName"
       "Rails/NegateInclude"
       "Rails/NotNullColumn"
       "Rails/OrderById"
       "Rails/Output"
       "Rails/OutputSafety"
       "Rails/Pick"
       "Rails/Pluck"
       "Rails/PluckId"
       "Rails/PluckInWhere"
       "Rails/PluralizationGrammar"
       "Rails/Presence"
       "Rails/Present"
       "Rails/RakeEnvironment"
       "Rails/ReadWriteAttribute"
       "Rails/RedundantAllowNil"
       "Rails/RedundantForeignKey"
       "Rails/RedundantPresenceValidationOnBelongsTo"
       "Rails/RedundantReceiverInWithOptions"
       "Rails/RedundantTravelBack"
       "Rails/ReflectionClassName"
       "Rails/RefuteMethods"
       "Rails/RelativeDateConstant"
       "Rails/RenderInline"
       "Rails/RenderPlainText"
       "Rails/RequestReferer"
       "Rails/RequireDependency"
       "Rails/ReversibleMigration"
       "Rails/ReversibleMigrationMethodDefinition"
       "Rails/RootJoinChain"
       "Rails/RootPublicPath"
       "Rails/SafeNavigation"
       "Rails/SafeNavigationWithBlank"
       "Rails/SaveBang"
       "Rails/SchemaComment"
       "Rails/ScopeArgs"
       "Rails/ShortI18n"
       "Rails/SkipsModelValidations"
       "Rails/SquishedSQLHeredocs"
       "Rails/StripHeredoc"
       "Rails/TableNameAssignment"
       "Rails/TimeZone"
       "Rails/TimeZoneAssignment"
       "Rails/ToFormattedS"
       "Rails/TransactionExitStatement"
       "Rails/UniqBeforePluck"
       "Rails/UniqueValidationWithoutIndex"
       "Rails/UnknownEnv"
       "Rails/UnusedIgnoredColumns"
       "Rails/Validation"
       "Rails/WhereEquals"
       "Rails/WhereExists"
       "Rails/WhereNot"
       "Security/CompoundHash"
       "Security/Eval"
       "Security/IoMethods"
       "Security/JSONLoad"
       "Security/MarshalLoad"
       "Security/Open"
       "Security/YAMLLoad"
       "Style/AccessModifierDeclarations"
       "Style/AccessorGrouping"
       "Style/Alias"
       "Style/AndOr"
       "Style/ArgumentsForwarding"
       "Style/ArrayCoercion"
       "Style/ArrayIntersect"
       "Style/ArrayJoin"
       "Style/AsciiComments"
       "Style/Attr"
       "Style/AutoResourceCleanup"
       "Style/BarePercentLiterals"
       "Style/BeginBlock"
       "Style/BisectedAttrAccessor"
       "Style/BlockComments"
       "Style/BlockDelimiters"
       "Style/CaseEquality"
       "Style/CaseLikeIf"
       "Style/CharacterLiteral"
       "Style/ClassAndModuleChildren"
       "Style/ClassCheck"
       "Style/ClassEqualityComparison"
       "Style/ClassMethods"
       "Style/ClassMethodsDefinitions"
       "Style/ClassVars"
       "Style/CollectionCompact"
       "Style/CollectionMethods"
       "Style/ColonMethodCall"
       "Style/ColonMethodDefinition"
       "Style/CombinableLoops"
       "Style/CommandLiteral"
       "Style/CommentAnnotation"
       "Style/CommentedKeyword"
       "Style/ComparableClamp"
       "Style/ConcatArrayLiterals"
       "Style/ConditionalAssignment"
       "Style/ConstantVisibility"
       "Style/Copyright"
       "Style/DataInheritance"
       "Style/DateTime"
       "Style/DefWithParentheses"
       "Style/Dir"
       "Style/DirEmpty"
       "Style/DisableCopsWithinSourceCodeDirective"
       "Style/DocumentDynamicEvalDefinition"
       "Style/Documentation"
       "Style/DocumentationMethod"
       "Style/DoubleCopDisableDirective"
       "Style/DoubleNegation"
       "Style/EachForSimpleLoop"
       "Style/EachWithObject"
       "Style/EmptyBlockParameter"
       "Style/EmptyCaseCondition"
       "Style/EmptyElse"
       "Style/EmptyHeredoc"
       "Style/EmptyLambdaParameter"
       "Style/EmptyLiteral"
       "Style/EmptyMethod"
       "Style/Encoding"
       "Style/EndBlock"
       "Style/EndlessMethod"
       "Style/EnvHome"
       "Style/EvalWithLocation"
       "Style/EvenOdd"
       "Style/ExpandPathArguments"
       "Style/ExplicitBlockArgument"
       "Style/ExponentialNotation"
       "Style/FetchEnvVar"
       "Style/FileEmpty"
       "Style/FileRead"
       "Style/FileWrite"
       "Style/FloatDivision"
       "Style/For"
       "Style/FormatString"
       "Style/FormatStringToken"
       "Style/FrozenStringLiteralComment"
       "Style/GlobalStdStream"
       "Style/GlobalVars"
       "Style/GuardClause"
       "Style/HashAsLastArrayItem"
       "Style/HashConversion"
       "Style/HashEachMethods"
       "Style/HashExcept"
       "Style/HashLikeCase"
       "Style/HashSyntax"
       "Style/HashTransformKeys"
       "Style/HashTransformValues"
       "Style/IdenticalConditionalBranches"
       "Style/IfInsideElse"
       "Style/IfUnlessModifier"
       "Style/IfUnlessModifierOfIfUnless"
       "Style/IfWithBooleanLiteralBranches"
       "Style/IfWithSemicolon"
       "Style/ImplicitRuntimeError"
       "Style/InPatternThen"
       "Style/InfiniteLoop"
       "Style/InlineComment"
       "Style/InverseMethods"
       "Style/InvertibleUnlessCondition"
       "Style/IpAddresses"
       "Style/KeywordParametersOrder"
       "Style/Lambda"
       "Style/LambdaCall"
       "Style/LineEndConcatenation"
       "Style/MagicCommentFormat"
       "Style/MapCompactWithConditionalBlock"
       "Style/MapToHash"
       "Style/MapToSet"
       "Style/MethodCallWithArgsParentheses"
       "Style/MethodCallWithoutArgsParentheses"
       "Style/MethodCalledOnDoEndBlock"
       "Style/MethodDefParentheses"
       "Style/MinMax"
       "Style/MinMaxComparison"
       "Style/MissingElse"
       "Style/MissingRespondToMissing"
       "Style/MixinGrouping"
       "Style/MixinUsage"
       "Style/ModuleFunction"
       "Style/MultilineBlockChain"
       "Style/MultilineIfModifier"
       "Style/MultilineIfThen"
       "Style/MultilineInPatternThen"
       "Style/MultilineMemoization"
       "Style/MultilineMethodSignature"
       "Style/MultilineTernaryOperator"
       "Style/MultilineWhenThen"
       "Style/MultipleComparison"
       "Style/MutableConstant"
       "Style/NegatedIf"
       "Style/NegatedIfElseCondition"
       "Style/NegatedUnless"
       "Style/NegatedWhile"
       "Style/NestedFileDirname"
       "Style/NestedModifier"
       "Style/NestedParenthesizedCalls"
       "Style/NestedTernaryOperator"
       "Style/Next"
       "Style/NilComparison"
       "Style/NilLambda"
       "Style/NonNilCheck"
       "Style/Not"
       "Style/NumberedParameters"
       "Style/NumberedParametersLimit"
       "Style/NumericLiteralPrefix"
       "Style/NumericLiterals"
       "Style/NumericPredicate"
       "Style/ObjectThen"
       "Style/OneLineConditional"
       "Style/OpenStructUse"
       "Style/OperatorMethodCall"
       "Style/OptionHash"
       "Style/OptionalArguments"
       "Style/OptionalBooleanParameter"
       "Style/OrAssignment"
       "Style/ParallelAssignment"
       "Style/ParenthesesAroundCondition"
       "Style/PercentLiteralDelimiters"
       "Style/PercentQLiterals"
       "Style/PerlBackrefs"
       "Style/PreferredHashMethods"
       "Style/Proc"
       "Style/QuotedSymbols"
       "Style/RaiseArgs"
       "Style/RandomWithOffset"
       "Style/RedundantArgument"
       "Style/RedundantAssignment"
       "Style/RedundantBegin"
       "Style/RedundantCapitalW"
       "Style/RedundantCondition"
       "Style/RedundantConditional"
       "Style/RedundantConstantBase"
       "Style/RedundantDoubleSplatHashBraces"
       "Style/RedundantEach"
       "Style/RedundantException"
       "Style/RedundantFetchBlock"
       "Style/RedundantFileExtensionInRequire"
       "Style/RedundantFreeze"
       "Style/RedundantHeredocDelimiterQuotes"
       "Style/RedundantInitialize"
       "Style/RedundantInterpolation"
       "Style/RedundantLineContinuation"
       "Style/RedundantParentheses"
       "Style/RedundantPercentQ"
       "Style/RedundantRegexpCharacterClass"
       "Style/RedundantRegexpEscape"
       "Style/RedundantReturn"
       "Style/RedundantSelf"
       "Style/RedundantSelfAssignment"
       "Style/RedundantSelfAssignmentBranch"
       "Style/RedundantSort"
       "Style/RedundantSortBy"
       "Style/RedundantStringEscape"
       "Style/RegexpLiteral"
       "Style/RequireOrder"
       "Style/RescueModifier"
       "Style/RescueStandardError"
       "Style/ReturnNil"
       "Style/SafeNavigation"
       "Style/Sample"
       "Style/SelectByRegexp"
       "Style/SelfAssignment"
       "Style/Semicolon"
       "Style/Send"
       "Style/SignalException"
       "Style/SingleArgumentDig"
       "Style/SingleLineBlockParams"
       "Style/SingleLineMethods"
       "Style/SlicingWithRange"
       "Style/SoleNestedConditional"
       "Style/SpecialGlobalVars"
       "Style/StabbyLambdaParentheses"
       "Style/StaticClass"
       "Style/StderrPuts"
       "Style/StringChars"
       "Style/StringConcatenation"
       "Style/StringHashKeys"
       "Style/StringLiterals"
       "Style/StringLiteralsInInterpolation"
       "Style/StringMethods"
       "Style/Strip"
       "Style/StructInheritance"
       "Style/SwapValues"
       "Style/SymbolArray"
       "Style/SymbolLiteral"
       "Style/SymbolProc"
       "Style/TernaryParentheses"
       "Style/TopLevelMethodDefinition"
       "Style/TrailingBodyOnClass"
       "Style/TrailingBodyOnMethodDefinition"
       "Style/TrailingBodyOnModule"
       "Style/TrailingCommaInArguments"
       "Style/TrailingCommaInArrayLiteral"
       "Style/TrailingCommaInBlockArgs"
       "Style/TrailingCommaInHashLiteral"
       "Style/TrailingMethodEndStatement"
       "Style/TrailingUnderscoreVariable"
       "Style/TrivialAccessors"
       "Style/UnlessElse"
       "Style/UnlessLogicalOperators"
       "Style/UnpackFirst"
       "Style/VariableInterpolation"
       "Style/WhenThen"
       "Style/WhileUntilDo"
       "Style/WhileUntilModifier"
       "Style/WordArray"
       "Style/YodaCondition"
       "Style/YodaExpression"
       "Style/ZeroLengthPredicate")
    "List of all cops.")

  ;; (require 'jf-copilot)

  (provide 'jf-coding)
  ;;; jf-coding.el ends here
#+end_src

** =jf-communicating.el=
#+begin_src emacs-lisp :tangle "jf-communicating.el" :results none
  ;;; jf-communicating.el --- Communication tooling -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary

  ;; Packages specifically here for helping with my communicating activities.

  ;;; Code

  (use-package mastodon
    :straight t
    :config (setq mastodon-instance-url "https://dice.camp"
                            mastodon-active-user "takeonrules"))

  (bind-key "s-3" #'jf/browsing-menu)
  (transient-define-prefix jf/browsing-menu ()
    "For browsing things."
    [["Mastodon"
       ("m /" "Buffers" mastodon-switch-to-buffer)
       ("m f" "Federated Timeline" mastodon-tl--get-federated-timeline)
       ("m h" "Home Timeline" mastodon-tl--get-home-timeline)
       ("m l" "Local Timeline" mastodon-tl--get-local-timeline)
       ("m n" "Notifications" mastodon-notifications-get)
       ("m #" "Tags Timeline" mastodon-tl--followed-tags-timeline)
       ("m t" "Toot‚Ä¶" mastodon-toot)
       ]])

  (provide 'jf-communicating)
  ;;; jf-communicating.el ends here
#+end_src
** =jf-completing.el=
#+begin_src emacs-lisp :tangle "jf-completing.el" :results none
  ;;; jf-completing.el --- Packages of the "completing" variety -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;; These packages help configure the "completing" activity in coding.  The
  ;; general idea of find me something.

  ;;; Code:

  ;;;; Other packages and their configurations

  (require 'jf-org-mode)

  (use-package abbrev
    ;; The =abbrev= package is simple and powerful, providing an auto-correct
    ;; that I configure.  No more ‚Äúteh‚Äù in my text.
    :straight (:type built-in)
    :custom (abbrev-file-name (file-truename
                                "~/git/dotemacs/emacs.d/abbrev_defs"))
    :hook (text-mode . abbrev-mode))

  ;; https://github.com/ChanderG/lam
  ;;
  ;; Create a buffer specific `abbrev'
  (use-package lam
    :straight (:host github :repo "ChanderG/lam")
    :bind ("C-x l" . #'lam/control))

  (use-package emacs
    :bind ("C-M-i" . completion-at-point)
    ("TAB" . indent-for-tab-command)
    :init
    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
    (setq read-extended-command-predicate
      #'command-completion-default-include-p)
    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)
    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (format "[%s %s] %s"
              (propertize "CRM" 'face 'error)
              (propertize
                (replace-regexp-in-string
                  "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                  crm-separator)
                'face 'success)
              (car args))
        (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)
    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))

  (use-package embark
    ;; The "missing" context menu; a bit like the right-click but more.
    :straight t
    :bind
    (("C-." . embark-act)       ;; pick some comfortable binding
      ("M-." . embark-dwim)
      ("C-s-e" . embark-export)
      ("H-e" . embark-export)
      ("C-h b" . embark-bindings))
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    (setq embark-action-indicator
      (lambda (map &optional _target)
        (which-key--show-keymap "Embark" map nil nil 'no-paging)
        #'which-key--hide-popup-ignore-command)
      embark-become-indicator embark-action-indicator))

  (use-package consult
    ;; Extensions for the numerous `completing-read' functions.  Highly extensible
    ;; and customizable.
    :straight t
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
            ("C-c h" . consult-history)
            ("C-c b" . consult-buffer)
            ("C-c k" . consult-kmacro)
            ;; C-x bindings (ctl-x-map)
            ("C-x M-:" . consult-complex-command)
            ("C-x b" . consult-bookmark)
            ("s-b" . consult-buffer)
            ("C-x 4 b" . consult-buffer-other-window)
            ;; Custom M-# bindings for fast register access
            ("M-#" . consult-register-load)
            ("M-'" . consult-register-store)
            ("M-`" . consult-register)
            ;; Other custom bindings
            ("C-y" . yank)
            ("C-c C-/" . #'consult-clock-in)
            ("M-y" . consult-yank-from-kill-ring)
            ("M-s k" . consult-keep-lines)
            ("M-s u" . consult-focus-lines)
            ;; M-g bindings (goto-map)
            ("M-g e" . consult-compile-error)
            ("M-g g" . consult-goto-line)
            ("H-o" . consult-org-agenda)
            ("M-g M-o" . consult-org-agenda)
            ("M-g M-g" . consult-goto-line)
            ("s-l" . consult-goto-line)
            ("C-l" . consult-goto-line)
            ("M-g o" . consult-outline)
            ("M-g m" . consult-mark)
            ("M-g M" . consult-global-mark)
            ("C-x C-SPC" . consult-global-mark)
            ("M-i" . jf/consult-imenu)
            ("M-g i" . consult-imenu)
            ("M-g I" . consult-imenu-multi)
            ;; M-s bindings (search-map)
            ("M-s f" . consult-find)
            ;; ("M-s L" . consult-locate)
            ;; ("M-s g" . consult-git-grep)
            ;; ("M-s G" . consult-git-grep)
            ;;
            ;; I keep this around because orderless search is great
            ("M-s r" . consult-ripgrep)
            ;; ("C-c f" . consult-ripgrep)
            ;; ("M-s l" . consult-line)
            ("M-s M-s" . consult-line-multi)
            ;; Customizations that map to ivy
            ("C-c r" . consult-recent-file)
            ;; ("C-c o" . consult-file-externally)
            ("C-s" . consult-line) ;; I've long favored Swiper mapped to c-s
            ;; Isearch integration
            ("M-s e" . consult-isearch-history)
            :map isearch-mode-map
            ("M-e" . consult-isearch-history)
            ("M-s e" . consult-isearch-history)
            ("M-s l" . consult-line))
    :commands (consult--read)
    ;; The :init configuration is always executed (Not lazy)
    :init
    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
      xref-show-definitions-function #'consult-xref)
    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
      register-preview-function #'consult-register-format)
    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)
    :custom
    (consult-narrow-key "<")
    ;; Updating the default to include "--smart-case"
    ;; Leveraging ripgrep-all https://github.com/phiresky/ripgrep-all
    (consult-ripgrep-command
      (concat "rg --null --hidden --line-buffered --color=ansi --max-columns=1000 "
        "--smart-case --no-heading --line-number --no-ignore-vcs "
        "--glob !vendor/ --glob !coverage/ --glob !**/tmp/ --glob !**/log/ "
        "--glob !public/ --glob !node_modules/ --glob !.git/ --glob !doc/ "
        "--glob !.yardoc/ --glob !.byebug_history "
        " . -e ARG OPTS"))
    (consult-ripgrep-args
      (concat "rg --null --hidden --line-buffered --color=never --max-columns=1000 "
        "--path-separator / --no-ignore-vcs --smart-case --no-heading "
        "--glob !vendor/ --glob !coverage/ --glob !**/tmp/ --glob !**/log/ "
        "--glob !public/ --glob !node_modules/ --glob !.git/ --glob !doc/ "
        "--glob !.yardoc/ --glob !.byebug_history "
        "--line-number "))
    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :preface
    (defun jf/consult-imenu (prefix)
      "Call `consult-imenu' or when PREFIX is given call `consult-imenu-multi'."
      (interactive "P")
      (if (car prefix)
        (consult-imenu-multi)
        (consult-imenu)))
    (defun consult-clock-in (prefix &optional match)
      "Clock into an Org agenda heading picking from MATCH.

  With a PREFIX jump to the agenda without starting the clock."
      (interactive "P")
      (let ((the-match (or match "TODO=\"STARTED\"|TODO=\"TODO\"")))
        (if prefix
          (consult-org-agenda the-match)
          (save-window-excursion
            (consult-org-agenda the-match)
            (org-clock-in)))))
    (defun jf/consult-buffer-kill ()
      "In `consult-buffer' kill the current candidate"
      (interactive)
      (let ((marker (string #x200002)) ;; probably some internal detail :(
             (candidate (vertico--candidate)))
        (when (s-ends-with? marker candidate)
          (kill-buffer (s-replace marker "" candidate))
          (vertico-next))))
    ;; Customizations
    :config
    (consult-customize
      consult-line consult-ripgrep consult-find
      :initial (when (use-region-p)
                 (buffer-substring-no-properties (region-beginning) (region-end)))
      ;; https://github.com/minad/consult/wiki#org-clock
      consult-clock-in
      :prompt "Clock in: "
      :preview-key "M-."
      :group
      (lambda (cand transform)
        (let* ((marker (get-text-property 0 'consult--candidate cand))
                (name (if (member marker org-clock-history)
                        "*Recent*"
                        (buffer-name (marker-buffer marker)))))
          (if transform (substring cand (1+ (length name))) name))))
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root))


  (use-package embark-consult
    ;; I use ~embark.el~ and ~consult.el~, let‚Äôs add a little bit more connective
    ;;  tissue.
    :straight t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

  (use-package consult-dir
    ;; This package helps ease traveling across directories by providing directory
    ;; candidates related to current buffers, bookmarks, and projects.  Further,
    ;; like other ~consult.el~ functions, you can use narrowing keys.  See
    ;; https://github.com/karthink/consult-dir.
    :straight t
    :after (consult)
    :bind (("C-x C-d" . consult-dir)
            :map minibuffer-local-completion-map
            ("C-x C-d" . consult-dir)
            ("C-x C-j" . consult-dir-jump-file)))

  (use-package consult-projectile
    ;; package provides a function I use everyday: ~M-x consult-projectile~.  When
    ;; I invoke ~consult-projectile~, I have the file completion for the current
    ;; project.  I can also type =b= + =SPACE= to narrow my initial search to open
    ;; buffers in the project.  Or =p= + =space= to narrow to other projects; and
    ;; then select a file within that project.
    :commands (consult-projectile)
    :straight (consult-projectile
                :type git
                :host gitlab
                :repo "OlMon/consult-projectile"
                :branch "master")
    :config
    (setq consult-projectile-sources
      '( ;; key b
         consult-projectile--source-projectile-buffer
         ;; key f
         consult-projectile--source-projectile-file
         ;; key p
         consult-projectile--source-projectile-project
         ;; key d
         consult-projectile--source-projectile-dir
         ;; key m
         consult--source-bookmark
         ;; key r
         consult-projectile--source-projectile-recentf
         ;; key *
         consult--source-modified-buffer))

    (defun consult-find-file-with-preview (prompt &optional dir default mustmatch initial pred)
      (interactive)
      (let ((default-directory (or dir default-directory)))
        (consult--read #'read-file-name-internal :state (consult--file-preview)
          :prompt prompt
          :initial initial
          :require-match mustmatch
          :predicate pred)))
    :bind
    ;;; This overwrite `ns-open-file-using-panel'; the operating system's "Finder"
    ;; ("C-c o" . consult-projectile)
    ;;; I have long had Cmd+t mapped to opening project files; however, I'm
    ;;; noticing the way I'm typing this and it is feeling wrong.  So now I won't
    ;;; have that way open.
    ("s-t" . consult-projectile)
    ("s-p" . consult-projectile)
    ("H-t" . consult-projectile)
    ("H-p" . consult-projectile))

  (use-package corfu
    ;; Completion overlay; a narrower intreface than the more verbose company.
    :straight t
    ;; Optionally use TAB for cycling, default is `corfu-complete'.
    :bind (:map corfu-map
            ("M-m" . corfu-move-to-minibuffer)
            ("<escape>". corfu-quit)
            ("<return>" . corfu-insert)
            ("M-d" . corfu-show-documentation)
            ("M-l" . 'corfu-show-location)
            ("TAB" . corfu-next)
            ([tab] . corfu-next)
            ("S-TAB" . corfu-previous)
            ([backtab] . corfu-previous))
    :custom
    ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
    ;; want to perform completion
    (tab-always-indent 'complete)
    (completion-cycle-threshold nil)      ; Always show candidates in menu
    (corfu-auto nil)
    (corfu-auto-prefix 2)
    (corfu-auto-delay 0.25)
    ;; (corfu-min-width 80)
    ;; (corfu-max-width corfu-min-width)     ; Always have the same width
    (corfu-count 14)
    (corfu-scroll-margin 4)
    (corfu-cycle nil)
    ;; (corfu-echo-documentation nil)        ; Already use corfu-doc
    (corfu-separator ?\s)                 ; Necessary for use with orderless
    (corfu-quit-no-match 'separator)
    (corfu-preview-current 'insert)       ; Preview current candidate?
    (corfu-preselect-first t)             ; Preselect first candidate?
    :preface
    (defun corfu-move-to-minibuffer ()
      "Move \"popup\" completion candidates to minibuffer.
  Useful if you want a more robust view into the recommend candidates."
      (interactive)
      (let (completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))
    (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active)
                (bound-and-true-p vertico--input)
                (eq (current-local-map) read-passwd-map))
      ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                  corfu-popupinfo-delay nil)
      (corfu-mode 1)))
    :config
    (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)
    :init
    ;; (corfu-indexed-mode)
    ;; Recommended: Enable Corfu globally.
    ;; This is recommended since dabbrev can be used globally (M-/).
    (global-corfu-mode)
    (load "~/.emacs.d/straight/build/corfu/corfu-indexed.el"
      nil
      jf/silence-loading-log)
    (corfu-indexed-mode)
    (load "~/.emacs.d/straight/build/corfu/corfu-info.el"
      nil
      jf/silence-loading-log)
    (load "~/.emacs.d/straight/build/corfu/corfu-popupinfo.el"
      nil
      jf/silence-loading-log)
    (corfu-popupinfo-mode))

  (use-package cape
    ;; Completion at point functions, with the amazing `cape-capf-super' for
    ;; granular configuration of specific mode completion behavior.
    :straight t
    :init
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-keyword)
    :bind (("C-c p d" . cape-dabbrev)
            ("C-c p e" . cape-elisp-block)
            ("C-c p f" . cape-file)
            ("C-c p h" . cape-history)
            ("C-c p s" . cape-symbol)
            ("C-c p w" . cape-dict)))

  (use-package grab-mac-link
    ;; Grab a link from a variety of MacOS applications.
    :straight t
    ;; Ensuring we load these, as I'll need them later.
    :commands (grab-mac-link-safari-1 grab-mac-link-firefox-1)
    :config
    ;; A replacement function for existing grab-mac-link-make-html-link
    (defun jf/grab-mac-link-make-html-link (url name)
      "Using HTML syntax, link to and cite the URL with the NAME."
      (format (concat "<cite>"
                "<a href=\"%s\" class=\"u-url p-name\" rel=\"cite\">"
                "%s"
                "</a>"
                "</cite>")
        url name))
    ;; The function advice to override the default behavior
    (advice-add 'grab-mac-link-make-html-link
      :override 'jf/grab-mac-link-make-html-link
      '((name . "jnf")))
    :bind (("C-c g" . grab-mac-link)))

  (use-package helpful
    ;; Help me lookup definitions and details.
    :init
    (use-package transient :straight t)
    ;; I'm going to talk about this later, but I'm adding this to the menu, so I
    ;; may as well state the dependency.
    (use-package embark :straight t)
    :straight t
    :config
    (transient-define-prefix jf/helpful-menu ()
      "Return a `transient' compliant list to apply to different transients."
      ["Help"
        ""
        ("Q" "Kill Helpful Buffers" helpful-kill-buffers)
        ""
        ("b" "Bindings" embark-bindings)
        ("c" "Command" helpful-command)
        ("d" "Definition" sdcv-search)
        ("D" "Docs" devdocs-lookup)
        ("f" "Function (interactive)" helpful-callable)
        ("F" "Function (all)" helpful-function)
        ("k" "Key" helpful-key)
        ("l" "Library" find-library)
        ("m" "Macro" helpful-macro)
        ("p" "Thing at point" helpful-at-point)
        ("." "Thing at point" helpful-at-point)
        ("t" "Text properties" describe-text-properties)
        ("v" "Variable" helpful-variable)])
    :bind ("H-h" . jf/helpful-menu)
    ("C-s-h" . jf/helpful-menu))

  (use-package hippie-exp
    ;; A composable expansion tool that I find compliments `corfu' in that it
    ;; looks in a different manner for completions.
    ;;
    ;; TODO: Perhaps I should spend a bit time investigating removing `hippie-exp'
    ;; in favor of `corfu' and `cape' behavior.  Definitely spend a bit of time exploring
    ;; this option.
    :straight t
    :config
    (setq hippie-expand-try-functions-list '(try-expand-dabbrev-visible
                                              try-expand-dabbrev
                                              try-expand-dabbrev-all-buffers
                                              try-expand-dabbrev-from-kill
                                              try-complete-file-name
                                              try-complete-file-name-partially
                                              try-expand-all-abbrevs
                                              try-expand-list
                                              try-expand-line
                                              try-complete-lisp-symbol-partially
                                              try-complete-lisp-symbol))
    :bind (("M-SPC" . hippie-expand))
    :init (global-set-key [remap dabbrev-expand] 'hippie-expand))

  (use-package marginalia
    ;; Given that my blog has lots of "writing in the margins" this is the package
    ;; for me.
    ;;
    ;; It provides annotations for completions; in particular I rely on showing
    ;; the docstring of `M-x' results.
    :straight t
    :config (setq marginalia-max-relative-age 0) ;; Set absolute value
    ;; /Note:/ The declaration of `marginalia-mode' must be in the :init
    ;; section.This ensures that it is enabled right away.  It also forces the
    ;; loading of the package.
    :init (marginalia-mode))

  (use-package orderless
    ;; The https://github.com/minad/orderless package provides completion tooling
    ;; for non-strict word order.  I spent considerable time reading through the
    ;; https://github.com/minad/consult/wiki
    ;;
    ;; As configured the orderless completion recognizes the following ‚Äúswitches‚Äù:
    ;;
    ;; - Flex (~\~~) :: Just start typing characters and you‚Äôll get matches that
    ;;   have those characters
    ;; - File Extension (~\.ext~) :: Match files with this extension.
    ;; - Regexp ~^.$~ :: Use some regular expression syntax
    ;;   - ~^~ matching beginning
    ;;   - ~.~ any ol‚Äô character
    ;;   - ~$~ matching ending
    ;; - Initialism (~`~) :: In ~M-x~ when I typed ~`pl~ the ~previous-line~
    ;;   function was a top match.  The initialism switch ‚Äúexplodes‚Äù the
    ;;   characters and says match methods who‚Äôs words start with those
    ;;   characters.
    ;; - Not Literal ~!~ :: Exclude candidates that match the literal
    ;;   (e.g. ~!previous~ won‚Äôt show ~previous-line~ in the ~M-x~ completion).
    ;; - Literal ~=~ :: No ‚Äúfuzzy buziness‚Äù, just match exactly what I typed.
    ;;
    ;; There is another case (e.g. ~%~ character fold) that I don‚Äôt yet
    ;; understand.
    :straight t
    :config
    (defvar +orderless-dispatch-alist
      '((?% . char-fold-to-regexp)
         (?! . orderless-without-literal)
         (?`. orderless-initialism)
         (?= . orderless-literal)
         (?~ . orderless-flex)))
    (defun +orderless-dispatch (pattern index _total)
      (cond
        ;; Ensure that $ works with Consult commands, which add disambiguation
        ;; suffixes
        ((string-suffix-p "$" pattern)
          `(orderless-regexp . ,(concat (substring pattern 0 -1)
                                  "[\x100000-\x10FFFD]*$")))
        ;; File extensions
        ((and
           ;; Completing filename or eshell
           (or minibuffer-completing-file-name
             (derived-mode-p 'eshell-mode))
           ;; File extension
           (string-match-p "\\`\\.." pattern))
          `(orderless-regexp . ,(concat "\\." (substring pattern 1)
                                  "[\x100000-\x10FFFD]*$")))
        ;; Ignore single !
        ((string= "!" pattern) `(orderless-literal . ""))
        ;; Prefix and suffix
        ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
           (cons (cdr x) (substring pattern 1))
           (when-let (x (assq (aref pattern (1- (length pattern)))
                          +orderless-dispatch-alist))
             (cons (cdr x) (substring pattern 0 -1)))))))
    ;; Define orderless style with initialism by default
    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism
                                    orderless-literal
                                    orderless-regexp)))
    ;; Certain dynamic completion tables (completion-table-dynamic) do not work
    ;; properly with orderless. One can add basic as a fallback.  Basic will only
    ;; be used when orderless fails, which happens only for these special tables.
    (setq completion-styles '(orderless basic)
      completion-category-defaults nil
            ;;; Enable partial-completion for files.
            ;;; Either give orderless precedence or partial-completion.
            ;;; Note that completion-category-overrides is not really an override,
            ;;; but rather prepended to the default completion-styles.
      ;; completion-category-overrides '((file (styles orderless
      ;; partial-completion))) ;; orderless is tried first
      completion-category-overrides '((file (styles partial-completion))
                                       ;; enable initialism by default for symbols
                                       (command (styles +orderless-with-initialism))
                                       (variable (styles +orderless-with-initialism))
                                       (symbol (styles +orderless-with-initialism)))
      orderless-component-separator #'orderless-escapable-split-on-space
      orderless-style-dispatchers '(+orderless-dispatch)))

  (use-package org-mac-link
    ;; Similar to `grab-mac-link' but a bit specific to `org-mode'.
    :straight (org-mac-link :type git :host github :repo "jeremyf/org-mac-link")
    :bind (:map org-mode-map (("C-c g" . org-mac-grab-link))))

  (use-package tempel
    ;; For awhile, I'd used yasnippets; themselves inspired by my beloved
    ;; TextMate.  However, I've found `tempel' to be both more than adequate and
    ;; has a narrower implementation foot-print, cleaving closer to emacs-lisp;
    ;; thus likely easing it's maintenance burden.
    :straight (tempel :host github :repo "minad/tempel")
    :custom (tempel-path "~/git/dotemacs/templates")
    :config (global-tempel-abbrev-mode)
    :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
            ("M-*" . tempel-insert))
    :bind (:map tempel-map (([backtab] . tempel-previous)
          ("TAB" . tempel-next)))
    :preface
    (cl-defun jf/org-macro-value-list (macro-name &key (dir org-directory))
      "List the unique inner text of all uses of MACRO-NAME in given DIR."
      (let ((path (if current-prefix-arg dir (or (buffer-file-name (current-buffer)) dir))))
        (s-split
          "\n"
          (s-trim
            (shell-command-to-string
              (concat
                "rg \"\\{\\{\\{"
                macro-name
                "\\((.+?)\\)\\}\\}\\}"
                "\" --only-matching --no-filename -r '$1' "
                path
                " | sort | uniq"))))))
    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'. `tempel-expand'
      ;; only triggers on exact matches. Alternatively use `tempel-complete' if
      ;; you want to see all matches, but then Tempel will probably trigger too
      ;; often when you don't expect it.
      ;; NOTE: We add `tempel-expand' *before* the main programming mode Capf,
      ;; such that it will be tried first.
      (setq-local completion-at-point-functions
        (cons #'tempel-expand
          completion-at-point-functions)))
    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
    ;; (tempel-global-abbrev-mode)
    :init
    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)
    ;; Hyper Macro!
    (tempel-key "H-m d" tsomb-date org-mode-map)
    (tempel-key "H-m u" update_block org-mode-map)
    (tempel-key "H-m c" macro-cite org-mode-map)
    (tempel-key "H-m i" macro-idiomatic org-mode-map)
    (tempel-key "H-m m" macro-mechanic org-mode-map)
    (tempel-key "H-m k" macro-keyboard org-mode-map))

  (use-package vertico
    ;; Another one of minad's packages which improves my day to day experience.  I
    ;; find the user experience wonderful when pairing vertical candidate
    ;; selection with `marginalia' and then having the `vertico-indexed-mode'
    ;; option for quick numerical selection.
    :straight (:type git :host github :repo "minad/vertico")
    :bind (:map vertico-map
            (("<tab>" . #'vertico-insert)
              ("<escape>" . #'minibuffer-keyboard-quit)
              ("M-p" . #'previous-history-element)
              ("M-n" . #'next-history-element)
              ;; I've been using more groupings, and being able to move through
              ;; those is nice.
              ("C-M-n" . #'vertico-next-group)
              ("C-M-p" . #'vertico-previous-group)
              ("C-SPC" . #'jf/vertico-restrict-to-matches)))
    :preface
    ;; https://github.com/minad/vertico/wiki#restrict-the-set-of-candidates
    (defun jf/vertico-restrict-to-matches ()
      "Restrict set of candidates to visible candidates"
      (interactive)
      (let ((inhibit-read-only t))
        (goto-char (point-max))
        (insert " ")
        (add-text-properties (minibuffer-prompt-end) (point-max)
          '(invisible t
             read-only t
             cursor-intangible t
             rear-nonsticky t))))
    :config
    (define-key vertico-map (kbd "C-SPC") #'jf/vertico-restrict-to-matches)
    (vertico-mode)
    ;; Use `consult-completion-in-region' if Vertico is enabled.
    ;; Otherwise use the default `completion--in-region' function.
    (setq completion-in-region-function
      (lambda (&rest args)
        (apply (if vertico-mode
                 #'consult-completion-in-region
                 #'completion--in-region)
          args)))
    (setq read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t
      completion-ignore-case t)
    (setq vertico-cycle t)
    :init
    ;; Type "C-3 return" and select the 3rd candidate in the list.
    (load "~/.emacs.d/straight/build/vertico/vertico-indexed.el"
      nil
      jf/silence-loading-log)
    (vertico-indexed-mode)
    (load "~/.emacs.d/straight/build/vertico/vertico-directory.el"
      nil
      jf/silence-loading-log)
    (load "~/.emacs.d/straight/build/vertico/vertico-repeat.el"
      nil
      jf/silence-loading-log)
    (global-set-key (kbd "M-r") #'vertico-repeat)
    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save))

  (use-package which-key
    ;; This package helps me begin typing a key sequence and seeing what options
    ;; are available to complete the sequence.
    ;;
    ;; For example, I type "C-c", wait a moment and get a menu that shows me what
    ;; key bindings start with "C-c"; and then I can type the following key and
    ;; execute that command.
    :straight t
    :custom
    (which-key-side-window-max-width 0.5)
    (which-key-min-column-description-width 60)
    (which-key-max-description-length 90)
    (which-key-show-docstrings t)
    (which-key-add-column-padding 2)
    :config
    (which-key-mode)
    (which-key-setup-side-window-right)
    (which-key-show-major-mode))

  (provide 'jf-completing)
  ;;; jf-completing.el ends here
#+end_src
** =jf-denote.el=
#+begin_src emacs-lisp :tangle "jf-denote.el" :results none
  ;;; jf-denote.el --- Note taking -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.

  ;;; Commentary:

  ;;;; Preamble
  ;;
  ;; Prior to `denote' I made extensive use of `org-roam'; I was following
  ;; `denote' development and appreciate Protesilaos's pedagological approach to
  ;; documentation.  I also appreciate the design considerations; which I wrote
  ;; about here: https://takeonrules.com/2022/10/09/denote-emacs-configuration/
  ;;
  ;; I installed denote and began exploring.  I am a software developer by trade,
  ;; and found the code accessible and discernable; that with it's sole dependency
  ;; being `emacs' I felt warranted further exploration.  Accessible, discernable,
  ;; and no dependencies are attractive attributes of software that I use as my
  ;; tools of work and play.  In my experience, the maintenance and enhancement is
  ;; easier for this kind of software.
  ;;
  ;; With further exploration, I migrated fully from `org-roam' to `denote'.
  ;;
  ;;
  ;;;; On Domains
  ;;
  ;; This package configures and extends `denote' by adding conceptual
  ;; domains to my note taking.  The domains are larger demarcations than
  ;; simple tags.  This is built on top of the `denote-directory' variable
  ;; and function.
  ;;
  ;; Further by leveraging domains, I have three means of searching:
  ;;
  ;; - "posts/" are all of my blog posts
  ;; - "-word" will find title's with "word" in them
  ;; - "_tag" will find the "tag" amongst the files keywords
  ;;
  ;; This allows me to leverage, if I want, Denote's siloing feature.

  ;;;; On Org Mode integration
  ;;
  ;; I make extensive use of `org-mode'; it is the format I use for crafting my
  ;; blog posts (see https://takeonrules.com).  It is also the tool I use for my
  ;; day to day task tracking and time tracking.
  ;;
  ;; I have structured my workflow so that any of these day to day activities can
  ;; easily produce blog posts.  I want my internal writing to have lots of
  ;; connective references; to help me find previous notes and perhaps look for
  ;; interesting connections.
  ;;
  ;; I also want posts that I publish to provide a similar experience; but the
  ;; links need to only be for publicly available connections.  In other words,
  ;; when I export a blog post, any internal links that have an external proxy are
  ;; rendered as links to those external proxies.  Any internal links without an
  ;; external proxy are rendered without links.
  ;;
  ;; This is done via `org-link-set-parameters' and denote's documentation (see
  ;; https://protesilaos.com/emacs/denote) provides excellent examples a
  ;; `org-link-set-parameters'.

  ;;; Code:

  (require 'cl-lib)
  ;;;; Loading dependencies
  (use-package denote
    ;; A narrow focus tool for organizing notes.  I appreciate the design
    ;; constraints and lack of external dependencies.  This package provides
    ;; portability.  It sits as an alternate to the amazing `org-roam' package.
    :straight (denote :host nil
                :type git
                :repo "https://git.sr.ht/~protesilaos/denote")
    :commands (denote-directory
                denote-file-prompt
                denote--title-prompt
                denote-get-path-by-id)
    :bind ("H-l" . 'jf/denote/link-or-create)
    ("H-i" . 'jf/denote/link-or-create)
    :hook (dired-mode . denote-dired-mode)
    :custom (denote-org-capture-specifiers
              "%(jf/denote/capture-wrap :link \"%L\" :content \"%i\")")
    :init
    (require 'denote-org-dblock)
    :custom
    (denote-directory (expand-file-name "denote" org-directory))
    ;; These are the minimum viable prompts for notes
    (denote-prompts '(title keywords))
    ;; I love ‚Äòorg-mode format; reading ahead I'm setting this
    (denote-file-type 'org)
    ;; Our controlled vocabulary...if you will.  This originally was a function
    ;; call, however there was a timing conflict with requiring denote-org-dblock
    ;; and when/where I declared the previous function.  By "inlining" the
    ;; function, I remove that temporal dependency.
    (denote-known-keywords (split-string-and-unquote
                             (shell-command-to-string
                               (concat
                                 "rg \"#\\+TAG:\\s([\\w-]+)\" "
                                 (expand-file-name "denote/glossary" org-directory)
                                 " --only-matching"
                                 " --no-filename "
                                 " --replace '$1'"))
                             "\n"))
    ;; Explicitly ensuring that tags can be multi-word (e.g. two or more
    ;; words joined with a dash).  Given that I export these tags, they
    ;; should be accessible to screen-readers.  And without the dashes
    ;; they are a garbled word salad.
    (denote-allow-multi-word-keywords t)
    ;; And `org-read-date' is an amazing bit of tech
    (denote-date-prompt-denote-date-prompt-use-org-read-date t))

  ;; (use-package denote-explore
  ;;   :straight (:host github :repo "pprevos/denote-explore")
  ;;   :after (denote))

  (use-package consult-notes
    ;;Let‚Äôs add another way at looking up files.  I appreciate the ability to
    ;;search all files and start with a character (e.g. =b=) followed by <space> to
    ;;filter to the note source keyed as =s= (e.g. Scientist).
    :straight (:type git :host github :repo "mclear-tools/consult-notes")
    ;; :after (consult denote)
    :bind
    ("H-d s" . 'consult-notes-search-in-all-notes)
    ("H-f" . 'consult-notes)
    ;; Ensuring that I search my denote/scientist sub-directory, which is
    ;; excluded from it's containing project's git repository.
    :custom (consult-notes-use-rg t)
    (consult-notes-ripgrep-args
      (concat
        "rg --null --line-buffered --color=never --max-columns=1000 "
        "--path-separator / --ignore-case --no-heading --line-number "
        "--hidden --glob=!.git/ -L --sortr=accessed"))
    :commands (consult-notes
                consult-notes-search-in-all-notes))

  ;;;; Note taking configurations

  ;;;;; `denote' and `org-mode' integration
  (cl-defun jf/denote/org-property-from-id (&key identifier property)
    ;; This function helps me retrieve Org-Mode properties from the given Denote
    ;; ID.
    "Given an IDENTIFIER and PROPERTY return it's value or nil.

      Return nil when:

      - is not a `denote' file
      - IDENTIFIER leads to a non `org-mode' file
      - PROPERTY does not exist on the file"
    (when-let ((filename (denote-get-path-by-id identifier)))
      (when (string= (file-name-extension filename) "org")
        (with-current-buffer (find-file-noselect filename)
          (cadar (org-collect-keywords (list property)))))))

  (cl-defun jf/denote/org-keywords-from-id (&key identifier keywords)
    "Given an IDENTIFIER and KEYWORDS list return an a-list of values.

      Return nil when:

      - is not a denote file
      - IDENTIFIER leads to a non `org-mode' file
      - KEYWORD does not exist on the file.

  This function is the plural version of `jf/denote/org-property-from-id'."
    ;; ;; Testing jf/denote/org-property-from-id
    ;; (message "%s" (jf/denote/org-property-from-id
    ;;     :identifier "20220930T215235"
    ;;		 :property "ABBR"))
    ;; ;; Testing jf/denote/org-keywords-from-id
    ;; (message "%s" (jf/denote/org-keywords-from-id
    ;;     :identifier "20220930T215235"
    ;;     :properties '("TITLE" "ABBR")))
    (when-let ((filename (denote-get-path-by-id identifier)))
      (when (string= (file-name-extension filename) "org")
        (with-current-buffer (find-file-noselect filename)
          (org-collect-keywords keywords)))))

  (defun jf/denote/plist-for-export-of-id (identifier)
    "Given an IDENTIFIER export a `plist' with the following properties:

      - :title
      - :key
      - :url

      Return nil when:

      - is not a denote file
      - IDENTIFIER leads to a non `org-mode' file"
    ;; Testing
    ;; (message "%s" (jf/denote/plist-for-export-of-id "20221009T115949"))
    (when-let ((filename (denote-get-path-by-id identifier)))
      (when (string= (file-name-extension filename) "org")
        (with-current-buffer (find-file-noselect filename)
          (let ((kw-plist (jf/org-keywords-as-plist
                            :keywords-regexp "\\(TITLE\\|GLOSSARY_KEY\\|OFFER\\|ROAM_REFS\\|SAME_AS\\)")))
            (list
              :title (lax-plist-get kw-plist "TITLE")
              :key (lax-plist-get kw-plist "GLOSSARY_KEY")
              :url (or
                     (lax-plist-get kw-plist "OFFER")
                     (when-let ((refs (lax-plist-get kw-plist "ROAM_REFS")))
                       (if (listp refs)
                         (first (s-split " " refs t))
                         refs))
                     (lax-plist-get kw-plist "SAME_AS"))))))))

  ;;;;; `denote' file finding functions

  (defun jf/denote/link-or-create (target &optional id-only)
    "Use `denote-link' on TARGET file, creating it if necessary.

  As `denote-link-or-create' but use `jf/denote/file-prompt'
  instead of `denote-file-prompt'.

  This function is intended for a global find of all notes.  With
  ID-ONLY link without title."
    (interactive (list (jf/denote/file-prompt)
                   current-prefix-arg))
    (if (and target (file-exists-p target))
      (let ((type (denote-filetype-heuristics target)))
        (denote-link target type
                      (denote--link-get-description target type)
                      id-only)
        )
      (denote--command-with-title-history #'denote-link-after-creating)))

  (defun jf/denote/file-prompt (&optional files-matching-regexp)
    "Prompt for a file based on subdirectories.

  See `denote-file-prompt'"
    ;; I‚Äôm not looking at active silo-ing and want to be able to search
    ;; specifically from the top-level and all subdirectories.
    (when-let* ((vc-dirs-ignores (mapcar
                                   (lambda (dir)
                                     (concat dir "/"))
                                   vc-directory-exclusion-list))
                 (files (mapcan
                          (lambda (sub-dir)
                            (project--files-in-directory (f-join
                                                           (denote-directory)
                                                           sub-dir)
                              vc-dirs-ignores))
                          jf/denote/subdirectories))
                 (file (funcall project-read-file-name-function
                         "Select note" files nil 'file-name-history)))
      (let ((completion-ignore-case read-file-name-completion-ignore-case))
        (add-to-history 'denote--file-history file)
        file)))

  (setq consult-notes-sources (list))
  (setq jf/denote/subdirectories (list))

  (defun jf/denote/find-file ()
    "Find file in the current denote directory."
    (interactive)
    (require 'consult-projectile)
    (require 'denote)
    ;; For this query, override the `projectile-git-command' so that I can
    ;; include my "denote/scientist" notes.
    (let ((projectile-git-command
            "git ls-files -zco --exclude-from=.projectile.gitignore"))
      (consult-projectile--file (denote-directory))))

  ;;;;; Note taking Domains
  (cl-defmacro jf/denote/create-functions-for (&key domain key (create-fn nil))
    "A macro to CREATE-FN for the given DOMAIN.

            The KEY is the ASCII value of the binding key.

            Creates:

            - Wrapping function of `jf/denote/find-file' that narrows results
            to the given DOMAIN.
            - Create linking function for DOMAIN.
            - Add the domain to the `jf/denote/subdirectories'.
            - Adds DOMAIN to `consult-notes-sources'."
    (let* ((finder-fn (intern (concat "jf/denote/find-file--" domain)))
            (subdirectory (f-join "~/git/org/denote" domain))
            (finder-docstring (concat "Find file in \""
                                domain
                                "\" subdirectory of `denote-directory'."))
            (default-create-fn (intern (concat "jf/denote/create--"
                                         domain
                                         "--default")))
            (default-create-docstring (concat "Create denote in \""
                                        domain
                                        "\" subdirectory of "
                                        "`denote-directory'."))
            (link-or-creator-fn (intern (concat "jf/denote/link-or-create--" domain)))
            (link-or-creator-docstring (concat "Link to denote in \""
                                         domain
                                         "\" subdirectory of "
                                         "`denote-directory'.")))
      `(progn
         (add-to-list 'jf/denote/subdirectories ,domain)
         (when (boundp 'consult-notes-sources)
           (add-to-list 'consult-notes-sources '(,domain ,key ,subdirectory)))
         (defun ,default-create-fn ()
           ,default-create-docstring
           (interactive)
           (let ((denote-directory (f-join (denote-directory) ,domain)))
             (call-interactively #'denote)))
         (bind-key (format "H-d c %c" ,key) (or ,create-fn ',default-create-fn))
         (bind-key (format "H-d f %c" ,key) ',finder-fn)
         (defun ,finder-fn ()
           ,finder-docstring
           (interactive)
           (let ((denote-directory (f-join (denote-directory) ,domain)))
             (call-interactively #'jf/denote/find-file)))
         (bind-key (format "H-d l %c" ,key) ',link-or-creator-fn)
         (defun ,link-or-creator-fn ()
           ,link-or-creator-docstring
           (interactive)
           (let ((denote-directory (f-join (denote-directory) ,domain)))
             (call-interactively #'denote-link-or-create)))
         )))

  ;;;;;; Blog Posts
  ;; The blog-post domain is for things that I have, will, or might publish to
  ;; https://takeonrules.com
  (jf/denote/create-functions-for :domain "blog-posts"
    :key ?b)

  (defun jf/denote/find-file--blog-posts-draft (filename)
    "Find a draft FILENAME in the \"blog-posts\" sub-directory of denote-directory."
    (interactive
      (list (jf/find-file-via-matching
                    :prompt "Draft filename: "
                    :matching "^#\\+ROAM_REFS:"
              :switch "--files-without-match"
                    :in (f-join (denote-directory) "blog-posts"))))
    (find-file filename))
  (bind-key "H-d f B" #'jf/denote/find-file--blog-posts-draft)

  ;;;;;; Scratch
  (defun jf/denote/create-scratch (title)
    "Create a scratch note with TITLE."
    (interactive (list (read-string
                         "Scratch title: "
                         (format-time-string "%Y-%m-%d Scratch"))))
    (denote title
      nil
      'org
      (f-join (denote-directory) "scratch")))

  ;; The scratch domain is a place to capture random notes.  These can be promoted
  ;; to another directory or eventually discarded.
  (jf/denote/create-functions-for :domain "scratch"
    :create-fn #'jf/denote/create-scratch
    :key ?s)

  ;;;;;; Scientist
  (jf/denote/create-functions-for :domain "work"
    :key ?w)

  (jf/denote/create-functions-for :domain "private"
    :key ?v)

  ;;;;;; Epigraphs
  (cl-defun jf/denote/create-epigraph (&key
                                        (body (read-from-minibuffer
                                                "Epigraph Text: "))
                                        ;; Todo prompt for Author Name
                                        (author_name (read-from-minibuffer
                                                       "Author Name: "))
                                        ;; Todo prompt for Work Title
                                        (work_title (read-from-minibuffer
                                                      "Work Title: "))
                                        (nth-words 8))
    "Create an epigraph from BODY, AUTHOR_NAME, and WORK_TITLE.

  Default the note‚Äôs title to the first NTH-WORDS of the BODY."
    (interactive)
    (let* ((body-as-list (s-split-words body))
            (title (s-join " " (if (> (length body-as-list) nth-words)
                                 (cl-subseq body-as-list 0 nth-words)
                                 body-as-list)))
            (template (concat
                        ;; The name of the author
                        "#+AUTHOR_NAME: " author_name "\n"
                        ;; Where can you ‚Äúfind‚Äù this author?
                        "#+AUTHOR_URL:\n"
                        ;; The GLOSSARY_KEY for the given author
                        "#+AUTHOR_KEY:\n"
                        ;; What‚Äôs the title of the work?
                        "#+WORK_TITLE: " work_title "\n"
                        ;; Where can you ‚Äúget‚Äù this work?
                        "#+WORK_URL:\n"
                        ;; The GLOSSARY_KEY for the given work
                        "#+WORK_KEY:\n"
                        ;; Indicates if this is a poem (or not)
                        "#+POEM:\n"
                        ;; The page in which this passage appears in the given
                        ;; work.
                        "#+PAGE:\n"
                        ;; The name of the translator
                        "#+TRANSLATOR_NAME:\n")))
      (denote title
        nil
        'org
        (f-join (denote-directory) "epigraphs")
        nil
        template)))

  (jf/denote/create-functions-for :domain "epigraphs"
    :key ?e
    :create-fn 'jf/denote/create-epigraph)

  ;;;;;; Glossary Entries
  (cl-defun jf/denote/create-glossary-entry
    (&key
      (title (read-from-minibuffer "Name the Entry: "))
      (is-a-game (yes-or-no-p "Is this a game?"))
      (abbr (read-from-minibuffer "Abbreviation (empty to skip): ")))
    "Create a `denote' entry for the given TITLE and ABBR.

      And if this IS-A-GAME then amend accordingly.

      NOTE: At present there is no consideration for uniqueness."
    (interactive)
    (let* ((key (downcase (denote-sluggify (if (s-present? abbr) abbr title))))
            (template (concat "#+GLOSSARY_KEY: " key "\n"
                        (when (s-present? abbr)
                          (concat "#+ABBR: " abbr "\n"))
                        ;; TODO: Include a prompt of existing disclaimers
                        "#+CONTENT_DISCLAIMER:\n"
                        "#+DESCRIPTION:\n"
                        (when is-a-game (concat "#+GAME: " key "\n"))
                        "#+ITEMID:\n"
                        "#+ITEMTYPE:\n"
                        "#+MENTION_AS:\n"
                        "#+NO_TITLE:\n"
                        "#+OFFER:\n"
                        "#+PLURAL_ABBR:\n"
                        "#+PLURAL_TITLE:\n"
                        "#+SAME_AS:\n"
                        "#+TAG:\n" ;; TODO: Assert uniqueness
                        "#+VERBOSE_TITLE:\n"))
            (keywords (list)))
      ;; Add both "abbr" and the abbr to the keywords; both help in searching
      ;; results
      (when (s-present? abbr)
        (progn (add-to-list 'keywords "abbr") (add-to-list 'keywords abbr)))
      (when is-a-game (add-to-list 'keywords "game"))
      (denote title
        keywords
        'org
        (f-join (denote-directory) "glossary")
        nil
        template)))

  (jf/denote/create-functions-for :domain "glossary"
    :key ?g
    :create-fn 'jf/denote/create-glossary-entry)
  ;; Testing jf/denote/org-property-from-id
  ;; (message "%s" (jf/denote/org-property-from-id :id "20220930T215235"
  ;;                :property "ABBR"))

  ;;;;;; Melange
  ;; All the other things; perhaps they could become blog posts, but for now they
  ;; remain part of the mixture and medley.
  (jf/denote/create-functions-for :domain "melange"
    :key ?m)

  ;;;;;; People
  ;; I do write notes about people I interact with.  Technically I have glossary
  ;; entries for people.  But those entries are for folks I don‚Äôt interact with.
  (jf/denote/create-functions-for :domain "people"
    :key ?p)

  ;;;;;; Indices

  ;; On my site I write https://takeonrules.com/series/.  I track this data in a
  ;; YAML file; I‚Äôd like to treat this data similar to my glossary.
  (cl-defun jf/denote/create-indices-entry (&key
                                             (title (read-from-minibuffer
                                                      "Name the index: "))
                                             (is-a-series
                                               (yes-or-no-p
                                                 "Take on Rules series?")))
    "Create a `denote' index entry for the given TITLE.

  Consider different logic if IS-A-SERIES."
    (interactive)
    (let* ((keywords (list))
            (template (concat (when (s-present? is-a-series)
                                "#+HIGHLIGHT: true\n"))))
      (when (s-present? is-a-series)
        (add-to-list 'keywords "series"))
      (denote title
        nil
        'org
        (f-join (denote-directory) "indices")
        nil
        template)))

  (jf/denote/create-functions-for :domain "references"
    :key ?r)

  (jf/denote/create-functions-for :domain "indices"
    :key ?i
    :create-fn 'jf/denote/create-indices-entry)

  ;;;;; `org-link-parameters'
  (cl-defun jf/org-link-complete-link-for (parg &key scheme filter subdirectory)
    "Prompt for `denote' with filename FILTER in the given SUBDIRECTORY.

      Returns a string of format: \"SCHEME:<id>\" where <id> is
      an `denote' identifier.

  PARG is part of the method signature for `org-link-parameters'."
    (let* ((denote-directory (if subdirectory
                               (f-join (denote-directory)
                                 (concat subdirectory "/"))
                               (denote-directory)))
            (file (funcall project-read-file-name-function
                    "Select note: "
                    (denote-all-files)
                    ;; Filter might be nil; if so pass nil.  Otherwise the string.
                    (when filter (lambda (fname) (s-contains? filter fname t)))
                    'denote--file-history)))
      ;; This leverages a post v1.0.0 parameter of Denote
      ;; See https://git.sr.ht/~protesilaos/denote/commit/c6c3fc95c66ba093a266c775f411c0c8615c14c7
      (concat scheme ":" (denote-retrieve-filename-identifier file))))

  (cl-defun jf/denote/link-ol-abbr-with-property (link
                                                   description
                                                   format
                                                   protocol
                                                   &key
                                                   keyword
                                                   additional-hugo-parameters
                                                   (use_hugo_shortcode
                                                     jf/exporting-org-to-tor))
    "Export a LINK with DESCRIPTION for the given PROTOCOL and FORMAT.

      FORMAT is an Org export backend.  We will discard the given
      DESCRIPTION.  PROTOCOL is ignored."
    (let* ((keyword-alist (jf/denote/org-keywords-from-id
                            :identifier link
                            :keywords (list "TITLE" keyword  "GLOSSARY_KEY")))
            (title (car (alist-get "TITLE" keyword-alist nil nil #'string=)))
            (keyword-value (car (alist-get keyword keyword-alist nil nil #'string=)))
            (key (car (alist-get "GLOSSARY_KEY" keyword-alist nil nil #'string=))))
      (cond
        ((or (eq format 'html) (eq format 'md))
          (if use_hugo_shortcode
            (format "{{< glossary key=\"%s\" %s >}}"
              key
              additional-hugo-parameters)
            (format "<abbr title=\"%s\">%s</abbr>"
              title
              keyword-value)))
        ((or (eq format 'latex) (eq format 'beamer))
          (format "\\ac{%s}" keyword-value))
        (t (format "%s (%s)"
             title
             keyword-value)))))

  (org-link-set-parameters "abbr"
    :complete (lambda (&optional parg)
                (jf/org-link-complete-link-for
                  parg
                  :scheme "abbr"
                  :filter "_abbr"))
    :export (lambda (link description format protocol)
              (jf/denote/link-ol-abbr-with-property
                link description format protocol
                :keyword "ABBR"
                :additional-hugo-parameters "abbr=\"t\""))
    :face #'jf/org-faces-abbr
    :follow #'denote-link-ol-follow
    )

  (org-link-set-parameters "abbr-plural"
    :complete (lambda (&optional parg)
                (jf/org-link-complete-link-for
                  parg
                  :scheme "abbr-plural"
                  :filter "_abbr"))
    :export (lambda (link description format protocol)
              (jf/denote/link-ol-abbr-with-property
                link description format protocol
                :keyword "PLURAL_ABBR"
                :additional-hugo-parameters "abbr=\"t\" plural=\"t\""))
    :face #'jf/org-faces-abbr
    :follow #'denote-link-ol-follow
      ;;;; I'm unclear if/how I want to proceed with this
    ;; :store (lambda (jf/org-link-store-link-for :scheme "abbr-plural"))
    )

  (org-link-set-parameters "date"
    :complete #'jf/denote/link-complete-date
    :export #'jf/denote/link-export-date
    :face #'jf/org-faces-date
    :follow #'jf/denote/link-follow-date)

  (cl-defun jf/denote/link-complete-date (&optional parg)
    "Prompt for the given DATE.

  While we are prompting for a year, month, and day; a reminder
  that this is intended to be conformant with the TIME element.
  But for my typical use I write these as either years; years and
  months; and most often year, month, and days.

  PARG is for conformant method signature."
    (format "date:%s" (org-read-date)))

  (cl-defun jf/denote/link-export-date (link description format protocol)
    "Export a date for the given LINK, DESCRIPTION, FORMAT, and PROTOCOL."
    (cond
      ((or (eq format 'html) (eq format 'md))
        (format "<time datetime=\"%s\" title=\"%s\">%s</time>" link link description))
      ((eq format 'beamer)
        (format "%s" description))
      (t (format "%s (%s)" description link))))

  (cl-defun jf/denote/link-follow-date (date &optional parg)
    "Follow the given DATE; uncertain what that means.

  PARG is for a conformant method signature."
    (message "TODO, implement link for %s" date))

  ;; I want to be able to link and export my epigraph entries.  For now, I'm
  ;; going to focus on the HTML and Markdown version; as most often when I
  ;; include an epigraph it is for my blog posts.
  (cl-defun jf/denote/link-ol-epigraph-link (link
                                              description format protocol
                                              &key
                                              additional-hugo-parameters
                                              (use_hugo_shortcode
                                                jf/exporting-org-to-tor))
    "Export the epigraph for the given LINK, DESCRIPTION, PROTOCOL, and FORMAT.

    NOTE: This only works for blog export.
    TODO: Consider how to expand beyond blog support."
    (cond
      ((and use_hugo_shortcode (or (eq format 'html) (eq format 'md)))
        (format "{{< epigraph key=\"%s\" >}}" link))
      ((or (eq format 'html) (eq format 'md))
        (concat "<blockquote>\n"
          (jf/epigraph-text-for :identifier link)
          "\n</blockquote>"))
      (t nil)))

  (cl-defun jf/epigraph-text-for (&key identifier)
    "Return the epigraph text for `denote' IDENTIFIER."
    (let ((filename (denote-get-path-by-id identifier)))
      (with-current-buffer (find-file-noselect filename)
        (let ((text (s-join "\n\n" (org-element-map
                                     (org-element-parse-buffer)
                                     'paragraph
                                     (lambda (p) (caddr p))))))
          (if (cadar (org-collect-keywords '("POEM")))
            (format "<pre class=\"poem\">\n%s\n</pre>" text)
            (format "%s" text))))))

  (org-link-set-parameters "epigraph"
    :complete (lambda (&optional parg)
                (jf/org-link-complete-link-for
                  parg
                  :scheme "epigraph"
                  :subdirectory "epigraphs"))
    :export (lambda (link description format protocol)
              (jf/denote/link-ol-epigraph-link
                link description format protocol))
    :face #'jf/org-faces-epigraph
    :follow #'denote-link-ol-follow)

  (defface jf/org-faces-date '((default :inherit link))
    "Face used to style `org-mode' date links in the buffer."
    :group 'denote-faces
    :package-version '(denote . "0.5.0"))

  (defface jf/org-faces-epigraph '((default :inherit link))
    "Face used to style `org-mode' epigraph links in the buffer."
    :group 'denote-faces
    :package-version '(denote . "0.5.0"))

  (defface jf/org-faces-abbr '((default :inherit link))
    "Face used to style `org-mode' abbr links in the buffer."
    :group 'denote-faces
    :package-version '(denote . "0.5.0"))

  (cl-defun jf/denote/link-ol-export (link
                                       description
                                       format
                                       protocol
                                       &key
                                       (use_hugo_shortcode
                                         jf/exporting-org-to-tor))
    "Export a `denote:' link from Org files.

  The LINK, DESCRIPTION, FORMAT, and PROTOCOL are handled by the
  export backend.

  When USE_HUGO_SHORTCODE is given use glossary based exporting."
    (let* ((path-id (denote-link--ol-resolve-link-to-target link :path-id))
            (path (file-name-nondirectory (car path-id)))
            (export-plist (jf/denote/plist-for-export-of-id link))
            (title (plist-get export-plist :title))
            (url (plist-get export-plist :url))
            (glossary_key (plist-get export-plist :key))
            (desc (or description title)))
      (if url
        (cond
          ((and use_hugo_shortcode glossary_key)
            (format "{{< glossary key=\"%s\" >}}" glossary_key))
          ;; Use the TakeOnRules shortcode that leverages Hugo built-in
          ((and use_hugo_shortcode (s-starts-with? "https://takeonrules.com/" url))
            (format "{{< linkToPath \"%s\" >}}"
              (s-trim (s-replace "https://takeonrules.com/" "/" url))))
          ((eq format 'html)
            (format "<a href=\"%s\">%s</a>" url desc))
          ((eq format 'md) (format "[%s](%s)" desc url))
          ((or (eq format 'latex) (eq format 'beamer))
            (format "\\href{%s}{%s}"
              (replace-regexp-in-string "[\\{}$%&_#~^]" "\\\\\\&" path)
              desc))
          ((eq format 'texinfo) (format "@uref{%s,%s}" path desc))
          ((eq format 'ascii) (format "[%s] <denote:%s>" desc path))
          (t path))
        desc)))

  (advice-add #'denote-link-ol-export
    :override #'jf/denote/link-ol-export
    '((name . "wrapper")))

  (defun jf/associate-blog-post-url-with-identifier (url identifier)
    "Associate given URL with the `denote' IDENTIFIER."
    (message "Associating URL: %s with IDENTIFIER: %s." identifier url)
    (let* ((filename (denote-get-path-by-id identifier))
            (buffer (find-file-noselect filename)))
      (with-current-buffer buffer
        (jf/export-org-to-tor--global-buffer-prop-ensure
          :key "ROAM_REFS"
          :plist (jf/org-keywords-as-plist :keywords-regexp "ROAM_REFS")
          :default url)
        (save-buffer))))

  (defun jf/org-mode/convert-link-type (&optional element)
    "Replace the given `org-mode' ELEMENT's link type and text."
    (interactive)
    (let* ((types '("abbr" "abbr-plural" "denote"))
            (element (or element (org-element-context))))
      (if (eq 'link (car element))
        (let ((type (org-element-property :type (org-element-context)))
               (denote-id (plist-get (cadr element) :path)))
          (if (member type types)
            (when-let ((new-type (completing-read "New link type: " types nil t)))
              (if-let ((new-text (jf/denote/org-property-from-id
                                   :identifier denote-id
                                   :property (cond
                                               ((string= "abbr" new-type) "ABBR")
                                               ((string= "abbr-plural" new-type) "PLURAL_ABBR")
                                               ((string= "denote" new-type) "TITLE")))))
                (progn
                  (replace-regexp-in-region "\\[\\[\\([^:]+\\):\\([0-9A-Z]+\\)\\]\\[\\([^]]+\\)\\]\\]"
                    (format "[[%s:%s][%s]]" new-type denote-id  new-text)
                    (org-element-property :begin element)
                    (org-element-property :end element))
                  (org-link-descriptive-ensure))
                (user-error "Expected denote-id %s to have a %s acceptable property" denote-id new-type)))
            (user-error "Current element is of type %s; it must be one of the following: %s" type types)))
        (user-error "Current element must be of type 'link; it is %S" (car element)))))

  ;;;;; Capturing functions for applications
  (defun jf/menu--org-capture-firefox ()
    "Create an `denote' entry from Firefox page."
    (interactive)
    (require 'grab-mac-link)
    (let* ((link-title-pair (grab-mac-link-firefox-1))
            (url (car link-title-pair))
            (title (cadr link-title-pair)))
      (jf/denote/capture-reference :url url :title title)))

  (defun jf/menu--org-capture-safari ()
    "Create an `denote' entry from Safari page."
    (interactive)
    (require 'grab-mac-link)
    (let* ((link-title-pair (grab-mac-link-safari-1))
            (url (car link-title-pair))
            (title (cadr link-title-pair)))
      (jf/denote/capture-reference :url url :title title)))

  (defun jf/capture/denote/from/eww-data ()
    "Create an `denote' entry from `eww' data."
    (interactive)
    (let* ((url (plist-get eww-data :url))
            (title (plist-get eww-data :title))
            (html (plist-get eww-data :source))
            (content (jf/convert-via-pandoc html :from "html" :to "org")))
      (jf/denote/capture-reference :url url :title title :content content)))

  (defun jf/capture/denote/from/elfeed-show-entry ()
    "Create `denote' entry from `elfeed-show-entry'."
    (interactive)
    (let* ((url (elfeed-entry-link elfeed-show-entry))
            (title (elfeed-entry-title elfeed-show-entry))
                  (html (elfeed-deref (elfeed-entry-content elfeed-show-entry)))
                  (content (jf/convert-via-pandoc html :from "html" :to "org")))
      (jf/denote/capture-reference :url url :title title :content content)))

  (cl-defun jf/convert-via-pandoc (text &key (from "html") (to "org"))
    "Convert TEXT, via pandoc, FROM one content-type TO another."
    (with-temp-buffer
                  (insert text)
                  (shell-command-on-region
                          (point-min) (point-max)
                          (concat (executable-find "pandoc") " -f " from " -t " to " --wrap=none")
        ;;| rg \"(\\\\\\\\)\" -r ''")
                          t t)
                  (buffer-substring-no-properties (point-min) (point-max))))

  (cl-defun jf/denote/capture-reference (&key
                                          title
                                          url
                                          (content "")
                                          (keywords (denote-keywords-prompt))
                                          (domain "references"))
    "Create a `denote' entry for the TITLE and URL.

  Capturing for the given CONTENT, DOMAIN, and KEYWORDS prompt."
    (denote title
      keywords
      'org
      (f-join (denote-directory) domain)
      nil
      (concat "#+ROAM_REFS: " url "\n\n" (or content ""))))

  (defun jf/denote/archive-timesheet-month ()
    "Cut the month agenda and create a `denote' note."
    (interactive)
    (let* ((headline (jf/org-agenda-headline-for-level :level 2))
            (title (org-element-property :title headline)))
      (org-cut-subtree)
      (denote (concat title " Time Sheet")
        '("timesheet" "scientist")
        'org
        (f-join (denote-directory) "scientist"))
      (yank)
      (save-buffer)))

  (provide 'jf-denote)
  ;;; jf-denote.el ends here
#+end_src
** =jf-experiments.el=
#+begin_src emacs-lisp :tangle "jf-experiments.el" :results none
  ;;; jf-experiments --- Where I put things that I'm exploring -*- lexical-binding: t -*-

  ;; Copyright (C) 2023 Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary

  ;;; Code

  ;; https://github.com/abo-abo/org-download
  (use-package org-download
    :straight t
    :hook (dired-mode . org-download-enable))

  (use-package parsebib
    :straight t)

  (use-package ebib
    :straight t)

  (use-package citar
    :custom (citar-bibliography '("~/git/org/bibliography.bib"))
    :straight t)

  (use-package citar-denote
    :straight t)

  ;; https://github.com/ruediger/qrencode-el/
  ;;
  ;; Generate an plain text QRCode (or PNG but really why not use those UTF
  ;; characters)
  (use-package qrencode
    :straight t)

  ;; I'm a huge fan of the Tufte style; my blog is based on that stylesheet and
  ;; then further simplified
  (use-package org-tufte
    :straight (org-tufte :host github :repo "Zilong-Li/org-tufte")
    :config
    (require 'org-tufte)
    (setq org-tufte-htmlize-code t))

  ;; ;; A package to browse/read reddit in emacs and `org-mode' format.
  ;; (use-package reddigg
  ;;   :straight (:host github :repo "jeremyf/emacs-reddigg")
  ;;   :config (setq reddigg--sub-url "https://www.reddit.com/r/%s/new.json?count=25")
  ;;   :custom (reddigg-subs '(emacs planetemacs orgmode wwn swn ruby rubyonrails)))

  ;; ;; Some customizations to the behavior of a reddit buffer.
  ;; (advice-add 'reddigg--ensure-modes
  ;;   :after (lambda ()
  ;;            ;; This seems like a good idea to limit behavior to only reddit.
  ;;            (setq-local org-confirm-elisp-link-function nil)
  ;;            ;; It's rather odd to consider adding GET request
  ;;            (read-only-mode)))

  ;; May as well make a menu for this experiment.
  ;; (defmacro jf/reddigg/create-view-function-for (sub)
  ;;   (let* ((fn (intern (concat "jf/reddigg/view-" sub)))
  ;;           (doc (concat "View /r/" sub))
  ;;           (desc (concat "/r/" sub)))
  ;;     `(transient-define-suffix ,fn ()
  ;;       ,doc
  ;;       :description ,desc
  ;;       (interactive)
  ;;        (reddigg-view-sub ,sub))))

  ;; (jf/reddigg/create-view-function-for "emacs")
  ;; (jf/reddigg/create-view-function-for "orgmode")
  ;; (jf/reddigg/create-view-function-for "planetemacs")
  ;; (jf/reddigg/create-view-function-for "ruby")
  ;; (jf/reddigg/create-view-function-for "rubyonrails")
  ;; (jf/reddigg/create-view-function-for "swn")
  ;; (jf/reddigg/create-view-function-for "wwn")

  ;; Removing as of <2023-08-05 Sat> as I don't use it and I was seein gmany
  ;; errors
  ;;
  ;; (use-package breadcrumb
  ;;   :straight (:host github :repo "joaotavora/breadcrumb")
  ;;   :config (breadcrumb-mode))

  (defun toggle-transparency ()
    "Toggle on and off transparency.

  I'm uncertain if this is useful/practical.  However there is
   literature regarding the benefits of transparency of files."
    (interactive)
    (let ((alpha (frame-parameter nil 'alpha)))
      (set-frame-parameter
        nil 'alpha
        (if (eql (cond ((numberp alpha) alpha)
                   ((numberp (cdr alpha)) (cdr alpha))
                   ;; Also handle undocumented (<active> <inactive>) form.
                   ((numberp (cadr alpha)) (cadr alpha)))
              100)
          '(75 . 50) '(100 . 100)))))


  ;; Going to experiment a moment with this.

  (setq gnus-select-method '(nntp "campaignwiki.org"))
  ;; (add-to-list 'gnus-secondary-select-methods '(nnml ""))


  (defun jf/rancher/rm-then-vim-project-file (&optional filename)
    "Kill some text to edit a FILENAME in Rancher."
    (interactive)
    (let* ((f (or filename (buffer-file-name)))
            (relative-name (concat "./" (file-relative-name f (projectile-project-root)))))
      (kill-new (f-read f))
      (kill-new (format "rm %s ; vim %s" relative-name relative-name))))

  ;; (use-package eyebrowse
  ;;   :straight t)

  ;; (use-package org-timeblock
  ;;   :straight (org-timeblock :type git
  ;;               :host github
  ;;               :repo "ichernyshovvv/org-timeblock"))

  (use-package stem-reading-mode
    :straight t
    :config (setq stem-reading-overlay t))

  (defun calculate-distance-to (to fun pred)
    "Calculate distance from BEG to END in units of FUN.
  Assume BEG <= END.  FUN is a function moving forward by one unit
  of measurement (e.g., a word or sentence)."
    (when to
      (save-excursion
        (let ((count 0))
          (while (funcall pred (point) to)
            (funcall fun)
            (cl-incf count))
          count))))

  (defun find-nearest-word-repetitions ()
    "Find and report the nearest repetitions of word at point."
    (interactive)
    (let* ((word (word-at-point))
            (re (format "\\b%s\\b" (regexp-quote word)))
            (case-fold-search t)
            (prev (save-excursion
                    (beginning-of-thing 'word)
                    (when (re-search-backward re nil t)
                      (point))))
            (prev-overlay (when prev
                            (make-overlay prev
                              (save-excursion
                                (goto-char prev)
                                (forward-word)
                                (point)))))
            (next (save-excursion
                    (end-of-thing 'word)
                    (when (re-search-forward re nil t)
                      (point))))
            (next-overlay (when next
                            (make-overlay next
                              (save-excursion
                                (goto-char next)
                                (backward-word)
                                (point)))))
            (prev-words (save-excursion
                          (beginning-of-thing 'word)
                          (calculate-distance-to prev #'backward-word #'>)))
            (next-words (save-excursion
                          (end-of-thing 'word)
                          (calculate-distance-to next #'forward-word #'<)))
            (prev-sentences (save-excursion
                              (beginning-of-thing 'sentence)
                              (calculate-distance-to prev #'backward-sentence #'>)))
            (next-sentences (save-excursion
                              (end-of-thing 'sentence)
                              (calculate-distance-to next #'forward-sentence #'<))))
      (message "%s\n%s\n%s"
        (format "Word on point is `%s'." word)
        (if prev
          (format "The previous occurrence was %s word(s)/%s sentence(s) ago."
            prev-words prev-sentences)
          "This is the first occurrence.")
        (if next
          (format "The next occurrence will be in %s word(s)/%s sentence(s)."
            next-words next-sentences)
          "This is the last occurrence."))
      (when prev
        (overlay-put prev-overlay 'face 'show-paren-match)
        (run-at-time "4 sec" nil (lambda ()
                                   (delete-overlay prev-overlay))))
      (when next
        (overlay-put next-overlay 'face 'show-paren-match)
        (run-at-time "4 sec" nil (lambda ()
                                   (delete-overlay next-overlay))))))

  ;; https://macowners.club/posts/org-capture-from-everywhere-macos/
  (defun jf/func-make-capture-frame ()
    "Create a new frame and run `org-capture'."
    (interactive)
    (make-frame '((name . "capture")
                   (top . 300)
                   (left . 700)
                   (width . 80)
                   (height . 25)))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (cl-flet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
      (org-capture)))

  (defadvice org-capture-finalize
    (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame."
    (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))

  (defadvice org-capture-destroy
    (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame."
    (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))

  (use-package eat
    :straight (:type git
                :host codeberg
                :repo "akib/emacs-eat"
                :files ("*.el" ("term" "term/*.el") "*.texi"
                         "*.ti" ("terminfo/e" "terminfo/e/*")
                         ("terminfo/65" "terminfo/65/*")
                         ("integration" "integration/*")
                         (:exclude ".dir-locals.el" "*-tests.el"))))

  (use-package treemacs
    :straight t
    :bind ("s-o" . #'treemacs-select-window))

  (use-package treemacs-projectile
    :straight t
    :after (treemacs projectile))

  (use-package treemacs-magit
    :straight t
    :after (treemacs magit))

  (transient-define-prefix jf/isearch-menu ()
    "isearch Menu"
    [["Edit Search String"
       ("e"
         "Edit the search string (recursive)"
         isearch-edit-string
         :transient nil)
       ("w"
         "Pull next word or character word from buffer"
         isearch-yank-word-or-char
         :transient nil)
       ("s"
         "Pull next symbol or character from buffer"
         isearch-yank-symbol-or-char
         :transient nil)
       ("l"
         "Pull rest of line from buffer"
         isearch-yank-line
         :transient nil)
       ("y"
         "Pull string from kill ring"
         isearch-yank-kill
         :transient nil)
       ("t"
         "Pull thing from buffer"
         isearch-forward-thing-at-point
         :transient nil)]
      ["Replace"
        ("q"
          "Start ‚Äòquery-replace‚Äô"
          isearch-query-replace
          :if-nil buffer-read-only
          :transient nil)
        ("x"
          "Start ‚Äòquery-replace-regexp‚Äô"
          isearch-query-replace-regexp
          :if-nil buffer-read-only
          :transient nil)]]
    [["Toggle"
       ("X"
         "Toggle regexp searching"
         isearch-toggle-regexp
         :transient nil)
       ("S"
         "Toggle symbol searching"
         isearch-toggle-symbol
         :transient nil)
       ("W"
         "Toggle word searching"
         isearch-toggle-word
         :transient nil)
       ("F"
         "Toggle case fold"
         isearch-toggle-case-fold
         :transient nil)
       ("L"
         "Toggle lax whitespace"
         isearch-toggle-lax-whitespace
         :transient nil)]
      ["Misc"
        ("o"
          "occur"
          isearch-occur
          :transient nil)]])
  (define-key isearch-mode-map (kbd "<f2>") #'jf/isearch-menu)

  (provide 'jf-experiments)
  ;;; jf-experiments.el ends here
#+end_src
** =jf-fonts-and-iconography.el=
#+begin_src emacs-lisp :tangle "jf-fonts-and-iconography.el" :results none
  ;;; jf-fonts-and-iconography.el --- How words and symbols are displayed -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.

  ;;; Commentary:

  ;; This package provides font, theme, and window support.

  ;;; Code:

  ;;;; Fonts
  (use-package fontaine
    ;; A narrow focus package for naming font configurations and then selecting
    ;; them.
    :straight t
    :config
    (setq fontaine-presets
      ;; I'm naming the presets as "actions"; the mindset that I'm using when
      ;; wanting that font.
      '((compact
          :default-height 110)
         (default
           :default-height 140)
         (comfy
           :default-height 160)
         (coding
           :default-height 140)
         (presenting
           :default-weight semilight
           :default-height 220
           :bold-weight extrabold)
         (reading
           :default-weight semilight
           :default-family "ETBembo"
           :default-height 220
           :bold-weight extrabold)
         (t
           ;; Following Prot‚Äôs example, keeping these for for didactic purposes.
           :default-family "Iosevka Comfy Motion Fixed"
           :default-weight regular
           :default-height 140
           :fixed-pitch-family nil ; falls back to :default-family
           :fixed-pitch-weight nil ; falls back to :default-weight
           :fixed-pitch-height 1.0
           :fixed-pitch-serif-family nil ; falls back to :default-family
           :fixed-pitch-serif-weight nil ; falls back to :default-weight
           :fixed-pitch-serif-height 1.0
           :variable-pitch-family "ETBembo"
           :variable-pitch-weight nil
           :variable-pitch-height 1.0
           :bold-family nil ; use whatever the underlying face has
           :bold-weight bold
           :italic-family nil
           :italic-slant italic
           :line-spacing nil)))
    (fontaine-set-preset 'default))

  ;;;; Icons

  (use-package all-the-icons
    ;; It's nice to see icons as a quick visual helper.
    :straight t
    :config
    (cl-defmacro jf/all-the-icons--with(&key name)
      "A macro to provide functions for icon names."
      (let ((defun-fn (intern (concat "jf/all-the-icons--with-" name)))
             (icon-fn (intern (concat "all-the-icons-" name)))
             (docstring (concat
                          "Displays an ICON from `all-the-icons-" name "'.")))
        `(defun ,defun-fn (icon str &optional height v-adjust)
           ,docstring
           (s-concat (,icon-fn
                       icon
                       :v-adjust (or v-adjust 0)
                       :height (or height 1))
             " " str))))
    (jf/all-the-icons--with :name "faicon")
    (jf/all-the-icons--with :name "material")
    (jf/all-the-icons--with :name "octicon")
    (jf/all-the-icons--with :name "alltheicon"))

  (use-package all-the-icons-dired
    ;; Incorporates file icons with file listings of dired.  /Note/: On 2021-04-11
    ;; I was getting the following error with this package: "*ERROR*: Symbol's
    ;; value as variable is void: file"
    :straight t
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))

  ;;;; Typography
  (use-package typopunct
    ;; A package that provides some automatic replacement of strings of keys.  For
    ;; example in text-mode, when I type three periods (e.g. ‚Äú.‚Äù) typopunct
    ;; replaces that with an ellipsis (e.g. ‚Äú‚Ä¶‚Äù)
    :straight t
    :config
    (add-hook 'org-mode-hook 'jf/typopunct-init)
    (defun jf/typopunct-init ()
      (require 'typopunct)
      (typopunct-change-language 'english)
      (typopunct-mode 1))
    (setq typopunct-buffer-language 'english)
    ;; To insert a typographical ellipsis sign (‚Ä¶) on three consecutive
    ;; dots, or a middle dot (¬∑) on ‚Äò^.‚Äô
    (defconst typopunct-ellipsis (decode-char 'ucs #x2026))
    (defconst typopunct-middot   (decode-char 'ucs #xB7)) ; or 2219
    (defun typopunct-insert-ellipsis-or-middot (arg)
      "Change three consecutive dots to a typographical ellipsis mark."
      (interactive "p")
      (cond
        ((and (= 1 arg)
           (eq (char-before) ?^))
          (delete-char -1)
          (insert typopunct-middot))
        ((and (= 1 arg)
           (eq this-command last-command)
           (looking-back "\\.\\." 1))
          (replace-match "")
          (insert typopunct-ellipsis))
        (t
          (self-insert-command arg))))
    (define-key typopunct-map "." 'typopunct-insert-ellipsis-or-middot)
    ;; feet, arcminutes, derivatives
    (defconst typopunct-prime  (decode-char 'ucs #x2032))
    ;; inches, arcseconds, double derivatives
    (defconst typopunct-dprime (decode-char 'ucs #x2033))
    (defconst typopunct-tprime (decode-char 'ucs #x2034))
    ;; The minus sign (‚àí) is separate from the hyphen (-), en dash (‚Äì) and
    ;; em dash (‚Äî). To build upon the clever behavior of the ‚Äò-‚Äô key
    (defconst typopunct-minus (decode-char 'ucs #x2212))
    (defconst typopunct-pm    (decode-char 'ucs #xB1))
    (defconst typopunct-mp    (decode-char 'ucs #x2213))
    (defadvice typopunct-insert-typographical-dashes
      (around minus-or-pm activate)
      (cond
        ((or (eq (char-before) typopunct-em-dash)
           (looking-back "\\([[:blank:]]\\|^\\)\\^" 2))
          (delete-char -1)
          (insert typopunct-minus))
        ((looking-back "[^[:blank:]]\\^" 1)
          (insert typopunct-minus))
        ((looking-back "+/" 1)
          (progn (replace-match "")
            (insert typopunct-pm)))
        (t ad-do-it)))
    (defun typopunct-insert-mp (arg)
      (interactive "p")
      (if (and (= 1 arg) (looking-back "-/" 2))
        (progn (replace-match "")
          (insert typopunct-mp))
        (self-insert-command arg)))
    (define-key typopunct-map "+" 'typopunct-insert-mp)
    (defconst typopunct-times (decode-char 'ucs #xD7))
    (defun typopunct-insert-times (arg)
      "Insert multiplication sign at ARG."
      (interactive "p")
      (if (and (= 1 arg) (looking-back "\\([[:blank:]]\\|^\\)\\^"))
        (progn (delete-char -1)
          (insert typopunct-times))
        (self-insert-command arg)))
    (define-key typopunct-map "x" 'typopunct-insert-times)
    (defadvice typopunct-insert-quotation-mark (around wrap-region activate)
      (let* ((lang (or (get-text-property (point) 'typopunct-language)
                     typopunct-buffer-language))
              (omark (if single
                       (typopunct-opening-single-quotation-mark lang)
                       (typopunct-opening-quotation-mark lang)))
              (qmark (if single
                       (typopunct-closing-single-quotation-mark lang)
                       (typopunct-closing-quotation-mark lang))))
        (cond
          (mark-active
            (let ((skeleton-end-newline nil)
                   (singleo (typopunct-opening-single-quotation-mark lang))
                   (singleq (typopunct-closing-single-quotation-mark lang)))
              (if (> (point) (mark))
                (exchange-point-and-mark))
              (save-excursion
                (while (re-search-forward (regexp-quote (string omark)) (mark) t)
                  (replace-match (regexp-quote (string singleo)) nil nil)))
              (save-excursion
                (while (re-search-forward (regexp-quote (string qmark)) (mark) t)
                  (replace-match (regexp-quote (string singleq)) nil nil)))
              (skeleton-insert (list nil omark '_ qmark) -1)))
          ((looking-at (regexp-opt (list (string omark) (string qmark))))
            (forward-char 1))
          (t ad-do-it)))))
  (provide 'jf-fonts-and-iconography)
  ;;; jf-fonts-and-iconography.el ends here
#+end_src
** =jf-formatting.el=
#+begin_src emacs-lisp :tangle "jf-formatting.el" :results none
  ;;; jf-formatting.el --- formatting functions -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.

  ;;; Commentary:

  ;; This package is on shaky grounds; I don't know if it makes sense.  There's
  ;; whitespace and sentence considerations.  There's also `htmlize' which is for
  ;; exporting a region as markdown or HTML.

  ;;; Code:

  (use-package ws-butler
    ;; Keep white space tidy.
    :straight t
    :hook (prog-mode . ws-butler-mode))

  (use-package fill-sentences-correctly
    ;; `fill-sentences-correctly-mode' ensures that `fill-paragraph' (e.g. M-q)
    ;; preserves two spaces.
    :straight (fill-sentences-correctly
         :host github
         :repo "duckwork/fill-sentences-correctly.el")
    :config (fill-sentences-correctly-mode))

  (use-package tomelr
    ;; Emacs-Lisp Library for converting S-expressions to TOML.  I'll likely be
    ;; using this as I move my Hugo front-matter from YAML to TOML, as per the
    ;; changes described by `ox-hugo'.
    :straight (tomelr :host github :repo "kaushalmodi/tomelr"))

  (provide 'jf-formatting)
  ;;; jf-formatting.el ends here
#+end_src
** =jf-framing.el=
#+begin_src emacs-lisp :tangle "jf-framing.el" :results none
  ;;; jf-framing.el --- How Emacs presents the frame -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;;
  ;; This personal package provides logic for both a focus mode and presentation
  ;; mode.  There are several assumptions about packages, but I guard those
  ;; assumptions with `fboundp'.
  ;;
  ;; To enter focus mode: "M-x logos-focus-mode"
  ;; To enter presentation mode: "M-x jf/minor-mode/presenter"

  ;;; Code:
  (use-package edit-indirect
    ;; A nice package for editing regions in separate buffers.  It doesn't appear
    ;; to get the mode guess right.  I haven't used this as much as
    ;; `narrow-region'.  Perhaps it can go?
    :straight t)

  (use-package logos
    ;; A `narrow-region' extension that moves towards providing a
    ;; presentation-type experience.
    :straight t
    :bind (:map logos-focus-mode-map
            ("M-]" . #'logos-forward-page-dwim)
            ("s-]" . #'logos-forward-page-dwim)
            ("M-[" . #'logos-backward-page-dwim)
            ("s-[" . #'logos-backward-page-dwim))
    :config
    (let ((map global-map))
      (define-key map [remap narrow-to-region] #'logos-narrow-dwim)
      (define-key map [remap forward-page] #'logos-forward-page-dwim)
      (define-key map [remap backward-page] #'logos-backward-page-dwim))
    ;; (let ((map logos-focus-mode-map))
    ;;   (define-key map [remap next-line] #'logos-forward-page-dwim)
    ;;   (define-key map [remap previous-line] #'logos-backward-page-dwim))
    (setq logos-outlines-are-pages t)
    (setq-default logos-hide-cursor t
      logos-hide-mode-line t
      logos-hide-buffer-boundaries t
      logos-hide-fringe t
      logos-variable-pitch t
      logos-buffer-read-only t
      logos-scroll-lock nil
      logos-olivetti t
      logos-outline-regexp-alist
      `((emacs-lisp-mode . "^;;;+ ")
        (org-mode . "^\\*+ +")
        (markdown-mode . "^\\#+ +")))
    (defun logos--reveal-entry ()
      "Reveal Org or Outline entry."
      (cond
       ((and (eq major-mode 'org-mode)
       (org-at-heading-p))
        (org-show-subtree))
       ((or (eq major-mode 'outline-mode)
      (bound-and-true-p outline-minor-mode))
        (outline-show-subtree))))
    :init
    (add-hook 'logos-page-motion-hook #'logos--reveal-entry))

  (use-package "nov.el"
    ;; A package to help in reading epubs.
    :straight t
    :init (use-package esxml :straight t)
    :config
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
    :custom (nov-text-width 80))

  (use-package so-long
    ;; Switch to `so-long' when the file gets too long for normal processing.
    :straight t
    :bind
    (:map so-long-mode-map
          ("C-s" . isearch-forward)
          ("C-r" . isearch-backward))
    :config (global-so-long-mode 1))

  (use-package olivetti
    :straight t
    :custom
    (olivetti-body-width 0.6)
    (olivetti-minimum-body-width 80)
    (olivetti-recall-visual-line-mode-entry-state t))

  ;;; qPresentation mode leveraging logos

  (defvar jf/minor-mode/presenter-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "C-n") #'next-line)
      (define-key map (kbd "C-p") #'previous-line)
      (dolist (key `("M-]" "s-]"))
        (define-key map (kbd key) 'logos-forward-page-dwim))
      (dolist (key `("M-[" "s-["))
        (define-key map (kbd key) 'logos-backward-page-dwim))
      map))

  (define-minor-mode jf/minor-mode/presenter
    "Enter a `logos' and `olivetti' mode for showing things."
    :init-value nil
    :global nil
    :keymap jf/minor-mode/presenter-map
    :lighter " presenter")

  (defcustom jf/minor-mode/presenter-on-hook
    (lambda ()
      (let ((logos-hide-cursor nil)
      (logos-buffer-read-only nil)
      (org-hide-emphasis-markers t))
        (call-interactively 'logos-narrow-dwim)
        (olivetti-mode t)
        (keycast-mode-line-mode t)
        (display-line-numbers-mode -1)
        (when (fboundp 'fontaine-set-preset) (fontaine-set-preset 'presenting))
        (when (fboundp 'vi-tilde-fringe-mode) (vi-tilde-fringe-mode -1))
        (when (fboundp 'git-gutter-mode) (git-gutter-mode -1))
        (when (fboundp 'centaur-tabs-local-mode) (centaur-tabs-local-mode -1))))
    "Hook when `jf/minor-mode/presenter' activated."
    :type 'hook)

  (defcustom jf/minor-mode/presenter-off-hook
    (lambda ()
      (call-interactively 'widen)
      (olivetti-mode -1)
      (keycast-mode-line-mode -1)
      ;; (setq-local  org-hide-emphasis-markers nil)
      (display-line-numbers-mode t)
      (when (fboundp 'fontaine-set-preset) (fontaine-set-preset 'default))
      (when (fboundp 'vi-tilde-fringe-mode) (vi-tilde-fringe-mode t))
      (when (fboundp 'git-gutter-mode) (git-gutter-mode t))
      (when (fboundp 'centaur-tabs-local-mode) (centaur-tabs-local-mode t)))
    "Hook when `jf/minor-mode/presenter' deactivated."
    :type 'hook)
  (provide 'jf-framing)
  ;;; jf-framing.el ends here
#+end_src
** =jf-gaming.el=
#+begin_src emacs-lisp :tangle "jf-gaming.el" :results none
  ;;; jf-gaming.el --- Gaming related functions -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;;; Code:

  ;;;; Dependencies
  (require 'jf-minor-mode-maker)
  (require 'jf-quick-help)
  (require 'jf-org-mode)

  (if (f-file?  "~/git/emacs-rpgtk/rpgtk-messages.el")
    (progn
      ;; Favor my clone of the code.
      (use-package rpgtk-messages
        :straight (:type git :local-repo "~/git/emacs-rpgtk/" :files ("rpgtk-messages.el")))
      (use-package rpgtk-dice
        :straight (:type git :local-repo "~/git/emacs-rpgtk/" :files ("rpgtk-dice.el")))
      (use-package rpgtk-tables
        :straight (:type git :local-repo "~/git/emacs-rpgtk/" :files ("rpgtk-tables.el"))
        :custom (rpgtk-tables-choose-predicate #'jf/rpgtk-tables-choose-predicate)
        :config
        (defun jf/rpgtk-tables-choose-predicate ()
          "Skip any tables that have a parent directory of \"/_private/\"."
          (-reject (lambda (el) (s-contains? "/_private/" el))
            (funcall #'rpgtk-tables-choose-default-predicate))))
      (use-package rpgtk-org
        :straight (:type git :local-repo "~/git/emacs-rpgtk/" :files ("rpgtk-org.el"))))
    (progn
      (use-package rpgtk-messages
        :straight (:host codeberg
                    :repo "takeonrules/emacs-rpgtk"
                    :type git
                    :files ("rpgtk-messages.el")))
      (use-package rpgtk-dice
        :init (use-package rpgtk-messages :straight t)
        :straight (:host codeberg
                    :repo "takeonrules/emacs-rpgtk"
                    :type git
                    :files ("rpgtk-dice.el")))
      (use-package rpgtk-tables
        :init (use-package rpgtk-messages :straight t)
        :straight (:host codeberg
                    :repo "takeonrules/emacs-rpgtk"
                    :type git
                    :files ("rpgtk-tables.el")))
      (use-package rpgtk-org
        :init (use-package rpgtk-messages :straight t)
        :straight (:host codeberg
                    :repo "takeonrules/emacs-rpgtk"
                    :type git
                    :files ("rpgtk-org.el")))))

  ;;;; General

  (defconst jf/gaming/runes
    '(("·ö†" . "Gandalf Rune for the One Ring") ;; (Runic Letter Fehu Feoh Fe F) Gandalf rune
      ("’á" . "Success Icon for the One Ring") ;; (Armenian Capital Letter Sha) Success Icon
      ("‚èø" . "Eye of Sauron for the One Ring") ;; (Observer Eye Symbol) Sauron symbol
      ))
  ;;;; Burning Wheel Code
  (jf/minor-mode-maker :title "Burning Wheel Gold"
           ;; Being a programmer and someone who plays table top
           ;; role-playing games (TTRPG), I‚Äôve often used the TTRPG
           ;; rules-set or systems to explore programming languages
           ;; and processes.  After all, I understand the TTRPG rules
           ;; well enough (or the algorithm‚Äôs description) that I can
           ;; spend time thinking through my approach in a
           ;; programming language.
                       :abbr "bwg"
                       :hooks (list 'org-mode-hook 'markdown-mode-hook))

  (jf/transient-quick-help jf/bwg-qh-wises
    :label "Wises"
    :header "BWG Wises Obstacles (page 309)"
    :body
    (s-join
     "\n"
     '("Common knowledge .............. Ob 1"
       "An interesting fact ........... Ob 2"
       "Details ....................... Ob 3"
       "Uncommon knowledge ............ Ob 4"
       "Rare goods .................... Ob 5"
       "Bizarre or obscure ............ Ob 7"
       "Freaky details or specifics ... Ob 8")))

  (jf/transient-quick-help jf/bwg-qh-expertise-exponent
    :label "Exponents"
    :header "BWG Expertise Exponent (page 12)"
    :body
    (s-join
     "\n"
     '("Exp 1  is naturally disinclined, crippled, or utterly incompetent."
       "Exp 2  is untrained, raw, weak, or unpracticed."
       "Exp 3  is nominally trained and practiced."
       "Exp 4  is competent; everday stuff doesn't pose a challenge."
       "Exp 5  is expert."
       "Exp 6  is near mastery."
       "Exp 7  is excellence."
       "Exp 8  is total mastery, complete understanding."
       "Exp 9  is uncanny; incomprehensibly good."
       "Exp 10 is as near perfection as the system allows.")))

  (jf/transient-quick-help jf/bwg-qh-absolute-difficulty
    :label "Difficulty"
    :header "BWG Absolute Difficulty (page 15)"
    :body
    (s-join
     "\n"
     '("Ob 1  A simple act done with little thought."
       "Ob 2  An act performed routinely at your job."
       "Ob 3  An act you can accomplish if you concentrate."
       "Ob 4  A risky act."
       "Ob 5  An act that requires expertise."
       "Ob 6  An act that requires a heroic effort."
       "Ob 7  An improbable feat."
       "Ob 8  An act requiring preternatural ability or a lot of help."
       "Ob 9  An act deemed nearly impossible."
       "Ob 10 A miracle.")))

  (jf/transient-quick-help jf/bwg-qh-circles-obstacles
    :label "Circles"
    :header "BWG Circles Obstacles (page 380-381)"
    :body
    (s-join
     "\n"
     '("Occupation"
       "  Broad occupation/profession, same life path ... +0 Ob"
       "  Uncommon occupation, or within same setting ... +2 Ob"
       "  Specific occupation, rare/unique occupation ... +3 Ob"
       ""
       "Station"
       "  Same station .................................. +0 Ob"
       "  Lower rank, station, or class ................. +1 Ob"
       "  Higher rank, station, or class ................ +2 Ob"
       "  Highest station or rank in the setting ........ +3 Ob"
       ""
       "Disposition and Knowledge"
       "  Common to circle .............................. +0 Ob"
       "  Different from circle members ................. +1-2 Ob"
       "  Specific, detailed, or rare ................... +3 Ob"
       ""
       "Time and Place"
       "  Doesn't matter ................................ +0 Ob"
       "  Unusual for this character .................... +1-2 Ob"
       "  Right here and now in the middle of trouble ... +3 Ob")))

  (jf/transient-quick-help jf/bwg-qh-circles-alternate
    :header "BWG Circles 2006 (Burning Anthology p7)"
    :label "Circles 2006"
    :body
    (s-join
     "\n"
     '("Occupation"
       "  Broad/common .................... +0 Ob"
       "  Uncommon ........................ +2 Ob"
       "  Specific/rare/unique ............ +3 Ob"
       ""
       "Station"
       "  Same station .................... +0 Ob"
       "  Higher or lower rank ............ +1 Ob"
       "  Lowest .......................... +2 Ob"
       "  Highest ......................... +3 Ob"
       ""
       "Attitude"
       "  Neutral to PC ................... +0 Ob"
       "  Predisposed or opposed .......... +1 Ob"
       "  Proponent, loyal, or specific ... +3 Ob"
       ""
       "Knowledge"
       "  Unimportant ..................... +0 Ob"
       "  General for subject ............. +1 Ob"
       "  Specific subject ................ +3 Ob"
       ""
       "Skill"
       "  Typical (Exponent 3) ............ +0 Ob"
       "  Competent (Exponent 4) .......... +1 Ob"
       "  Expert (Expoonent 5) ............ +2 Ob"
       "  Master (Exponent 6) ............. +3 Ob"
       ""
       "Place/Time"
       "  Prior to important test ......... +0 Ob"
       "  Prior to conflict ............... +1 Ob"
       "  In midst of conflict ............ +3 Ob")))

  (jf/transient-quick-help jf/bwg-qh-steel-test-adjustments
    :header "BWG Steel Test Adjustments (page 363)"
    :label "Steel"
    :body
    (s-join
     "\n"
     '("Conditions for Steel Advantags"
       "  Being startled by something mundane ......... +2D"
       "  Feeling safe in a group of friends/allies ... +1D"
       ""
       "Conditions for Steel Disadvantages"
       "  Being shot at ............................... +1 Ob"
       "  Being directly affect by magic .............. +1 Ob"
       "  Witnessing a person killed .................. +1 Ob"
       "  Small explosions ............................ +2 Ob"
       "  Committing murder ........................... +2 Ob"
       "  Explosions .................................. +3 Ob"
       "  Witnessing pronounced sorcery at play ....... +3 Ob"
       "  Seeing a ghost .............................. +3 Ob"
       "  Seeing the living dead ...................... +4 Ob"
       "  Volcanic eruptions, cataclysm ............... +4 Ob"
       "  Seeing horrible magic at work ............... +4 Ob"
       "  Being in the presence of the supernatural ... +5 Ob")))

  (jf/transient-quick-help jf/bwg-qh-test-difficulty
    :header "BWG Difficulty of Test by Dice Rolled (p41)"
    :label "Test Difficulty"
    :body
    (s-join
     "\n"
     '("| Dice | Routine | Difficult | Challenging |
            |------+---------+-----------+-------------|
            |   1D | Ob 1    | Ob 1      | Ob 2+       |
            |   2D | Ob 1    | Ob 2      | Ob 3+       |
            |   3D | Ob 1-2  | Ob 3      | Ob 4+       |
            |   4D | Ob 1-2  | Ob 3-4    | Ob 5+       |
            |   5D | Ob 1-3  | Ob 4-5    | Ob 6+       |
            |   6D | Ob 1-4  | Ob 5-6    | Ob 7+       |
            |   7D | Ob 1-4  | Ob 5-7    | Ob 8+       |
            |   8D | Ob 1-5  | Ob 6-8    | Ob 9+       |
            |   9D | Ob 1-6  | Ob 7-9    | Ob 10+      |
            |  10D | Ob 1-7  | Ob 8-10   | Ob 11+      |
            |  11D | Ob 1-8  | Ob 9-11   | Ob 12+      |
            |  12D | Ob 1-9  | Ob 10-12  | Ob 13+      |
            |  13D | Ob 1-10 | Ob 11-13  | Ob 14+      |
            |  14D | Ob 1-11 | Ob 12-14  | Ob 15+      |
            |  15D | Ob 1-12 | Ob 13-15  | Ob 16+      |
            |  16D | Ob 1-13 | Ob 14-16  | Ob 17+      |
            |  17D | Ob 1-14 | Ob 15-17  | Ob 18+      |
            |  18D | Ob 1-15 | Ob 16-18  | Ob 19+      |")))

  (defconst jf/bwg-mortal-wounds-scale
    ;; When running Burning Wheel Gold, on occassion I need to establish the PTGS
    ;; for a creature or person.
    ;;
    ;; Yes, I could‚Äôve written out (0 "B1" "B2" "B3" "B4" "B5" "B6" "B7" "B8" "B9"
    ;; "B10" "B11" "B12" "B13" "B14" "B15" "B16" "G1" "G2" "G3" "G4" "G5" "G6"
    ;; "G7" "G8" "G9" "G10" "G11" "G12" "G13" "G14" "G15" "G16" "W1" "W2" "W3"
    ;; "W4" "W5" "W6" "W7" "W8" "W9" "W10" "W11" "W12" "W13" "W14" "W15" "W16")
    ;; faster than the following constant, but I wanted to learn a bit of
    ;; emacs-lisp, so I chose to write the following.

    ;; I copied that text string from the introspected variable.  Because if I
    ;; wasn't going to write it the first time, I sure wasn't going to do it if I
    ;; had already stored that value in a constant.
    (let* ((shades '("B" "G" "W"))
           (rank '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))
           (scale (-flatten
                   (-map (lambda (s)
                           (-map (lambda (r)
                                   (format "%s%s" s r))
                                 rank))
                         shades))))
      ;; I want B1 to have an index of 1.  Hence pre-pending the 0 to the list.
      (add-to-list 'scale 0)
      scale)
    "The BWG Physical Tolerance Grayscale (from B1 to W16).")

  (defun jf/bwg-qh-ptgs (forte power &optional round-up)
    "Calculate Burning Wheel PTGS.

  This requires FORTE, POWER, and ROUND-UP.

  Note, this assumes Black or Grey shade only."
    (interactive "sForte: \nsPower: \nP")
    ;; Note the / function uses integer floor division.
    (let* ((forte-index (-elem-index (upcase forte) jf/bwg-mortal-wounds-scale))
           (power-index (-elem-index (upcase power) jf/bwg-mortal-wounds-scale)))
      (unless forte-index (throw 'invalid-entry (format "Invalid Forte %s" forte)))
      (unless power-index (throw 'invalid-entry (format "Invalid Power %s" power)))
      (let ((scale (cond ((and (< forte-index 17) (< power-index 17))
                          (jf/bwg-qh-ptgs--shade-black forte-index
                                                       power-index
                                                       round-up))
                         ((and (< forte-index 17) (< power-index 34))
                          (jf/bwg-qh-ptgs--shade-black forte-index
                                                       (- power-index 16)
                                                       round-up
                                                       :add 2))
                         ((and (< forte-index 34) (< power-index 17))
                          (jf/bwg-qh-ptgs--shade-black (- forte-index 16)
                                                       power-index
                                                       round-up
                                                       :add 2))
                         ((and (< forte-index 34) (< power-index 34))
                          (jf/bwg-qh-ptgs--shade-gray forte-index
                                                      power-index
                                                      round-up)))))
        (jf/bwg-qh-ptgs--render-popup :power power
                                      :forte forte
                                      :round-up round-up
                                      :scale scale))))

  (cl-defun jf/bwg-qh-ptgs--render-popup (&key power forte round-up scale)
    "Render PTGS help for given POWER, FORTE, ROUND-UP, and SCALE.

    Where SCALE is a list of 6 elements: Su, Li, Mi, Se, Tr, and Mo"
    (jf/quick-help
     :header (concat "BWG PTGS (p98, p546) Forte:"
         forte ", Power: " power (when round-up " (Rounded up)"))
     :body (format (concat
                    "Su %s; Li %s; Mi %s; Se %s; Tr %s; Mo %s"
                    "\n\nForte: %s\nPower: %s"
                    (when round-up "\n(Rounded up)") "\n")
                   (nth (nth 0 scale) jf/bwg-mortal-wounds-scale)
                   (nth (nth 1 scale) jf/bwg-mortal-wounds-scale)
                   (nth (nth 2 scale) jf/bwg-mortal-wounds-scale)
                   (nth (nth 3 scale) jf/bwg-mortal-wounds-scale)
                   (nth (nth 4 scale) jf/bwg-mortal-wounds-scale)
                   (nth (nth 5 scale) jf/bwg-mortal-wounds-scale)
                   (upcase forte)
                   (upcase power))))

  (cl-defun jf/bwg-qh-ptgs--shade-black (forte power
                 &optional round-up
                 &key (add 0))
    "Calculate Black shade PTGS (BWGR p98, p546).

  This requires FORTE, POWER, ROUND-UP, and ADD.

  Returns a list of 6 elements: Su, Li, Mi, Se, Tr, and Mo"
    (interactive "nForte: \nnPower: \nP")
    ;; Note the / function uses integer floor division.
    (let* ((mw-rnd (if round-up 1 0))
           (mo (+ 6 add (/ (+ forte power mw-rnd) 2)))
           (step (+ (/ (+ 1 forte) 2)))
           (su (+ 1 (/ forte 2)))
           (li (+ su step))
           (mi (+ li step))
           (se (+ mi step))
           (tr (+ se step))
           (tr (if (< tr mo) tr (- mo 1)))
           (se (if (< se tr) se (- tr 1)))
           (mi (if (< mi se) mi (- se 1)))
           (li (if (< li mi) li (- mi 1))))
      (list su li mi se tr mo)))

  (defun jf/bwg-qh-ptgs--shade-gray (forte power &optional round-up)
    "Calculate Gray shade PTGS (BWGR p546).

  This requires FORTE, POWER, and ROUND-UP.

  Returns a list of 6 elements: Su, Li, Mi, Se, Tr, and Mo"
    (let* ((fort-exponent (- forte 16))
           (mw-rnd (if round-up 1 0))
           (mo (+ 6 (/ (+ forte power mw-rnd) 2)))
           (su fort-exponent)
           (li (+ su fort-exponent))
           (mi (- mo 4))
           (se (- mo 2))
           (tr (- mo 1)))
      (list su li mi se tr mo)))

  (defconst jf/bwg-lifepath--path-to-html-file
    ;; While running (or playing) a game of Burning Wheel, it can be useful to have
    ;; access to character lifepaths.  These can give you insight into a quick NPC.
    ;;
    ;; I have transformed and edited the http://charred-black.herokuapp.com/#/ into
    ;; individual YAML files that sit on my local machine.  I also created a bit of
    ;; https://gohugo.io/ code to render lifepaths from those YAML files.  You can
    ;; see an example at
    ;; https://takeonrules.com/2018/10/10/burning-wheel-lifepaths-inspired-by-warhammer-fantasy/
    ;;
    ;; I‚Äôm thinking what would be useful to create a searchable index of those
    ;; lifepaths.  For now, I‚Äôll search based on the stock, setting, and lifepath
    ;; name (all of which happen to be in the pathname of the YAML file).
    ;;
    ;; But instead of hopping to the YAML file, I‚Äôd like to jump to the spot on an
    ;; HTML page with that information.  This way when I ‚Äúfind‚Äù a lifepath, I can
    ;; see what other lifepaths are of comparable station (a common need when
    ;; testing Circles).
    "~/git/org/assets/burning-wheel.html"
    "The path to an HTML.")

  (defconst jf/bwg-lifepath--narrowing-regexp
    "data-lifepath="
    "All lines in `jf/bwg-lifepath--path-to-html-file' that have this substring contain filterable data.")

  (global-set-key (kbd "C-M-s-b") 'jf/menu--bwg)
  (transient-define-prefix jf/menu--bwg ()
    "Define the BWG help prefix."
    ["Burning Wheel"
     ("c" jf/bwg-qh-circles-obstacles)
     ("C" jf/bwg-qh-circles-alternate)
     ("d" jf/bwg-qh-absolute-difficulty)
     ("e" jf/bwg-qh-expertise-exponent)
     ("p" "PTGS" jf/bwg-qh-ptgs)
     ("s" jf/bwg-qh-steel-test-adjustments)
     ("t" jf/bwg-qh-test-difficulty)
     ("w" jf/bwg-qh-wises)
     ])

  ;;;; Core RPG

  (jf/minor-mode-maker :title "CORE RPG"
                       :abbr "core"
                       :hooks (list 'org-mode-hook 'markdown-mode-hook))

  (jf/transient-quick-help jf/rpg-core-qh-stat-scores
    :label "Stat Descriptors"
    :header "CORE Stat Descriptors"
    :body
    (s-join
     "\n"
     '("1 ... Average"
       "2 ... Remarkable"
       "3 ... Excellent"
       "4 ... Gifted"
       "5 ... Prodigy"
       "6 ... Apex")))

  (jf/transient-quick-help jf/rpg-core-qh-skill-scores
    :label "Skill Descriptors"
    :header "CORE Skill Descriptors"
    :body
    (s-join
     "\n"
     '("1 ... Trained"
       "2 ... Competent"
       "3 ... Veteran"
       "4 ... Expert"
       "5 ... Innovator"
       "6 ... Legend")))

  (jf/transient-quick-help jf/rpg-core-qh-item-bonuses
    :label "Item Bonus Levels"
    :header "CORE Item Bonus Levels"
    :body
    (s-join
     "\n"
     '("1 ... Trained"
       "2 ... Competent"
       "3 ... Veteran"
       "4 ... Expert"
       "5 ... Innovator"
       "6 ... Legend")))

  (jf/transient-quick-help jf/rpg-core-qh-fame-levels
    :label "Fame Levels"
    :header "CORE Fame Levels"
    :body
    (s-join
     "\n"
     '("1 ... Local/Professional"
       "2 ... Regional/Subcultural"
       "3 ... National/Cultural"
       "4 ... International/Global"
       "5 ... Historical/Legendary"
       "6 ... Mythic Universal")))

  (jf/transient-quick-help jf/rpg-core-qh-difficulty-levels
    :label "Difficulty Levels (DL)"
    :header "CORE Difficulty Levels"
    :body
    (s-join
     "\n"
     '("1 .... No-Brainer"
       "2 .... Easy"
       "3 .... Challenging"
       "4 .... Difficulut"
       "5 .... Hard"
       "6 .... Very Hard"
       "7 .... Unlikely"
       "8 .... Ridiculous"
       "9 .... Absurd"
       "10 ... Insane")))

  (jf/transient-quick-help jf/rpg-core-qh-difficulty-levels
    :label "Difficulty Levels (DL) (RMSS)"
    :header "CORE Difficulty Levels (RMSS)"
    :body
    (s-join
     "\n"
     '("1 .... Routine"
       "2 .... Easy"
       "3 .... Challenging"
       "4 .... Difficult"
       "5 .... Hard"
       "6 .... Very Hard"
       "7 .... Extermely Hard"
       "8 .... Sheer Folly"
       "9 .... Absurd"
       "10 ... Nigh Impossible")))

  (jf/transient-quick-help jf/rpg-core-qh-standard-modifiers
    :label "Standard Modifiers"
    :header "CORE Standard Modifiers"
    :body
    (s-join
     "\n"
     '("+N .... Skill level and items"
       "+1 .... Superior position/advantage"
       "+1 .... Character development from /Flash of Insight/"
       "-1 .... Wounded for 2 or more"
       "-1 .... Within skill but not specialty"
       "-1 .... Pro kit required but makeshift tools"
       "-2 .... Pro kit required but no tools"
       "-2 .... Attempting 2 Actions at once")))

  (jf/transient-quick-help jf/rpg-core-qh-hit-locations
    :label "Hit Locations"
    :header "CORE Hit Locations; +2 to attacks from above."
    :body
    (s-join
     "\n"
     '("2 .... Left Leg"
       "3 .... Right Leg"
       "4 .... Crotch/Abdoment"
       "5 .... Left Arm"
       "6 .... Right Arm"
       "7 .... Belly/Lower Back"
       "8 .... Left Shoulder"
       "9 .... Right Shoulder"
       "10 ... Chest/Upper Back"
       "11 ... Neck"
       "12 ... Head")))

  (jf/transient-quick-help jf/rpg-core-qh-lifeshaping-events
    :label "LifeShaping Events"
    :header "CORE LifeShaping Events (DayTrippers)"
    :body
    (s-join
     "\n"
     '("Belief ......... What the PC Believes"
       "Concept ........ What Ideas the PC Has"
       "Duty ........... What the PC Is Obliged to Do"
       "Goal ........... What the PC Wants to Do"
       "History ........ What the PC Has Learned in Life"
       "Mission ........ What the PC‚Äôs Orders Are"
       "Problem ........ Stuff the PC Has Issues With"
       "Relationship ... People the PC Interacts With"
       "Thing .......... The PC‚Äôs Most Personal Possessions")))

  (jf/transient-quick-help jf/rpg-core-qh-help
    :label "Help"
    :header "CORE Help (DayTrippers)"
    :body
    (s-join
     "\n"
     '("Miss 2 or more ... Help gets -1")))

  ;;;; Eberron
  (jf/minor-mode-maker :title "Eberron"
                       :abbr "eb"
                       :hooks (list 'org-mode-hook 'markdown-mode-hook))

  (jf/transient-quick-help jf/eberron-qh-dragonmarks
    :label "Dragonmarks"
    :header "Eberron Dragonmarks, Houses, and Stock"
    :body
    (s-join
     "\n"
     '("| Name             | House               | Stock                 |"
       "|------------------+---------------------+-----------------------|"
       "| Detection        | Medani              | half-elf              |"
       "| Finding          | Tharashk            | half-orc,  human      |"
       "| Handling         | Vadalis             | human                 |"
       "| Healing          | Jorasco             | halfling              |"
       "| Hospitality      | Ghallanda           | halfling              |"
       "| Making           | Cannith             | human                 |"
       "| Passage          | Orien               | human                 |"
       "| Scribing         | Sivis               | gnome                 |"
       "| Sentinel         | Deneith             | human                 |"
       "| Shadow           | Phiarlan & Thuranni | elf                   |"
       "| Storm            | Lyrandar            | half-elf              |"
       "| Warding          | Kundarak            | dwarf                 |"
       "| Death            | Vol                 | elf, currently lost   |"
       "| Aberrant         | Tarkanan            | any                   |")))

  (jf/transient-quick-help jf/eberron-qh-planes
    :label "Planes"
    :header "Eberron Planes"
    :body
    (s-join
     "\n"
     '("Daanvi, the Perfect Order"
       "Dal Quor, the Region of Dreams"
       "Dolurrh, the Realm of the Dead"
       "Fernia, the Sea of Fire"
       "Irian, the Eternal Day"
       "Kythri, the Churning Chaos"
       "Lamannia, the Twilight Forest"
       "Mabar, the Endless Night"
       "Risia, the Plain of Ice"
       "Shavarath, the Battleground"
       "Syrania, the Azure Sky"
       "Thelanis, the Faerie Court"
       "Xoriat, the Realm of Madness")))

  (jf/transient-quick-help jf/eberron-qh-religion
    :label "Religion"
    :header "Eberron Religion"
    :body
    (s-join
     "\n"
     '("| Pantheon     | Deity             | Domain            |"
       "|--------------+-------------------+-------------------|"
       "| Sovereign    | Arawai            | Life, Love        |"
       "| Sovereign    | Aureon            | Law, Lore         |"
       "| Sovereign    | Balinor           | Horn, Hunt        |"
       "| Sovereign    | Boldrei           | Hall, Hearth      |"
       "| Sovereign    | Dol Arrah         | Sun, Sacrifice    |"
       "| Sovereign    | Dol Dorn          | Strength, Steel   |"
       "| Sovereign    | Kol Korran        | World, Wealth     |"
       "| Sovereign    | Olladra           | Feast, Fortune    |"
       "| Sovereign    | Onatar            | Fire, Forge       |"
       "| Silver Flame | Silver Flame, the | Goodness, Law     |"
       "| Dark Six     | Devourer, the     | Wave, Whelm       |"
       "| Dark Six     | Fury, the         | Rage, Ruin        |"
       "| Dark Six     | Keeper, the       | Death, Decay      |"
       "| Dark Six     | Mockery, the      | Betray, Bloodshed |"
       "| Dark Six     | Shadow, the       | Magic, Mayhem     |"
       "| Dark Six     | Traveler, the     | Chaos, Change     |")))

  (transient-define-prefix jf/menu--eberron ()
    "Define the Eberron help prefix."
    ["Eberron"
     ("d" jf/eberron-qh-dragonmarks)
     ("p" jf/eberron-qh-planes)
     ("r" jf/eberron-qh-religion)

      ])
  (provide 'jf-gaming)
  ;;; jf-gaming.el ends here
#+end_src
** =jf-illuminating.el=
#+begin_src emacs-lisp :tangle "jf-illuminating.el" :results none
  ;;; jf-illuminating.el --- Packages and functions that "illuminate" the current state -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.

  ;;; Commentary:

  ;; Within this package are tools for highlighting and illuminating the current
  ;; moment.

  ;;; Code:
  (use-package expand-region
    ;; A simple package that does two related things really well; expands and
    ;; contracts the current region.  I use this all the time.
    ;;
    ;; In writing, with the cursor at point, when I expand it selects the word.
    ;; The next expand the sentence, then paragraph, then page.  In programming it
    ;; leverages sexp.
    :straight (:host github :repo "jeremyf/expand-region.el")
    :bind (("C-=" . er/expand-region)
            ("C-+" . er/contract-region)))

  ;; I thought I might use this but I never practiced.  Holding it as a reminder.
  ;; Learning about this, may be curious about https://tony-zorman.com/posts/change-inner.html
  ;; (use-package change-inner
  ;;   :straight t
  ;;   :bind (;; Note the symmetry between 'change-inner binding and er/expand-region
  ;;           ("C-c C-=" . 'change-inner)
  ;;           ;; Below is an alternate consideration; namely if I want inner/outer
  ;;           ;; behavior
  ;;           ;; ("C-c TAB" . 'change-inner)
  ;;           ;; ("C-c C-o" . 'change-outer)
  ;;           ))


  (use-package display-fill-column-indicator
    ;; It's nice to have a gentle reminder showing me the recommended column width
    ;; for the current buffer.
    :straight (:type built-in)
    :hook (prog-mode . display-fill-column-indicator-mode))

  (use-package kind-icon
    ;; This packages helps provide additional icons for functions and variables in
    ;; the completion candidates.
    :straight t
    :after corfu
    :custom
    (kind-icon-use-icons t)
    (kind-icon-default-face 'corfu-default) ; Have background color be the same as
                                          ; `corfu' face background
    (kind-icon-blend-background nil)  ; Use midpoint color between foreground and
                                          ; background colors ("blended")?
    (kind-icon-blend-frac 0.08)
    ;; directory that defaults to the `user-emacs-directory'. Here, I change that
    ;; directory to a location appropriate to `no-littering' conventions, a
    ;; package which moves directories of other packages to sane locations.
    ;; (svg-lib-icons-dir (no-littering-expand-var-file-name "svg-lib/cache/")) ;
    ;; Change cache dir
    :config
                                          ; Enable `kind-icon'
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)
    ;; Add hook to reset cache so the icon colors match my theme
    ;; NOTE 2022-02-05: This is a hook which resets the cache whenever I switch
    ;; the theme using my custom defined command for switching themes. If I don't
    ;; do this, then the backgound color will remain the same, meaning it will not
    ;; match the background color corresponding to the current theme. Important
    ;; since I have a light theme and dark theme I switch between. This has no
    ;; function unless you use something similar
    (add-hook 'kb/themes-hooks
      #'(lambda () (interactive) (kind-icon-reset-cache))))

  (use-package lin
    ;;  ‚ÄúLIN locally remaps the hl-line face to a style that is optimal for major
    ;;  modes where line selection is the primary mode of interaction.‚Äù  In
    ;;  otherwords, ~lin.el~ improves the highlighted line behavior for the
    ;;  competing contexts.
    :straight (lin :host gitlab :repo "protesilaos/lin")
    :init (global-hl-line-mode)
    :config (lin-global-mode 1)
    (setq lin-face 'lin-blue))

  (use-package pulsar
    ;; A little bit of visual feedback.  See
    ;; https://protesilaos.com/codelog/2022-03-14-emacs-pulsar-demo/
    :straight (pulsar :host gitlab :repo "protesilaos/pulsar")
    :hook
    (consult-after-jump . pulsar-recenter-top)
    (consult-after-jump . pulsar-reveal-entry)
    ;; integration with the built-in `imenu':
    (imenu-after-jump . pulsar-recenter-top)
    (imenu-after-jump . pulsar-reveal-entry)
    :config
    (pulsar-global-mode 1)
    (setq pulsar-face 'pulsar-magenta
      pulsar-delay 0.05)
    (setq ring-bell-function 'jf/pulse)
    :preface
    (defun jf/pulse (&optional parg)
      "Pulse the current line.

    If PARG (given as universal prefix), pulse between `point' and `mark'."
      (interactive "P")
      (if (car parg)
        (pulsar--pulse nil nil (point) (mark))
        (pulsar-pulse-line)))
    :bind (("C-c C-l" . jf/pulse)))

  (use-package rainbow-mode
    ;; When I toggle on Rainbow mode, it colorizes the text that is color names
    ;; and hex declarations (e.g. "#0000ff" ).  Most useful when working with CSS,
    ;; but sometimes non-CSS files have those declarations as well.
    :straight t)

  (use-package rainbow-delimiters
    ;; A quick and useful visual queue for paranthesis.
    :straight t
    :hook ((prog-mode) . rainbow-delimiters-mode))

  (use-package recursion-indicator
    ;; I vascilate between yes and no; but invariably find myself stuck in a
    ;; recursed buffer.
    :straight t
    :config
    (setq enable-recursive-minibuffers t)
    (recursion-indicator-mode))

  (use-package vi-tilde-fringe
    ;; Show tilde (e.g. ~\~~) on empty trailing lines.  This is a feature ported
    ;; from https://en.wikipedia.org/wiki/Vi
    :straight t
    :config (global-vi-tilde-fringe-mode))

  (use-package whole-line-or-region
    ;; From the package commentary, ‚ÄúThis minor mode allows functions to operate
    ;; on the current line if they would normally operate on a region and region
    ;; is currently undefined.‚Äù  I‚Äôve used this for awhile and believe it‚Äôs not
    ;; baked into my assumptions regarding how I navigate Emacs.
    :straight t
    :config (whole-line-or-region-global-mode))

  ;; Since writing the comment about folding, I haven't used it.
  ;; (use-package yafolding
  ;;   ;; It can be helpful to fold regions; I don't do it much but it can be
  ;;   ;; helpful.
  ;;   :straight t)

  (use-package keycast
    ;; When I turn on `keycast-mode-line' each key press will echo in the
    ;; mode-line.  There are other options for logging which could be conceptually
    ;; useful for feeding a macro.
    :straight t)

  (provide 'jf-illuminating)
  ;;; jf-illuminating.el ends here
#+end_src
** =jf-keybindings.el=
#+begin_src emacs-lisp :tangle "jf-keybindings.el" :results none
  ;;; jf-keybindings --- These are the keys that bind -*- lexical-binding: t -*-

  ;; Copyright (C) 2023 Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;; I'm experimenting with `general'; and as such feel that I want to start from
  ;; a clean "package" and build up from there.  That means going into my existing
  ;; bindings and migrating them...if I like this pathway.
  ;;
  ;;

  ;;; Code:

  ;; emacs.d/jf-versioning.el:102:  :bind (("C-c m" . magit-status)
  ;; emacs.d/jf-versioning.el:107:  :bind (:map magit-log-mode-map ("C-x g b" . 'jf/magit-browse-pull-request))
  ;; emacs.d/jf-versioning.el:133:  :bind ("C-x g =" . git-gutter:popup-hunk)
  ;; emacs.d/jf-versioning.el:172:  :bind (:map git-messenger-map (("p" . 'jf/open-pull-request-for-current-line)
  ;; emacs.d/jf-versioning.el:174:  :bind (("s-6" . jf/git-messenger-popup)
  ;; emacs.d/jf-versioning.el:206:  :bind (("C-z" . undo)
  ;; emacs.d/jf-writing.el:47:  :bind ("C-c C-'" . sdcv-search))
  ;; emacs.d/jf-writing.el:71:  :bind ("M-q" . unfill-toggle)
  ;; emacs.d/jf-writing.el:82:  :bind (([C-s-down] . move-text-down)
  ;; emacs.d/jf-writing.el:95:  :bind (("C-M-SPC" . set-rectangular-region-anchor)
  ;; emacs.d/jf-completing.el:27:  :bind ("C-M-i" . completion-at-point)
  ;; emacs.d/jf-completing.el:80:  :bind (;; C-c bindings (mode-specific-map)
  ;; emacs.d/jf-completing.el:249:  :bind (("C-x C-d" . consult-dir)
  ;; emacs.d/jf-completing.el:281:  :bind (:map corfu-map
  ;; emacs.d/jf-completing.el:339:  :bind (("C-c p d" . cape-dabbrev)
  ;; emacs.d/jf-completing.el:363:  :bind (("C-c g" . grab-mac-link)))
  ;; emacs.d/jf-completing.el:392:  :bind ("H-h" . jf/helpful-menu)
  ;; emacs.d/jf-completing.el:415:  :bind (("M-SPC" . hippie-expand))
  ;; emacs.d/jf-completing.el:514:  :bind (:map org-mode-map (("C-c g" . org-mac-grab-link))))
  ;; emacs.d/jf-completing.el:524:  :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
  ;; emacs.d/jf-completing.el:526:  :bind (:map tempel-map (([backtab] . tempel-previous)
  ;; emacs.d/jf-denote.el:77:  :bind ("H-l" . 'jf/denote/link-or-create)
  ;; emacs.d/jf-reading.el:13:  :bind (:map doc-view-mode-map
  ;; emacs.d/jf-reading.el:29:  :bind ((:map elfeed-search-mode-map
  ;; emacs.d/jf-reading.el:139:  :bind (:map eww-mode-map ("U" . eww-up-url))
  ;; emacs.d/jf-reading.el:140:  :bind (("C-s-w" . browse-url-at-point))
  ;; emacs.d/jf-illuminating.el:22:  :bind (("C-=" . er/expand-region)
  ;; emacs.d/jf-illuminating.el:103:  :bind (("C-c C-l" . jf/pulse)))
  ;; emacs.d/jf-illuminating.el:153:;;   :bind (:map symbol-overlay-mode-map
  ;; emacs.d/jf-utility.el:85:  :bind (:map deadgrep-mode-map
  ;; emacs.d/jf-utility.el:111:  :bind (:map wgrep-mode-map
  ;; emacs.d/jf-utility.el:129:  :bind (("C-a" . crux-move-beginning-of-line)
  ;; emacs.d/jf-utility.el:139:  :bind ("C-c =" . math-at-point))
  ;; emacs.d/jf-coding.el:263:;;   :bind (("C-c C-e" . emmet-expand-yas ))
  ;; emacs.d/jf-coding.el:347:  :bind (:map rspec-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
  ;; emacs.d/jf-coding.el:348:  :bind (:map ruby-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
  ;; emacs.d/jf-menus.el:71:  :bind ("C-x f" . file-info-show)
  ;; emacs.d/jf-organizing.el:23:  :bind ("s-." . projectile-toggle-between-implementation-and-test))
  ;; emacs.d/jf-org-mode.el:60:  :bind ("C-c C-j" . jf/project/jump-to-task)
  ;; emacs.d/jf-org-mode.el:61:  :bind (:map org-mode-map (("C-c C-j" . jf/project/jump-to-task)
  ;; emacs.d/jf-org-mode.el:234:  :bind (:map org-mode-map
  ;; emacs.d/jf-org-mode.el:237:  :bind (("C-c l s" . org-store-link)
  ;; emacs.d/jf-org-mode.el:720:  :bind ("C-M-s-c" . jf/formatted-copy-org-to-html)
  ;; emacs.d/jf-navigating.el:16:  :bind (("C-x o" . ace-window)
  ;; emacs.d/jf-navigating.el:22:  :bind (("C-j" . avy-goto-char-timer))
  ;; emacs.d/jf-navigating.el:42:  :bind ("s-4" . 'imenu-list-smart-toggle)
  ;; emacs.d/jf-navigating.el:43:  :bind (:map imenu-list-major-mode-map ("o" . 'imenu-list-goto-entry))
  ;; emacs.d/jf-windows.el:218:;;   :bind (:map bufler-list-mode-map
  ;; emacs.d/jf-windows.el:221:;;   :bind (("s-3" . bufler-switch-buffer)


  (use-package general
    :straight t
    :config
    (general-define-key
      :prefix "C-c C-o"
      "a" 'org-agenda
      "c" 'org-capture))



  (provide 'jf-keybindings)
  ;;; jf-keybindings.el ends here
#+end_src
** =jf-launching.el=
#+begin_src emacs-lisp :tangle "jf-launching.el" :results none
  ;;; jf-launching.el --- For launching Emacs -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:


  ;; BEGIN Core Configuration
  ;; I have chosen to adopt \"straight.el\" for my package management.  The fact
  ;; that it seamlessly works with `use-package' has help me keep my code more
  ;; organized.

  ;;; Code:
  ;;
  ;; https://www.reddit.com/r/emacs/comments/mtb05k/emacs_init_time_decreased_65_after_i_realized_the/
  (setq straight-check-for-modifications '(check-on-save find-when-checking))

  ;; This preamble is part of straight-use-package My understanding, in
  ;; reading straight documentation is that it has better load
  ;; times. However, the configuration options I often see leverage
  ;; "use-package" which is why most of my package declarations look as
  ;; they do.
  (defvar bootstrap-version)
  (defvar bootstrap-version)
  (let ((bootstrap-file
          (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
         (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
        (url-retrieve-synchronously
          "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
          'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (setq straight-repository-branch "develop")
  (straight-use-package 'use-package)

  (use-package exec-path-from-shell
    ;; https://xenodium.com/trying-out-gccemacs-on-macos/
    :straight t
    :config
    (exec-path-from-shell-initialize)
    (if (and (fboundp 'native-comp-available-p)
          (native-comp-available-p))
      (progn
        (message "Native comp is available")
        ;; Using Emacs.app/Contents/MacOS/bin since it was compiled with
        ;; ./configure --prefix="$PWD/nextstep/Emacs.app/Contents/MacOS"
        (add-to-list 'exec-path (concat invocation-directory "bin") t)
        (setenv "LIBRARY_PATH" (concat (getenv "LIBRARY_PATH")
                                 (when (getenv "LIBRARY_PATH")
                                   ":")
                                 ;; This is where Homebrew puts gcc libraries.
                                 (car (file-expand-wildcards
                                        "/opt/homebrew/lib/gcc/*"))))
        ;; Only set after LIBRARY_PATH can find gcc libraries.
        (setq comp-deferred-compilation t))
      (message "Native comp is *not* available")))

  ;; These are some general configurations that I‚Äôve slowly accumulated.  There‚Äôs
  ;; inline documentation in most cases.  There might be little bits worth
  ;; teasing out but for the most part, you can move along and reference this
  ;; later.

  (setq user-full-name "Jeremy Friesen"
    user-mail-address "jeremy@jeremyfriesen.com")
  (defconst jf/github-username "jeremyf"
    "My username on github.")

  (defconst jf/silence-loading-log t
    "When t log to stdout load messages from this configuration.

       In a previous iteration, I loaded lots of separate '*.el' files.
       This flag allowed me to more easily troubleshoot those load
       attempts.")

  (make-directory "~/.emacs.d/autosaves/" t) ;; Ensuring I have an autosave
  ;; directory.
  (recentf-mode 1) ;; Track recent
  (run-at-time nil (* 2 60) 'recentf-save-list) ;; Save files every 2 minutes
  (global-auto-revert-mode)

  (setq-default fill-column 80)
  (setq-default cursor-type 'bar) ;; Doing a bit of configuration of my cursors
  (blink-cursor-mode t)

  (when (executable-find "rg")
    (setq grep-program "rg"))

  (setq
    backup-by-copying t         ;; Don't delink hardlinks

    backup-directory-alist '((".*" . "~/.emacs.d/backups/"))

    bookmark-default-file "~/git/emacs-bookmarks/bookmarks.el"
    bookmark-save-flag 1

    custom-safe-themes t        ;; I may as well trust themes.

    create-lockfiles nil        ;; Don't create lock files.

    delete-old-versions t       ;; Automatically delete excess backups
    dired-dwim-target t ;; https://www.reddit.com/r/emacs/comments/102y0n4/weekly_tips_tricks_c_thread/

    echo-key-strokes 0.2

    global-mark-ring-max 32

    help-window-select t

    idle-update-delay 1.1       ;; Slow down the UI being updated to improve
    ;; performance

    indent-tabs-mode nil        ;; Ensure tabs are expanded, not inserted

    inhibit-startup-screen t    ;; Don't include the  emacs "start" window

    kept-new-versions 20        ;; how many of the newest versions to keep

    kept-old-versions 5         ;; and how many of the old

    kill-ring-max 120           ;; Set a generous kill ring size.

    load-prefer-newer t ;; Favor new bit code

    read-process-output-max (* 6 512 1024)  ;; Increase read size per process

    recentf-max-menu-items 50

    recentf-max-saved-items 50

    require-final-newline t

    show-trailing-whitespace t

    switch-to-buffer-obey-display-actions t ;; https://www.masteringemacs.org/article/demystifying-emacs-window-manager

    ;; split-width-threshold nil ;; 160 * 8

    ;; https://github.com/maryrosecook/emacs/blob/6ef574e27f33f08a81b26970b5fb9b4c9c1f9eff/init.el#L745
    split-height-threshold 99999999999999999 ;; make emacs only add vertical split panes

    vc-follow-symlinks t        ;; Follow symlinks instead of prompting.

    version-control t           ;; Use version numbers on backups

    x-underline-at-descent-line t ;; Recommendation from
    ;; https://protesilaos.com/emacs/modus-themes

    ns-right-command-modifier 'hyper ;; Exposing one additional modifier key.

    line-move-visual t)

  (bind-key "H-s" 'save-buffer)
  ;; With subword-mode, HelloWorld is two words for navigation.
  (global-subword-mode)


  ;; When you open Emacs, grab all the space on the screen
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))

  (tool-bar-mode -1) ;; Hide the icons of the Emacs toolbar
  (scroll-bar-mode -1) ;; Hide the scroll bar. Let's be clear, I don't use it.
  (defalias 'yes-or-no-p 'y-or-n-p) ;; Always "y" or "n" for yes/no

  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

  (add-function :after after-focus-change-function
    (defun jf/garbage-collect-maybe ()
      (unless (frame-focus-state)
        (garbage-collect))))

  ;; And I‚Äôm going to disable a few key bindings.  These were always messing me
  ;; up a bit.  Also enable a few that I find helpful.  (I‚Äôll enable a lot more
  ;; later).
  (unbind-key "C-z") ;; `suspend-frame'
  (unbind-key "C-c o") ;; was bound to open a file externally
  (unbind-key "C-x C-c") ;; was `save-buffers-kill-terminal'

  (global-set-key (kbd "<M-delete>") 'kill-word)
  (global-set-key (kbd "<s-down>") 'end-of-buffer)
  (global-set-key (kbd "<s-up>") 'beginning-of-buffer)
  (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
  (global-set-key (kbd "s-w") 'kill-current-buffer)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "M-RET") 'newline-and-indent)

  (use-package minions
    :straight t
    :custom (minions-prominent-modes '(flymake-mode))
    :config (minions-mode 1))

  (use-package gcmh
    ;; *Gcmh* does garbage collection (GC) when the user is idle.
    :straight t
    :init
    (setq gcmh-idle-delay 5
      gcmh-high-cons-threshold (* 16 1024 1024))  ; 16mb
    :config (gcmh-mode))

  ;;; Connective Tissue and oddity functions:
  (defvar server-visit-files-custom-find:buffer-count
    "A counter for assisting with opening multiple files via a single
      client call.")

  (defadvice server-visit-files
    (around server-visit-files-custom-find
      activate compile)
    "Maintain a counter of visited files from a single client call."
    (let ((server-visit-files-custom-find:buffer-count 0))
      ad-do-it))
  (defun server-visit-hook-custom-find ()
    "Arrange to visit the files from a client call in separate windows."
    (if (zerop server-visit-files-custom-find:buffer-count)
      (progn
        (delete-other-windows)
        (switch-to-buffer (current-buffer)))
      (let ((buffer (current-buffer))
             (window (split-window-sensibly)))
        (switch-to-buffer buffer)
        (balance-windows)))
    (setq server-visit-files-custom-find:buffer-count
      (1+ server-visit-files-custom-find:buffer-count)))
  (add-hook 'server-visit-hook 'server-visit-hook-custom-find)


  (defconst jf/tor-home-directory
    (file-truename "~/git/takeonrules.source")
    "The home directory of TakeOnRules.com Hugo repository.")

  (defconst jf/tor-hostname-default-local
    "http://localhost:1313"
    "The scheme, host name, and port for serving up a local TakeOnRules.com.")

  (defconst jf/tor-hostname-default-remote
    "https://takeonrules.com"
    "The scheme and host name for TakeOnRules.com.")

  (defvar jf/tor-hostname-current
    jf/tor-hostname-default-local
    "What is the current hostname for serving TakeOnRules content.")

  ;; https://www.reddit.com/r/emacs/comments/112t0uo/comment/ja41lso/?utm_source=share&utm_medium=web2x&context=3
  (require 'info)
  (info-initialize)
  (push "/opt/homebrew/share/info" Info-directory-list)

  (provide 'jf-launching)
  ;;; jf-launching.el ends here
#+end_src
** =jf-make-mark-visible.el=
#+begin_src emacs-lisp :tangle "jf-make-mark-visible.el" :results none
  ;;;; Make the mark visible, and the visibility toggleable. ('mmv' means 'make
  ;;;; mark visible'.) By Patrick Gundlach, Teemu Leisti, and Stefan.

  (defface jf/make-mark-visible/face
    '((t :background "maroon2" :foreground "white"))
    "Face used for showing the mark's position.")

  (defvar-local jf/make-mark-visible/mark-overlay nil
    "The overlay for showing the mark's position.")

  (defvar-local jf/make-mark-visible/is-mark-visible t
    "The overlay is visible only when this variable's value is t.")

  (defun jf/make-mark-visible/draw-mark (&rest _)
    "Make the mark's position stand out by means of a one-character-long overlay.
     If the value of variable `jf/make-mark-visible/is-mark-visible' is nil, the mark will be
     invisible."
    (unless jf/make-mark-visible/mark-overlay
      (setq jf/make-mark-visible/mark-overlay (make-overlay 0 0 nil t))
      (overlay-put jf/make-mark-visible/mark-overlay 'face 'jf/make-mark-visible/face))
    (let ((mark-position (mark t)))
      (cond
       ((null mark-position) (delete-overlay jf/make-mark-visible/mark-overlay))
       ((and (< mark-position (point-max))
             (not (eq ?\n (char-after mark-position))))
        (overlay-put jf/make-mark-visible/mark-overlay 'after-string nil)
        (move-overlay jf/make-mark-visible/mark-overlay mark-position (1+ mark-position)))
       (t
        ; This branch is called when the mark is at the end of a line or at the
        ; end of the buffer. We use a bit of trickery to avoid the higlight
        ; extending from the mark all the way to the right end of the frame.
        (overlay-put jf/make-mark-visible/mark-overlay 'after-string
                     (propertize " " 'face (overlay-get jf/make-mark-visible/mark-overlay 'face)))
        (move-overlay jf/make-mark-visible/mark-overlay mark-position mark-position)))))

  (add-hook 'pre-redisplay-functions #'jf/make-mark-visible/draw-mark)

  (defun jf/make-mark-visible/toggle-mark-visibility ()
    "Toggles the mark's visiblity and redraws it (whether invisible or visible)."
    (interactive)
    (setq jf/make-mark-visible/is-mark-visible (not jf/make-mark-visible/is-mark-visible))
    (if jf/make-mark-visible/is-mark-visible
        (set-face-attribute 'jf/make-mark-visible/face nil :background "maroon2" :foreground "white")
      (set-face-attribute 'jf/make-mark-visible/face nil :background 'unspecified :foreground 'unspecified))
    (jf/make-mark-visible/draw-mark))

  (global-set-key (kbd "C-c v") 'jf/make-mark-visible/toggle-mark-visibility)
#+end_src
** =jf-menus.el=
#+begin_src emacs-lisp :tangle "jf-menus.el" :results none
  ;;; jf-menus --- A container for my Emacs menus -*- lexical-binding: t -*-

  ;; Copyright (C) 2022 Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary

  ;;; Code

  (bind-key "M-[" #'backward-paragraph)
  (bind-key "s-[" #'backward-paragraph)
  (bind-key "M-]" #'forward-paragraph)
  (bind-key "s-]" #'forward-paragraph)

  (transient-define-suffix jf/jump-to/violet-board ()
    "Jump to üíú Violet üíú"
    :description "Jump to Violet"
    (interactive)
    (require 'eww)
    (eww-browse-with-external-browser "https://github.com/orgs/scientist-softserv/projects/43"))
  (bind-key "C-c l v" #'jf/jump-to/violet-board)

  (transient-define-suffix jf/jump-to/agenda-personal ()
    "Jump to personal agenda"
    :description "Agenda, Personal"
    (interactive)
    (find-file "~/git/org/agenda.org"))

  (transient-define-suffix jf/shr/toggle-images ()
    "Toggle showing or hiding images"
    :description (lambda ()
                                     (format "Show SHR Images (%s)"
                     (if shr-inhibit-images " " "*")))
    (interactive)
    (setq shr-inhibit-images (not shr-inhibit-images)))

  (transient-define-suffix jf/jump-to/code-backlog ()
    "Jump to coding backlog"
    :description "Capture Backlog"
    (interactive)
    (find-file jf/org-mode/capture/filename))

  ;; (transient-define-suffix jf/capture-region-to-clock (b e p)
  ;;   "Capture region to clock‚Ä¶"
  ;;   :description "Capture region to clock‚Ä¶"
  ;;   (interactive "r\nP")
  ;;   (jf/org-mode/capture/insert-content-dwim b e p))

  (transient-define-suffix jf/org-mode/add-abstract (abstract)
    "Add ABSTRACT to `org-mode'"
    :description "Add Abstract‚Ä¶"
    (interactive (list (read-string "Abstract: ")))
    (when (jf/org-mode/blog-entry?)
      (save-excursion
        (goto-char (point-min))
        (re-search-forward "^$")
        (insert "\n#+HUGO_CUSTOM_FRONT_MATTER: :abstract " abstract))))

  (transient-define-suffix jf/org-mode/add-series (series)
    "Add SERIES to `org-mode'"
    :description "Add Series‚Ä¶"
    (interactive (list (completing-read "Series: " (jf/tor-series-list))))
    (when (jf/org-mode/blog-entry?)
      (save-excursion
        (goto-char (point-min))
        (re-search-forward "^$")
        (insert "\n#+HUGO_CUSTOM_FRONT_MATTER: :series " series))))

  (transient-define-suffix jf/org-mode/add-session-report (date game location)
    "Add session report metadata (DATE, GAME, and LOCATION) to current buffer."
    :description "Add Session‚Ä¶"
    (interactive (list
                   (org-read-date nil nil nil "Session Date")
                   (completing-read "Game: " (jf/tor-game-list))
                   (completing-read "Location: " jf/tor-session-report-location)))
    (when (jf/org-mode/blog-entry?)
      (save-excursion
        (goto-char (point-min))
        (re-search-forward "^$")
        (insert "\n#+HUGO_CUSTOM_FRONT_MATTER: :sessionReport "
                "'((date . \"" date "\") (game . \"" game "\") "
                "(location . \"" location "\"))"))))

  (defun jf/org-mode/blog-entry? (&optional buffer)
    (when-let* ((buffer (or buffer (current-buffer)))
                 (file (buffer-file-name buffer)))
      (and (denote-file-is-note-p file)
        (string-match-p "\\/blog-posts\\/" file))))

  (transient-define-suffix jf/enable-indent-for-tab-command ()
    :description "Enable `indent-for-tab-command'"
    (interactive)
    (global-set-key (kbd "TAB") #'indent-for-tab-command))

  ;; this suffix provides a dynamic description of the current host I want to use
  ;; for my blog.  And the prefix‚Äôs function toggles the host.
  (global-set-key (kbd "s-1") 'jf/menu)
  (transient-define-prefix jf/menu ()
    "A context specific \"mega\" menu."
    ;; Todo, can I get this section into a function so I can duplicate it in the jf/menu--tor?
    [["Jump to"
       ("j a" "Agenda" jf/project/jump-to-task)
       ("j A" jf/jump-to/agenda-personal)
       ("j c" "Capture Backlog" jf/jump-to/code-backlog)
       ("j g" "Global Mark" consult-global-mark)
       ("j h" "Hugo File" jf/jump_to_corresponding_hugo_file :if-derived org-mode)
       ("j m" "Mark" consult-mark)
       ;; ("j p" "Jump in Pull requests" jf/org-mode/open-all-unresolved-pull-requests)
       ("j r" "Jump to Git Related" consult-git-related-find-file)
       ("j l" "Jump to Magit Project Lists" magit-list-repositories)
       ;; ("j s" "Jump to Shortdoc" shortdoc-display-group)
       ("j v" jf/jump-to/violet-board)]
      ["Tasks"
        ("i" "Clock in‚Ä¶" consult-clock-in)
        ("r" "Run command‚Ä¶" run-command)
        ("s" "Search note content‚Ä¶" consult-notes-search-in-all-notes)
        ("S" "Search note filename‚Ä¶" consult-notes)
        ("C-t" "Start a timer‚Ä¶" tmr-with-description)
        ("C-M-s-t" "Archive month as timesheet‚Ä¶" jf/denote/archive-timesheet-month)
        ("t" "Todo for project‚Ä¶" magit-todos-list)
        ("u" jf/org-mode/agenda-files-update)
        ("w" "Weekly hours report" jf/org-mode-weekly-report)]
      ["Denote"
        ("d a" jf/project/add-project-path :if jf/denote?)
        ("d c" jf/denote-org-capture/filename-set)
        ("d p" jf/project/convert-document-to-project :if jf/denote?)
        ]
      ["Blogging"
        ("b a" jf/org-mode/add-abstract :if jf/org-mode/blog-entry?)
        ("b r" jf/org-mode/add-session-report :if jf/org-mode/blog-entry?)
        ("b s" jf/org-mode/add-series :if jf/org-mode/blog-entry?)
        ("b x" "Export to TakeOnRules‚Ä¶" jf/export-org-to-tor :if jf/org-mode/blog-entry?)]]
    [["Modes"
       ;; I could write functions for these, but this is concise enough
       ("m h" jf/hammerspoon-toggle-mode  :if-non-nil hammerspoon-edit-minor-mode)
       ("m t" "Typopunct ( )" typopunct-mode :if-nil typopunct-mode)
       ("m t" "Typopunct (*)" typopunct-mode :if-non-nil typopunct-mode)
       ("m o" "MacOS Native Option ( )" jf/toggle-osx-alternate-modifier :if-non-nil ns-alternate-modifier)
       ("m o" "MacOS Native Option (*)" jf/toggle-osx-alternate-modifier :if-nil ns-alternate-modifier)
       ("m i" jf/shr/toggle-images)
       ("TAB" jf/enable-indent-for-tab-command)
       ]
      ["Grab Refs"
        ("g e" "Elfeed" jf/capture/denote/from/elfeed-show-entry :if-derived elfeed-show-mode)
        ("g f" "Firefox" jf/menu--org-capture-firefox)
        ("g s" "Safari" jf/menu--org-capture-safari)
        ("g w" "Eww" jf/capture/denote/from/eww-data :if-derived eww-mode)
        ]])

  ;; (use-package file-info
  ;;   ;; Show the metadata of the current buffer's file; and then copy those values.
  ;;   ;; The package also appears highly extensible.
  ;;   :straight (:host github :repo "artawower/file-info.el")
  ;;   :bind ("C-x f" . file-info-show)
  ;;   :config
  ;;   (setq hydra-hint-display-type 'posframe)
  ;;   (setq hydra-posframe-show-params `(:poshandler posframe-poshandler-frame-center
  ;; 						 :internal-border-width 2
  ;; 						 :internal-border-color "#61AFEF"
  ;; 						 :left-fringe 16
  ;; 						 :right-fringe 16)))

  (provide 'jf-menus)
  ;;; jf-menus.el ends here
#+end_src
** =jf-minor-mode-maker.el=
#+begin_src emacs-lisp :tangle "jf-minor-mode-maker.el" :results none
  ;;; jf-minor-mode-maker.el --- Simple focus mode and extras -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.

  ;;; Commentary:

  ;; Provides a macro for personal minor mode declaration.  Why the macro?  As a
  ;; matter of practice and documentation.  I also want to get better at writing.

  ;;; Code:
  (require 'cl-macs)
  (cl-defmacro jf/minor-mode-maker (&key title abbr hooks keymap)
      "A macro to declare a minor mode.

    Use TITLE to derive the docstring.
    Use ABBR to derive the mode-name lighter.
    Add hook to each HOOKS provided.
  And assign a KEYMAP."
      (let ((mode-name (intern (s-downcase (concat "jf/" abbr "-minor-mode"))))
            (lighter (concat " " abbr))
            (docstring (concat "Minor mode for " title ".")))
        `(progn
           (define-minor-mode ,mode-name
             ,docstring
             :init-value nil
             :global nil
             :keymap ,keymap
             :lighter ,lighter)
           (when ,hooks
             (-each ,hooks (lambda(hook) (add-hook hook (lambda () (,mode-name)))))))))

  (provide 'jf-minor-mode-maker)
  ;;; jf-minor-mode-maker.el ends here
#+end_src
** =jf-navigating.el=
#+begin_src emacs-lisp :tangle "jf-navigating.el" :results none
  ;;; jf-navigating.el --- Simple focus mode and extras -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;;; Code:

  ;;;; Packages
  (use-package ace-window
    ;; Quick navigation from window to window.
    :straight t
    :custom (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    :bind (("C-x o" . ace-window)
     ("M-o" . ace-window)))

  (use-package avy
    ;; Pick a letter, avy finds all words with that at the beginning of it.  Narrow
    ;; results from there.
    :bind (("C-j" . avy-goto-char-timer))
    :straight t)

  (use-package browse-at-remote
    ;; Because I sometimes want to jump to the source code.  And in looking at
    ;; this I learned about vc-annotate; a better blame than what I've had before.
    ;; `bar-browse' is faster than `browse-at-remote'.
    :straight t
    :bind
    ;; Note this is in the same prefix space as `link-hint'
    ("C-c l r" . browse-at-remote)
    ("C-c l a" . vc-annotate)
    ("C-c l n" . jf/project/jump-to/notes)
    ("C-c l t" . git-timemachine))

  (use-package imenu-list
    ;; Show an outline summary of the current buffer.
    :custom (imenu-list-focus-after-activation t)
    (imenu-list-size 0.4)
    (imenu-list-position 'right)
    :bind ("s-4" . 'imenu-list-smart-toggle)
    :bind (:map imenu-list-major-mode-map ("o" . 'imenu-list-goto-entry))
    :straight t)

  (use-package link-hint
    ;; I use this more and more and more.  Invoking `link-hint-open-link'
    ;; highlights the visible URLs, providing quick keys to then open those URLs.
    ;; If there's only one candidate, the function opens that URL.
    :straight t
    :bind
    ;; Note this is in the same prefix space as `browse-at-remote'
    ("C-c l o" . jf/link-hint-open-link)
    ("C-c l c" . link-hint-copy-link)
    :preface
    (defun jf/link-hint-open-link (prefix)
      "Hint at then browse a URL.

  When given PREFIX use `eww-browse-url'."
      (interactive "P")
      (let ((browse-url-browser-function
              (if prefix #'eww-browse-url browse-url-browser-function)))
          (link-hint-open-link))))

  ;;;; Custom Functions
  ;; (defun jf/scroll-down-half-page ()
  ;;   "Scroll down half a page while keeping the cursor centered"
  ;;   ;; See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/
  ;;   (interactive)
  ;;   (let ((ln (line-number-at-pos (point)))
  ;;         (lmax (line-number-at-pos (point-max))))
  ;;     (cond ((= ln 1) (move-to-window-line nil))
  ;;           ((= ln lmax) (recenter (window-end)))
  ;;           (t (progn
  ;;                (move-to-window-line -1)
  ;;                (recenter))))))

  ;; (defun jf/scroll-up-half-page ()
  ;;   "Scroll up half a page while keeping the cursor centered"
  ;;   ;; See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/
  ;;   (interactive)
  ;;   (let ((ln (line-number-at-pos (point)))
  ;;         (lmax (line-number-at-pos (point-max))))
  ;;     (cond ((= ln 1) nil)
  ;;           ((= ln lmax) (move-to-window-line nil))
  ;;           (t (progn
  ;;                (move-to-window-line 0)
  ;;                (recenter))))))


  ;; https://github.com/baron42bba/.emacs.d/blob/master/bba.org
  (defvar jf/bracket/brackets nil "String of left/right brackets pairs.")
  (setq jf/bracket/brackets "()[]{}<>ÔºàÔºâÔºªÔºΩÔΩõÔΩù‚¶Ö‚¶Ü„Äö„Äõ‚¶É‚¶Ñ‚Äú‚Äù‚Äò‚Äô‚Äπ‚Ä∫¬´¬ª„Äå„Äç„Äà„Äâ„Ää„Äã„Äê„Äë„Äî„Äï‚¶ó‚¶ò„Äé„Äè„Äñ„Äó„Äò„ÄôÔΩ¢ÔΩ£‚ü¶‚üß‚ü®‚ü©‚ü™‚ü´‚üÆ‚üØ‚ü¨‚ü≠‚åà‚åâ‚åä‚åã‚¶á‚¶à‚¶â‚¶ä‚ùõ‚ùú‚ùù‚ùû‚ù®‚ù©‚ù™‚ù´‚ù¥‚ùµ‚ù¨‚ù≠‚ùÆ‚ùØ‚ù∞‚ù±‚ù≤‚ù≥‚å©‚å™‚¶ë‚¶í‚ßº‚ßΩÔπôÔπöÔπõÔπúÔπùÔπû‚ÅΩ‚Åæ‚Çç‚Çé‚¶ã‚¶å‚¶ç‚¶é‚¶è‚¶ê‚ÅÖ‚ÅÜ‚∏¢‚∏£‚∏§‚∏•‚üÖ‚üÜ‚¶ì‚¶î‚¶ï‚¶ñ‚∏¶‚∏ß‚∏®‚∏©ÔΩüÔΩ†‚ßò‚ßô‚ßö‚ßõ‚∏ú‚∏ù‚∏å‚∏ç‚∏Ç‚∏É‚∏Ñ‚∏Ö‚∏â‚∏ä·öõ·öú‡º∫‡ºª‡ºº‡ºΩ‚èú‚èù‚é¥‚éµ‚èû‚èü‚è†‚è°ÔπÅÔπÇÔπÉÔπÑÔ∏πÔ∏∫Ô∏ªÔ∏ºÔ∏óÔ∏òÔ∏øÔπÄÔ∏ΩÔ∏æÔπáÔπàÔ∏∑Ô∏∏")

  (defvar jf/bracket/left-brackets '("(" "{" "[" "<" "„Äî" "„Äê" "„Äñ" "„Äà" "„Ää" "„Äå" "„Äé" "‚Äú" "‚Äò" "‚Äπ" "¬´" )
    "List of left bracket chars.")

  (progn
    ;; make jf/bracket/left-brackets based on jf/bracket/brackets
    (setq jf/bracket/left-brackets '())
    (dotimes (-x (- (length jf/bracket/brackets) 1))
      (when (= (% -x 2) 0)
              (push (char-to-string (elt jf/bracket/brackets -x))
          jf/bracket/left-brackets)))
    (setq jf/bracket/left-brackets (reverse jf/bracket/left-brackets)))

  (defvar jf/bracket/right-brackets '(")" "]" "}" ">" "„Äï" "„Äë" "„Äó" "„Äâ" "„Äã" "„Äç" "„Äè" "‚Äù" "‚Äô" "‚Ä∫" "¬ª")
    "List of right bracket chars.")
  (progn
    (setq jf/bracket/right-brackets '())
    (dotimes (-x (- (length jf/bracket/brackets) 1))
      (when (= (% -x 2) 1)
              (push (char-to-string (elt jf/bracket/brackets -x))
          jf/bracket/right-brackets)))
    (setq jf/bracket/right-brackets (reverse jf/bracket/right-brackets)))

  (defun jf/bracket/backward-left-bracket ()
    "Move cursor to the previous occurrence of left bracket.

  The list of brackets to jump to is defined by `jf/bracket/left-brackets'.
  URL `http://ergoemacs.org/emacs/emacs_navigating_keys_for_brackets.html'
  Version 2015-10-01"
    (interactive)
    (search-backward-regexp (regexp-opt jf/bracket/left-brackets) nil t))

  (defun jf/bracket/forward-right-bracket ()
    "Move cursor to the next occurrence of right bracket.

  The list of brackets to jump to is defined by `jf/bracket/right-brackets'.
  URL `http://ergoemacs.org/emacs/emacs_navigating_keys_for_brackets.html'
  Version 2015-10-01"
    (interactive)
    (re-search-forward (regexp-opt jf/bracket/right-brackets) nil t))

  (define-key global-map (kbd "C-c C-<left>") 'jf/bracket/backward-left-bracket)
  (define-key global-map (kbd "C-c C-<right>") 'jf/bracket/forward-right-bracket)

  (provide 'jf-navigating)
  ;;; jf-navigating.el ends here
#+end_src
** =jf-org-mode.el=
#+begin_src emacs-lisp :tangle "jf-org-mode.el" :results none
  ;;; jf-org-mode.el --- Org-Mode configuration -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;; Pre-amble to prepare for `org-mode'

  ;;; Code:
  (require 'cl-lib)

  ;; I maintain a list of data directories, each might have ‚Äúrelevant to
  ;; org-mode‚Äù files.  The `jf/org-mode/agenda-files' reads the file system to gather
  ;; sources for `org-mode' agenda.
  (defun jf/is-work-machine? ()
    "Am I working on my company machine machine."
    (string= (getenv "USER") "jeremy"))

  (defvar jf/org-mode/capture/filename
    "~/git/org/denote/melange/20230210T184422--example-code__programming.org"
    "The file where I'm capturing content.

  By default this is my example code project.")

  (defconst jf/agenda-filename/scientist
    "~/git/org/denote/scientist/20221021T221357--scientist-agenda__agenda_scientist.org")

  (defconst jf/agenda-filename/personal
    "~/git/org/agenda.org")

  (defvar jf/primary-agenda-filename-for-machine
    (if (jf/is-work-machine?)
      jf/agenda-filename/scientist
      jf/agenda-filename/personal))

  (defun jf/org-capf ()
    "The `completion-at-point-functions' I envision using for `org-mode'."
    (setq-local completion-at-point-functions
      (list (cape-capf-super
              #'jf/version-control/issue-capf
              #'jf/version-control/project-capf
              #'jf/org-capf-links
              #'tempel-expand
              #'cape-file))))

  ;; Cribbed from `org-roam' org-roam-complete-link-at-point
  (defun jf/org-capf-links ()
    "Complete links."
    (when (and (thing-at-point 'symbol)
            (not (org-in-src-block-p))
            (not (save-match-data (org-in-regexp org-link-any-re))))
      ;; We want the symbol so that links such performing completion on "org-mode"
      ;; will look for links with the text of org-mode and then replace the text
      ;; "org-mode" with the returned link.
      (let ((bounds (bounds-of-thing-at-point 'symbol)))
        (list (car bounds) (cdr bounds)
          ;; Call without parameters, getting a links (filtered by CAPF magic)
          (jf/org-links-with-text)
          :exit-function
          (lambda (text _status)
            ;; We want the properties of that link.  In the case of one match, the
            ;; provided text will have the 'link property.  However if the
            (let ((link (car (jf/org-links-with-text text))))
              (delete-char (- (length text)))
              (insert "[[" (get-text-property 0 'link link) "][" text "]]")))
          ;; Proceed with the next completion function if the returned titles
          ;; do not match. This allows the default Org capfs or custom capfs
          ;; of lower priority to run.
          :exclusive 'no))))

  (defun jf/org-links-with-text (&optional given-link)
    "Return the `distinct-' `org-mode' links in the `current-buffer'.

  Each element of the list will be a `propertize' string where the string value is
  the text of the link and the \"link\" property will be the :raw-link.

  When provided a GIVEN-LINK stop processing when we encounter the
  first matching link."
    (let ((links (org-element-map
                   (org-element-parse-buffer)
                   'link
                   (lambda (link)
                     (when-let* ((left (org-element-property :contents-begin link))
                                  (right (org-element-property :contents-end link)))
                     (let ((returning (propertize
                                        (buffer-substring-no-properties
                                          left
                                          right)
                                        'link (org-element-property :raw-link link))))
                         (if given-link
                           (when (string= given-link returning) returning)
                           returning))))
                   nil
                   given-link)))
      ;; Ensure that we have a distinct list.
      (if (listp links)
        (-distinct links)
        (list links))))

  ;;; Begin Org Mode (all it's glory)
  (use-package org
    :straight (org :type built-in)
    :hook
    (org-mode . (lambda ()
                  (jf/org-capf)
                  (turn-on-visual-line-mode)
                  (electric-pair-mode -1)))
    ;; Disable org-indent-mode; it's easy enough to enable.  The primary reason is
    ;; that it does not play nice with the multi-cursor package.  And I'd prefer
    ;; to have that work better by default.
    ;;
    ;; (org-mode . org-indent-mode)
    :bind ("C-c C-j" . jf/project/jump-to-task)
    ("C-c C-x C-j" . org-clock-goto)
    :bind (:map org-mode-map (("C-c C-j" . jf/project/jump-to-task)
                               ("C-x n t" . jf/org-mode/narrow-to-date)
                               ("C-j" . avy-goto-char-timer)))
    :custom (org-use-speed-commands t)
    (org-time-stamp-rounding-minutes '(0 15))
    (org-clock-rounding-minutes 15)
    (org-link-frame-setup '((vm . vm-visit-folder-other-frame)
                             (vm-imap . vm-visit-imap-folder-other-frame)
                             (gnus . org-gnus-no-new-news)
                             (file . find-file)
                             (wl . wl-other-frame)))
    :config
    (setq org-clock-persist 'history)
    (setq org-export-headline-levels 4)
    ;; When I would load the agenda, I'd invariably type "l" to list the entries.
    (setq org-agenda-start-with-log-mode t)
    (setq org-confirm-babel-evaluate #'jf/org-confirm-babel-evaluate
      org-fontify-quote-and-verse-blocks t
      ;; I'd prefer to use the executable, but that doe not appear to be the
      ;; implementation of org-babel.
      org-plantuml-jar-path (concat
                              (string-trim
                                (shell-command-to-string "brew-path plantuml"))
                              "/libexec/plantuml.jar")
      org-insert-heading-respect-content t
      org-catch-invisible-edits 'show-and-error
      org-use-fast-todo-selection 'expert
      org-log-into-drawer t
      org-imenu-depth 4
      org-hide-emphasis-markers t
      ;; turning off org-elements cache speeds up input latency
      ;; See https://www.reddit.com/r/emacs/comments/11ey9ft/weekly_tips_tricks_c_thread/
      org-element-use-cache nil
      org-export-with-sub-superscripts '{}
      org-pretty-entities t
      org-pretty-entities-include-sub-superscripts nil
      org-agenda-log-mode-items '(clock)
      org-directory (file-truename "~/git/org")
      ;; org-agenda-files (jf/org-mode/agenda-files)
      org-default-notes-file (concat
                               org-directory
                               "/captured-notes.org")
      org-log-done 'time
      org-todo-keywords '((type "TODO(t)"
                            "STARTED(s!)"
                            "|"
                            "WAITING(w@/!)"
                            "CANCELED(c@/!)"
                            "DONE(d!)")))

    (transient-define-suffix jf/denote-org-capture/filename-set ()
      "Work with `jf/denote-org-capture/filename'"
           :description '(lambda ()
                           (concat
                             "Denote Capture Filename: "
           (propertize (format "%s" (and denote-last-path
                                      (file-exists-p denote-last-path)
                                      (denote-retrieve-filename-title denote-last-path)))
             'face 'transient-argument)))
            (interactive)
      (if denote-last-path
        (setq denote-last-path nil)
        (let ((fname (buffer-file-name (current-buffer))))
          (setq denote-last-path (and (denote-file-is-note-p  fname) fname)))))

    (defun jf/denote-org-capture ()
      "An org-capture conformant function for capturing to a blog-post."
      (if denote-last-path
        denote-org-capture-specifiers
        (let ((denote-directory (f-join denote-directory "blog-posts")))
          (denote-org-capture))))

    (setq org-latex-default-class "jf/article")

    (org-babel-do-load-languages 'org-babel-load-languages
      (append org-babel-load-languages
        '((emacs-lisp . t)
           (shell . t)
           (plantuml . t)
           (ruby . t))))
    (add-to-list 'org-structure-template-alist '("m" . "marginnote"))
    (add-to-list 'org-structure-template-alist '("D" . "details"))
    (add-to-list 'org-structure-template-alist '("S" . "summary"))
    (add-to-list 'org-structure-template-alist '("U" . "update"))
    (add-to-list 'org-structure-template-alist '("i" . "inlinecomment"))
    :init
    (require 'ox)
    ;; I grabbed from the following LaTeX class from
    ;; https://www.reddit.com/r/emacs/comments/3zcr43/nooborgmode_custom_latexpdf_export_custom_style/.
    ;; I‚Äôm trash with LaTeX, but like the layout thusfar.
    (progn
    (setq org-latex-classes '())
    (add-to-list 'org-latex-classes
      '("jf/article"
         "\\documentclass[11pt,a4paper]{article}"
         ("\\section{%s}" . "\\section{%s}")
         ("\\subsection{%s}" . "\\subsection{%s}")
         ("\\subsubsection{%s}" . "\\subsubsection{%s}")
         ("\\paragraph{%s}" . "\\paragraph{%s}")
         ("\\subparagraph{%s}" . "\\subparagraph{%s}"))))

    ;; \\hypersetup{colorlinks=false,pdfborderstyle={/S/U/W 1},pdfborder=0 0 1}"
    ;; Make TAB act as if it were issued from the buffer of the languages's major
    ;; mode.
    :custom (org-src-tab-acts-natively t)
    (org-clock-clocktable-default-properties '(:maxlevel 5 :link t :tags t))
    :bind (:map org-mode-map
            ("C-c l u" . jf/org-mode/convert-link-type)
            ("C-c l i" . org-insert-link)
            ("M-g o" . consult-org-heading))
    :bind (("C-c l s" . org-store-link)
            ("C-c a" . org-agenda)
            ("C-c c" . org-capture)
            ("C-s-t" . org-toggle-link-display)))

  (with-eval-after-load 'org
    (org-clock-persistence-insinuate))

  (defun jf/org-confirm-babel-evaluate (lang body)
    "Regardless of LANG and BODY approve it."
    nil)

  ;;; Additional Functionality for Org Mode
  ;; Cribbed from https://xenodium.com/emacs-dwim-do-what-i-mean/
  (defun jf/org-insert-link-dwim (parg &rest args)
    "Like `org-insert-link' but with personal dwim preferences.

    With PARG, skip personal dwim preferences.  Pass ARGS."
    (interactive "P")
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
            (clipboard-url (when (string-match-p "^http" (current-kill 0))
                             (current-kill 0)))
            (region-content (when (region-active-p)
                              (buffer-substring-no-properties (region-beginning)
                                (region-end)))))
      (cond
        ((car parg)
          (call-interactively 'org-insert-link nil nil))
        ((and region-content clipboard-url (not point-in-link))
          (delete-region (region-beginning) (region-end))
          (insert (org-make-link-string clipboard-url region-content)))
        ((and clipboard-url (not point-in-link))
          (insert (org-make-link-string
                    clipboard-url
                    (read-string "Title: "
                      (with-current-buffer
                        (url-retrieve-synchronously clipboard-url)
                        (dom-text (car
                                    (dom-by-tag (libxml-parse-html-region
                                                  (point-min)
                                                  (point-max))
                                      'title))))))))
        (t
          (call-interactively 'org-insert-link)))))

  ;;; Org Mode time tracking and task tracking adjustments

  (defun jf/org-mode-agenda-project-prompt ()
    "Prompt for project based on existing projects in agenda file.

      Note: I tried this as interactive, but the capture templates
      insist that it should not be interactive."
    (completing-read
      "Project: "
      (sort
        (-distinct
          (org-map-entries
            (lambda ()
              (org-element-property :raw-value (org-element-at-point)))
            "+LEVEL=4+projects" 'agenda))
        #'string<)))

  ;; When I jump to a new task for the day, I want to position that task within
  ;; the prompted project.  Inspiration from
  ;; https://gist.github.com/webbj74/0ab881ed0ce61153a82e.
  (cl-defun jf/org-mode-agenda-find-project-node
    (&key
      (tag "projects")
      (project (jf/org-mode-agenda-project-prompt))
      ;; The `file+olp+datetree` directive creates a headline like ‚Äú2022-09-03 Saturday‚Äù.
      (within_headline (format-time-string "%Y-%m-%d %A")))
    "Position `point' at the end of the given PROJECT WITHIN_HEADLINE.

  And use the given TAG."
    ;; We need to be using the right agenda file.
    (with-current-buffer (find-file-noselect
                           jf/primary-agenda-filename-for-machine)
      (let ((existing-position (org-element-map
                                 (org-element-parse-buffer)
                                 'headline
                                 ;; Finds the end position of:
                                 ;; - a level 4 headline
                                 ;; - that is tagged as a :projects:
                                 ;; - is titled as the given project
                                 ;; - and is within the given headline
                                 (lambda (hl)
                                   (and (=(org-element-property :level hl) 4)
                                     ;; I can't use the :title attribute as it
                                     ;; is a more complicated structure; this
                                     ;; gets me the raw string.
                                     (string= project
                                       (plist-get (cadr hl) :raw-value))
                                     (member tag
                                       (org-element-property :tags hl))
                                     ;; The element must have an ancestor with
                                     ;; a headline of today
                                     (string= within_headline
                                       (plist-get
                                         ;; I want the raw title, no
                                         ;; styling nor tags
                                         (cadr
                                           (car
                                             (org-element-lineage hl)))
                                         :raw-value))
                                     (org-element-property :end hl)))
                                 nil t)))
        (if existing-position
          ;; Go to the existing position for this project
          (goto-char existing-position)
          (progn
            ;; Go to the end of the file and append the project to the end
            (goto-char (point-max))
            ;; Ensure we have a headline for the given day
            (unless (org-element-map
                      (org-element-parse-buffer)
                      'headline
                      (lambda (hl)
                        (string= within_headline
                          (plist-get
                            ;; I want the raw title, no styling nor tags
                            (cadr (car (org-element-lineage hl)))
                            :raw-value))))
              (insert (concat "\n\n*** "within_headline)))
            (insert (concat "\n\n**** " project " :" tag ":\n\n")))))))

  (cl-defun jf/org-mode-agenda-find-blocked-node ()
    "Add a blocker node to today."
    (jf/org-mode-agenda-find-project-node :tag "blockers"
      :project (concat
                 "Blockers for "
                 (format-time-string
                   "%Y-%m-%d"))))

  (cl-defun jf/org-mode-agenda-find-merge-request-node ()
    "Add a mergerequest node to today."
    (jf/org-mode-agenda-find-project-node :tag "mergerequests"
      :project (concat "Merge Requests for "
                 (format-time-string
                   "%Y-%m-%d"))))

  ;; Takes my notes for the day and formats them for a summary report.
  (defun jf/org-mode-agenda-to-stand-up-summary (parg)
    "Copy to the kill ring the day's time-tracked summary.

  When given PARG, prompt for the day of interest.

  NOTE: This follows the convention that projects are on headline 4 and
  tasks within projects are headline 5."
    (interactive "P")
    (with-current-buffer (find-file-noselect
                           jf/primary-agenda-filename-for-machine)
      (save-excursion
        (let ((within_headline
                ;; Use the CCYY-MM-DD Dayname format and prompt for a date if
                ;; PREFIX-ARG given.
                (format-time-string "%Y-%m-%d %A"
                  (when (car parg)
                    (org-read-date nil t nil "Pick a day:" )))))
          (kill-new
            (concat "*Summary of " within_headline "*\n\n"
              (s-trim
                (s-join
                  "\n"
                  (org-element-map
                    (org-element-parse-buffer)
                    'headline
                    (lambda (hl)
                      (when (member
                              within_headline
                              (mapcar
                                (lambda (ancestor)
                                  (plist-get (cadr ancestor) :raw-value))
                                (org-element-lineage hl)))
                        (pcase (org-element-property :level hl)
                          (4 (concat "\n" (plist-get (cadr hl) :raw-value)))
                          (5 (if (and
                                   (member "mergerequest" (org-element-property :tags hl))
                                   (eq 'done (org-element-property :todo-type hl)))
                               nil
                               (concat "- " (plist-get (cadr hl) :raw-value))))
                          (_ nil)))))))))
          (jf/create-scratch-buffer)
          (yank)))))

  (defun jf/org-mode/narrow-to-date (date)
    "Narrow agenda to given DATE agenda subtree."
    (interactive (list (if current-prefix-arg
                         (org-read-date nil nil nil "Pick a day:")
                         (format-time-string "%Y-%m-%d"))))
    (widen)
    (goto-char (point-max))
    (re-search-backward (concat "^\*\*\* " date))
    (end-of-line)
    (org-narrow-to-subtree)
    (message "Narrowing to %s agenda" date))

  ;; I‚Äôm responsible for tracking my work time.  I want a way to quickly see what
  ;; that is for the current week.
  ;;
  ;; A utility function providing an overrview
  (cl-defun jf/org-mode-weekly-report ()
    "Jump to my weekly time tracker.

  Useful for providing me with an overview of my total tracked time
  for the week."
    (interactive)
    (find-file jf/primary-agenda-filename-for-machine)
    (require 'pulsar)
    (pulsar-pulse-line)
    (org-clock-report 4))

  ;; Another task at end of month is to transcribing my agenda‚Äôs timesheet to
  ;; entries in our time tracking software.  From the day‚Äôs project link in the
  ;; =org-clock-report=, I want to copy the headlines of each of the tasks.  I
  ;; fill out my time sheets one day at a time.
  (defun jf/org-mode-time-entry-for-project-and-day ()
    "Function to help report time for Scientist.com.

  Assumes that I'm on a :projects: headline.

  - Sum the hours (in decimal form) for the tasks.
  - Create a list of the tasks.
  - Write this information to the message buffer.
  - Then move to the next heading level."
    (interactive)
    (let* ((project (plist-get (cadr (org-element-at-point)) :raw-value))
            (tasks (s-join "\n"
                     (org-with-wide-buffer
                       (when (org-goto-first-child)
                         (cl-loop collect (concat "- "
                                            (org-no-properties
                                              (org-get-heading t t t t)))
                           while (outline-get-next-sibling))))))
            (hours (/ (org-clock-sum-current-item) 60.0))
            (output (format "Tasks:\n%s\nProject: %s\nHours: %s\n"
                      tasks
                      project
                      hours)))
      (kill-new tasks)
      (message output)))

  ;;; Extra Org Mode Export Function(s)

  ;; Org Mode has built-in capabilities for exporting to HTML (and other
  ;; languages).  The following function does just a bit more.  It converts the
  ;; org region to HTML and sends it to the clipboard as an RTF datatype.
  ;;
  ;; Why is that nice?  As an RTF datatype, the paste receiver better handles the
  ;; HTML (e.g., I can more readily paste into an Email and it pastes as
  ;; expected).
  ;;
  ;; See
  ;; https://kitchingroup.cheme.cmu.edu/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/
  ;; for more details.  One addition I made was to add the ~-inputencoding UTF-8~
  ;; switch.  Without it, I would end up with some weird characters from odd
  ;; smartquote handling.
  (require 'jf-formatting)


  ;; In
  ;; https://takeonrules.com/2022/02/26/note-taking-with-org-roam-and-transclusion/,
  ;; I wrote about ~org-transclusion~.  The quick version, ~org-transclusion~
  ;; allows you to include text from one file into another.  This allows for
  ;; document composition.
  (use-package org-transclusion
    :straight t
    :init (setq org-transclusion-exclude-elements '(property-drawer keyword)))


  ;; I love the work of Daniel Mendler (https://github.com/minad).
  ;; This package gives a bit of visual chrome to org files.
  (use-package org-modern
    :straight (:host github :repo "minad/org-modern")
    :custom ((org-modern-star '("‚óâ" "‚óã" "‚óà" "‚óá" "‚Ä¢"))
              ;; Showing the depth of stars helps with the speed keys as well as
              ;; gives a clearer indicator of the depth of the outline.
              (org-modern-hide-stars nil))
    :config (global-org-modern-mode))

  (use-package org-appear
    :straight (:type git :host github :repo "awth13/org-appear")
    :hook (org-mode . org-appear-mode))

  ;;; Org Export and Composition Functionality
  (setq org-export-global-macros (list))
  (use-package ox
    :straight (ox :type built-in)
    :config
    (add-to-list 'org-export-global-macros
      '("kbd" . "@@html:<kbd>@@$1@@html:</kbd>@@"))
    (add-to-list 'org-export-global-macros
      '("cite" . "@@html:<cite>@@$1@@html:</cite>@@"))
    (add-to-list 'org-export-global-macros
      '("dfn" . "@@html:<dfn>@@$1@@html:</dfn>@@"))
    (add-to-list 'org-export-global-macros
      '("mark" . "@@html:<mark>@@$1@@html:</mark>@@"))
    (add-to-list 'org-export-global-macros
      '("scene-date" . "#+begin_marginnote\nThe scene occurs on @@html:<span class=\"time\">@@$1@@html:</span>@@.\n#+end_marginnote")))
  (add-to-list 'org-export-global-macros
    '("mention" . "@@hugo:{{< glossary key=\"@@$1@@hugo:\" >}}@@"))
  (add-to-list 'org-export-global-macros
    '("abbr" . "@@hugo:{{< glossary key=\"@@$1@@hugo:\" abbr=\"t\" >}}@@"))
  (add-to-list 'org-export-global-macros
    '("abbr-plural" . "@@hugo:{{< glossary key=\"@@$1@@hugo:\" abbr=\"t\" plural=\"t\" >}}@@"))
  (add-to-list 'org-export-global-macros
    '("i" . "@@html:<i class=\"dfn\">@@$1@@html:</i>@@"))
  (add-to-list 'org-export-global-macros
    '("mechanic" . "@@html:<i class=\"mechanic\">@@$1@@html:</i>@@"))
  (add-to-list 'org-export-global-macros
    '("m" . "@@html:<i class=\"mechanic\">@@$1@@html:</i>@@"))
  (add-to-list 'org-export-global-macros
    '("newline" . "@@latex:\\@@ @@html:<br />@@"))
  (add-to-list 'org-export-global-macros
    '("newpage" . "@@latex:\newpage@@"))
  (add-to-list 'org-export-global-macros
    '("linkToSeries" . "@@hugo:{{< linkToSeries \"@@$1@@hugo:\" >}}@@"))'

  (defun jf/org-link-delete-link ()
    "Remove the link part of `org-mode' keeping only description."
    (interactive)
    (let ((elem (org-element-context)))
      (when (eq (car elem) 'link)
        (let* ((content-begin (org-element-property :contents-begin elem))
                (content-end  (org-element-property :contents-end elem))
                (link-begin (org-element-property :begin elem))
                (link-end (org-element-property :end elem)))
          (when (and content-begin content-end)
            (let ((content (buffer-substring-no-properties
                             content-begin content-end)))
              (delete-region link-begin link-end)
              (insert (concat content " "))))))))

  ;; (defun jf/force-org-rebuild-cache (prefix-arg)
  ;;   "Call functions to rebuild the applicable `org-mode' and `org-roam' cache(s).

  ;; When given PREFIX_ARG, clear the org-roam database (via
  ;;  `org-roam-db-clear-all') then sync.  This will slow down the sync."
  ;;   (interactive "P")
  ;;   (org-id-update-id-locations)
  ;;   (when (fboundp 'org-roam-db-clear-all)
  ;;     (progn
  ;;       (when (car prefix-arg) (org-roam-db-clear-all))
  ;;       (org-roam-db-sync)
  ;;       (org-roam-update-org-id-locations))))

  (cl-defun jf/org-agenda/send-forward-task ()
    "Send an `org-mode' task node forward."
    (interactive)
    (save-excursion
      (let* ((day-project-task
               (jf/org-agenda/timesheet/get-day-and-project-and-task-at-point))
              (from-project (plist-get day-project-task :project))
              (from-task (plist-get day-project-task :task)))
        ;; Narrowing the region to perform quicker queries on the element
        (narrow-to-region (org-element-property :begin from-task)
          (org-element-property :end from-task))

        ;; Grab each section for the from-task and convert that into text.
        ;;
        ;; Yes we have the from-task, however, we haven't parsed that entity.
        ;; Without parsing that element, the `org-element-contents' returns nil.
        (let ((content (s-join "\n" (org-element-map (org-element-parse-buffer)
                                      'section
                                      (lambda (section)
                                        (mapconcat
                                          (lambda (element)
                                            (pcase (org-element-type element)
                                              ;; I want to skip my time entries
                                              ('drawer nil)
                                              (_ (buffer-substring-no-properties
                                                   (org-element-property
                                                     :begin element)
                                                   (org-element-property
                                                     :end element)))))
                                          (org-element-contents section)
                                          "\n"))))))
          (widen)
          (org-capture-string (format "%s %s :%s:\n\n%s %s %s :%s:\n%s"
                                (s-repeat (org-element-property :level from-project) "*")
                                (org-element-property :raw-value from-project)
                                (s-join ":" (org-element-property :tags from-project))
                                (s-repeat (org-element-property :level from-task) "*")
                                (org-element-property :todo-keyword from-task)
                                (org-element-property :raw-value from-task)
                                (s-join ":" (org-element-property :tags from-task))
                                content)
            "d"))
        ;; Now that we've added the content, let's tidy up the from-task.
        (goto-char (org-element-property :contents-begin from-task))
        ;; Prompt for the todo state of the original task.
        (call-interactively 'org-todo))))

  (defun jf/org-agenda/timesheet/get-day-and-project-and-task-at-point ()
    "Return a plist of :day, :project, and :task for element at point."
    (let* ((task (jf/org-agenda-headline-for-level :level 5))
            (project (progn
                       (org-up-heading-safe)
                       (org-element-at-point)))
            (day (progn
                   (org-up-heading-safe)
                   (org-element-at-point))))
      (list :project project :task task :day day)))

  (cl-defun jf/org-agenda-headline-for-level (&key (level 5))
    "Find the `org-mode' ancestor headline with LEVEL."
    (let ((element (org-element-at-point)))
      (if (eq 'headline (org-element-type element))
        (let ((element-level (org-element-property :level element)))
          (cond
            ((= level element-level)
              (progn (message "Found %s" element) element))
            ((> level element-level)
              (user-error "Selected element %s is higher level." element-level))
            ((< level element-level)
              (progn (org-up-heading-safe) (jf/org-agenda-headline-for-level :level level)))))
        (progn
          (org-back-to-heading)
          (jf/org-agenda-headline-for-level :level level)))))

  (use-package htmlize
    :straight t
    :bind ("C-M-s-c" . jf/formatted-copy-org-to-html)
    :config
    ;; The following functions build on both org and the htmlize package.  I
    ;; define them as part of the config because without the package these won't
    ;; work.
    ;;
    ;; For this to work, I needed to permit my \"~/bin/emacsclient\" in the
    ;; Security & Privacy > Accessibility system preference.
    ;;
    ;; http://mbork.pl/2021-05-02_Org-mode_to_Markdown_via_the_clipboard
    (defun jf/org-copy-region-as-markdown ()
      "Copy the region (in Org) to the system clipboard as Markdown."
      (interactive)
      (require 'ox)
      (if (use-region-p)
        (let* ((region
                 (buffer-substring-no-properties
                   (region-beginning)
                   (region-end)))
                (markdown
                  (org-export-string-as region 'md t '(:with-toc nil))))
          (gui-set-selection 'CLIPBOARD markdown))))

    ;; I have found that Slack resists posting rich content, so I often need to
    ;; open up TextEdit, paste into an empty file, copy the contents, and then
    ;; paste into Slack.
    (defun jf/formatted-copy-org-to-html (prefix)
      "Export region to HTML, and copy it to the clipboard.

  When given the PREFIX arg, paste the content into TextEdit (for future copy)."
      (interactive "P")
      (save-window-excursion
        (let* ((buf (org-export-to-buffer 'html "*Formatted Copy*" nil nil t t))
                (html (with-current-buffer buf (buffer-string))))
          (with-current-buffer buf
            (shell-command-on-region
              (point-min)
              (point-max)
              "textutil -inputencoding UTF-8 -stdout -stdin -format html -convert rtf | pbcopy"))
          (kill-buffer buf)
          ;; Paste into TextEdit
          (when (car prefix)
            (ns-do-applescript
              (concat
                "tell application \"TextEdit\"\n"
                "\tactivate\n"
                "\tset myrtf to the clipboard as ¬´class RTF ¬ª\n"
                "\tset mydoc to make new document\n"
                "\tset text of mydoc to myrtf\n"
                "end tell")))
          ))))

  ;; https://www.reddit.com/r/emacs/comments/yjobc2/what_method_do_you_use_to_create_internal_links/
  (defun jf/org-parse-headline (headline)
    "Raw value of the given HEADLINE plist."
    (plist-get (cadr headline) :raw-value))

  (defun jf/org-get-headlines ()
    "Get a plist of `org-mode' headlines within the current buffer."
    (org-element-map (org-element-parse-buffer)
      'headline #'jf/org-parse-headline))

  (defun jf/org-link-to-headline ()
    "Insert an internal link to a headline."
    (interactive)
    (let* ((headlines (jf/org-get-headlines))
            (choice (completing-read "Headings: " headlines nil t))
            (desc (read-string "Description: " choice)))
      (org-insert-link buffer-file-name (concat "*" choice) desc)))

  ;; If the example doesn't exist, create the example in the file

  (cl-defun jf/org-mode/capture/prompt-for-example
    (&optional given-mode &key (tag "example"))
    "Prompt for the GIVEN-MODE example with given TAG."
    (let* ((mode (or given-mode (completing-read "Example:"
                                  '("Existing" "New" "Stored")))))
      (cond
        ((string= mode "New")
          (let ((example (read-string "New Example Name: "
                           nil
                           nil
                           (format-time-string "%Y-%m-%d %H:%M:%S"))))
            (with-current-buffer (find-file-noselect
                                   jf/org-mode/capture/filename)
              (jf/org-mode/capture/set-position-file :headline nil
                :tag "examples"
                :depth 1)
              (insert (s-format jf/org-mode/capture/example-template
                        'aget
                        (list (cons "example" example) (cons "tag" tag))))
              example)))
        ((string= mode "Existing")
          (with-current-buffer (find-file-noselect
                                 jf/org-mode/capture/filename)
            (let ((examples (org-map-entries
                              (lambda ()
                                (org-element-property :title (org-element-at-point)))
                              (concat "+LEVEL=2+" tag) 'file)))
              (if examples
                (completing-read "Example: " examples nil t)
                (jf/org-mode/capture/prompt-for-example "New" :tag tag)))))
        ((string= mode "Stored")
          (or jf/org-mode/capture/stored-context
            (jf/org-mode/capture/prompt-for-example "Existing" :tag tag))))))

  (defvar jf/org-mode/capture/example-template
    (concat "\n\n** TODO ${example} :${tag}:\n\n*** TODO Context\n\n"
      "*** Code :code:\n\n*** TODO Discussion\n\n*** COMMENT Refactoring\n\n"))

  (defvar jf/org-mode/capture/stored-context
    nil
    "A cached value to help quickly capture items.")

  (cl-defun jf/org-mode/capture/set-position-file
    (&key
      (headline (jf/org-mode/capture/prompt-for-example))
      (tag "code")
      (depth 3))
    "Position `point' at the end of HEADLINE.

  The HEADLINE must have the given TAG and be at the given DEPTH
  and be a descendent of the given PARENT_HEADLINE.  If the
  HEADLINE does not exist, write it at the end of the file."
    ;; We need to be using the right agenda file.
    (with-current-buffer (find-file-noselect jf/org-mode/capture/filename)
      (setq jf/org-mode/capture/stored-context headline)
      (let* ((existing-position (org-element-map
                                  (org-element-parse-buffer)
                                  'headline
                                  (lambda (hl)
                                    (and (=(org-element-property :level hl) depth)
                                      (member tag
                                        (org-element-property :tags hl))
                                      (if headline
                                        (string= headline
                                          (plist-get
                                            (cadr
                                              (car
                                                (org-element-lineage hl)))
                                            :raw-value))
                                        t)
                                      (org-element-property :end hl)))
                                  nil t)))
        (goto-char existing-position))))

  ;; With Heavy inspiration from http://www.howardism.org/Technical/Emacs/capturing-content.html
  (defvar jf/org-mode/capture/template/default
    (concat "\n**** ${function-name}"
      "\n:PROPERTIES:"
      "\n:CAPTURED_AT: ${captured-at}"
      "\n:REMOTE_URL: [[${remote-url}][${function-name}]]"
      "\n:LOCAL_FILE: [[file:${file-name}::${line-number}]]"
      "\n:FUNCTION_NAME: ${function-name}"
      "\n:END:\n"
      "\n#+BEGIN_${block-type} ${block-mode}"
      "\n${block-text}"
      "\n#+END_${block-type}"))

  (defvar jf/org-mode/capture/template/while-clocking
    (concat "\n:PROPERTIES:"
      "\n:CAPTURED_AT: ${captured-at}"
      "\n:REMOTE_URL: [[${remote-url}][${function-name}]]"
      "\n:LOCAL_FILE: [[file:${file-name}::${line-number}]]"
      "\n:FUNCTION_NAME: ${function-name}"
      "\n:END:\n"
      "\n#+BEGIN_${block-type} ${block-mode}"
      "\n${block-text}"
      "\n#+END_${block-type}"))

  (cl-defun jf/org-mode/capture/get-field-values (block-text)
    "Get the text between START and END returning a fields and values.

  The return value is a list of `cons' with the `car' values of:

  - function-name
  - captured-at
  - remote-url
  - file-name
  - line-number
  - block-type
  - block-mode
  - block-text"
    (require 'magit)
    (require 'git-link)
    (let* ((file-name (buffer-file-name (current-buffer)))
            (org-src-mode (replace-regexp-in-string
                            "-\\(ts-\\)?mode"
                            ""
                            (format "%s" major-mode)))
            (func-name (which-function))
            (type (cond
                    ((eq major-mode 'nov-mode) "QUOTE")
                    ((derived-mode-p 'prog-mode) "SRC")
                    (t "SRC" "EXAMPLE")))
            (file-base (if file-name
                         (file-name-nondirectory file-name)
                         (format "%s" (current-buffer))))
            (line-number (line-number-at-pos (region-beginning)))
            (remote-link (when (magit-list-remotes)
                           (progn
                             (call-interactively 'git-link)
                             (car kill-ring)))))
      `(("function-name" . ,(or func-name "Unknown"))
         ("captured-at" . ,(format-time-string "%Y-%m-%d %H:%M"))
         ("remote-url" . ,remote-link)
         ("file-name" . ,file-name)
         ("line-number" . ,line-number)
         ("block-type" . ,type)
         ("block-mode" . ,org-src-mode)
         ("block-text" . , block-text))))

  (cl-defun jf/denote/capture-wrap (&key link content)
    "Given the LINK and CONTENT return a string to insert into the capture."
    ;; We must do funny business with the link to discern the type.
    (let* ((elements (s-split "::" (string-replace "]]" "" (string-replace "[[" "" link))))
            (parts (s-split ":" (car elements)))
            (type (car parts))
            (path (s-join ":" (cdr parts))))
      (cond
        ;; The 'eww-mode never fires :(
        ((eq 'eww-mode major-mode)
          (save-excursion
            (let* ((url (plist-get eww-data :url))
                    (title (plist-get eww-data :title)))
              (concat "#+attr_shortcode:"
                (when title (concat " :cite " title))
                (when url (concat " :cite_url " url))
                "\n#+begin_blockquote\n" content "\n#+end_blockquote\n%?"))))
        ((string= "elfeed" type)
          (save-excursion
            (funcall (org-link-get-parameter type :follow) path)
            (let ((url (elfeed-entry-link elfeed-show-entry))
                   (title (elfeed-entry-title elfeed-show-entry))
                   (author (plist-get (car (plist-get (elfeed-entry-meta elfeed-show-entry) :authors)) :name)))
              (concat (when (or author title url) "#+attr_shortcode:")
                (when author (concat " :pre " author))
                (when title (concat " :cite " title))
                (when url (concat " :cite_url " url))
                "\n#+begin_blockquote\n" content "\n#+end_blockquote\n%?"))))
        ((string= "file" type)
          (save-excursion
            (org-link-open-as-file path nil)
            (s-format jf/org-mode/capture/template/while-clocking
              'aget
              (jf/org-mode/capture/get-field-values content))))
        ((or (string= "http" type) (string= "https" type))
          (save-excursion
            (concat "#+attr_shortcode: :cite_url " link
                "\n#+begin_blockquote\n" content "\n#+end_blockquote\n%?")))
        (t (concat "\n#+begin_example\n" content "\n#+end_example")))))
  (defun jf/org-mode/capture/parameters (prefix)
    "A logic lookup table by PREFIX."
    (cond
      ;; When we're clocking and no prefix is given...
      ((and (= 1 prefix) (fboundp 'org-clocking-p) (org-clocking-p))
        (list :key "i" :template jf/org-mode/capture/template/while-clocking))
      ;; We're not clocking or we provided a prefix.
      (t (list :key "c" :template jf/org-mode/capture/template/default))))

  (bind-key "s-8" 'jf/org-mode/capture/insert-content-dwim)
  (cl-defun jf/org-mode/capture/insert-content-dwim (start end prefix)
    "Capture the text between START and END.

  Without PREFIX and not clocking capture clock otherwise capture to Backlog."
    (interactive "r\np")
    ;; There is a data structure looking to exist.  That structure is:
    ;;
    ;; - org-capture-key (default "c")
    ;; - template jf/org-mode/capture/template/default
    (let ((params (jf/org-mode/capture/parameters prefix))
           (block-text (buffer-substring-no-properties start end)))
      (org-capture-string (s-format (plist-get params :template)
                            'aget
                            (jf/org-mode/capture/get-field-values block-text))
        (plist-get params :key))))

  (defun jf/capture/text-from-stdin (text)
    "Capture TEXT to current file.

  I envision this function called from the command-line."
    (if (and (fboundp 'org-clocking-p) (org-clocking-p))
      (org-capture-string text "i")
      (with-current-buffer (window-buffer)
        (goto-char (point-max))
        (insert "\n" text))))

  ;; (defun jf/org-mode/open-all-unresolved-pull-requests ()
  ;;   "Opens all unresolved pull requests identified in agenda."
  ;;   (interactive)
  ;;   (dolist (url (-distinct
  ;;                  (org-map-entries
  ;;                    (lambda ()
  ;;                      (org-element-property :raw-value (org-element-at-point)))
  ;;                    "+LEVEL=5+mergerequests+TODO=\"STARTED\"" 'agenda)))
  ;;     (eww-browse-with-external-browser url)))


  (setq org-capture-templates
      '(("d" "To Denote"
          plain (file denote-last-path)
          #'jf/denote-org-capture
          :no-save t
          :immediate-finish nil
          :kill-buffer t
          :jump-to-captured t)
         ("c" "Content to Clock"
           plain (clock)
           "%(jf/denote/capture-wrap :link \"%L\" :content \"%i\")"
           :empty-lines 1)
         ("i" "Immediate to Clock"
           plain (clock)
           "%i%?"
           :immediate-finish t)
         ("t" "Task (for Project)"
           plain (function jf/org-mode/capture/project-task/find)
           "%?"
           :empty-lines-before 1
           :empty-lines-after 1
           :clock-in t
           :clock-keep t
           :jump-to-capture t)
         ("n" "Note for project task"
           plain (function jf/org-mode/capture/project-task/find)
           "%T\n\n%?"
           :empty-lines-before 1
           :empty-lines-after 1)))

  (use-package org-noter
               :straight
               (:repo "org-noter/org-noter"
                      :host github
                      :type git
                 :files ("*.el" "modules/*.el"))
    :config
    (setq org-noter-doc-split-fraction '(0.67 . 0.33)))

  (use-package org-bookmark-heading
    ;; Capture more robust org-mode bookmarks
    :straight t
    :preface
    (defun jf/org-bookmark-heading--display-path (path)
      "Return display string for PATH.

  Returns the title at the PATH when file is a `denote' file."
      (if (denote-file-is-note-p path)
        (denote-retrieve-filename-title path)
        (org-bookmark-heading--display-path path))))

  (defun jf/org-bookmark-heading-make-record (&rest app)
    "Coerce the absolute file path to home relative.

  APP is the parameters for saving the bookmark."
    (let ((bookmark-alist (apply app)))
      (when-let ((home-relative-filename (jf/filename/tilde-based (alist-get 'filename bookmark-alist))))
        (setf (alist-get 'filename bookmark-alist) home-relative-filename))
      ;; Return the modified bookmark-alist
      bookmark-alist))
  (advice-add #'org-bookmark-heading-make-record :around #'jf/org-bookmark-heading-make-record)


  ;; (use-package org-pdftools
  ;;   :straight t
  ;;   :hook (org-mode . org-pdftools-setup-link))

  ;; (use-package org-noter-pdftools
  ;;   :straight t
  ;;   :after org-noter
  ;;   :config
  ;;   ;; Add a function to ensure precise note is inserted
  ;;   (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
  ;;     (interactive "P")
  ;;     (org-noter--with-valid-session
  ;;      (let ((org-noter-insert-note-no-questions (if toggle-no-questions
  ;;                                                    (not org-noter-insert-note-no-questions)
  ;;                                                  org-noter-insert-note-no-questions))
  ;;            (org-pdftools-use-isearch-link t)
  ;;            (org-pdftools-use-freepointer-annot t))
  ;;        (org-noter-insert-note (org-noter--get-precise-info)))))

  ;;   ;; fix https://github.com/weirdNox/org-noter/pull/93/commits/f8349ae7575e599f375de1be6be2d0d5de4e6cbf
  ;;   (defun org-noter-set-start-location (&optional arg)
  ;;     "When opening a session with this document, go to the current location.
  ;; With a prefix ARG, remove start location."
  ;;     (interactive "P")
  ;;     (org-noter--with-valid-session
  ;;       (let ((inhibit-read-only t)
  ;;              (ast (org-noter--parse-root))
  ;;              (location (org-noter--doc-approx-location (when (called-interactively-p 'any) 'interactive))))
  ;;         (with-current-buffer (org-noter--session-notes-buffer session)
  ;;           (org-with-wide-buffer
  ;;             (goto-char (org-element-property :begin ast))
  ;;             (if arg
  ;;               (org-entry-delete nil org-noter-property-note-location)
  ;;               (org-entry-put nil org-noter-property-note-location
  ;;                 (org-noter-pdftools--pretty-print-location location))))))))
  ;;   (with-eval-after-load 'pdf-annot
  ;;     (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))


  (setq org-export-filter-node-property-functions
    (list
      (lambda (data back-end channel)
        (cond
          ((eq back-end 'latex)
            (let ((field-value (s-split ":" data)))
              ;; (format "\\item\\textbf{%s:} %s\n"
              (format "\\item[{%s:}] %s\n"
                (s-titleize (s-replace "_" " " (car field-value)))
                (s-trim (cadr field-value)))))
          (t data)))))

  (defun jf/org-latex-property-drawer (_property-drawer contents _info)
    "Transcode a PROPERTY-DRAWER element from Org to LaTeX.
  CONTENTS holds the contents of the drawer.  INFO is a plist
  holding contextual information."
    (and (org-string-nw-p contents)
      (format "\\begin{description}\n%s\\end{description}" contents)))

  (advice-add #'org-latex-property-drawer :override #'jf/org-latex-property-drawer)

  ;; Without these, I've lost table of contents in PDF exports.
  (defun jf/org-export-change-options (plist backend)
    (cond
      ((equal backend 'html)
       (plist-put plist :with-toc nil)
       (plist-put plist :section-numbers nil))
      ((equal backend 'latex)
       (plist-put plist :with-toc 3)
       (plist-put plist :section-numbers nil)))
    plist)
  (add-to-list 'org-export-filter-options-functions #'jf/org-export-change-options)


  (provide 'jf-org-mode)
  ;;; jf-org-mode.el ends here
#+end_src
** =jf-organizing.el=
#+begin_src emacs-lisp :tangle "jf-organizing.el" :results none
  ;;; jf-organizing.el --- Simple focus mode and extras -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;; Packages specifically here for helping with my writing activities.

  ;;; Code:
  (use-package project
    ;; I'm unclear why I have this and projectile declared/required.
    ;;
    ;; TODO: Can I not require this?
    :straight t)

  (use-package projectile
    ;; Convenient organization and commands for projects.
    :straight t
    :config (projectile-mode 1)
    :custom (projectile-project-search-path '("~/git/"))
    ;; (projectile-git-fd-args "-H -0 -E hyrax-webapp -E .git -tf --strip-cwd-prefix -c never")
    ;; (projectile-git-submodule-command "")
    :bind ("s-." . projectile-toggle-between-implementation-and-test))

  (provide 'jf-organizing)
  ;;; jf-organizing.el ends here
#+end_src
** =jf-project-theme-colors.el=
#+begin_src emacs-lisp :tangle "jf-project-theme-colors.el" :results none
  ;;; jf-project-theme-colors --- Consolidated colors for themes -*- lexical-binding: t -*-

  ;; Copyright (C) 2023 Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;; The options that I'm considering are from the modus color palette:
  ;;
  ;; bg-red-intense
  ;; bg-green-intense
  ;; bg-yellow-intense
  ;; bg-blue-intense
  ;; bg-magenta-intense
  ;; bg-cyan-intense
  ;; bg-red-subtle
  ;; bg-green-subtle
  ;; bg-yellow-subtle
  ;; bg-blue-subtle
  ;; bg-magenta-subtle
  ;; bg-cyan-subtle
  ;; bg-red-nuanced
  ;; bg-green-nuanced
  ;; bg-yellow-nuanced
  ;; bg-blue-nuanced
  ;; bg-magenta-nuanced
  ;; bg-cyan-nuanced
  ;; bg-ochre
  ;; bg-lavender
  ;; bg-sage

  ;;; Code:

  (require 'modus-themes)
  (require 'projectile)
  (defvar jf/project/theme-colors/table
    '(("~/git/dotemacs/" . bg-green-subtle)
      ("~/git/dotzshrc/" . bg-green-subtle)
      ("~/git/takeonrules.source/" . bg-green-nuanced)
      ("~/git/org/" . bg-green-nuanced)
      ("~/git/britishlibrary/" . bg-blue-intense)
      ("~/git/adventist-dl/" . bg-yellow-intense)
      ("~/git/utk-hyku/" . bg-red-intense)
      ("~/git/bulkrax/" . bg-sage)
      ("~/git/space_stone/" . bg-magenta-nuanced)
      ("~/git/derivative_rodeo/" . bg-ochre)
      ("~/git/hyrax/" . bg-sage))
    "A list of projects and their colors.

  The `car' of each list item should be of begin with \"~/\" and
   end with \"/\" (so as to conform to multiple machines and
   projectile's interface.")

  (cl-defun jf/project/theme-colors/current (&key (default 'bg-blue-subtle))
    "Return a HEX color (e.g. \"#CCDDEE\") for the given project.

  The DEFAULT is a named color in the `modus-themes' palette."

    (let* ((project-dir (abbreviate-file-name (or (projectile-project-root) "~/")))
     (name (alist-get project-dir
          jf/project/theme-colors/table
          default nil #'string=)))
     (modus-themes-get-color-value name)))

  (defvar jf/project/theme-colors/faces
    (list 'line-number-current-line 'mode-line-active)
    "The faces to update with the theme-colors.")

  (defvar jf/project/theme-colors/hooks
    (list 'buffer-list-update-hook
    'projectile-after-switch-project-hook)
    "The hooks to call to set the theme colors.")

  (defun jf/project/theme-colors/apply-to-buffer ()
    "Apply the the project's colors to the buffer (e.g. 'mode-line-active)."
    (unless (active-minibuffer-window)
      (dolist (element jf/project/theme-colors/faces)
        (face-remap-add-relative
         element
         `( :background ,(jf/project/theme-colors/current)
      :foreground ,(face-attribute 'default :foreground))))))

  ;; I need to ensure that I'm not doing this while Emacs is initializing.  If I
  ;; don't have the 'after-init-hook I experience significant drag/failure to
  ;; initialize.
  (add-hook 'after-init-hook
      (lambda ()
        (dolist (hook jf/project/theme-colors/hooks)
          (add-hook hook #'jf/project/theme-colors/apply-to-buffer))))

  (provide 'jf-project-theme-colors)
  ;;; jf-project-theme-colors.el ends here
#+end_src
** =jf-project.el=
#+begin_src emacs-lisp :tangle "jf-project.el" :results none
  ;;; jf-project --- Connective Tissue for Projects -*- lexical-binding: t -*-

  ;; Copyright (C) 2022 Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.

  ;;; Commentary

  ;; There are three interactive functions:
  ;;
  ;; - `jf/project/jump-to/notes'
  ;; - `jf/project/jump-to/project-work-space'
  ;; - `jf/project/jump-to/timesheet'
  ;;
  ;; Let's talk of the three targets for jumping.
  ;;
  ;; Notes: Each project has an index.  The index is a place for high-level notes
  ;; and links to related concepts:
  ;;
  ;; Project Space: Each project has different spaces where I do work, examples
  ;; include the following:
  ;;
  ;; - Agenda :: Where I track time.
  ;; - Code :: Where I write code.
  ;; - Discussion :: Where I discuss the project with collaborators.
  ;; - Notes :: Where I take larger conceptual notes.
  ;; - Project board :: Where I see what's in flight.
  ;; - Remote :: Where I read/write issues and pull requests.
  ;;
  ;; Timesheet: For many projects, I track time.  This lets me jump to today's
  ;; headline for the given project.  The headline is where I record tasks to
  ;; which I then track time.
  ;;
  ;; Each project's index is assumed to be an `org-mode' file with two top-level
  ;; keywords:
  ;;
  ;; `#+PROJECT_NAME:'
  ;; `#+PROJECT_PATHS:'
  ;;
  ;; There should be one `#+PROJECT_NAME:' keyword and there can be many
  ;; `#+PROJECT_PATHS:'.  Each `#+PROJECT_PATHS:' is a `cons' cell.  The `car' is
  ;; the label and the `cdr' is the path.  The path can be a filename or a URL.
  ;;
  ;; The `jf/project/jump-to/project-work-space' will prompt for a project then a
  ;; workspace.  From there, it will jump to the corresponding location.

  ;;; Code

  ;;;; Dependencies
  (require 's)
  (require 'f)
  (require 'pulsar)
  (require 'jf-org-mode)

  ;;;; Interactive Commands
  (cl-defun jf/project/jump-to/notes (&key project)
    "Jump to the given PROJECT's notes file.

  Determine the PROJECT by querying `jf/project/list-projects'."
    (interactive)
    (let* ((project (or (s-presence project)
                      (jf/project/find-dwim)))
                  (filename (cdar (jf/project/list-projects :project project))))
      (find-file filename)))

  ;; I work on several different projects each day; helping folks get unstuck.  I
  ;; also need to track and record my time.
  (bind-key "C-c C-j" 'jf/project/jump-to-task)
  (cl-defun jf/project/jump-to-task (&optional prefix)
    "Jump to task.

  With one PREFIX go to place where we would jump on capture."
    (interactive "p")
    (require 'org-capture)
    (require 'pulsar)
    (cond
      ((>= prefix 16)
        (if-let ((filename (cdar (jf/project/list-projects :project "SoftServ"))))
          (org-link-open-as-file (concat filename "::*Timeblock") nil)
          (org-capture-goto-target "t")))
      ((>= prefix 4)
        (org-capture-goto-target "t"))
      (t (progn
           (call-interactively #'set-mark-command)
           (if (when (and (fboundp 'org-clocking-p) (org-clocking-p)) t)
             (progn
               (org-clock-goto)
               (goto-char (org-element-property :contents-begin (org-element-at-point))))
             ;; Jump to where we would put a project were we to capture it.
             (org-capture-goto-target "t")))))
    (pulsar-pulse-line))

  (bind-key "s-2" 'jf/project/jump-to/project-work-space)
  (defun jf/project/jump-to/project-work-space (project)
    "Prompt for PROJECT then workspace and open that workspace."
    (interactive (list (jf/project/find-dwim)))
    (let*
      ;; Get the project's file name
      ((filename (cdar (jf/project/list-projects :project project)))
        (paths-cons-list (jf/project/project-paths-for filename))
        (path-name (completing-read (format "Links for %s: " project) paths-cons-list nil t))
        (path (alist-get path-name paths-cons-list nil nil #'string=)))
      (cond
        ((s-starts-with? "http" path)
          (eww-browse-with-external-browser path))
        ((f-dir-p path)
          (dired path))
        ((f-file-p path)
          (if (string= "pdf" (f-ext path))
                  (shell-command (concat "open " path))
                  (find-file path)))
        ;; Try the path as an org-link (e.g. path == "denote:20230328T093100")
        (t (when-let* ((type-target (s-split ":" path))
                        ;; There's a registered handler for the protocol
                        ;; (e.g. "denote")
                        (follow-func (org-link-get-parameter
                                       (car type-target) :follow)))
             (funcall follow-func (cadr type-target))
             ;; We tried...and don't know how to handle this.
             (progn
                     (message "WARNING: Project %s missing path name \"%s\" (with path %s)"
                             project path-name path)
                     (jf/project/jump-to/notes :project project)))))))

  (defun jf/project/project-paths-for (filename)
    "Find the project paths for the given FILENAME.

  Added in cases where we want to inject the actual file."
    (with-current-buffer (find-file-noselect filename)
      (let ((paths (cl-maplist #'read (cdar (org-collect-keywords '("PROJECT_PATHS"))))))
        (setq paths (cons (cons "Notes" filename) paths)))))

  ;;;; Support Functions
  (cl-defun jf/project/list-projects (&key (project ".+")
                                                                     (directory org-directory))
    "Return a list of `cons' that match the given PROJECT.

  The `car' of the `cons' is the project (e.g. \"Take on Rules\").
  The `cdr' is the fully qualified path to that projects notes file.

  The DIRECTORY defaults to `org-directory' but you can specify otherwise."
    (mapcar (lambda (line)
                    (let* ((slugs (s-split ":" line))
                                  (proj (s-trim (car (cdr slugs))))
                                  (filename (s-trim (car slugs))))
                      (cons proj filename)))
            (split-string-and-unquote
              (shell-command-to-string
                (concat
                  "rg \"^#\\+PROJECT_NAME: +(" project ") *$\" " directory
                  " --only-matching --no-ignore-vcs --with-filename -r '$1' "
                  "| tr '\n' '@'"))
              "@")))

  (cl-defun jf/project/get-project-from/project-source-code (&key (directory org-directory))
    "Return the current \"noted\" project name.

  Return nil if the current buffer is not part of a noted project.

  Noted projects would be found within the given DIRECTORY."
    (when-let ((project_path_to_code_truename (cdr (project-current))))
      (let ((project_path_to_code (jf/filename/tilde-based
                                    project_path_to_code_truename)))
        ;; How to handle multiple projects?  Prompt to pick one
        (let ((filename (s-trim (shell-command-to-string
                                                    (concat
                                                            "rg \"^#\\+PROJECT_PATHS: .*"
                                                            project_path_to_code " *\\\"\" "
                                                            directory " --files-with-matches "
                                                            " --no-ignore-vcs --ignore-case")))))
                (unless (string-equal "" filename)
                  (with-current-buffer (find-file-noselect (file-truename filename))
              (jf/project/get-project-from/current-buffer-is-project)))))))

  (defun jf/project/get-project-from/current-clock ()
    "Return the current clocked project's name or nil."
    ;; This is a naive implementation that assumes a :task: has the clock.  A
    ;; :task:'s immediate ancestor is a :projects:.
    (when-let ((m (and
                                (fboundp 'org-clocking-p) ;; If this isn't set, we ain't
                                ;; clocking.
                                (org-clocking-p)
                                org-clock-marker)))
      (with-current-buffer (marker-buffer m)
        (goto-char m)
        (jf/project/get-project-from/current-buffer-is-project))))

  (defun jf/project/get-project-from/current-buffer-is-project ()
    "Return the PROJECT_NAME keyword of current buffer."
    (cadar (org-collect-keywords (list "PROJECT_NAME"))))

  (defun jf/project/find-dwim ()
    "Find the current project based on context.

  When the `current-prefix-arg' is set always prompt for the project."
    ;; `jf/project/get-project-from/current-agenda-buffer'
    (or
      (and (not current-prefix-arg)
              (or
          (jf/project/get-project-from/current-buffer-is-project)
                (jf/project/get-project-from/current-clock)
                (jf/project/get-project-from/project-source-code)))
      (completing-read "Project: " (jf/project/list-projects))))

  ;; The default relevant `magit-list-repositories'
  ;; The following command shows all "project" directories
  ;;
  (defvar jf/git-project-paths
    '(("~/git/takeonrules.source/" . 1)
       ("~/git/burning_wheel_lifepaths/" . 1)
       ("~/git/dotzshrc/" .  1)
       ("~/git/dotemacs/" . 1)
       ("~/git/emacs-bookmarks/" . 1)
       ("~/git/org" . 1)
       ("~/git/takeonrules.source/themes/hugo-tufte" . 1))
    "A list of `con' cells where the `car' is the name of a directory
  and the `cdr' is a ranking.  I have pre-populated this list with
  repositories that are generally available on both machines.")

  (defun jf/git-project-paths/dynamic ()
    "Return a list of code repository paths."
    (split-string-and-unquote
      (s-trim-right
        (shell-command-to-string
          (concat
            "rg \"^#\\+PROJECT_PATHS: +[^\\.]+\\. +\\\"(~/git/[^/]+/)\\\"\\)\" "
            "~/git/org --no-ignore-vcs --replace='$1' "
            "--only-matching --no-filename")))
      "\n"))

  (dolist (path (jf/git-project-paths/dynamic))
    (add-to-list 'jf/git-project-paths (cons path 1)))

  (setq magit-repository-directories jf/git-project-paths)

  (defun jf/org-mode/agenda-files ()
    "Return a list of note files containing 'agenda' tag.

  Uses the fd command (see https://github.com/sharkdp/fd)

  We want files to have the 'projects' `denote' keyword."
    (let ((projects (mapcar (lambda (el) (cdr el)) (jf/project/list-projects))))
      (when (file-exists-p jf/agenda-filename/scientist) (setq projects (cons jf/agenda-filename/scientist projects)))
      (when (file-exists-p jf/agenda-filename/personal) (setq projects (cons jf/agenda-filename/personal projects)))
      projects))

  (transient-define-suffix jf/org-mode/agenda-files-update (&rest _)
    "Update the value of `org-agenda-files'."
    :description "Update agenda files‚Ä¶"
    (interactive)
    (message "Updating `org-agenda-files'")
    (setq org-agenda-files (jf/org-mode/agenda-files)))

  ;; (advice-add 'org-agenda :before #'jf/org-mode/agenda-files-update)
  ;; (advice-add 'org-todo-list :before #'jf/org-mode/agenda-files-update)
  (add-hook 'after-init-hook #'jf/org-mode/agenda-files-update)

  (defun jf/org-mode/capture/project-task/find ()
    "Find the project file and position to the selected task."
    (let* ((project (completing-read "Project: " (jf/project/list-projects)))
            (filename (cdar (jf/project/list-projects :project project)))
            (tasks (jf/org-mode/existing-tasks filename))
            (task-name (completing-read (format "Task for %s: " project) tasks)))
      ;; Defer finding this file as long as possible.
      (find-file filename)

      (if-let (task (alist-get task-name tasks nil nil #'string=))
        ;; I like having the most recent writing close to the headline; showing a
        ;; reverse order.  This also allows me to have sub-headings within a task
        ;; and not insert content and clocks there.
        ;; (if-let ((drawer (car (org-element-map task 'drawer #'identity))))
        ;; (goto-char (org-element-property :contents-end drawer))
        ;; (goto-char (org-element-property :contents-begin task)))
        (goto-char (org-element-property :contents-begin task))
        (progn
          (goto-char (point-max))
          ;; Yes make this a top-level element.  It is easy to demote and move
          ;; around.
          (insert "* TODO " task-name " :tasks:\n\n")))))

  (defun jf/org-mode/existing-tasks (&optional filename)
    "Return an alist of existing tasks in given FILENAME.

  Each member's `car' is title and `cdr' is `org-mode' element.

  Members of the sequence either have a tag 'tasks' or are in a todo state."
    (with-current-buffer (or (and filename (find-file-noselect filename)) (current-buffer))
      (mapcar (lambda (headline)
                (cons (org-element-property :title headline) headline))
        (org-element-map
          (org-element-parse-buffer 'headline)
          'headline
          (lambda (headline)
            (and
              (or (eq (org-element-property :todo-type headline) 'todo)
                (member "tasks" (org-element-property :tags headline)))
              headline))))))

  (defun jf/org-mode/blog-entry? (&optional buffer)
    (when-let* ((buffer (or buffer (current-buffer)))
                 (file (buffer-file-name buffer)))
      (and (denote-file-is-note-p file)
        (string-match-p "\\/blog-posts\\/" file))))

  (cl-defun jf/denote? (&key (buffer (current-buffer)))
    (when-let* ((file (buffer-file-name buffer)))
      (denote-file-is-note-p file)))

  (transient-define-suffix jf/project/convert-document-to-project (&optional buffer)
    "Conditionally convert the current BUFFER to a project.

  This encodes the logic for creating a project."
    :description "Convert to project‚Ä¶"
    (interactive)
    (let ((buffer (or buffer (current-buffer))))
      (with-current-buffer buffer
        (if-let* ((file (buffer-file-name buffer))
                   (_proceed (and
                     (denote-file-is-note-p file)
                     (derived-mode-p 'org-mode)
                     (not (jf/project/get-project-from/current-buffer-is-project))))
                   (existing-title (org-get-title))
                   (file-type (denote-filetype-heuristics file))
                   (keywords (denote-retrieve-keywords-value file file-type)))
          (progn
            ;; Goto the 5th line
            (goto-line 5)
            (insert "\n#+PROJECT_NAME: " existing-title
              "\n#+CATEGORY: " existing-title)
            (setq keywords (cons "projects" keywords))
            (denote-rewrite-keywords file keywords file-type)
            (call-interactively #'denote-rename-file-using-front-matter))
          (user-error "Unable to convert buffer to project")))))

  (transient-define-suffix jf/project/add-project-path (label path)
    "Add a PROJECT_PATH `org-mode' keyword to buffer.

  This encodes the logic for creating a project."
    :description "Add project path‚Ä¶"
    (interactive (list
                   (read-string "Label: ")
                   (read-string "Path: ")))
    (save-excursion
      (goto-char (point-min))
      (let ((case-fold-search t))
        (if (or
              (re-search-forward "^#\\+PROJECT_PATHS:" nil t)
              (re-search-forward "^#\\+PROJECT_NAME:" nil t))
          (end-of-line)
          (progn (goto-line 6) (re-search-forward "^$" nil t)))
        (insert "\n#+PROJECT_PATHS: (\"" (s-trim label) "\" . \"" (s-trim path) "\")"))))

  (provide 'jf-project)
  ;;; jf-project.el ends here
#+end_src
** =jf-quick-help.el=
#+begin_src emacs-lisp :tangle "jf-quick-help.el" :results none
  ;;; jf-quick-help.el --- Simple focus mode and extras -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;; Package-Requires: ((transient "0.3.7") (emacs "25.1"))

  ;;; Commentary:
  ;;
  ;; This package provides a simple way to register quick help function.

  ;;; Code:
  (require 'cl-lib)
  (cl-defun jf/quick-help (&key header body)
    "Create a help window with HEADER and BODY."
    (let ((qh-buff (concat "*Quick Help: " header "*")))
      (progn (or (get-buffer qh-buff)
                 (progn (get-buffer-create qh-buff)
                        (with-current-buffer qh-buff
                          (insert (concat "**" header "**\n" body))
                          (goto-char (point-min))
                          (not-modified)
                          (read-only-mode)
                          (special-mode)
                          (local-set-key (kbd "q") 'kill-buffer-and-window))))
             (pop-to-buffer qh-buff '((display-buffer-below-selected)
                                      ;; When sizing the buffer, if tab-line-format is
                                      ;; active then that "line" is not counted in
                                      ;; calculating the fit-to-window-buffer value.
                                      ;; Which means that the buffer flows into the
                                      ;; mode-line.  So turn it off for this buffer.
                                      (window-parameters . ((tab-line-format . none)
                                                            (no-other-window . nil)))
                                      (window-height . fit-window-to-buffer)))
             (message "q - Remove Window"))))

  (cl-defmacro jf/transient-quick-help (name &key header label body)
    "Macro for creating callable functions that display help.

        NAME is name of function,
        LABEL is label for the menu
        HEADER is name of buffer, and TEXT is displayed."
    (declare (indent defun))
    `(progn
       (transient-define-suffix ,name nil
         ,header
         :description ,label
         (interactive)
         (jf/quick-help :header ,header :body ,body))))

  (provide 'jf-quick-help)
  ;;; jf-quick-help.el ends here
#+end_src
** =jf-reading.el=
#+begin_src emacs-lisp :tangle "jf-reading.el" :results none
  ;;; jf-reading.el --- Simple focus mode and extras -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;;; Code:
  (use-package doc-view
    ;; A package for improving the in Emacs viewing experience of PDFs.
    :straight (doc-view :type built-in)
    :bind (:map doc-view-mode-map
                ("C-c g" . doc-view-goto-page)))


  (use-package elfeed
    ;; An Emacs RSS reader.  I‚Äôve used Google Reader, Feedly, Inoreader, and
    ;; Newsboat.  I wrote about
    ;; https://takeonrules.com/2020/04/12/switching-from-inoreader-to-newsboat-for-rss-reader/,
    ;; and the principles apply for Elfeed.
    :straight t
    :after org
    :hook ((elfeed-show-mode . jf/reader-visual))
    :custom
    (elfeed-curl-timeout 90)
    (elfeed-db-directory "~/Documents/.elfeed")
    :config
    (setq-default elfeed-search-filter "@2-days-ago +unread ")
    :bind ((:map elfeed-search-mode-map
             ("q" . jf/elfeed-save-db-and-bury))))

  (defun jf/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer."
    ;;write to disk when quiting
    (interactive)
    (elfeed-db-save)
    (quit-window))

  (defun jf/elfeed-load-db-and-open ()
    "Load the elfeed db from disk before opening."
    (interactive)
    (elfeed)
    (elfeed-update)
    (elfeed-db-load)
    (elfeed-search-update--force))
  (defalias 'rss 'jf/elfeed-load-db-and-open)

  ;; From https://karthinks.com/blog/lazy-elfeed/
  (defun elfeed-search-show-entry-pre (&optional lines)
    "Return a function that will scroll n LINES in `elfeed' search results.

  It will display entries without switching to them."
    (lambda (times)
      (interactive "p")
      (forward-line (* times (or lines 0)))
      (recenter)
      (call-interactively #'elfeed-search-show-entry)
      (select-window (previous-window))
      (unless elfeed-search-remain-on-entry (forward-line -1))))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "n")
       (elfeed-search-show-entry-pre +1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "p")
       (elfeed-search-show-entry-pre -1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "M-RET")
       (elfeed-search-show-entry-pre)))
  ;; End https://karthinks.com/blog/lazy-elfeed/

  (use-package elfeed-org
    ;; Maintaining my RSS subscriptions in `org-mode' format.
    :straight t
    :after elfeed
    :config (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/git/org/elfeed.org")))

  (use-package elfeed-curate
    :straight (:host github :repo "rnadler/elfeed-curate")
    :bind (:map elfeed-search-mode-map
                ("a" . elfeed-curate-edit-entry-annoation)
                ("x" . elfeed-curate-export-entries))
          (:map elfeed-show-mode-map
                ("a" . elfeed-curate-edit-entry-annoation)
                ("m" . elfeed-curate-toggle-star)
                ("q" . kill-buffer-and-window)))

  (use-package eww
    ;; A plain text browser.  Use this to see just how bad much of the web has
    ;; become.
    :straight t
    :config
    (setq shr-cookie-policy nil)
    (setq eww-auto-rename-buffer 'title)
    (defun shr-tag-dfn (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-cite (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-q (dom)
      (shr-insert (car shr-around-q-tag))
      (shr-generic dom)
      (shr-insert (cdr shr-around-q-tag)))

    (defcustom shr-around-q-tag '("‚Äú" . "‚Äù")
      "The before and after quotes.  `car' is inserted before the Q-tag and `cdr' is inserted after the Q-tag.

  Alternative suggestions are: - '(\"\\\"‚Äú\" . \"\\\"\")"
      :type (cons 'string 'string))

    (defface shr-small
      '((t :height 0.8))
      "Face for <small> elements.")

    ;; Drawing inspiration from shr-tag-h1
    (defun shr-tag-small (dom)
      (shr-fontize-dom dom (when shr-use-fonts 'shr-small)))

    (defface shr-time
      '((t :inherit underline :underline (:style wave)))
      "Face for <time> elements.")

    ;; Drawing inspiration from shr-tag-abbr
    (defun shr-tag-time (dom)
      (when-let* ((datetime (or
           (dom-attr dom 'title)
           (dom-attr dom 'datetime)))
      (start (point)))
        (shr-generic dom)
        (shr-add-font start (point) 'shr-time)
        (add-text-properties
         start (point)
         (list
    'help-echo datetime
    'mouse-face 'highlight))))


    ;; EWW lacks a style for article
    (defun shr-tag-article (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    ;; EWW lacks a style for section; This is quite provisional
    (defun shr-tag-section (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    (setq browse-url-browser-function 'browse-url-default-macosx-browser)
    :bind (:map eww-mode-map ("U" . eww-up-url))
    :bind (("C-s-w" . browse-url-at-point))
    :hook ((eww-mode . jf/reader-visual)))

  (defun jf/reader-visual ()
    "A method to turn on visual line mode and adjust text scale."
    ;; A little bit of RSS beautification.
    (text-scale-set 2)
    (turn-on-visual-line-mode))

  (provide 'jf-reading)
  ;;; jf-reading.el ends here
#+end_src
** =jf-the-one-ring.el=
#+begin_src emacs-lisp :tangle "jf-the-one-ring.el" :results none
  ;;; jf-the-one-ring --- Tables and Rollers for The One Ring -*- lexical-binding: t -*-

  ;; Copyright (C) 2022 Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary

  ;; This package contains tabular data from The One Ring‚Ñ¢ tabletop role-playing
  ;; games.
  ;;
  ;; It also provides tools to "roll" on those tables.
  ;;
  ;; "Strider", "The One Ring", "Middle-earth", and "The Lord of the Rings" are
  ;; trademarks or registered trademarks of the Saul Zaentz Company d/b/a
  ;; Middle-earth Enterprises (SZC).

  ;; Many tables have 12 entries.  The 0th entry is for the eye rune, 1st through
  ;; 10th is their respictive numbers, and the 11th is the gandalf rune.  This is
  ;; a case where the programming convention of arrays/lists indexes start at 0
  ;; really shines!

  ;;; Code

  (require 'transient)
  (require 'jf-quick-help)
  (require 's)

  ;;;; Tables

  ;;;;; Core Rules

  (defconst jf/gaming/the-one-ring/feat-die
    '("‚èø"
      1 2 3 4 5 6 7 8 9 10
      "·ö†")
    "By convention all Feat-die tables treat the initial list item as the \"‚èø\" roll.")

  (defconst jf/gaming/the-one-ring/feat-die-favourability
    '(("Favoured" . (lambda (table)
                      (nth (max (random (length table))
                                (random (length table)))
                           table)))
      ("Neutral" . (lambda (table)
                     (seq-random-elt table)))
      ("Ill-Favoured" . (lambda (table)
                          (nth (min (random (length table))
                                    (random (length table)))
                               table))))
    "Favourability options and associated roller.")

  (defconst jf/gaming/the-one-ring/table/nameless-things
    '(:name-prefix
      ("The Bane" "The Scourge" "The Horror" "The Terror"
       "The Defiler" "The Devourer" "The Stalker" "The Hunter"
       "The Watcher" "The Crawler" "The Lurker" "The Flame")
      :name-suffix
      ("in the Dark" "of the Abyss" "in the Deep"
       "of the Pit" "of Ud√ªn" "in the Water")
      :named-by
      ("by Men" "by Elves" "by Dwarves"
       "by Orcs" "by the Wise" "in ancient lore")
      :description-prefix
      ("Bat-like" "Spider-like" "Fish-like" "Slug-like"
       "Worm-like" "Centipede-like" "Insect-like" "Crustacean-like"
       "Octopus-like" "Fish-like" "Toad-like" "Troll-like")
      :description-suffix
      ("with remorseless eyes" "with great horns" "with luminous skin"
       "with a huge head" "with a swollen body" "yet greater")
      :before-you-see-it
      ("notice a deadly silence" "hear a sinister hissing"
       "hear a low growl" "see the bones of its victims"
       "feel your skin crawl" "hear a deafening sound or scream"
       "notice its tracks" "hear a terrifying scream"
       "smell a hideous stench" "feel a violent gust of air"
       "hear a piping sound" "feel a terrible cold")
      :what-you-first-see
      ("is a great shadow, in the middle of which is a dark form"
       "are its great claws"
       "are its eyes, glowing in the dark"
       "is that its body is flaccid and translucent, as if composed of gelatinous material"
       "is its gaping mouth, opening and closing as if gasping for air"
       "is a large maw, with fangs eerily similar to human teeth"
       "is that swarms of insects or other vermin are crawling before it"
       "is a long, sinuous tentacle, slithering towards you"
       "are its huge fangs, so big and long that it cannot close its mouth"
       "are its wide, blind eyes"
       "are many twisted horns of stained ivory"
       "is a vision of a beautiful creature, a phantom of the mind")))

  (defconst jf/gaming/the-one-ring/distinctive-features-table
    '("Synonym of a PC's distinctive feature"
      (("Bold" "Cunning" "Eager" "Fair" "Fair-spoken" "Faithful")
       ("Arrogant" "Brutal" "Cowardly" "Cruel" "Deceitful" "Fearful"))
      (("Fierce" "Generous" "Honourable" "Inquisitive" "Keen-eyed" "Lordly")
       ("Forgetful" "Grasping" "Guilt-ridden" "Haughty" "Idle" "Mistrustful"))
      (("Merry" "Patient" "Proud" "Rustic" "Secretive" "Stern")
       ("Murderous" "Overconfident" "Resentful" "Scheming" "Scornful" "Spiteful"))
      (("Subtle" "Swift" "Tall" "True-hearted" "Wary" "Wilful")
       ("Thieving" "Traitorous" "Troubled" "Tyrannical" "Uncaring" "Wavering"))
      "Antonym of a PC's distinctive feature"))

  ;;;;; Strider Mode
  (defconst jf/gaming/the-one-ring/strider-mode/event-table
    '(:table (:terrible-misfortune :despair :ill-choices :ill-choices
                                  :mishap :mishap :mishap :mishap
                                  :short-cut :short-cut :chance-meeting :joyful-sight)
            :details
            ( :terrible-misfortune
              ( :consequence "If the roll fails, the target is Wounded."
                :title "Terrible Misfortune"
                :fatigue 3
                :events
                (("Dire confrontation" . "Noteworthy Encounter")
                 ("Rival Predator" . "HUNTING to avoid becoming the hunted")
                 ("Violent weather" . "EXPLORE to find shelter")
                 ("Hidden hazard" . "AWARENESS to avoid stumbling into danger")
                 ("Dangerous terrain" . "EXPLORE to find a safer route")
                 ("Stalking enemy" . "AWARENESS to spot the foul presence")))
              :despair
              ( :consequence "If the roll fails, gain 2 Shadow points (Dread)."
                :title "Despair"
                :fatigue 2
                :events
                (("Servants of the Enemy" . "Noteworthy Encounter")
                 ("Torrential weather" . "EXPLORE to find the least exposed path")
                 ("Nightmarish presence" . "AWARENESS to sense the danger")
                 ("Fading vigour" . "HUNTING to gain sustenance")
                 ("Corrupted site" . "EXPLORE to find your way out")
                 ("Grisly scene or foreboding portent" . "AWARENESS to be forewarned")))
              :mishap
              ( :consequence "If the roll fails, add 1 day to the length of the journey, and gain 1 additional Fatigue."
                :title "Mishap"
                :fatigue 2
                :events
                (("Sparse wildlife" . "HUNTING to forage what you can")
                 ("Lost direction" . "EXPLORE to find your way")
                 ("Obstructed path" . "AWARENESS to spot a way around")
                 ("Elusive quarry" . "HUNTING to track it down")
                 ("Rough terrain" . "EXPLORE to safely traverse")
                 ("Wandering enemies" . "AWARENESS to sense their coming")))
              :ill-choices
              ( :consequence "If the roll fails, gain 1 Shadow point (Dread)."
                :title "Ill Choices"
                :fatigue 2
                :events
                (("Mismanaged provisions" . "HUNTING to replenish stores")
                 ("Wayward path" . "EXPLORE to retrace your steps")
                 ("Overlooked hazard" . "AWARENESS to escape safely")
                 ("Lost quarry" . "HUNTING to follow its tracks")
                 ("Disorienting environs" . "EXPLORE to find your way")
                 ("Haunting visions" . "AWARENESS to over- come darkness")))
              :short-cut
              ( :consequence "If the roll succeeds, reduce the length of the journey by 1 day."
                :title "Short Cut"
                :fatigue 1
                :events
                (("Game trail" . "HUNTING to traverse the path")
                 ("Secluded path" . "EXPLORE to navigate the wilds")
                 ("Helpful tracks" . "AWARENESS to follow the tracks")
                 ("Animal guide" . "HUNTING to follow at a distance")
                 ("Favourable weather" . "EXPLORE to make the most of it")
                 ("Familiar waypoint" . "AWARENESS to recognize the landmark")))
              :chance-meeting
              ( :consequence "If the roll succeeds, no Fatigue is gained, and you may envision a favourable encounter."
                :title "Chance Meeting"
                :fatigue 1
                :events
                (("Lone hunter" . "HUNTING to trade stories")
                 ("Fellow traveller" . "EXPLORE to learn about the path ahead")
                 ("Discreet watcher" . "AWARENESS to spot them")
                 ("Noble beast" . "HUNTING to commune")
                 ("Secluded encampment" . "EXPLORE to find your way off the beaten path")
                 ("Auspicious gathering" . "Noteworthy Encounter")))
              :joyful-sight
              ( :consequence "If the roll succeeds, regain 1 Hope."
                :title "Joyful Sight"
                :fatigue 0
                :events
                (("Majestic creatures" . "HUNTING to observe without startling them")
                 ("Inspiring vista" . "EXPLORE to reach a vantage point")
                 ("Benevolent being" . "AWARENESS to sense their presence")
                 ("Abundant foraging" . "HUNTING to replenish your rations")
                 ("Ancient monument" . "AWARENESS to recognize its significance")
                 ("Peaceful sanctuary" . "Noteworthy Encounter"))))))

  (defconst jf/gaming/the-one-ring/strider-mode/fortune-tables
    '(("·ö†" .
       ("The Eye of the Enemy focuses elsewhere. Decrease Eye Awareness by 1."
        "You may bypass a threat without attracting notice"
        "You gain the attention of a potential ally"
        "An enemy inadvertently reveals their position"
        "You gain favoured ground"
        "Enemies run afoul of danger"
        "You locate or learn of a useful item"
        "Your success instils new hope or renewed resolve"
        "You find a moment of comfort or safety"
        "You learn or realize something which gives helpful insight into your mission"
        "You encounter an opportunity suited to your nature or abilities"
        "An unexpected ally appears or sends aid"))
      ("‚èø" .
       ("Your actions catch the Eye of the Enemy. Increase Eye Awareness by 2."
        "You draw unwanted attention"
        "Your actions are observed by someone of ill-intent"
        "Unexpected enemies emerge or are sighted"
        "You are hindered by difficult terrain or an unfa- vourable environment"
        "You find yourself ill-equipped for the circumstances"
        "A favoured weapon or item is lost, broken, or sacrificed"
        "You are plagued by troubling visions or thoughts"
        "An old injury or stress resurfaces"
        "You learn or realize something which adds a new complication to your mission"
        "You face a test which is contrary to your nature or abilities"
        "An ally becomes a hindrance or liability"))))

  (defconst jf/gaming/the-one-ring/strider-mode/lore-table
    '(
      :action ("‚èø Abandon" "‚èø Attack" "‚èø Betray" "‚èø Corrupt" "‚èø Defeat" "‚èø Weaken" ;; Eye of Sauron
               "Aid" "Arrive" "Await" "Breach" "Break" "Capture" ;; 1
               "Change" "Chase" "Command" "Control" "Create" "Defy" ;; 2
               "Demand" "Discover" "Disguise" "Endure" "Escape" "Evade" ;; 3
               "Explore" "Find" "Focus" "Gather" "Guard" "Guide" ;; 4
               "Hide" "Hinder" "Hoard" "Hold" "Hunt" "Journey" ;; 5
               "Lead" "Learn" "Leave" "Lose" "Mourn" "Move" ;; 6
               "Persist" "Preserve" "Prevent" "Refuse" "Reject" "Remove" ;; 7
               "Replenish" "Restore" "Scheme" "Search" "Seize" "Share" ;; 8
               "Slay" "Steal" "Summon" "Surrender" "Surround" "Threaten" ;; 9
               "Transform" "Trap" "Trick" "Uncover" "Uphold" "Withstand" ;; 10
               "·ö† Believe" "·ö† Bolster" "·ö† Defend" "·ö† Forgive" "·ö† Resist" "·ö† Strengthen") ;; Rune of Gandalf
      :aspect ("‚èø Corrupted" "‚èø Cruel" "‚èø Deceptive" "‚èø Fell" "‚èø Ruined" "‚èø Treacherous" ;; Eye of Sauron
               "Active" "Ancient" "Bold" "Bright" "Broken" "Cheerless" ;; 1
               "Cold" "Concealed" "Dangerous" "Dark" "Dead" "Defended" ;; 2
               "Desolate" "Destroyed" "Dreadful" "Empty" "Evil" "Faded" ;; 3
               "Far-reaching" "Fierce" "Foreboding" "Forgotten" "Fragile" "Ghastly" ;; 4
               "Gloomy" "Growing" "Hidden" "Ill-fated" "Impenetrable" "Inspiring" ;; 5
               "Isolated" "Lofty" "Lost" "Menacing" "Mighty" "Mysterious" ;; 6
               "Noble" "Obstructed" "Old" "Ominous" "Open" "Peaceful" ;; 7
               "Restored" "Sheltered" "Silent" "Simple" "Small" "Sombre" ;; 8
               "Stony" "Stout" "Stricken" "Stubborn" "Twisted" "Unnatural" ;; 9
               "Veiled" "Vigorous" "Weary" "Wild" "Wretched" "Young" ;; 10
               "·ö† Flourishing" "·ö† Beautiful" "·ö† Good" "·ö† Kind" "·ö† Gentle" "·ö† Wondrous") ;; Rune of Gandalf
      :focus ("‚èø Curse" "‚èø Despair" "‚èø Enemy" "‚èø Fear" "‚èø Shadow" "‚èø War" ;; Eye of Sauron
              "Battle" "Border" "Burden" "Council" "Court" "Creature" ;; 1
              "Darkness" "Death" "Defence" "Depths" "Doubt" "Dreams" ;; 2
              "Fate" "Fire" "Folk" "Followers" "Greed" "Haven" ;; 3
              "History" "Honour" "Journey" "Kindred" "Knowledge" "Land" ;; 4
              "Leader" "Legend" "Life" "Light" "Luck" "Memory" ;; 5
              "Message" "Might" "Nature" "Pain" "Path" "Patron" ;; 6
              "Peril" "Plan" "Power" "Prophecy" "Quest" "Refuge" ;; 7
              "Riddle" "Ruins" "Rumour" "Secret" "Skill" "Song" ;; 8
              "Story" "Strength" "Time" "Tool" "Treasure" "Trust" ;; 9
              "Truth" "Vengeance" "Wealth" "Weapon" "Wilds" "Wish" ;; 10
              "·ö† Courage" "·ö† Duty" "·ö† Fellowship" "·ö† Hope" "·ö† Love" "·ö† Peace") ;; Rune of Gandalf
      )
    "From Strider Mode p11-12")

  (defconst jf/gaming/the-one-ring/strider-mode/revelation-episode-table
    '("Internal strife or an external threat puts your Safe Haven in peril"
      "Unexpected danger arises on the path ahead, forcing you to seek a new route"
      "Nature is corrupted and turns against you"
      "Spies of the Enemy carry word of your mission"
      "Enemy minions launch an ambush or lay a trap"
      "Enemy minions pick up your trail"
      "An important location is overtaken by an enemy"
      "An item you carry holds a curse, or is hunted by an enemy"
      "You are tempted by something greatly desired, to the detriment of your mission"
      "Malicious lies cause others to mistrust or fear you"
      "Conflict brews between allies"
      "An important ally is put in danger")
    "Roll a 1d12; by convention the 0th is Sauron.")

  (defconst jf/gaming/the-one-ring/strider-mode/telling-table
    ;; List contains 12 elements; 0th index is "Sauron", then 1st through 10th are
    ;; 1 through 10 and 11th is "Gandalf".
    '(("Certain" . ("‚èø No with an extreme result or twist"
                    "Yes" "Yes" "Yes" "Yes" "Yes" "Yes" "Yes" "Yes" "Yes" "Yes"
                    "·ö† Yes with an extreme result or twist"))
      ("Likely" . ("‚èø No with an extreme result or twist"
                   "No" "No" "No" "Yes" "Yes" "Yes" "Yes" "Yes" "Yes" "Yes"
                   "·ö† Yes with an extreme result or twist"))
      ("Middling" . ("‚èø No with an extreme result or twist"
                     "No" "No" "No" "No" "No" "Yes" "Yes" "Yes" "Yes" "Yes"
                     "·ö† Yes with an extreme result or twist"))
      ("Doubtful" . ("‚èø No with an extreme result or twist"
                     "No" "No" "No" "No" "No" "No" "No" "Yes" "Yes" "Yes"
                     "·ö† Yes with an extreme result or twist"))
      ("Unthinkable" . ("‚èø No with an extreme result or twist"
                        "No" "No" "No" "No" "No" "No" "No" "No" "No" "Yes"
                        "·ö† Yes with an extreme result or twist")))
    "An translation of the Telling Table from Strider Mode.")


  ;;;;; Help

  (jf/transient-quick-help jf/gaming/the-one-ring/strider-mode/experience-milestones
    :label "Strider: XP Milestones"
    :header "Strider: Experience Milestones"
    :body
    (s-join
     "\n"
     '("| Milestone                                    | Adventure Pt | Skill Pt |"
       "|----------------------------------------------+--------------+----------|"
       "| Accept a mission from a patron               |            1 | -        |"
       "| Achieve a notable personal goal              |            1 | 1        |"
       "| Complete a patron‚Äôs mission                  |            1 | 1        |"
       "| Complete a meaningful journey                |            - | 2        |"
       "| Face a Noteworthy Encounter during a journey |            - | 1        |"
       "| Reveal a significant location or discovery   |            1 | -        |"
       "| Overcome a tricky obstacle                   |            - | 1        |"
       "| Participate in a Council                     |            - | 1        |"
       "| Survive a dangerous combat                   |            1 | -        |"
       "| Face a Revelation Episode                    |            1 | -        |")))

  ;;;; Rollers

  (cl-defun jf/gaming/the-one-ring/roll/favorability-with-table (&key favorability table)
    "Roll on the TABLE using the FAVORABILITY."
    (funcall (alist-get favorability
                        jf/gaming/the-one-ring/feat-die-favourability
                        nil
                        nil
                        #'string=)
             table))

  (cl-defun jf/gaming/the-one-ring/roll/feat-die (favorability)
    "Return a random result of the feat die based on the given FAVORABILITY."
    (interactive (list (completing-read "Favourability: "
                                        jf/gaming/the-one-ring/feat-die-favourability)))
    (jf/gaming/the-one-ring/roll/favorability-with-table :favorability favorability
                                                         :table jf/gaming/the-one-ring/feat-die))

  (defun jf/gaming/the-one-ring/roll/fortune-table (fortune_type)
    "Return a random fortune based given FORTUNE_TYPE."
    (interactive (list
                  (completing-read "Fortune Type: "
                                   jf/gaming/the-one-ring/strider-mode/fortune-tables)))
    (format "Fortune %s: ‚Äú%s‚Äù"
            fortune_type
            (jf/roll-on-table (alist-get fortune_type
                               jf/gaming/the-one-ring/strider-mode/fortune-tables
                               nil
                               nil
                               #'string=))))

  (cl-defun jf/gaming/the-one-ring/roll/lore-table
      (question
       &key
       (lore-table jf/gaming/the-one-ring/strider-mode/lore-table))
    "Return the response from asking the lore table the given QUESTION."
    (interactive (list
                  (read-string "Open-ended Question: ")))
    (concat "{{{i(Lore Table)}}}:\n"
            "\n"
            "- Question :: ‚Äú" question "‚Äù\n"
            "- Action :: " (jf/roll-on-table (plist-get lore-table :action)) "\n"
            "- Aspect :: " (jf/roll-on-table (plist-get lore-table :aspect)) "\n"
            "- Focus :: " (jf/roll-on-table (plist-get lore-table :focus)) "\n"))

  (cl-defun jf/gaming/the-one-ring/roll/skill-check (dice
                                                     favorability
                                                     &key
                                                     (is_weary
                                                      jf/gaming/the-one-ring/character-is-weary))
    "Return the verbose results of rolling the DICE with the given FAVORABILITY for the feat die."
    (interactive (list
                  (read-number "Number of D6s: ")
                  (completing-read "Favourability: "
                                   jf/gaming/the-one-ring/feat-die-favourability)))
    (let* ((feat-die (jf/gaming/the-one-ring/roll/feat-die favorability))
           (success-dice (jf/gaming/the-one-ring/roll/success-dice :dice dice :is_weary is_weary))
           (weary_message (if is_weary " with Weary condition" ""))
           (prefix (format "%s %sd6%s [Feat: %s  Success: %s]"
                           favorability
                           dice
                           weary_message
                           feat-die
                           (plist-get success-dice :rolls))))
      (cond
       ((numberp feat-die)
        (format "%s: %s %s’á "
                prefix
                (+ feat-die (plist-get success-dice :total))
                (plist-get success-dice :sixes)))
       ((string= "‚èø" feat-die)
        (format "%s: %s %s %s’á"
                prefix
                feat-die
                (plist-get success-dice :total)
                (plist-get success-dice :sixes)))
       ((string= "·ö†" feat-die)
        (format "%s: %s %s’á"
                prefix
                feat-die
                (plist-get success-dice :sixes))))))

  (defun jf/gaming/the-one-ring/roll/solo-event-table (favorability)
    "Return the results of rolling on the solo event table with the given FAVORABILITY."
    (interactive (list (completing-read "Favourability: "
                                        jf/gaming/the-one-ring/feat-die-favourability)))
    (let* ((subtable-name (jf/gaming/the-one-ring/roll/favorability-with-table
                           :favorability favorability
                           :table (plist-get jf/gaming/the-one-ring/strider-mode/event-table :table)))
           (details (plist-get jf/gaming/the-one-ring/strider-mode/event-table :details))
           (subtable (plist-get details subtable-name))
           (subtable-events (jf/roll-on-table (plist-get subtable :events))))
      (format "%s: %s\n\n- Fatigue :: %s\n- Consequence :: %s\n- Task :: %s\n"
              (plist-get subtable :title)
              (car subtable-events)
              (plist-get subtable :fatigue)
              (plist-get subtable :consequence)
              (cdr subtable-events))))

  (cl-defun jf/gaming/the-one-ring/roll/success-dice (&key dice (is_weary nil))
    "Roll a number of \"The One Ring\" success DICE.  And reject some results when character IS_WEARY."
    (let ((total 0)
          (sixes 0)
          (rolls (list))
          (roll 0))
      (while (> dice 0)
        (setq roll (1+ (random 6)))
        (push roll rolls)
        (when (or (not is_weary) (> roll 3)) (setq total (+ total roll)))
        (when (= 6 roll) (setq sixes (+ 1 sixes)))
        (setq dice (1- dice)))
      (list :total total :sixes sixes :rolls rolls)))

  (defun jf/gaming/the-one-ring/roll/telling-table (question likelihood)
    "Return the response from asking the telling table a yes/no QUESTION with a given LIKELIHOOD."
    (interactive (list
                  (read-string "Yes/No Question: ")
                  (completing-read "Likelihood of yes: " jf/gaming/the-one-ring/strider-mode/telling-table)))
    (concat "{{{i(Telling Table)}}}:\n"
            "\n"
            "- Question :: ‚Äú" question "‚Äù\n"
            "- Likelihood :: " likelihood "\n"
            "- Answer :: ‚Äú" (jf/roll-on-table (alist-get likelihood jf/gaming/the-one-ring/strider-mode/telling-table nil nil #'string=)) "‚Äù"
            "\n"))

  ;;;; Session Tracking
  (defvar jf/gaming/the-one-ring/strider-mode/character-sheet-filename
    (file-truename "~/git/org/denote/melange/20221128T203953--duinhir-tailwind__rpgs_the-one-ring.org"))

  (defvar jf/gaming/the-one-ring/strider-mode/campaign-index-filename
    (file-truename "~/git/org/denote/indices/20221129T091857--the-travels-of-duinhir-tailwind__rpgs_the-one-ring.org"))

  (cl-defun jf/sidebar--build (&key
                               buffer-name
                               (body nil)
                               (read-only nil)
                               (position nil)
                               (mode nil))
    "Build the sidebar from the given buffer attributes.

  Find or create the BUFFER_NAME with the given BODY and move to
  the given POSITION and toggle on the MODE.  Then set the buffer
  to READ_ONLY."
    (interactive)
    ;; If the buffer doesn't exist, create it and configure accordingly
    (unless (get-buffer buffer-name)
      (progn
        (get-buffer-create buffer-name)
        (with-current-buffer buffer-name
          (insert (or body (buffer-string)))
          (goto-char (or position (point-min)))
          (not-modified)
          (if mode (funcall mode) (special-mode))
          (when read-only (read-only-mode)))))
    (with-current-buffer buffer-name
      (local-set-key (kbd "s-w") 'kill-buffer-and-window)
      (let ((display-buffer-mark-dedicated t))
        (pop-to-buffer buffer-name '((display-buffer-in-side-window)
                                     (side . right)
                                     (window-width 72)
                                     (window-parameters
                                      (tab-line-format . none)
                                      (mode-line-format . none)
                                      (no-delete-other-windows . t)))))
      (message "s-q - Remove Window")
      (require 'pulsar)
      (pulsar-pulse-line)))

  (cl-defun jf/gaming/the-one-ring/strider-mode/pop-open-filename
      (&key (filename jf/gaming/the-one-ring/strider-mode/character-sheet-filename))
    "Pop open for viewing the given FILENAME."
    (with-current-buffer (find-file-noselect filename)
      (jf/sidebar--build
       :buffer-name filename
       :read-only t
       :body (buffer-string)
       :mode 'org-mode)))

  (cl-defmacro jf/gaming/the-one-ring/register-condition (&key condition)
    "Generate the `transient' suffix and variable for the given CONDITION."
    (let* ((var-sym (intern (concat "jf/gaming/the-one-ring/character-is-" condition)))
           (var-docstring (concat "Is the current character is " condition "?"))
           (fun-sym (intern (concat "jf/gaming/the-one-ring/character-is-" condition "/set")))
           (fun-docstring (concat "Toggle current character's \"" condition "\" condition status.")))
      `(progn
         (defvar ,var-sym
           nil
           ,var-docstring)
         (transient-define-suffix ,fun-sym ()
           ,fun-docstring
           :description '(lambda ()
                           (concat
                            (s-titleize ,condition) ": "
                            (propertize
                             (format "%s" (if ,var-sym "Yes" "No"))
                             'face 'transient-argument)))
           (interactive)
           (setq ,var-sym (not ,var-sym))))))

  (jf/gaming/the-one-ring/register-condition :condition "miserable")
  (jf/gaming/the-one-ring/register-condition :condition "weary")
  (jf/gaming/the-one-ring/register-condition :condition "wounded")

  ;; TODO: Register: Travel Fatigue, Exhaustion, Hope, Shadow Points.
  ;;       And function to "write" that to character sheet.

  ;;;; Menu
  (global-set-key (kbd "H-1") 'jf/gaming/the-one-ring/menu)
  (transient-define-prefix jf/gaming/the-one-ring/menu ()
    ["The One Ring\n"
     ["Rolls"
      ("r d" "Distinctive features‚Ä¶"
       (lambda ()
         (interactive)
         (insert
          (concat "Distinctive Features: "
                  "‚Äú" (jf/roll-on-table jf/gaming/the-one-ring/distinctive-features-table) "‚Äù "
                  "‚Äú" (jf/roll-on-table jf/gaming/the-one-ring/distinctive-features-table) "‚Äù"))))
      ("r f" "Feat die‚Ä¶"
       (lambda ()
         (interactive)
         (insert
          (format "Feat Die: %s"
                  (call-interactively 'jf/gaming/the-one-ring/roll/feat-die)))))
      ("r F" "Fortune table"
       (lambda ()
         (interactive)
         (insert (call-interactively 'jf/gaming/the-one-ring/roll/fortune-table))))
      ("r j" "Journey event (Solo)"
       (lambda ()
         (interactive)
         (insert (call-interactively 'jf/gaming/the-one-ring/roll/solo-event-table))))
      ("r l" "Lore table‚Ä¶"
       (lambda ()
         (interactive)
         (insert (call-interactively 'jf/gaming/the-one-ring/roll/lore-table))))
      ("r r" "Revelation Episode‚Ä¶"
       (lambda ()
         (interactive)
         (insert (concat "Revelation Episode: "
                         (jf/roll-on-table jf/gaming/the-one-ring/strider-mode/revelation-episode-table)))))
      ("r s" "Skill check‚Ä¶"
       (lambda ()
         (interactive)
         (insert (call-interactively 'jf/gaming/the-one-ring/roll/skill-check))))
      ("r t" "Telling table‚Ä¶"
       (lambda ()
         (interactive)
         (insert (call-interactively 'jf/gaming/the-one-ring/roll/telling-table))))
      ]
     ["Conditions"
      ("-m" jf/gaming/the-one-ring/character-is-miserable/set :transient t)
      ("-w" jf/gaming/the-one-ring/character-is-weary/set :transient t)
      ("-W"  jf/gaming/the-one-ring/character-is-wounded/set :transient t)
      ]
     ["Jump To"
      ("j c" "Character Sheet"
       (lambda ()
         (interactive)
         (jf/gaming/the-one-ring/strider-mode/pop-open-filename
          :filename jf/gaming/the-one-ring/strider-mode/character-sheet-filename)))
      ("j i" "Index of Campaign"
       (lambda ()
         (interactive)
         (jf/gaming/the-one-ring/strider-mode/pop-open-filename
          :filename jf/gaming/the-one-ring/strider-mode/campaign-index-filename)))
      ("j x" jf/gaming/the-one-ring/strider-mode/experience-milestones)
      ]])

  (provide 'jf-the-one-ring)
  ;;; jf-the-one-ring.el ends here
#+end_src
** =jf-utility.el=
#+begin_src emacs-lisp :tangle "jf-utility.el" :results none
  ;;; jf-utility.el --- Simple focus mode and extras -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;; Packages specifically here for helping with my coding activities.

  ;;; Code:

  (use-package xref
    :straight t
    :custom
    (xref-file-name-display 'project-relative)
    (xref-search-program 'ripgrep))

  (use-package tmr
    ;; A timer package.
    ;;
    ;; My dbus install is not behaving so I'm cheating with a bit of AppleScript
    :preface
    (defun jf/tmr-notification-notify (timer)
      "Dispatch a notification for TIMER."
      (let ((title "TMR May Ring (Emacs tmr package)")
             (description (tmr--timer-description timer)))
        (ns-do-applescript (concat "display notification \""
                             description
                             "\" sound name \"Glass\""))))
    :custom (tmr-notify-function #'jf/notifications-notify)
    (tmr-timer-completed-functions
      (list #'tmr-print-message-for-completed-timer
        #'tmr-sound-play
        #'jf/tmr-notification-notify))
    :straight (tmr :host nil :type git
                :repo "https://git.sr.ht/~protesilaos/tmr"))

  (use-package transient
    ;; A package for creating turbo-charged menus.  It is the backbone for the
    ;; menu-like dispatch of `magit' functionality.
    :straight t)

  (use-package ts
    ;; Timestamp library (not typescript)
    :straight t)

  ;;; Support packages

  (use-package keychain-environment
    ;; Help me manage my secrets via the OS
    ;; Load keychain environment
    :straight t
    :config (keychain-refresh-environment))

  (use-package dash
    ;; A modern list API for Emacs. No 'cl required.
    ;; (See https://github.com/magnars/dash.el/)
    :straight t)

  (use-package f
    ;; A modern API for working with files and directories in Emacs.
    ;; (See https://github.com/rejeep/f.el/)
    :straight t)

  (use-package s
    ;; The long lost Emacs string manipulation library.
    ;; (See https://github.com/magnars/s.el/)
    :straight t)

  (use-package deadgrep
    ;; Where consult-rg provides a live search feature, deadgrep provides a
    ;; resulting search buffer.  You submit your search term and get the metadata
    ;; and the matches.
    :custom (deadgrep-display-buffer-function
              (lambda (buffer) (display-buffer-same-window buffer '())))
    :straight t
    :preface
    (defun jf/deadgrep/exit-with-save ()
      "Exit deadgrep edit mode and prompt to save buffers."
      (interactive)
      (when (eq major-mode #'deadgrep-edit-mode)
        (progn
          (deadgrep-mode)
          (call-interactively 'save-some-buffers))))
    :bind (:map deadgrep-mode-map
            (("C-c C-p" . deadgrep-edit-mode)
              ("e" . deadgrep-edit-mode))
            :map deadgrep-edit-mode-map
            ("C-c C-c" . jf/deadgrep/exit-with-save)))

  (use-package wgrep
    ;; ‚ÄúEdit a grep buffer and apply those changes to the file buffer.‚Äù  In other
    ;; words, after ‚Äúsearching‚Äù for something, sending the results to a buffer
    ;; (via `embark-export' or such thing), you can edit that search results
    ;; buffer and propogate the changes to the locations of the elements that
    ;; matched the search.
    ;;
    ;;   1.  Call `consult-ripgrep' (via ~C-c f~) to search for something.
    ;;   2.  Call `embark-export' (via ~C-s-e~) to export to a grep buffer.
    ;;   3.  Call `wgrep-change-to-wgrep-mode' (via ~e~ or ~C-c C-p~)
    ;;   4.  Edit the grep buffer as you would anywhere else.
    ;;   5.  Save (via ~C-x C-s~) or Cancel (via ~C-c C-k~).
    :after (embark-consult ripgrep)
    :config (setq wgrep-auto-save-buffer t)
    (setq wgrep-change-readonly-file t)
    :straight t
    :preface
    (defun jf/wgrep-finish-edit ()
      "Finish a `wgrep' edit session."
      (interactive)
      (wgrep-save-all-buffers)
      (wgrep-finish-edit))
    :bind (:map wgrep-mode-map
            ;; Added keybinding to echo Magit behavior
            ("C-c C-c" . jf/wgrep-finish-edit)
            :map grep-mode-map
            ("e" . wgrep-change-to-wgrep-mode)
            :map ripgrep-search-mode-map
            ("e" . wgrep-change-to-wgrep-mode)))

  (use-package rg
    ;; A highly performant successor to the venerable grep.
    :after (wgrep)
    :config (rg-enable-menu)
    ;; :init (setq ripgrep-arguments "--ignore-case")
    :straight t)

  (use-package color-rg
    ;; This command provides an interface to ripgrep with results buffer that
    ;; provides a modeline with available commands.  Were it not for
    ;; `consult-ripgrep' interaction with `orderless', it would be a complete
    ;; replacement.  But I'll keep both of them around.
    :straight t
    :commands (color-rg-read-file-type color-rg-search-input color-rg-read-input)
    :custom (color-rg-search-ignore-rules "-g '!node_modules' -g '!dist' -g '!coverage' -g '!doc'")
    :config
    (defun jf/color-rg-search-project (prefix &optional keyword directory globs)
      "Dispatch to `color-rg-search-input' based on given PREFIX.

  Prompt, via `color-rg-search-input', for KEYWORD when none is given.

  No PREFIX given: search in current DIRECTORY.
  One PREFIX given: prompt for a DIRECTORY.
  Two PREFIX given: prompt for DIRECTORY and filename GLOBs."
      (interactive "p")
      (let ((keyword (or keyword (color-rg-read-input)))
             (directory (or directory
                          (if (>= (or prefix 0) 4)
                          ;; A kludge to prompt for a directory
                          (call-interactively (lambda (dir) (interactive "D") dir))
                          (color-rg-project-root-dir))))
             (globs (or globs (when (>= (or prefix 0) 16)
                        (color-rg-read-file-type "Filter file by type (default: [ %s ]): ")))))
        (color-rg-search-input keyword directory globs)))
    :bind
    ("C-c f f" . jf/color-rg-search-project)
    ("C-c f <RET>" . jf/color-rg-search-project)
    ("C-c f l" . color-rg-search-input-in-current-file)
    ("C-c f r" . consult-ripgrep)
    (:map color-rg-mode-map (("p" . color-rg-jump-prev-keyword)
                             ("n" . color-rg-jump-next-keyword))))

  (use-package visual-regexp
    ;; I haven't used much search and replace but the visual queues are useful.
    ;; And I learned about ,\ in this play.  ,\(upcase \1) will upcase the first
    ;; capture region.
    :straight t
    :bind ("C-c C-r r" . vr/replace)
    ("C-c C-r m" . vr/mc-mark)
    ("C-c C-r q" . vr/query-replace)
    ("C-c C-r p" . project-query-replace-regexp))

  ;; https://github.com/hokomo/query-replace-parallel
  ;; Presented at https://pad.emacsconf.org/2023-parallel
  (use-package query-replace-parallel
    :straight (:host github :repo "hokomo/query-replace-parallel")
    :commands (query-replace-parallel query-replace-parallel-regexp))

  (use-package crux
    ;; A mix of a few odd and useful functions.
    :straight t
    :bind (("C-a" . crux-move-beginning-of-line)
            ("<C-s-return>" . crux-smart-open-line-above)
            ("C-s-k" . crux-kill-line-backwards)
            ("<s-backspace>" . crux-kill-line-backwards)
            ("<f9>" . crux-kill-other-buffers)))

  (use-package math-at-point
    ;; Sometimes you just want to do math
    :straight (math-at-point :type git :host github
                :repo "shankar2k/math-at-point")
    :bind ("C-c =" . math-at-point))

  ;;;; Hammerspoon --------------------------------------------------------------

  ;; Hammerspoon is a Lua application that provides a consistent API for
  ;; interacting with MacOS.  The editWithEmacs.spoon allows me to copy text from
  ;; one region, edit it in Emacs, and paste it back into the Application.
  (when (file-directory-p
          "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon")
    (load
      "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el"
      nil
      jf/silence-loading-log))

  (require 'transient)
  ;; this suffix provides a dynamic description of the current major mode for a
  ;; `hammerspoon-edit-minor-mode' buffer.  And the prefix‚Äôs function toggles
  ;; that mode.
  (transient-define-suffix jf/hammerspoon-toggle-mode ()
    "Set the hammerspoon mode."
    :description '(lambda ()
                    (concat
                      "Hammerspoon Mode: "
                      (propertize
                        (format "%s" major-mode)
                        'face 'transient-argument)))
    (interactive)
    (hammerspoon-toggle-mode))

  ;; The following function facilitates a best of both worlds.  By default, I
  ;; want Option to be Meta (e.g. \"M-\") in Emacs.  However, I can toggle that
  ;; setting.  That way if I need an umlaut (e.g., \"¬®\"), I can use MacOS‚Äôs
  ;; native functions to type \"‚å•\" + \"u\".
  ;;
  ;; I like having MacOS‚Äôs native Option (e.g. =‚å•=) modifier available.  But
  ;; using that default in Emacs would be a significant hinderance.
  (defun jf/toggle-osx-alternate-modifier ()
    "Toggle native OS-X Option modifier setting (e.g. `ns-alternate-modifier')."
    (interactive)
    (if ns-alternate-modifier
      (progn (setq ns-alternate-modifier nil)
        (message "Enabling OS X native Option modifier"))
      (progn (setq ns-alternate-modifier 'meta)
        (message "Disabling OX X native Option modifier (e.g. Option as Meta)"))))

  ;; I try to get quick feedback when writing emacs-lisp; the
  ;; `jf/eval-region-dwim' binds a mnemonic key sequence to an extend
  ;; `eval-region'.
  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'jf/eval-region-dwim)
  (defun jf/eval-region-dwim ()
    "When region is active, evaluate it and kill the mark.

  Else, evaluate the whole buffer."
    (interactive)
    (if (not (region-active-p))
      (progn
        (message "Evaluating buffer...")
        (eval-buffer))
      (progn
        (message "Evaluating region...")
        (eval-region (region-beginning) (region-end)))
      (setq-local deactivate-mark t)))

  (global-set-key (kbd "C-k") 'jf/kill-line-or-region)
  (defun jf/kill-line-or-region (&optional arg)
    "Kill the selected region otherwise kill the ARG number of lines."
    (interactive "P")
    (if (use-region-p)
      (kill-region (region-beginning) (region-end))
      (kill-line arg)))

  (global-set-key (kbd "C-c n") 'jf/yank-file-name-to-clipboard) ;; Deprecated
  (global-set-key (kbd "C-c y n") 'jf/yank-file-name-to-clipboard)
  (defun jf/yank-file-name-to-clipboard (arg)
    "Nab, I mean copy, the current buffer file name to the clipboard.

    When you pass one universal prefix ARG, nab the project relative filename.
    When you pass two or more prompt for different aspects of a file."
    ;; https://blog.sumtypeofway.com/posts/emacs-config.html
    (interactive "P")
    (let* ((prefix (car arg))
            (raw-filename
              (if (equal major-mode 'dired-mode)
                default-directory
                (buffer-file-name)))
            (filename
              (cond
                ((not prefix) raw-filename)
                ((= prefix 4) (concat "./" (file-relative-name raw-filename (projectile-project-root))))
                ((>= prefix 16)
                  (let ((options '(("Filename, Basename" .
                         (lambda (f) (file-name-nondirectory f)))
                        ("Filename, Project Relative" .
                          (lambda (f) (concat "./" (file-relative-name f (projectile-project-root)))))
                        ("Filename, Full" .
                          (lambda (f) (f)))
                        ("Dirname" .
                          (lambda (f) (file-name-directory f)))
                        ("Dirname, Project Relative" .
                          (lambda (f) (concat "./" (file-relative-name (file-name-directory f) (projectile-project-root))))))))
                    (funcall (alist-get (completing-read "Option: " options nil t)
                                         options nil nil #'string=)
                      raw-filename))))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))

  (defun jf/sort-unique-lines (reverse beg end
                                &optional adjacent keep-blanks interactive)
    "Sort lines and delete duplicates.

    By default the sort is lexigraphically ascending.  To sort as
    descending set REVERSE to non-nil.  Specify BEG and END for the
    bounds of sorting.  By default, this is the selected region.

    I've included ADJACENT, KEEP-BLANKS, and INTERACTIVE so I can
    echo the method signature of `sort-lines' and
    `delete-duplicate-lines'"
    (interactive "P\nr")
    (sort-lines reverse beg end)
    (delete-duplicate-lines beg end reverse adjacent keep-blanks interactive))

  ;; Sometimes I just want to duplicate an area without copy and paste.  This
  ;; helps that process.  It‚Äôs not as smart as TextMate‚Äôs equivalent function,
  ;; but it‚Äôs close enough.
  (global-set-key (kbd "C-M-d") 'jf/duplicate-current-line-or-lines-of-region)
  (global-set-key (kbd "C-c d") 'jf/duplicate-current-line-or-lines-of-region)
  (defun jf/duplicate-current-line-or-lines-of-region (arg)
    "Duplicate ARG times current line or the lines of the current region."
    (interactive "p")
    (if (use-region-p)
      (progn
        (when (> (point) (mark))
          (exchange-point-and-mark))
        (beginning-of-line)
        (exchange-point-and-mark)
        (end-of-line)
        (goto-char (+ (point) 1))
        (exchange-point-and-mark)
        (let* ((end (mark))
                (beg (point))
                (region
                  (buffer-substring-no-properties beg end)))
          (dotimes (_i arg)
            (goto-char end)
            (insert region)
            (setq end (point)))))
      (crux-duplicate-current-line-or-region arg)))

  ;; A simple wrapper around scratch, that helps name it and sets the major mode
  ;; to `org-mode'.
  (global-set-key (kbd "<f12>") 'jf/create-scratch-buffer)
  (cl-defun jf/create-scratch-buffer (&optional arg)
    "Create a `scratch' buffer; if ARG given create a `denote' scratch note."
    (interactive "P")
    (if (car arg)
      (jf/denote/create-scratch (format-time-string "%Y-%m-%d Scratch"))
      (progn
        (crux-create-scratch-buffer)
        (rename-buffer (concat "*scratch* at " (format-time-string "%Y-%m-%d %H:%M")))
        (org-mode))))

  ;; Sometimes I want to move, without renaming, a file.  This function helps
  ;; make that easy.
  (global-set-key (kbd "C-x m") 'jf/move-file)
  (defun jf/move-file (target-directory)
    "Write this file to TARGET-DIRECTORY, and delete old one."
    (interactive "DTarget Directory: ")
    (let* ((source (expand-file-name (file-name-nondirectory
                                       (buffer-file-name))
                     default-directory))
            (target (f-join target-directory (file-name-nondirectory
                                               (buffer-file-name)))))
      (save-buffer)
      (rename-file source target)
      (kill-current-buffer)))

  (global-set-key (kbd "s-5") 'jf/org-insert-immediate-active-timestamp)
  (defun jf/org-insert-immediate-active-timestamp (arg)
    "Insert an active date for today.

    One universal ARG prompts for date
    Two universal ARG inserts timestamp.
    then insertes active date."
    ;; Insert an active timestamp, with a few options.
    (interactive "P")
    (let ((prefix (car arg)))
      (cond
        ((not prefix)  (org-insert-time-stamp nil nil nil))
        ((= prefix 4) (org-insert-time-stamp (org-read-date nil t nil "Date")
                        nil nil))
        ((>= prefix 16)  (org-insert-time-stamp nil t nil)))))

  (global-set-key (kbd "C-w") 'jf/delete-region-or-backward-word)
  (global-set-key (kbd "M-DEL") 'jf/delete-region-or-backward-word)
  (global-set-key (kbd "<C-M-backspace>") 'backward-kill-paragraph)
  (defun jf/delete-region-or-backward-word (&optional arg)
    "Delete selected region otherwise delete backwards the ARG number of words."
    (interactive "p")
    (if (region-active-p)
      (delete-region (region-beginning) (region-end))
      (jf/delete-word (- arg))))

  (defun jf/delete-word (arg)
    "Delete characters forward until encountering the end of a word.

  With ARG, do this that many times."
    (interactive "p")
    (if (use-region-p)
      (delete-region (region-beginning) (region-end))
      (delete-region (point) (progn (forward-word arg) (point)))))

  (defun jf/auto-create-missing-dirs ()
    "Ensure that we create directories along the new path."
    ;; Ensure that we create the directories along the path of a new file I‚Äôm
    ;; creating.  See
    ;; https://emacsredux.com/blog/2022/06/12/auto-create-missing-directories/
    (let ((target-dir (file-name-directory buffer-file-name)))
      (unless (file-exists-p target-dir)
        (make-directory target-dir t))))

  (add-to-list 'find-file-not-found-functions #'jf/auto-create-missing-dirs)

  (use-package run-command
    ;; A means of registering shell commands that I can easily run in Emacs.
    :straight t
    :preface
    (defun jf/run-command-recipes ()
      "Run command recipes"
      (list
        (let ((dir (projectile-project-root)))
          (when (f-exists? (f-join (projectile-project-root) "Gemfile.lock"))
            (list :command-name "run-command-samvera-versions"
              ;; TODO: Extract some of this as a command.
              :command-line (format "cd %s; rg \"^ +((bulk|hy)rax([-_].*)?|\\(*.\\)iiif\\(*.\\)|rails|qa|blacklight([-_].*)?) \\(\\d+\\.\\d+\\.\\d+\" Gemfile.lock | sort" dir)
              :display (format "Samvera gem versions for %s" dir))))
        (list :command-name "install-dotzshrc-files"
          :command-line "cd ~/git/dotzshrc; ruby install.rb"
          :display "Install dotzshrc files")
        (list :command-name "run-command-takeonrules-server"
          :command-line "cd ~/git/takeonrules.source/; bin/rake knowledge_manager:pull"
          :display "Serve takeonrules.com locally")))
    :config
    (add-to-list 'run-command-recipes 'jf/run-command-recipes))

  (defun jf/get-line-text (&optional delta)
    "Copy the text of the line at DELTA lines from point.

  TODO: This function pollutes the `mark-ring' and `kill-ring'; I think
  I'm okay with that behavior, but I'm putting it here to mention it ‚Äúout loud‚Äù."
    (interactive "P")
    (save-excursion
      (when delta (forward-line (if (numberp delta) delta (car delta))))
      (beginning-of-line)
      (set-mark (point))
      (end-of-line)
      (copy-region-as-kill (mark) (point)))
    (let ((text (substring-no-properties (car kill-ring))))
      text))

  (defun jf/filename/tilde-based (filename)
    "Return ~/ relative FILENAME."
    (string-replace (getenv "HOME") "~"
      (if (consp filename) (cadr filename) filename)))

  (provide 'jf-utility)
  ;;; jf-utility.el ends here
#+end_src
** =jf-versioning.el=
#+begin_src emacs-lisp :tangle "jf-versioning.el" :results none
  ;;; jf-versioning.el --- Simple focus mode and extras -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;;; Code:
  (use-package git-modes
    ;; A mode for editing gitconfig files.
    :straight t)

  (use-package emacsql
    :straight (:host github :repo "magit/emacsql"))

  (use-package magit
    ;; A fantastic UI for git commands; the interactive rebase is an absolute
    ;; wonder tool (see
    ;; https://takeonrules.com/2023/01/12/using-the-git-interactive-staging-as-a-moment-to-facilitate-synthesis/).
    ;; Also the progenitor of `transient'
    :straight (:host github :repo "magit/magit")
    :commands (magit-process-git)
    ;; My "~/bin/editor" script was causing problems in that it was asking to wait.
    :init (use-package with-editor
            :straight t
            :custom (with-editor-emacsclient-executable (file-truename "~/bin/git_editor")))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Adding format to git-commit-fill-column of 72 as best practice.
    (setq git-commit-fill-column 72)
    ;; Keeping the summary terse helps with legibility when you run a
    ;; report with only summary.
    (setq git-commit-summary-max-length 50)
    ;; Set the tabular display columns for the `magit-list-repositories'
    (setq magit-repolist-columns
      '(("Name"    25 magit-repolist-column-ident ())
         ("Version" 25 magit-repolist-column-version ())
         ("Œ¥"        1 magit-repolist-column-flag ())
         ("‚á£"        3 magit-repolist-column-unpulled-from-upstream
           ((:right-align t)
             (:help-echo "Upstream changes not in branch")))
         ("‚á°"        3 magit-repolist-column-unpushed-to-upstream
           ((:right-align t)
             (:help-echo "Local changes not in upstream")))
         ("Branch"  25 magit-repolist-column-branch ())
         ("Path"    99 magit-repolist-column-path ())))
    ;; Have magit-status go full screen and quit to previous
    ;; configuration.  Taken from
    ;; http://whattheemacsd.com/setup-magit.el-01.html#comment-748135498
    ;; and http://irreal.org/blog/?p=2253
    ;; (defadvice magit-status (around magit-fullscreen activate)
    ;;   (window-configuration-to-register :magit-fullscreen)
    ;;   ad-do-it
    ;;   (delete-other-windows))
    ;; (defadvice magit-mode-quit-window (after magit-restore-screen activate)
    ;;   (jump-to-register :magit-fullscreen))
    :config
    ;; (use-package libgit :straight t)
    (remove-hook 'magit-status-sections-hook 'magit-insert-tags-header)
    :preface
    (defun jf/magit-browse-pull-request ()
      "In `magit-log-mode' open the associated pull request
    at point.

    Assumes that the commit log title ends in the PR #, which
    is the case when you use the Squash and Merge strategy.

    This implementation is dependent on `magit' and `s'."
      (interactive)
      (let* ((beg (line-beginning-position))
              (end (line-end-position))
              (summary
                (buffer-substring-no-properties
                  beg end)))
        (jf/open-pull-request-for :summary summary)))
    (defun jf/git-current-remote-url ()
      "Get the current remote url."
      (s-trim
        (shell-command-to-string
          (concat
            "git remote get-url "
            (format "%s" (magit-get-current-remote))))))
    (cl-defun jf/open-pull-request-for (&key summary)
      "Given the SUMMARY open the related pull request.

    This method assumes you're using Github's Squash and Strategy."
      (let ((remote-url (jf/git-current-remote-url)))
        (save-match-data
          (and (string-match "(\\#\\([0-9]+\\))$" summary)
            (browse-url
              (concat
                ;; I tend to favor HTTPS and the repos end in ".git"
                (s-replace ".git" "" remote-url)
                "/pull/"
                (match-string 1 summary)))))))
    (defun jf/open-pull-request-for-current-line ()
      "For the current line open the applicable pull request."
      (interactive)
      (let ((summary
              (s-trim
                (shell-command-to-string
                  (concat "git --no-pager annotate "
                    "-w -L "
                    (format "%s" (line-number-at-pos))
                    ",+1 "
                    "--porcelain "
                    buffer-file-name
                    " | rg \"^summary\"")))))
        (jf/open-pull-request-for :summary summary)))
    :bind (("C-c m" . magit-status)
            ("C-x g m" . magit-status)
            ("C-x g f" . magit-file-dispatch)
            ("C-x g d" . magit-dispatch))
    ;; In other situations I bind s-6 to `git-messenger:popup-message'
    :bind (:map magit-log-mode-map ("C-x g b" . #'jf/magit-browse-pull-request))
    :hook ((with-editor-post-finish . #'magit-status)
            (git-commit-mode . (lambda () (setq fill-column git-commit-fill-column)))))

  (setq auth-sources (list "~/.authinfo"))

  (use-package forge
    ;; :commands (forge-mode)
    ;; :hook ((magit-status-sections . #'forge-insert-pullreqs)
    ;;         (magit-status-sections . #'forge-insert-assigned-issues))
    :bind ("C-s-f" . #'forge-dispatch)
    :straight (:host github :repo "magit/forge"))

  (defvar jf/version-control/valid-commit-title-prefixes
    '("üéÅ: feature (A new feature)"
       "üêõ: bug fix (A bug fix)"
       "üìö: docs (Changes to documentation)"
       "üíÑ: style (Formatting, missing semi colons, etc; no code change)"
       "‚ôªÔ∏è: refactor (Refactoring production code)"
       "‚òëÔ∏è: tests (Adding tests, refactoring test; no production code change)"
       "üßπ: chore (Updating build tasks, package manager configs, etc; no production code change)"
       "üõ†: build"
       "üí∏: minting a new version"
       "üîÑ: revert"
       "ü¶Ñ: spike (Indicates research task; usually creates more tickets)"
       "‚òÑÔ∏è: epic (Enumeration of lots of other issues/tasks)"
       "‚öôÔ∏è: config changes"
       "üé¨: initial commit or setup of project/component"
       "üöß: work in progress (WIP)"
       "ü§ñ: continuous integration (CI) changes")
    ;; The following list was pulled from http://udacity.github.io/git-styleguide/
    ;;
    ;; '("feat: A new feature"
    ;;    "fix: A bug fix"
    ;;    "docs: Changes to documentation"
    ;;    "style: Formatting, missing semi colons, etc; no code change"
    ;;    "refactor: Refactoring production code"
    ;;    "test: Adding tests, refactoring test; no production code change"
    ;;    "chore: Updating build tasks, package manager configs, etc; no production code change")
    "Team üíú Violet üíú 's commit message guidelines on <2023-05-12 Fri>.")

  (use-package git-commit
    :straight t
    :hook ((git-commit-mode . jf/git-commit-mode-setup))
    :bind (:map git-commit-mode (("TAB" .  #'completion-at-point)))
    :preface
    (defun jf/git-commit-mode-setup ()
      ;; Specify config capf
      (setq-local completion-at-point-functions
                    (cons #'jf/version-control/issue-capf
                            (cons #'jf/version-control/project-capf
                              completion-at-point-functions)))
      (goto-char (point-min))
      (beginning-of-line-text)
      (when (looking-at-p "^$")
        (jf/insert-task-type-at-point :at (point-min)))))

  (global-set-key (kbd "s-7") #'jf/insert-task-type-at-point)
  (cl-defun jf/insert-task-type-at-point (&key (splitter ":") (padding " ") (at nil))
    "Select and insert task type.

  Split result on SPLITTER and insert result plus PADDING.  When
  provided AT, insert character there."
    (interactive)
    (let ((commit-type (completing-read "Commit title prefix: "
                         jf/version-control/valid-commit-title-prefixes nil t)))
      (when at (goto-char at))
      (insert (car (s-split splitter commit-type)) padding)))

  ;; COMMENTED OUT FOR FUTURE REFERENCE
  ;; (transient-define-prefix jf/magit-aux-commands ()
  ;;   "My personal auxiliary magit commands."
  ;;   ["Auxiliary commands"
  ;;    ("d" "Difftastic Diff (dwim)" jf/magit-diff-with-difftastic)
  ;;    ("s" "Difftastic Show" jf/magit-show-with-difftastic)])

  ;; (require 'magit)
  ;; (transient-append-suffix 'magit-dispatch "!"
  ;;   '("#" "My Magit Cmds" jf/magit-aux-commands))

  ;; (define-key magit-status-mode-map (kbd "#") #'jf/magit-aux-commands)

  (use-package git-timemachine
    ;; With the time machine, travel back and forth through a files history.
    :straight (:host github :repo "emacsmirror/git-timemachine"))

  (use-package git-gutter
    ;; Show the current git state in the gutter.  As you edit a line in a file
    ;; track by git, the indicators change to reflect if this is a modification,
    ;; addition, or deletion.
    :straight t
    :custom (git-gutter:update-interval 0.25)
    :bind ("C-x g =" . git-gutter:popup-hunk)
    ("C-x g p" . git-gutter:previous-hunk)
    ("C-x g n" . git-gutter:next-hunk)
    :init (global-git-gutter-mode t)
    (setq git-gutter:modified-sign "Œî"
      git-gutter:added-sign "+"
      git-gutter:deleted-sign "-"))

  (use-package git-link
    ;; Type ~M-x git-link~ and the function pushes the Git forge URL to the kill
    ;; ring; I‚Äôve configured the URL to use the SHA of the commit of the line on
    ;; which I called `git-link'.  This is helpful for sharing links with other
    ;; folks.  I use this /all of the time./ See https://github.com/sshaw/git-link.
    :config
    (defun jf/git-browse-to-repository (remote)
      "Open in external browser the current repository's given REMOTE."
      (interactive (list (git-link--select-remote)))
      (git-link-homepage remote)
      (browse-url (car kill-ring)))
    (setq git-link-use-commit t) ;; URL will be SHA instead of branch
    :straight t)

  (use-package git-messenger
    ;; Sometimes I want to see more ~git~ information regarding the current line.
    ;; `git-messenger' provides a popup that shows the information and provides
    ;; some additional options.
    :config (setq git-messenger:show-detail t)
    (defun jf/git-messenger-popup ()
      "Open `git-messenger' or github PR.

    With universal argument, open the github PR for current line.

    Without universal argument, open `git-messenger'."
      (interactive)
      (if (equal current-prefix-arg nil) ; no C-u
        (git-messenger:popup-message)
        (jf/open-pull-request-for-current-line)))
    :custom
    (git-messenger:use-magit-popup t)
    :bind (:map git-messenger-map (("p" . 'jf/open-pull-request-for-current-line)
                                    ("l" . 'git-link)))
    :bind (("s-6" . jf/git-messenger-popup)
            ("C-x g b" . jf/git-messenger-popup))
    :straight t)

  (use-package blamer
    ;; When working in code, I want different ways to view the metadata around the
    ;; code.  This adds a quick annotation to the current line; When did the last
    ;; person touch this and what was the message.  It's most useful aspect is
    ;; seeing multiple lines without relying on the blame.
    :straight (blamer :host github :repo "Artawower/blamer.el")
    :custom
    ;; Set to 0 because I don‚Äôt enable by default.  So I‚Äôm in a mindset of show
    ;; me who and when.
    (blamer-idle-time 0.0)
    (blamer-author-formatter "‚úé %s ")
    (blamer-datetime-formatter "[%s] ")
    (blamer-commit-formatter "‚óè %s")
    (blamer-min-offset 40)
    (blamer-max-commit-message-length 20))

  (use-package savehist
    ;; Save my history.
    :init
    (savehist-mode))

  ;; (use-package savekill
  ;;   ;; Write "kill" command inputs to disk.
  ;;   :straight t)

  (use-package undo-tree
    ;; Provides a UI for undo trees.  I'm not certain what I want to do with this.
    :straight t
    :bind (("C-z" . undo)
            ("C-s-z" . undo-tree-redo))
    :custom (undo-tree-history-directory-alist ("." . "~/.emacs.d/undo-tree/"))
    :init
    (unless (f-dir? "~/.emacs.d/undo-tree/") (mkdir "~/.emacs.d/undo-tree/"))
    :config
    (global-undo-tree-mode +1))

  (provide 'jf-versioning)
  ;;; jf-versioning.el ends here
#+end_src
** =jf-windows.el=
#+begin_src emacs-lisp :tangle "jf-windows.el" :results none
  ;;; jf-windows.el --- Working to manage my windows -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:
  ;;
  ;; This package provides theme, frame, and window support.

  ;;; Code:

  ;;;; Themes
  (mapc #'disable-theme custom-enabled-themes)

  (use-package window
    ;; Wrangle up how windows and buffers display.
    :straight (:type built-in)
    :custom
    (display-buffer-alist
      '(;; no windows
         ("\\*elfeed-curate-annotation\\*"
           (display-buffer-in-side-window)
           (window-height . 0.33)
           (side . bottom)
           (window-parameters . ((mode-line-format . (" %b")))))
         ("\\`\\*Async Shell Command\\*\\'"
           (display-buffer-no-window))
         ;; I like the slide out window for this "context-type menus"
         ("\\*\\(eldoc\\|Ilist\\|Embark Actions\\|helpful .*\\)\\*"
           (display-buffer-in-side-window)
           (window-width . 0.5)
           (side . right)
           (slot . 0)
           (window-parameters . ((mode-line-format . (" %b")))))
         ("*Register Preview*" (display-buffer-reuse-window))))
         ;; (t (display-buffer-reuse-window display-buffer-same-window))))
    :bind (("s-q" . #'jf/bury-or-unbury-buffer))
    :config (setq confirm-kill-emacs #'yes-or-no-p)
    :preface
    ;; For some reason, the C-x 5 0 keybindings don't set in my brain.
    (defun jf/bury-or-unbury-buffer (&optional prefix)
      "Without PREFIX `bury-buffer' a buffer.

  With one universal PREFIX, `unbury-buffer'.
  With two universal PREFIX `delete-frame'.
  With three or more universal PREFIX `save-buffers-kill-emacs'."
      (interactive "p")
      (cond
        ((eq prefix nil) (if buffer-read-only (kill-current-buffer) (bury-buffer)))
        ((>= prefix 64) (save-buffers-kill-emacs t))
        ((>= prefix 16) (delete-frame))
        ((>= prefix 4) (unbury-buffer))
        (t (if buffer-read-only (kill-current-buffer) (bury-buffer)))))
    (cl-defun jf/side-window-toggle ()
      "Either bury the dedicated buffer or open one based on `current-buffer'."
      (interactive)
      (if (window-dedicated-p)
        (bury-buffer)
        (call-interactively #'jf/display-buffer-in-side-window)))
    ;; Inspired by
    ;; https://www.reddit.com/r/emacs/comments/12l6c19/comment/jg98fk4/
    (cl-defun jf/display-buffer-in-side-window (&optional (buffer (current-buffer))
                                                 &key (side 'right) (size 0.4) (slot 0))
      "Display BUFFER in dedicated side window.

  With universal prefix, use left SIDE instead of right.  With two
  universal prefixes, prompt for SIDE and SLOT and SIZE (which allows
  setting up an IDE-like layout)."
      (interactive (list (current-buffer)
                     :side (pcase current-prefix-arg
                             ('nil 'right)
                             ('(4) 'left)
                             (_ (intern (completing-read "Side: "
                                          '(left right top bottom) nil t))))
                     :size (pcase current-prefix-arg
                             ('nil 0.45)
                             ('(4) 0.45)
                             (_ (read-number "Size: " 0.45)))
                     :slot (pcase current-prefix-arg
                             ('nil 0)
                             ('(4) 0)
                             (_ (read-number "Slot: ")))))
      (let ((display-buffer-mark-dedicated t)
             (size-direction (pcase side
                               ('right 'window-width)
                               ('left 'window-width)
                               (_ 'window-height))))
        ;; Question: Do I assume that I'll be focused in that new window?  If so,
        ;; consider `pop-to-buffer'.  Otherwise `display-buffer' will open the
        ;; buffer but leave focus in the originating window.
        (display-buffer buffer
          `(display-buffer-in-side-window
             (,size-direction . ,size)
             (side . ,side)
             (slot . ,slot)
             (window-parameters
               (mode-line-format . (" Dedicate: %b"))
               (no-delete-other-windows . t))))
        ;; The pulse makes sense when I'm using `display-buffer'.
        (pulsar-pulse-line-green))))

  ;; Show tabs as they are tricky little creatures
  (defface jf/tabs-face '((default :inherit font-lock-misc-punctuation-face))
    "Help me see tabs; they are tricky creatures.")
  (defface jf/bom-face '((default :inherit font-lock-misc-punctuation-face))
    "Help me see BOM characters \"Ôªø\"; they are tricky!")

  (add-hook 'prog-mode-hook
    (lambda () (font-lock-add-keywords nil '(("\t" . 'jf/tabs-face)))
      (font-lock-add-keywords nil '(("Ôªø" . 'jf/bom-face)))
      ))
  (add-hook 'text-mode-hook
    (lambda () (font-lock-add-keywords nil '(("\t" . 'jf/tabs-face)))
      (font-lock-add-keywords nil '(("Ôªø" . 'jf/bom-face)))
      ))

  ;; And now the theme.  I‚Äôve chosen the modus themes (e.g. ~modus-vivendi~ and
  ;; ~modus-operandi~).  They provide a light and dark theme with a focus on visual
  ;; accessibility.
  (defun jf/modus-themes-custom-faces ()
    "Set the various custom faces for both `treesit' and `tree-sitter'."
    (modus-themes-with-colors
      (custom-set-faces
        `(rpgtk-critical-success-roll
           ((,c :weight ultra-bold :foreground ,green)))
        `(rpgtk-successful-roll
            ((,c :weight bold :foreground ,olive)))
        `(rpgtk-failed-roll
           ((,c :weight bold :foreground ,rust)))
        `(rpgtk-critical-failure-roll
           ((,c :weight ultra-bold :foreground ,red-intense)))
        `(rpgtk-middlin-roll
           ((,c :weight bold :foreground ,yellow-intense)))
        `(rpgtk-other-roll
           ((,c :weight bold :foreground ,gold)))
        `(rpgtk-roll-expression
           ((,c :foreground ,gold)))
        `(rpgtk-display-dice-sequence
           ((,c :foreground ,fg-dim)))
        `(rpgtk-display-dice-sequence-separator
           ((,c :foreground ,fg-space)))
        `(rpgtk-display-dice-sequence-border
           ((,c :foreground ,fg-space)))
        `(rpgtk-dimmed-display
           ((,c :foreground ,fg-space)))
        `(rpgtk-bright-display
           ((,c :foreground ,fg-main)))
        ;; `(org-meta-line
        ;;   ((,c (:foreground ,yellow-faint))))
        `(denote-faces-link
           ((,c (:inherit link
                  :box (:line-width (1 . 1)
                         :color ,border-mode-line-inactive
                         :style released-button)))))
        `(jf/bom-face
           ((,c (:width ultra-expanded :box (:line-width (2 . 2)
                                              :color ,underline-err
                                              :style released-button)))))
        `(jf/tabs-face
           ((,c :underline (:style wave :color ,bg-blue-intense))))
        `(jf/org-faces-date
           ((,c :underline nil :foreground ,cyan-faint)))
        `(jf/org-faces-epigraph
           ((,c :underline nil :slant oblique :foreground ,fg-alt)))
        `(jf/org-faces-abbr
           ((,c :underline t :slant oblique :foreground ,fg-dim)))
        `(org-list-dt
           ((,c :bold t :slant italic :foreground ,fg-alt)))
        `(font-lock-misc-punctuation-face
           ((,c :foreground ,green-warmer)))
        `(org-block
           ((,c :background ,bg-ochre)))
        `(org-block-begin-line
           ((,c :background ,bg-lavender)))
        `(org-block-end-line
           ((,c :background ,bg-lavender)))
        `(hl-todo
           ((,c :foreground ,red-faint)))
        `(color-rg-font-lock-header-line-text
           ((,c :foreground ,green)))
        `(color-rg-font-lock-header-line-keyword
           ((,c :foreground ,keybind)))
        `(color-rg-font-lock-function-location
           ((,c :foreground ,keybind)))
        `(color-rg-font-lock-header-line-edit-mode
           ((,c :foreground ,keybind)))
        `(color-rg-font-lock-header-line-directory
           ((,c :foreground ,fg-link :background ,bg-link)))
        `(color-rg-font-lock-command
           ((,c :foreground ,fg-alt :background ,bg-inactive)))
        `(color-rg-font-lock-file
           ((,c :foreground ,fg-link :background ,bg-link)))
        `(color-rg-font-lock-line-number
           ((,c :background ,bg-line-number-inactive :foreground ,fg-line-number-inactive)))
        `(color-rg-font-lock-column-number
           ((,c :background ,bg-line-number-inactive :foreground ,fg-line-number-inactive)))
        `(color-rg-font-lock-position-splitter
           ((,c :background ,bg-line-number-inactive :foreground ,fg-line-number-inactive)))
        `(color-rg-font-lock-match
           ((,c :background ,bg-completion-match-3 :foreground ,fg-completion-match-3)))
        `(color-rg-font-lock-mark-changed
           ((,c :backgr
              ound ,bg-changed :foreground ,fg-changed)))
        `(color-rg-font-lock-mark-deleted
           ((,c :background ,bg-removed :foreground ,fg-removed)))
        `(fill-column-indicator
           ((,c :width ultra-condensed :background ,fringe :foreground ,fringe)))
        `(font-lock-regexp-face
           ((,c :foreground ,red))))))

  (add-hook 'modus-themes-after-load-theme-hook
    #'jf/modus-themes-custom-faces)

  (use-package modus-themes
    ;; I love [[http://protesilaos.com][Prot]]‚Äôs attention to detail with the modus
    ;; themes.  Here‚Äôs my configuration for these two sibling themes.  There‚Äôs a
    ;; bit of chatter, but all told it sets things up how I like.
    :straight (:type git :host gitlab :repo "protesilaos/modus-themes" :branch "main")
    :init
    (setq modus-themes-italic-constructs t
      modus-themes-bold-constructs t
      modus-themes-mixed-fonts t
      modus-themes-variable-pitch-ui nil
      modus-themes-custom-auto-reload t
      modus-themes-disable-other-themes t
      modus-themes-org-blocks 'tinted-background
      modus-themes-common-palette-overrides
      '(
         (comment yellow-faint)
         (string green)
         ;; Favoring more of the defaults; below is some settings I've used for
         ;; quite a while (paired with the above)
         ;;
         ;;    (builtin magenta)
         ;;    (constant magenta-cooler)
         ;;    (docstring green-warmer)
         ;;    (docmarkup magenta-faint)
         ;;    (fnname magenta-warmer)
         ;;    (keyword cyan)
         ;;    (preprocessor cyan-cooler)
         ;;    (type magenta-cooler)
         ;;    (variable blue-warmer)
         ;;    (rx-construct red-faint)
         ;;    (rx-backslash blue-cooler)
         )
      modus-themes-completions '((matches . (extrabold))
                                  (selection . (semibold accented))
                                  (popup . (accented intense)))
      modus-themes-headings
      '((1 . (variable-pitch bold 1.7))
         (2 . (overline semibold 1.5))
         (3 . (monochrome overline 1.4 background))
         (4 . (overline 1.3))
         (5 . (rainbow 1.2))
         (6 . (rainbow 1.15))
         (t . (rainbow 1.1)))))

  (defun jf/dark ()
    "Toggle system-wide Dark or Light setting."
    (interactive)
    (shell-command "osascript -e 'tell application \"System Events\" to tell appearance preferences to set dark mode to not dark mode'")
    (jf/emacs-theme-by-osx-appearance))

  (defun jf/emacs-theme-by-osx-appearance ()
    "Set theme based on OSX appearance state."
    (if (equal "Dark" (substring
                        (shell-command-to-string
                          "defaults read -g AppleInterfaceStyle")
                        0 4))
      (modus-themes-load-theme 'modus-vivendi-tinted)
      (modus-themes-load-theme 'modus-operandi-tinted)))

  (jf/emacs-theme-by-osx-appearance)


  ;; https://macowners.club/posts/custom-functions-5-navigation/
  (global-set-key (kbd "C-x 2") #'jf/nav-split-and-follow-below)
  (defun jf/nav-split-and-follow-below ()
    "Split the selected window in two with the new window is below.
  This uses `split-window-below' but follows with the cursor."
    (interactive)
    (split-window-below)
    (other-window 1))

  (global-set-key (kbd "C-x 3") #'jf/nav-split-and-follow-right)
  (defun jf/nav-split-and-follow-right ()
    "Split the selected window in two with the new window is to the right.
  This uses `split-window-right' but follows with the cursor."
    (interactive)
    (split-window-right)
    (other-window 1))

  (global-set-key (kbd "s-\\") #'jf/nav-toggle-split-direction)
  (defun jf/nav-toggle-split-direction ()
    "Toggle window split from vertical to horizontal.
  This work the other way around as well.
  Credit: https://github.com/olivertaylor/dotfiles/blob/master/emacs/init.el"
    (interactive)
    (if (> (length (window-list)) 2)
        (error "Can't toggle with more than 2 windows")
      (let ((was-full-height (window-full-height-p)))
        (delete-other-windows)
        (if was-full-height
            (split-window-vertically)
          (split-window-horizontally))
        (save-selected-window
          (other-window 1)
          (switch-to-buffer (other-buffer))))))


  (provide 'jf-windows)
  ;;; jf-windows.el ends here
#+end_src
** =jf-writing.el=
#+begin_src emacs-lisp :tangle "jf-writing.el" :results none
  ;;; jf-writing.el --- General writing functions -*- lexical-binding: t -*-

  ;; Copyright (C) 2022  Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>

  ;; This file is NOT part of GNU Emacs.
  ;;; Commentary:

  ;; Packages specifically here for helping with my writing activities.

  ;;; Code:

  (require 'jf-org-mode)
  (require 'jf-denote)

  (use-package emojify
    ;; All the people using emojiis; why not
    :straight t
    :config
    (defun --set-emoji-font (frame)
      "Adjust the font settings of FRAME so Emacs can display emoji properly."
      (if (eq system-type 'darwin)
    ;; For NS/Cocoa
    (set-fontset-font t
          'symbol
          (font-spec :family "Apple Color Emoji")
          frame
          'prepend)
        ;; For Linux
        (set-fontset-font t
        'symbol
        (font-spec :family "Symbola")
        frame
        'prepend)))
    ;; For when Emacs is started in GUI mode:
    (--set-emoji-font nil)
    ;; Hook for when a frame is created with emacsclient
    ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
    (add-hook 'after-make-frame-functions '--set-emoji-font))

  (use-package sdcv-mode
    ;; This follows from
    ;; http://mbork.pl/2017-01-14_I'm_now_using_the_right_dictionary
    ;;
    ;; Namely I want to use a more inspiring dictionary for the poetry and prose.
    :straight (sdcv-mode :type git :host github :repo "gucong/emacs-sdcv")
    :bind ("C-c C-'" . sdcv-search))


  ;; (use-package flymake-vale
  ;;   :straight (flymake-value :type git
  ;;         :host github
  ;;         :repo "tpeacock19/flymake-vale")
  ;;   :hook ((text-mode       . flymake-vale-load)
  ;;          (latex-mode      . flymake-vale-load)
  ;;          (org-mode        . flymake-vale-load)
  ;;          (markdown-mode   . flymake-vale-load)
  ;;          (message-mode    . flymake-vale-load)))

  (use-package unicode-fonts
    ;; Before the emojii...
    :straight t
    :config (unicode-fonts-setup))


  (use-package unfill
    ;; Provides the reverse of ~fill-paragraph~, and a toggle fill and unfill.  In
    ;; fact, the unfill/fill function of Emacs was the first editor function I saw
    ;; (shown to me by a friend in 2005) that had me strongly consider Emacs. Alas
    ;; I was not prepared for Emacs.
    :bind ("M-q" . unfill-toggle)
    :straight t)

  (use-package hungry-delete
    ;; Delete multiple spaces in one delete stroke.
    :straight t
    :config (global-hungry-delete-mode))

  (use-package move-text
    ;; A simple package ability to move lines up and down.
    :straight t
    :bind (([C-s-down] . move-text-down)
           ([C-s-up] . move-text-up)))

  (use-package titlecase
    ;; The rules of ‚Äútitlecase‚Äù are confounding.  The ~titlecase.el~ package
    ;; provides numerous ways to cast a string to ‚Äútitlecase.‚Äù  I chose wikipedia
    ;; style as a quasi-opinionated compromise.
    :straight (titlecase :host github :repo "duckwork/titlecase.el")
    :custom (titlecase-style 'wikipedia))

  (use-package multiple-cursors
    ;; Allow Emacs to work with multiple cursors.  See
    ;; https://melpa.org/#/multiple-cursors
    :bind (("C-M-SPC" . set-rectangular-region-anchor)
           ("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-s-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c C->" . mc/mark-all-like-this)
           ("C-c C-SPC" . mc/edit-lines)) ;; CTRL+CMD+c
    :straight t)

  (use-package iedit
    ;; Type \"C-;\" to select current symbol and all matches; Then edit at multiple
    ;; points.
    :straight t)

  (provide 'jf-writing)
  ;;; jf-writing.el ends here
#+end_src

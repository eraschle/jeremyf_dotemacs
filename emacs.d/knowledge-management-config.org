# -*- lexical-binding: t; org-insert-tilde-language: emacs-lisp; -*-
#+TITLE: Take on Rules
#+SUBTITLE: Or How I Want to Test This Thing Out
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+FILETAGS: :takeonrules:
#+STARTUP: showall
#+PROPERTY: header-args:emacs-lisp :comments link
#+OPTIONS: toc:3

By now, with all that I’ve written, it should be evident that knowledge management is both a critical need and something that Emacs must certainly support.

Another “killer feature” of Emacs is org-mode and it’s constellation of packages.

* Org-Mode

Oh ~org-mode~, one of the “why you should use Emacs” packages.  It’s a set of organizational tools that allow for progressive adoption.  You can start writing in ~org-mode~ syntax and leave it at that.  From there you can delve further into the ~org-mode~ ecosystem.

A bit of pre-amble.  I maintain a list of data directories, each might have “relevant to org-mode” files.  The ~jf/org-agenda-files~ reads the file system to gather sources for ~org-mode~ agenda.

#+begin_src emacs-lisp
  (defun is-work-machine? ()
    "Am I working on my machine"
    (file-exists-p (file-truename "~/git/org/scientist/dailies/.keep")))

  (defvar jf/primary-agenda-filename-for-machine
    (if (is-work-machine?)
	"~/git/org/scientist/agenda.org"
      "~/git/org/agenda.org"))

  (cl-defun jf/org-agenda-files (&key
				 (paths jf/data-directories)
				 (basenames '("agenda.org")))
    "Return the list of filenames where BASENAMES exists in PATHS."
    ;; I want to include my configuration file in my agenda querying.
    (setq returning-list '("~/git/dotemacs/emacs.d/configuration.org"))
    (dolist (path paths)
      (dolist (basename basenames)
	(when (f-exists-p (f-join path basename))
	  (add-to-list 'returning-list (f-join path basename)))))
    returning-list)

  (cl-defun jf/jump-to-agenda-or-mark (prefix-arg)
    "Jump to and from current agenda item to mark.

  With PREFIX_ARG go to beginning of today's headline."
    (interactive "P")
    (if (car prefix-arg)
	;; Jump to where we would put a project were we to capture it.
	(org-capture-goto-target "p")
      (if (string= (buffer-file-name) (file-truename jf/primary-agenda-filename-for-machine))
	  (call-interactively #'consult-global-mark)
	(progn
	  (call-interactively #'set-mark-command)
	  (if (when (and (fboundp 'org-clocking-p) (org-clocking-p)) t)
	      (org-clock-goto)
	    ;; Jump to where we would put a project were we to capture it.
	    (org-capture-goto-target "p")))))
    (require 'pulsar)
    (pulsar-pulse-line))
    #+end_src

The rudimentary configuration of my ~org-mode~.  Later, I write about ~org-roam~ which introduces my more generalized note taking system.

#+begin_src emacs-lisp
  (use-package org
    :straight (org :type built-in)
    :hook (org-mode . turn-on-visual-line-mode)
    :bind ("C-j" . jf/jump-to-agenda-or-mark)
    :bind (:map org-mode-map ("C-j" . jf/jump-to-agenda-or-mark))
    :config (setq
	     org-export-with-sub-superscripts nil
	     org-directory (file-truename "~/git/org")
	     org-agenda-files (jf/org-agenda-files
			       :paths jf/data-directories
			       :basenames '("agenda.org"))
	     org-default-notes-file (concat
				     org-directory
				     "/captured-notes.org")
	     org-todo-keywords '((sequence "BLOCKED" "|" "UNBLOCKED")
				 (sequence "TO-MERGE" "|" "MERGED")
				 (sequence
				  "TODO"
				  "IN-PROGRESS"
				  "WAITING"
				  "|"
				  "DONE")))
    (setq org-capture-templates
	  '(("@"
	     "All Todo"
	     entry (file+olp jf/primary-agenda-filename-for-machine "General Todo Items")
	     "* TODO %?\n  %i\n  %a"
	     :empty-lines-before 1)
	    ("b" "Blocker"
	     plain (file+function jf/primary-agenda-filename-for-machine jf/org-mode-agenda-find-blocked-node)
	     "***** BLOCKED %^{Describe the blocker}? :blocker:"
	     :immediate-finish t
	     :empty-lines-after 1
	     )
	    ("m" "Merge Request"
	     plain (file+function jf/primary-agenda-filename-for-machine jf/org-mode-agenda-findq-merge-request-node)
	     "***** TO-MERGE %^{URL of Merge Request}? :mergerequest:"q
	     :immediate-finish t
	     :empty-lines-after 1
	     )
	    ;; Needed for the first project of the day; to ensure the datetree is
	    ;; properly generated.
	    ("p" "Project"
	     entry (file+olp+datetree jf/primary-agenda-filename-for-machine)
	     "* %(jf/org-mode-agenda-project-prompt) :project:\n\n%?"
	     :empty-lines-before 1
	     :immediate-finish t
	     :empty-lines-after 1)
	    ("t" "Task"
	     ;; I tried this as a node, but that created headaches.  Instead I'm
	     ;; making the assumption about project/task depth.
	     plain (file+function jf/primary-agenda-filename-for-machine jf/org-mode-agenda-find-project-node)
	     ;; The five ***** is due to the assumptive depth of the projects and tasks.
	     "***** %? :task:\n\n")
	    ))

    (setq org-latex-default-class "jf/article")

    (org-babel-do-load-languages 'org-babel-load-languages
				 (append org-babel-load-languages
					 '((emacs-lisp . t)
					   (shell . t)
					   (plantuml . t)
					   (ruby . t))))
    :init (require 'ox)
    ;; I grabbed from the following LaTeX class from
    ;; https://www.reddit.com/r/emacs/comments/3zcr43/nooborgmode_custom_latexpdf_export_custom_style/.
    ;; I’m trash with LaTeX, but like the layout thusfar.
    (add-to-list 'org-latex-classes
		 '("jf/article"
		   "\\documentclass[11pt,a4paper]{article}
  \\usepackage[utf8]{inputenc}
  \\usepackage[T1]{fontenc}
  \\usepackage{fixltx2e}
  \\usepackage{graphicx}
  \\usepackage{longtable}
  \\usepackage{float}
  \\usepackage{wrapfig}
  \\usepackage{rotating}
  \\usepackage[normalem]{ulem}
  \\usepackage{amsmath}
  \\usepackage{textcomp}
  \\usepackage{marvosym}
  \\usepackage{wasysym}
  \\usepackage{amssymb}
  \\usepackage{hyperref}
  \\usepackage{mathpazo}
  \\usepackage{xcolor}
  \\usepackage{enumerate}
  \\definecolor{bg}{rgb}{0.95,0.95,0.95}
  \\tolerance=1000
	[NO-DEFAULT-PACKAGES]
	[PACKAGES]
	[EXTRA]

  \\linespread{1.1}
  \\hypersetup{pdfborder=0 0 0}"
		   ("\\section{%s}" . "\\section*{%s}")
		   ("\\subsection{%s}" . "\\subsection*{%s}")
		   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
		   ("\\paragraph{%s}" . "\\paragraph*{%s}")))

    ;; \\hypersetup{colorlinks=false,pdfborderstyle={/S/U/W 1},pdfborder=0 0 1}"
    ;; Make TAB act as if it were issued from the buffer of the languages's major
    ;; mode.
    :custom (org-src-tab-acts-natively t)
    (org-clock-clocktable-default-properties '(:maxlevel 5 :link t :tags t))
    :bind (:map org-mode-map
		("C-c l i" . jf/org-insert-link-dwim)
		("s-2" . consult-org-heading))
    :bind (("C-c l s" . org-store-link)
	   ("C-c a" . org-agenda)
	   ("C-c c" . org-capture)
	   ("C-s-t" . org-toggle-link-display)))

  (defun my-org-confirm-babel-evaluate (lang body) nil)
  (setq org-confirm-babel-evaluate #'my-org-confirm-babel-evaluate)

  ;; To make Org mode take care of versioning of attachments for you,
  ;; add the following to your Emacs config:
  (require 'org-attach-git)

  ;; See
  ;; https://www.reddit.com/r/orgmode/comments/i6hl8b/image_preview_size_in_org_mode/
  ;; for further discussion
  ;;
  ;; One consideration is that the below setq should be called as part
  ;; of the `org-toggle-inline-images`.  <2020-11-14 Sat 12:09>: I
  ;; commented out the lines below as it created a very small image
  ;; (about the size of one character).  (setq org-image-actual-width
  ;; (truncate (* (window-pixel-width) 0.8)))


  ;; I'd prefer to use the executable, but that doe not appear to be the
  ;; implementation of org-babel.
  (setq org-plantuml-jar-path (concat (string-trim (shell-command-to-string "brew-path plantuml")) "/libexec/plantuml.jar"))
#+end_src

I cribbed the following function from [[https://xenodium.com/emacs-dwim-do-what-i-mean/][Emacs DWIM: do what ✨I✨ mean]].

#+begin_src emacs-lisp
  (defun jf/org-insert-link-dwim ()
    "Like `org-insert-link' but with personal dwim preferences."
    (interactive)
    (let* ((point-in-link (org-in-regexp org-link-any-re 1))
	   (clipboard-url (when (string-match-p "^http" (current-kill 0))
			    (current-kill 0)))
	   (region-content (when (region-active-p)
			     (buffer-substring-no-properties (region-beginning)
							     (region-end)))))
      (cond ((and region-content clipboard-url (not point-in-link))
	     (delete-region (region-beginning) (region-end))
	     (insert (org-make-link-string clipboard-url region-content)))
	    ((and clipboard-url (not point-in-link))
	     (insert (org-make-link-string
		      clipboard-url
		      (read-string "Title: "
				   (with-current-buffer (url-retrieve-synchronously clipboard-url)
				     (dom-text (car
						(dom-by-tag (libxml-parse-html-region
							     (point-min)
							     (point-max))
							    'title))))))))
	    (t
	     (call-interactively 'org-insert-link)))))
#+end_src

** Time Tracking

I wrote about this in [[https://takeonrules.com/2022/09/06/org-mode-capture-templates-and-time-tracking/][Org Mode Capture Templates and Time Tracking // Take on Rules]].  But to summarize, I work on several different projects each day; helping folks get unstuck.  I also need to track and record my time.

The following three functions help me provide structure for time tracking and note taking:

- =jf/org-mode-agenda-project-prompt=
- =jf/org-mode-agenda-find-project-node=
- =jf/org-mode-agenda-to-stand-up-summary=

I want to re-use existing project names but also allow for new ones, and =jf/org-mode-agenda-project-prompt= queries my agenda file for the projects I’ve already recorded time towards.

#+begin_src emacs-lisp
  (defun jf/org-mode-agenda-project-prompt ()
    "Prompt for project based on existing projects in agenda file.

      Note: I tried this as interactive, but the capture templates
      insist that it should not be interactive."
    (completing-read
     "Project: "
     (sort
      (-distinct
       (org-map-entries
	(lambda ()
	  (org-element-property :title (org-element-at-point)))
	"+LEVEL=4+project" 'agenda)
       ) #'string<)))
#+end_src

When I jump to a new task for the day, I want to position that task within the prompted project.  Inspiration for =jf/org-mode-agenda-find-project-node= comes from https://gist.github.com/webbj74/0ab881ed0ce61153a82e.

#+begin_src emacs-lisp
  (cl-defun jf/org-mode-agenda-find-project-node (&key
						  (tag "project")
						  (project (jf/org-mode-agenda-project-prompt))
						  ;; The `file+olp+datetree` directive creates a headline like “2022-09-03 Saturday”.
						  (within_headline (format-time-string "%Y-%m-%d %A")))
    "Find and position the cursor at the end of
      the given PROJECT WITHIN_HEADLINE."
    ;; We need to be using the right agenda file.
    (with-current-buffer (find-file-noselect jf/primary-agenda-filename-for-machine)
      (let ((existing-position (org-element-map
				   (org-element-parse-buffer)
				   'headline
				 ;; Finds the end position of:
				 ;; - a level 4 headline
				 ;; - that is tagged as a :project:
				 ;; - is titled as the given project
				 ;; - and is within the given headline
				 (lambda (hl)
				   (and (=(org-element-property :level hl) 4)
					;; I can't use the :title attribute as it is a
					;; more complicated structure; this gets me
					;; the raw string.
					(string= project (plist-get (cadr hl) :raw-value))
					(member "project" (org-element-property :tags hl))
					;; The element must have an ancestor with a headline of today
					(string= within_headline
						 (plist-get
						  ;; I want the raw title, no styling nor tags
						  (cadr (car (org-element-lineage hl))) :raw-value))
					(org-element-property :end hl)))
				 nil t)))
	(if existing-position
	    ;; Go to the existing position for this project
	    (goto-char existing-position)
	  (progn
	    ;; Go to the end of the file and append the project to the end
	    (end-of-buffer)
	    (insert (concat "\n\n**** " project " :" tag ":\n\n")))))))
  (cl-defun jf/org-mode-agenda-find-blocked-node ()
    "Add a blocker node to today."
    (jf/org-mode-agenda-find-project-node :tag "blockers" :project (concat "Blockers for " (format-time-string "%Y-%m-%d"))))

  (cl-defun jf/org-mode-agenda-find-merge-request-node ()
    "Add a mergerequest node to today."
    (jf/org-mode-agenda-find-project-node :tag "mergerequest" :project (concat "Merge Requests for " (format-time-string "%Y-%m-%d"))))
#+end_src

The =jf/org-mode-agenda-to-stand-up-summary= function takes my notes for the day and formats them for a summary report.

#+begin_src emacs-lisp
  (cl-defun jf/org-mode-agenda-to-stand-up-summary (prefix-arg
						    &key
						    (within_headline (format-time-string "%Y-%m-%d %A")))
    "Copy to the kill ring the project tasks WITHIN_HEADLINE.

  When given PREFIX_ARG, open a temporary buffer and yank the
  report into that buffer.

  NOTE: This follows the convention that projects are on headline 4 and
  tasks within projects are headline 5."
    (interactive "P")
    (with-current-buffer (find-file-noselect jf/primary-agenda-filename-for-machine)
      (save-excursion
	(kill-new
	 (s-trim
	  (s-join
	   "\n"
	   (org-element-map
	       (org-element-parse-buffer)
	       'headline
	     (lambda (hl)
	       (when (member
		      within_headline
		      (mapcar
		       (lambda (ancestor) (plist-get (cadr ancestor) :raw-value))
		       (org-element-lineage hl)))
		 (if (=(org-element-property :level hl) 4)
		     (concat "\n" (plist-get (cadr hl) :raw-value))
		   (concat "- " (plist-get (cadr hl) :raw-value)))))
	     ))))
	(unless (car prefix-arg)
	  (jf/create-scratch-buffer)
	  (yank)))))
#+end_src

I’m responsible for tracking my work time.  I want a way to quickly see what that is for the current week.

#+begin_src emacs-lisp
  (cl-defun jf/org-mode-weekly-report ()
    "Jump to my weekly time tracker."
    (interactive)
    (find-file jf/primary-agenda-filename-for-machine)
    (require 'pulsar)
    (pulsar-pulse-line)
    (org-clock-report 4))
#+end_src

#+begin_src emacs-lisp
  (defun jf/org-mode-end-of-month-report ()
    "Generate an end of month report from projects and tasks."
    (interactive)
    (message
     "%s"
     (s-join
      ""
      (org-element-map
	  (org-element-parse-buffer)
	  'headline
	(lambda (hl)
	  (pcase (org-element-property :level hl)
	    (3 (concat "\n--------------------------------------------------------------------------------\n"
		       (plist-get (cadr hl) :raw-value)
		       "\n--------------------------------------------------------------------------------"))
	    (4 (concat "\n" (format "%s" (/ (org-clock-sum) 60.0)) "\t" (plist-get (cadr hl) :raw-value)))
	    (5 (concat "\n- " (plist-get (cadr hl) :raw-value)))))))))
#+end_src

Another task at end of month is to transcribing my agenda’s timesheet to entries in our time tracking software.  From the day’s project link in the =org-clock-report=, I want to copy the headlines of each of the tasks.  I fill out my time sheets one day at a time.

#+begin_src emacs-lisp
  (defun jf/org-mode-tasks-for-project-and-day ()
    "Function to help report time for Scientist.com

  Assumes that I'm on a :project: headline.

  - Sum the hours (in decimal form) for the tasks.
  - Create a list of the tasks.
  - Write this information to the message buffer.
  - Then move to the next heading level.
  "
    (interactive)
    (let ((project (plist-get (cadr (org-element-at-point)) :raw-value))
	  (tasks (s-join "\n" (org-with-wide-buffer
			       (when (org-goto-first-child)
				 (cl-loop collect (concat "- " (org-no-properties (org-get-heading t t)))
					  while (outline-get-next-sibling))))))
	  (time (/ (org-clock-sum-current-item) 60.0)))
      (kill-new tasks)
      (kill-new (format "%s" time))
      (message "Project: %s\nHours: %s\nTasks:\n%s" project time tasks)
      (call-interactively #'org-forward-heading-same-level)))
#+end_src

** Copy Org and Paste in Rich Text Format

Org Mode has built-in capabilities for exporting to HTML (and other languages).  The following function does just a bit more.  It converts the org region to HTML and sends it to the clipboard as an RTF datatype.

Why is that nice?  As an RTF datatype, the paste receiver better handles the HTML (e.g., I can more readily paste into an Email and it pastes as expected).

See [[https://kitchingroup.cheme.cmu.edu/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/][Copy formatted org-mode text from Emacs to other applications]] for more details.  One addition I made was to add the ~-inputencoding UTF-8~ switch.  Without it, I would end up with some weird characters from odd smartquote handling.

/Note:/ For this to work, I needed to permit my =\~/bin/emacsclient= iin the Security & Privacy > Accessibility system preference.  /At least I think that’s what got things working./

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-s-c") 'jf/formatted-copy-org-to-html)
  (defun jf/formatted-copy-org-to-html (prefix)
    "Export region to HTML, and copy it to the clipboard.

  When given the PREFIX arg, paste the content into TextEdit (for future copy)."
    (interactive "P")
    (save-window-excursion
      (let* ((buf (org-export-to-buffer 'html "*Formatted Copy*" nil nil t t))
	     (html (with-current-buffer buf (buffer-string))))
	(with-current-buffer buf
	  (shell-command-on-region
	   (point-min)
	   (point-max)
	   "textutil -inputencoding UTF-8 -stdout -stdin -format html -convert rtf | pbcopy"))
	(kill-buffer buf)
	;; Paste into TextEdit
	(when (car prefix)
	  (ns-do-applescript
	   (concat
	    "tell application \"TextEdit\"\n"
	    "\tactivate\n"
	    "\tset myrtf to the clipboard as «class RTF »\n"
	    "\tset mydoc to make new document\n"
	    "\tset text of mydoc to myrtf\n"
	    "end tell")))
	)))

  ;; http://mbork.pl/2021-05-02_Org-mode_to_Markdown_via_the_clipboard
  (defun jf/org-copy-region-as-markdown ()
    "Copy the region (in Org) to the system clipboard as Markdown."
    (interactive)
    (if (use-region-p)
	(let* ((region
		(buffer-substring-no-properties
		 (region-beginning)
		 (region-end)))
	       (markdown
		(org-export-string-as region 'md t '(:with-toc nil))))
	  (gui-set-selection 'CLIPBOARD markdown))))

  (use-package htmlize
    :straight t)
#+end_src

I have found that Slack resists posting rich content, so I often need to open up TextEdit, paste into an empty file, copy the contents, and then paste into Slack.

** Swapping Tilde and Backtick in Org and More

I jump between Markdown and Org Mode with some frequency.  In many cases I prefer Org Mode.  Except when it comes to code declaration.  The tilde (e.g., =~=) is cumbersome compared to the backtick (e.g., =`=).

What follows came from [[http://mbork.pl/2022-01-17_Making_code_snippets_in_Org-mode_easier_to_type][Marcin Borkowski: 2022-01-17 Making code snippets in Org-mode easier to type]].

Now when I type =~~~=, I get a source block.  And I can even default that block to a specific language (via ~org-insert-tilde-language~).

#+begin_src emacs-lisp
  (define-key org-mode-map (kbd "~") #'org-insert-backtick)
  (defun org-insert-backtick ()
    "Insert a backtick using `org-self-insert-command'."
    (interactive)
    (setq last-command-event ?`)
    (call-interactively #'org-self-insert-command))

  (defvar-local org-insert-tilde-language nil
    "Default language name in the current Org file.
  If nil, `org-insert-tilde' after 2 tildes inserts an \"example\"
  block.  If a string, it inserts a \"src\" block with the given
  language name.")

  (define-key org-mode-map (kbd "`") #'org-insert-tilde)
  (defun org-insert-tilde ()
    "Insert a tilde using `org-self-insert-command'."
    (interactive)
    (if (string= (buffer-substring-no-properties (- (point) 3) (point))
		 "\n~~")
	(progn (delete-char -2)
	       (if org-insert-tilde-language
		   (insert (format "#+begin_src %s\n#+end_src"
				   org-insert-tilde-language))
		 (insert "#+begin_example\n#+end_example"))
	       (forward-line -1)
	       (if (string= org-insert-tilde-language "")
		   (move-end-of-line nil)
		 (org-edit-special)))
      (setq last-command-event ?~)
      (call-interactively #'org-self-insert-command)))
#+end_src

* Org-Roam

This is my third iteration on an ~org-roam~.  It's goal is to address use-cases that I've encountered while moving more of my note-taking with ~org-roam~.

One use-case is when I'm running or playing in an RPG session.  During those sessions, when I create/find/insert nodes, I almost want to leverage the same tags.  That can be in my capturing of nodes or in my searching for nodes.  This is something I observed while running my 13 session "Thel Sector" campaign.

A second use-case is when I'm writing notes or thoughts related to work.  In a past life, I might have written notes for either my employer or Samvera (a community in which I participated).  Those notes might overlap but rarely did.

While I’m writing those notes, if I’m developing out concepts, I might want to filter my captures and searches to similar tags.

Another use case is less refined, namely I'm writing but am not "in" a specific context.

However, v2 of my org-roam structure[fn:1], didn't quite get out of the way.  I never quite got to the speed of note taking that I had for the original Thel Sector campaign.

What follows builds on Jethro Kuan's [[https://jethrokuan.github.io/org-roam-guide/][How I Take Notes with Org-roam]].  Reading Jethro Kuan's post helped me see how I could do this.

Additional resources:

- [[https://sqrtminusone.xyz/configs/emacs/#org-roam][Pavel Korytov’s Emacs config (Org Roam)]]

** Preliminaries

The ~jf/org-roam-capture-templates-plist~ variable defines the possible org-roam capture templates that I will use.  I have chosen to narrow these to three types:

- ~refs~ :: References to other people’s thoughts.
- ~main~ :: My thoughts, still churning, referencing other thoughts.
- ~scientist~ :: Documents specific to scientist work.

/Note:/ I chose to go with 4 character types to minimize it’s impact on rendering “type” in the search results (4 characters requires less visual space than 10 characters).

As of <2022-04-10 Sun> I am rarely using ~pubs~ simply comingling ~pubs~ and ~main~.  A “pub” is something that has a ~ROAM_REFS~ entry and is in the “mine” sub-directory.

#+begin_src emacs-lisp
  (defvar jf/org-roam-capture-templates-plist
    (list
     ;; These are references to "other people's thoughts."
     :refs '("r" "refs" plain "%?"
	     :if-new (file+head "refs/%<%Y%m%d>---${slug}.org" "#+title: ${title}\n#+FILETAGS:\n")
	     :unnarrowed t)
     ;; These are "my thoughts" with references to "other people's thoughts."
     :main '("m" "main" plain "%?"
	     :if-new (file+head "main/%<%Y%m%d>---${slug}.org"
				"#+title: ${title}\n#+FILETAGS: ${auto-tags}\n")
	     :immediate-finish t
	     :unnarrowed t)
     :scientist '("s" "scientist" plain "%?"
		  :if-new (file+head "scientist/%<%Y%m%d>---${slug}.org"
				     "#+title: ${title}\n#+FILETAGS: :scientist:${auto-tags}\n")
		  :immediate-finish t
		  :unnarrowed t)
     ;; These are publications of "my thoughts" referencing "other people's thoughts".
     ;; :pubs '("p" "pubs" plain "%?"
     ;; 	   :if-new (file+head "pubs/%<%Y%m%d>---${slug}.org" "#+title: ${title}\n#+FILETAGS:\n")
     ;; 	   :immediate-finish t
     ;; 	   :unnarrowed t)
     )
    "Templates to use for `org-roam' capture.")
#+end_src

The ~jf/org-context-plist~ defines and names some of the contexts in which I might be writing.  Each named context defines the associated tags.  These are the tags that all nodes will have when they are written in the defined context.

Loosely related is the ~jf/org-auto-tags--current-list~; Contexts are a named set of tags.  However, other functions don’t operate based on context.  They instead operated based on the tags.

#+begin_src emacs-lisp
  (defvar jf/org-context-plist
    (list
     :none
     (list
      :name "none"
      :tags (list))

     :burning-locusts
     (list
      :name "burning-locusts"
      :tags '("burning-locusts"
	      "rpgs"
	      "burning-wheel"))
     :drinax
     (list
      :name "drinax"
      :tags '("campaigns"
	      "drinax"
	      "rpgs"))
     :forem
     (list
      :name "forem"
      :tags '("forem"))

     :mistimed-scroll
     (list
      :name "mistimed-scroll"
      :tags '("eberron"
	      "mistimed-scroll"
	      "rpgs"
	      "burning-wheel"))
     :scientist
     (list
      :name "scientist"
      :tags '("scientist"))
     :thel-sector
     (list
      :name "thel-sector"
      :tags '("thel-sector"
	      "rpgs" "swn")))
    "A list of contexts that I regularly write about.")

  (defvar jf/org-auto-tags--current-list
    (list)
    "The list of tags to automatically apply to an `org-roam' capture.")
#+end_src

I can use ~jf/org-auto-tags--set~ to create an ad hoc context, or perhaps a "yet to be named" context.  I can use ~jf/org-auto-tags--set-by-context~ to establish the current context (or clear it).

#+begin_src emacs-lisp
  (defun jf/org-auto-tags--set (tags)
    "Prompt user or more TAGS."
    (interactive
     (list
      (completing-read-multiple
       "Tag(s): " (org-roam-tag-completions))))
    (setq jf/org-auto-tags--current-list tags))

  (cl-defun jf/org-context-list-completing-read
      (&key
       (context-plist
	jf/org-context-plist))
    "Create a list of contexts from the CONTEXT-PLIST for completing read.

	 The form should be '((\"forem\" 1) (\"burning-loscusts\" 2))."
    ;; Skipping the even entries as those are the "keys" for the plist,
    ;; the odds are the values.
    (-non-nil (seq-map-indexed
	       (lambda (context index)
		 (when (oddp index)
		   (list (plist-get context :name) index)))
	       context-plist)))

  (cl-defun jf/org-auto-tags--set-by-context
      (context
       &key
       (context-plist jf/org-context-plist))
    "Set auto-tags by CONTEXT.

     Prompt for CONTEXT from CONTEXT-PLIST."
    (interactive
     (list
      (completing-read
       "Context: " (jf/org-context-list-completing-read))))
    (setq jf/org-auto-tags--current-list
	  (plist-get
	   (plist-get
	    context-plist (intern (concat ":" context)))
	   :tags)))
#+end_src

With the ~jf/org-auto-tags--current-list~ variable set, I want a function to inject those tags onto my captures.  Looking at the [[https://www.orgroam.com/manual.html#Org_002droam-Template-Expansion][org-roam docs on template expansion]], I want to create a function named ~org-roam-node-auto-tags~.

#+begin_src emacs-lisp
  (cl-defun org-roam-node-auto-tags
      (node
       &key
       (tag-list jf/org-auto-tags--current-list))
    "Inject the TAG-LIST into the {auto-tags} region of captured NODE.

       See https://www.orgroam.com/manual.html#Template-Walkthrough"
    (if (and tag-list (> (length tag-list) 0))
	(concat ":" (s-join ":" tag-list) ":")
      ""))
#+end_src

And finally, we have functions to use for establishing what templates are available based on the context, as well as what to setup as the default filter-fn for org-capture.

In other words, when I have set one or more tags, I want to use the templates appropriate for those tags and filter my org-roam-nodes so that only those nodes that have all of the tags are candidates.

#+begin_src emacs-lisp
  (cl-defun jf/org-roam-templates-list
      (template
       &key
       (template-plist jf/org-roam-capture-templates-plist))
    "List of `org-roam' capture templates based on the given TEMPLATE.

       Searches the TEMPLATE-PLIST for the templates.

       Note, the :all template assumes we use the whole list."
    (if (eq template :all)
	(-non-nil
	 (seq-map-indexed
	  (lambda (tmp index)
	    (when (oddp index)
	      tmp))
	  template-plist))
      (list (plist-get template-plist template))))

  (cl-defun jf/org-roam-templates-context-fn
      (&key
       (tag-list jf/org-auto-tags--current-list))
    "Returns a set of templates based on TAG-LIST.

       A key assumption is that if there's a default tag list, use the
       :main template."
    (if (and tag-list (> (length tag-list) 0))
	(if (-contains? tag-list "scientist")
	    (jf/org-roam-templates-list :scientist)
	  (jf/org-roam-templates-list :main))
      (jf/org-roam-templates-list :all)))

  (cl-defun jf/org-roam-filter-context-fn
      (node
       &key
       (tag-list jf/org-auto-tags--current-list))
    "Determine TAG-LIST is subset of NODE's tags."
    ;; gnus-subsetp is a more "permissive" version of subsetp.  It doesn't
    ;; consider order.  And looks at strings as equal if their values are the
    ;; same.
    (require 'gnus)
    (gnus-subsetp tag-list (org-roam-node-tags node)))
#+end_src

** Configuration

I wrote three functions to mirror three core functions of org-mode:

- ~jf/org-roam-capture~ :: find or create a node and file it away.
- ~jf/org-roam-node-insert~ :: find or create a node and insert a link to that node.  This is my “take notes quick” function.
- ~jf/org-roam-find-node~ :: find a node and open that node in the frame.

For each of those functions, I establish the filter based on the current context and/or tags.  I also limit the available capture templates based on the context.

#+begin_src emacs-lisp
  (defun jf/org-roam-capture
      (&optional
       goto
       keys)
    "Call `org-roam-capture' based on set tags."
    (interactive "P")
    (org-roam-capture
     goto
     keys
     :filter-fn 'jf/org-roam-filter-context-fn
     :templates (jf/org-roam-templates-context-fn)))

  (defun jf/org-roam-node-insert ()
    "Call `org-roam-node-insert' based on set tags."
    (interactive)
    (org-roam-node-insert
     'jf/org-roam-filter-context-fn
     :templates (jf/org-roam-templates-context-fn)))

  (defun jf/org-roam-find-node
      (&optional
       other-window
       initial-input)
    "Call `org-roam-node-find' based on set tags."
    (interactive current-prefix-arg)
    (org-roam-node-find
     other-window
     initial-input
     'jf/org-roam-filter-context-fn
     nil
     :templates (jf/org-roam-templates-context-fn)))
#+end_src

#+begin_src emacs-lisp
  (defun jf/org-roam-insert-at-point-epigraph-macro (&optional initial-input)
    "Insert an epigraph macro at point.

  Filter selections to INITIAL-INPUT."
    (interactive)
    (let ((node (org-roam-node-read
		 initial-input
		 (lambda (node)
		   (jf/org-roam-filter-context-fn node :tag-list '("epigraphs"))))))
      (insert (format "\n{{{epigraph(%s,%s)}}}\n"
		      (org-roam-node-id node)
		      (org-roam-node-title node)))))
#+end_src

And with all of that, let’s get into the org-roam configuration.

#+begin_src emacs-lisp
  (use-package org-roam
    :straight t
    :config
    (setq org-roam-dailies-capture-templates
	  '(("i" "item" item
	     "[ ] %?"
	     :target (file+head "%<%Y-%m-%d>.org"
				"#+title: %<%Y-%m-%d>\n#+FILETAGS: :dailies:\n"))))
    :custom
    ;; See https://github.com/nobiot/org-transclusion/issues/136
    (org-roam-db-extra-links-exclude-keys '((node-property "ROAM_REFS")))
    (org-roam-directory (file-truename "~/git/org"))
    (org-roam-dailies-directory (if (is-work-machine?) "scientist/dailies/" "dailies"))
    (org-roam-node-display-template
     (concat "${type:7} "
	     " ${title:80} "
	     (propertize "${tags:50}" 'face 'org-tag)))
    (org-roam-node-annotation-function
     (lambda (node)
       (org-roam-node-backlinkscount node)))
    (org-roam-capture-templates (jf/org-roam-templates-list :all))
    :bind (("C-c o f" . jf/org-roam-find-node)
	   ("C-s-f" . jf/org-roam-find-node)
	   ("C-s-c" . jf/org-roam-capture)
	   ("C-c o c" . jf/org-roam-capture)
	   )
    :bind (:map org-mode-map
		(("C-s-;" . org-roam-buffer-toggle)
		 ("s-i" . jf/org-roam-node-insert)
		 ("C-c o i" . jf/org-roam-node-insert)
		 ("C-s-<right>" . org-roam-dailies-goto-next-note)
		 ("C-s-<left>" . org-roam-dailies-goto-previous-note)))
    :init
    ;; Help keep the `org-roam-buffer', toggled via `org-roam-buffer-toggle', sticky.
    (add-to-list 'display-buffer-alist
		 '("\\*org-roam\\#"
		   (display-buffer-in-side-window)
		   (side . right)
		   (slot . 0)
		   (window-width . 0.33)
		   (window-parameters . ((no-other-window . t)
					 (no-delete-other-windows . t)))))
    ;; When t the autocomplete in org documents will query the org roam database
    (setq org-roam-completion-everywhere t)
    (setq org-roam-v2-ack t)
    (org-roam-db-autosync-mode))
#+end_src

This function returns the node’s type (e.g., it’s directory).

#+begin_src emacs-lisp
  ;; This needs to be after the `org-roam’ declaration as it is dependent on the
  ;; structures of `org-roam'.
  (cl-defmethod org-roam-node-type ((node org-roam-node))
    "Return the TYPE of NODE."
    (condition-case nil
	(file-name-nondirectory
	 (directory-file-name
	  (file-name-directory
	   (file-relative-name
	    (org-roam-node-file node)
	    org-roam-directory))))
      (error "")))

  ;; From https://github.com/org-roam/org-roam/wiki/User-contributed-Tricks
  (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
    (let* ((count (caar (org-roam-db-query
			 [:select (funcall count source)
				  :from links
				  :where (= dest $s1)
				  :and (= type "id")]
			 (org-roam-node-id node)))))
      (format "    %4d \xf0c1   %s" count (format-time-string "%Y-%m-%d" (org-roam-node-file-mtime node)))))
#+end_src

** Leveraging Tag Filtering with Org-Roam CAPF

This function pairs with ~jf/org-roam-filter-context-fn~ contexts.  It’s an inner function to the auto-completes that ~org-roam~ exposes.  This way, while I have a context “activated”, when I use auto-complete, it limits the titles to those with the matching tags.

#+begin_src emacs-lisp
  ;; This resolves the auto-complete prompt to conform to the contexts I
  ;; previously wrote about.
  (cl-defun org-roam--get-titles (&key (tag-list jf/org-auto-tags--current-list))
    "Return all distinct titles and aliases in the Org-roam database.

    When given a TAG-LIST select only titles that are associated with *all* of the given tags."
    (if (and tag-list (> (length tag-list) 0))
	(let ((tag-vector (seq--into-vector tag-list))
	      (count (length tag-list)))
	  (mapcar #'car (org-roam-db-query
			 [:select :distinct title :from nodes
				  :where (in id
					     [:select node_id
						      :from tags
						      :where (in tag $v1)
						      :group :by node_id
						      :having (>= (funcall count node_id) $s2)])
				  :union :select :distinct alias :from aliases
				  :where (in node_id
					     [:select node_id
						      :from tags
						      :where (in tag $v3)
						      :group :by node_id
						      :having (>= (funcall count node_id) $s4)])]
			 ;; Note: I tried re-using $v1 and $s2 for the alias, but
			 ;; that resulted in hitting a grinding halt.
			 tag-vector count tag-vector count)))
      (mapcar #'car (org-roam-db-query
		     [:select :distinct title :from nodes
			      :union :select alias :from aliases]))))
#+end_src

/I tried to use an advising function, but ran into problems.  I instead chose to rewrite the function used by Org-Roam’s ~org-roam-complete-link-at-point~ and ~org-roam-complete-everywhere~.

** Org-Roam UI

The ~org-roam-ui~ package provides a graphical representation of the graph of ~org-roam~ documents.

#+begin_src emacs-lisp
  (use-package org-roam-ui
    :straight
    (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
    :after org-roam
    ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
    ;;         a hookable mode anymore, you're advised to pick something yourself
    ;;         if you don't care about startup time, use
    ;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
	  org-roam-ui-follow t
	  org-roam-ui-update-on-save t
	  org-roam-ui-open-on-start t))
#+end_src

All told, the past experience when running [[https://takeonrules.com/series/new-vistas-in-the-thel-sector/][New Vistas in the Thel Sector // Take on Rules]] informed how I thought about my note taking.

** Other Contexts

Try as I may, based on my configuration, I can’t get [[https://orgmode.org/manual/Protocols.html#Protocols][org-protocol]] to work.  So I’ve opted to take a different path; write some Emacs functions instead.

- ~jf/org-roam-capture-ref~ :: Capture a “refs” context ~org-roam-node~ for the given title and url.
- ~jf/menu--org-capture-elfeed-show~ :: Capture an RSS entry.
- ~jf/menu--org-capture-firefox~ :: Capture the active tab of Firefox.
- ~jf/menu--org-capture-safari~ :: Capture the active tab of Safari.

These tie into my the context and auto-tags.

#+begin_src emacs-lisp
  (cl-defun jf/org-roam-capture-ref (&key title url)
    "Capture the TITLE and URL in the `org-roam' :refs template"
    ;; If your installation of org-roam includes the fix fore
    ;; https://github.com/org-roam/org-roam/issues/2078 then you can leave the
    ;; below commented out.
    ;;
    ;; This looks a bit odd, but to capture the :ref we need the callback from org-roam.
    ;; (require 'org-roam-protocol)
    ;;
    (org-roam-capture-
     :keys "r"
     ;; TODO: I would love to get tags working but I'm missing something
     :node (org-roam-node-create :title title)
     :info (list :ref url)
     :props '(:immediate-finish nil)
     :templates (jf/org-roam-templates-list :refs)))

  (cl-defun jf/menu--org-capture-elfeed-show (&key (entry elfeed-show-entry))
    "Create an `org-roam-node' from elfeed ENTRY."
    (interactive)
    (let ((url (elfeed-entry-link entry))
	  (title (elfeed-entry-title entry)))
      (jf/org-roam-capture-ref :url url :title title)))

  (defun jf/menu--org-capture-firefox ()
    "Create an `org-roam-node' from Firefox page.

    Depends on the `grab-mac-link' package."
    (interactive)
    (let* ((link-title-pair (grab-mac-link-firefox-1))
	   (url (car link-title-pair))
	   (title (cadr link-title-pair)))
      (jf/org-roam-capture-ref :url url :title title)))

  (defun jf/menu--org-capture-safari ()
    "Create an `org-roam-node' from Safari page.

    Depends on the `grab-mac-link' package."
    (interactive)
    (let* ((link-title-pair (grab-mac-link-safari-1))
	   (url (car link-title-pair))
	   (title (cadr link-title-pair)))
      (jf/org-roam-capture-ref :url url :title title)))

  (defun jf/menu--org-capture-eww ()
    "Create an `org-roam-node' from `eww' data"
    (interactive)
    (let* ((url (plist-get eww-data :url))
	   (title (plist-get eww-data :title)))
      (jf/org-roam-capture-ref :url url :title title)))
#+end_src

** Things I’ve Learned about Org Roam

Reading https://sqrtminusone.xyz/configs/emacs/#managing-tables, I learned about ~org-table-export~.

Reading [[https://systemcrafters.net/build-a-second-brain-in-emacs/5-org-roam-hacks/#build-your-org-agenda-from-org-roam-notes][5 Org Roam Hacks for Better Productivity in Emacs - System Crafters]], I learned about how to incorporate ~org-roam~ docs into my agenda.

* Org Transclusions

In [[https://takeonrules.com/2022/02/26/note-taking-with-org-roam-and-transclusion/][Note Taking with Org Roam and Transclusion]], I wrote about ~org-transclusion~.  The quick version, ~org-transclusion~ allows you to include text from one file into another.  This allows for document composition.

#+begin_src emacs-lisp
  (use-package org-transclusion
    :straight t
    :init (setq org-transclusion-exclude-elements '(property-drawer keyword)))
#+end_src

#+begin_src emacs-lisp
  (setq org-export-global-macros (list))
#+end_src

First, I’m considering swapping in and out the macros based on export context.  But I’m getting ahead of myself.

* Org Modern

I love [[https://github.com/minad][Daniel Mendler]]’s work; let’s test drive ~org-modern~.

#+begin_src emacs-lisp
  (use-package org-modern
    :straight (:host github :repo "minad/org-modern")
    :custom (org-modern-star '("◉" "○" "◈" "◇" "•"))
    :hook (org-mode . org-modern-mode))
#+end_src

* Macro Expansion

~org-mode~ provides macro expansion.  Here’s I’m declaring a few “global macros”.

** General

#+begin_src emacs-lisp
  (add-to-list 'org-export-global-macros
	       '("kbd" . "@@html:<kbd>@@$1@@html:</kbd>@@"))

  (add-to-list 'org-export-global-macros
	       '("date" . "@@html:<time datetime=\"$1\">@@$2@@html:</time>@@"))

  (add-to-list 'org-export-global-macros
	       '("cite" . "@@html:<cite>@@$1@@html:</cite>@@"))

  (add-to-list 'org-export-global-macros
	       '("dfn" . "@@html:<dfn>@@$1@@html:</dfn>@@"))

  (add-to-list 'org-export-global-macros
	       '("scene-date" . "#+begin_marginnote\nThe scene occurs on @@html:<span class=\"time\">@@$1@@html:</span>@@.\n#+end_marginnote"))
#+end_src

** Hugo Specific

The following macros map to my [[https://codeberg.org/takeonrules/takeonrules-hugo-theme/src/branch/main/layouts/shortcodes/glossary.html][Glossary shortcode of my hugo theme]]:

- ~mention~
- ~abbr~
- ~abbr-plural~
- ~linkToGame~

#+begin_src emacs-lisp
  (add-to-list 'org-export-global-macros
	       '("mention" . "@@hugo:{{< glossary key=\"@@$1@@hugo:\" >}}@@"))
  (add-to-list 'org-export-global-macros
	       '("abbr" . "@@hugo:{{< glossary key=\"@@$1@@hugo:\" abbr=\"t\" >}}@@"))
  (add-to-list 'org-export-global-macros
	       '("abbr-plural" . "@@hugo:{{< glossary key=\"@@$1@@hugo:\" abbr=\"t\" plural=\"t\" >}}@@"))
  (add-to-list 'org-export-global-macros
	       '("linkToGame" . "@@hugo:{{< glossary key=\"@@$1@@hugo:\" abbr=\"t\" >}}@@"))
#+end_src

I’ve taken to using the i-tag as idiomatic, meaning it’s a defined term (lacking it’s definition).  I don’t want to conflate this with org-modes =/= marker.

#+begin_src emacs-lisp
  (add-to-list 'org-export-global-macros
	       '("i" . "@@html:<i class=\"dfn\">@@$1@@html:</i>@@"))
#+end_src

Sometimes I use inline sidenotes, that’s the purpose of this macro.

#+begin_src emacs-lisp
  (add-to-list 'org-export-global-macros
	       '("sidenote" . "@@hugo:{{< sidenote >}}@@$1@@hugo:{{< /sidenote >}}@@"))
#+end_src

#+begin_src emacs-lisp
  (add-to-list 'org-export-global-macros
	       '("linkToSeries" . "@@hugo:{{< linkToSeries \"@@$1@@hugo:\" >}}@@"))
#+end_src

** Listing Function

#+begin_src emacs-lisp
  (cl-defun jf/org-macro-value-list (macro-name &key (dir org-directory))
    "List the unique inner text of all uses of MACRO-NAME in given DIR."
    (s-split
     "\n"
     (s-trim
      (shell-command-to-string
       (concat
	"rg \"\\{\\{\\{"
	macro-name
	"\\((.+?)\\)\\}\\}\\}"
	"\" --only-matching --no-filename -r '$1' "
	dir
	" | sort | uniq")))))
#+end_src

** Removing Links

#+begin_src emacs-lisp
  (defun jf/org-link-delete-link ()
    "Remove the link part of an org-mode link at point and keep
  only the description"
    (interactive)
    (let ((elem (org-element-context)))
      (when (eq (car elem) 'link)
	  (let* ((content-begin (org-element-property :contents-begin elem))
		 (content-end  (org-element-property :contents-end elem))
		 (link-begin (org-element-property :begin elem))
		 (link-end (org-element-property :end elem)))
	    (when (and content-begin content-end)
		(let ((content (buffer-substring-no-properties content-begin content-end)))
		  (delete-region link-begin link-end)
		  (insert (concat content " "))))))))
#+end_src

The following configuration ensures that I render unique links in the backlink section of org-roam nodes.

/[[https://github.com/org-roam/org-roam/blob/master/CHANGELOG.md#221][Org-Roam 2.2.1]] resolves [[https://github.com/org-roam/org-roam/issues/2119][Allow for `org-roam-buffer`'s Backlinks section to be unique per source · Issue #2119 · org-roam/org-roam]]./

#+begin_src emacs-lisp
  (setq org-roam-mode-section-functions
	'((org-roam-backlinks-section :unique t)
	  (org-roam-reflinks-section)))
#+end_src

** Syncing the Org Caches

I encountered the following message when attempting to export data:  ~=> "org-export-data: Unable to resolve link: EXISTING-PROPERTY-ID"~

See https://takeonrules.com/2022/01/11/resolving-an-unable-to-resolve-link-error-for-org-mode-in-emacs/ for details

#+begin_src emacs-lisp
  (defun jf/force-org-rebuild-cache (prefix-arg)
    "Call some functions to rebuild the `org-mode' and `org-roam' cache.

  When given PREFIX_ARG, clear the org-roam database (via `org-roam-db-clear-all') then sync.  This will slow down the sync."
    (interactive "P")
    (org-id-update-id-locations)
    (when (car prefix-arg) (org-roam-db-clear-all))
    (org-roam-db-sync)
    (org-roam-update-org-id-locations))
#+end_src

** Capturing Epigraphs

For my blogging purposes, I capture epigraphs and blockquotes.  These are treated somewhat differently.

The ~jf/org-mode-add-epigraph-keys~ function seeds the properties for a

#+begin_src emacs-lisp
  (defun jf/org-mode-add-epigraph-keys ()
    "Add the epigraph properties to the current org-roam node."
    (interactive)
    (save-excursion
      (org-roam-tag-add '("epigraphs"))
      (dolist (prop (list
		     '("AUTHOR_NAME" t)
		     '("AUTHOR_URL" nil)
		     '("AUTHOR_KEY" nil)
		     '("WORK_TITLE" t)
		     '("WORK_URL" nil)
		     '("WORK_KEY" nil)
		     '("POEM" nil)
		     '("PAGE" nil)
		     '("TRANSLATOR_NAME" nil)))
	(org-roam-property-add (car prop) (if (cadr prop) "**REQUIRED**" "")))))
#+end_src

** Org Roam “Backlinks” for Tags

This builds on [[https://github.com/org-roam/org-roam/issues/1698][Automatic node linking to tags and TODO states · Issue #1698 · org-roam/org-roam]]

#+begin_src emacs-lisp
  (defun jf/org-roam-tagged-by-sections (node)
    "The tagged-by section for NODE.

  Given the node's title and aliases, find all nodes that have a tag with that name."
    ;; See `org-roam-reflinks-section'
    (let* ((aliases (org-roam-node-aliases node))
	   (title (org-roam-node-title node)))))

  ;; (defun org-roam-reflinks-section (node)
  ;;   "The reflinks section for NODE."
  ;;   (when-let ((refs (org-roam-node-refs node))
  ;; 	     (reflinks (seq-sort #'org-roam-reflinks-sort (org-roam-reflinks-get node))))
  ;;     (magit-insert-section (org-roam-reflinks)
  ;;       (magit-insert-heading "Reflinks:")
  ;;       (dolist (reflink reflinks)
  ;; 	(org-roam-node-insert-section
  ;; 	 :source-node (org-roam-reflink-source-node reflink)
  ;; 	 :point (org-roam-reflink-point reflink)
  ;; 	 :properties (org-roam-reflink-properties reflink)))
  ;;       (insert ?\n))))
#+end_src

** Custom Link Types

- =abbr= :: Create an abbreviation.
- =abbr-plural=  :: Create an pluralized abbreviation.
- =glossary= :: Create a general link/reference to an Org-Roam node as a glossary entry.  See [[http://takeonrules.com/site-map/glossary/][Glossary of Terms for Take on Rules]].

*** Adding =abbr:= link type

#+begin_src emacs-lisp
  (org-link-set-parameters "abbr"
			   :complete (lambda (&optional parg) (jf/org-link-complete-link-for
							       parg
							       :scheme "abbr"
							       :property "ABBR"))
			   :export #'jf/org-abbr-link-export-link
			   :follow #'jf/org-mode-link-follow-link)

  (cl-defun jf/org-link-complete-link-for (parg &key scheme property)
    "Prompt for finding a SCHEME compatible `org-roam-node' with PROPERTY.

  Returns a string of format: \"SCHEME:<id>\" where <id> is an `org-roam-node' id."
    (format
     "%s:%s"
     scheme
     (org-roam-node-id
      (org-roam-node-read
       nil
       (lambda (el)
	 (alist-get property (org-roam-node-properties el) nil nil #'string=))
       nil t (concat "Node with " property " property: ")))))

  (cl-defun jf/org-abbr-link-export-link (id description format protocol &key (use_hugo_shortcode jf/exporting-org-to-tor))
    "Export a LINK with DESCRIPTION for the given PROTOCOL and FORMAT.

      FORMAT is an Org export backend. We will discard the given DESCRIPTION.  PROTOCOL is ignored."
    (if-let ((node (org-roam-node-from-id id)))
	(let* ((title (org-roam-node-title node))
	       (properties (org-roam-node-properties node))
	       (property (alist-get "ABBR" properties nil nil #'string=)))
	  (pcase format
	    (`html (if use_hugo_shortcode
		       (format "{{< glossary key=\"%s\" abbr=\"t\" >}}" (alist-get "GLOSSARY_KEY" properties property nil #'string=) )
		     (format "<abbr title=\"%s\">%s</abbr>" title property)))
	    (`md (if use_hugo_shortcode
		     (format "{{< glossary key=\"%s\" abbr=\"t\" >}}" (alist-get "GLOSSARY_KEY" properties property nil #'string=) )
		   (format "<abbr title=\"%s\">%s</abbr>" title property)))
	    (_ (format "%s (%s)" title property))))))

  (defun jf/org-mode-link-follow-link (id)
    "Navigate link to find ID and open the `org-roam-node`."
    (if-let ((node (org-roam-node-from-id id)))
	(progn
	  (org-mark-ring-push)
	  '(org-roam-node-visit node nil 'force))))
#+end_src

For example the following will resolve as an =abbr= link: =[[abbr:86F3E44F-AA0E-4B08-B0D8-30A764B4CD13][Org-Roam]]=

The =abbr:= scheme informs Org-Mode to use the =abbr= link handling.  The =86F3E44F-AA0E-4B08-B0D8-30A764B4CD13= is an =org-roam-node= node ID; which in this case references the Org-Roam node in my database.  The =[Org-Roam]= is a buffer specific description; the exporter will discard that and use the information provided in the =org-roam-node=.

As of <2022-09-24 Sat>, the above does not create an Org-Roam backlink.  The simplest solution is to add an =roam:<id>= element to the =ROAM_REFS= property.

*** Adding the =abbr-plural:= link type

#+begin_src emacs-lisp
  (org-link-set-parameters "abbr-plural"
			   :complete (lambda (&optional parg) (jf/org-link-complete-link-for
							       parg
							       :scheme "abbr-plrual"
							       :property "ABBR_PLURAL"))
			   :export #'jf/org-abbr-plural-link-export-link
			   :follow #'jf/org-mode-link-follow-link)

  (cl-defun jf/org-abbr-plural-link-export-link (id description format protocol &key (use_hugo_shortcode jf/exporting-org-to-tor))
    "Export a LINK with DESCRIPTION for the given PROTOCOL and FORMAT.

      FORMAT is an Org export backend. We will discard the given DESCRIPTION.  PROTOCOL is ignored."
    (if-let ((node (org-roam-node-from-id id)))
	(let* ((properties (org-roam-node-properties node))
	       (property (alist-get "ABBR_PLURAL" properties nil nil #'string=))
	       (key (alist-get "GLOSSARY_KEY" properties property nil #'string=))
	       ;; Need a fallback to a viable title
	       (title (or (alist-get "TITLE_PLURAL" properties nil nil #'string=) (org-roam-node-title node))))
	  (pcase format
	    (`html (if use_hugo_shortcode
		       (format "{{< glossary key=\"%s\" abbr=\"t\" plural=\"t\" >}}" key)
		     (format "<abbr title=\"%s\">%s</abbr>" title key)))
	    (`md (if use_hugo_shortcode
		     (format "{{< glossary key=\"%s\" abbr=\"t\" plural=\"t\" >}}" key)
		   (format "<abbr title=\"%s\">%s</abbr>" title key)))
	    (_ (format "%s (%s)" title key))))))
#+end_src


*** Adding the =cite:= link type

#+begin_src emacs-lisp
  (org-link-set-parameters "cite"
			   :complete (lambda (&optional parg) (jf/org-link-complete-link-for
							       parg
							       :scheme "cite"
							       :property "GLOSSARY_KEY"))
			   :export #'jf/org-cite-link-export-link
			   :follow #'jf/org-mode-link-follow-link)

  (cl-defun jf/org-cite-link-export-link (id description format protocol &key (use_hugo_shortcode jf/exporting-org-to-tor))
    "Export a LINK with DESCRIPTION for the given PROTOCOL and FORMAT.

      FORMAT is an Org export backend. We will discard the given DESCRIPTION.  PROTOCOL is ignored."
    (if-let ((node (org-roam-node-from-id id)))
	(let* ((properties (org-roam-node-properties node))
	       (key (alist-get "GLOSSARY_KEY" properties nil nil #'string=))
	       (title (org-roam-node-title node)))
	  (pcase format
	    (`html (if use_hugo_shortcode
		       (format "{{< glossary key=\"%s\" >}}" key)
		     (format "<cite>%s</cite>" title)))
	    (`md (if use_hugo_shortcode
		     (format "{{< glossary key=\"%s\" >}}" key)
		   (format "<cite>%s</cite>" title)))
	    (_ (format "%s" title))))))
#+end_src

* Conclusion

This is the core of my note taking engine.  It builds on the idea that I want to reduce the number of decisions I make.  This is extremely important when I’m writing session notes.

While I’m playing in a session, my entire context ideally collapses to the relevant tags that I’ve established at the beginning of the session.  That way I’m certain that I’m filing away notes to their proper location.

[fn:1] Iterating on my v2 ~org-roam~ setup was critical in learning more about Emacs.  I will certainly [[https://codeberg.org/takeonrules/dotemacs/src/commit/2f5d6c81d68aaa0d4de9cc7b409c090c0886300a/jnf-emacs-packages/jnf-org-roam-v2.el][reference my v2 org roam configuration]] as I continue my Emacs usage.

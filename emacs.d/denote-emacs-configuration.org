#+title:      Denote Emacs Configuration
#+date:       [2022-10-09 Sun 09:05]
#+filetags:   :emacs:programming:
#+identifier: 20221009T090515

#+SUBTITLE: A Literate Configuration

I wrote about [[id:05E6CA75-FCB3-44C5-955C-DA41614D3A4E][Exploring the Denote Emacs Package]] and [[id:7DF50246-B0AA-41C4-B986-E6DB305E653E][Migration Plan for Org-Roam Notes to Denote]]; this is now my configuration for using [[id:B659BD7E-30F9-4049-87ED-C47224399B7D][Denote]].  This sits orthogonal to my data migration of notes into Denote paradigm.

#+begin_marginnote
I’m writing the data migration scripts in [[denote:20220926T204604][Ruby]]; I’m more fluent in that language and found it just a easier to conceptualize the migration.  As of [[date:2022-10-03][October 3rd]], I have completed a test migration of my glossary.

As of [[date:2022-10-11][Tuesday, October 11th]] I have written several yet to publish programming posts.  I’m planning to publish those at my next convenience.
#+end_marginnote

** Configuration

This base configuration gets me started using Denote.

#+begin_src emacs-lisp
  (use-package denote
    ;; I want to point to cutting edge development; there's already features I
    ;; want that have been added since v1.0.0
    :straight (denote :host nil :type git :repo "https://git.sr.ht/~protesilaos/denote")
    :commands (denote-directory denote-file-prompt denote--title-prompt denote-get-path-by-id)
    :bind ("H-f" . 'jf/denote-find-file)
    ("H-i" . 'denote-link)
    :hook (dired-mode . denote-dired-mode)
    :custom ((denote-directory (expand-file-name "denote" org-directory))
	     ;; These are the minimum viable prompts for notes
	     (denote-prompts '(title keywords))
	     ;; I love ‘org-mode format; reading ahead I'm setting this
	     (denote-file-type 'org)
	     ;; TODO - this is inferred from my glossary, but as of <2022-10-11
	     ;; Tue> does not update when I add to the glossary.
	     (denote-known-keywords (jf/calculated-list-of-denote-known-keywords
				     :from (expand-file-name "denote/glossary" org-directory)))
	     ;; Explicitly ensuring that tags can be multi-word (e.g. two or more
	     ;; words joined with a dash).  Given that I export these tags, they
	     ;; should be accessible to screen-readers.  And without the dashes
	     ;; they are a garbled word salad.
	     (denote-allow-multi-word-keywords t)
	     ;; And `org-read-date' is an amazing bit of tech
	     (denote-date-prompt-denote-date-prompt-use-org-read-date t)))
#+end_src

Let’s add another way at looking up files.

#+begin_src emacs-lisp
  (use-package consult-notes
    :straight (:type git :host github :repo "mclear-tools/consult-notes")
    :bind
    ("H-d s" . 'consult-notes-search-in-all-notes)
    ("H-d f RET" . 'consult-notes)
    :commands (consult-notes
	       consult-notes-search-in-all-notes))

  (setq consult-notes-sources (list))
#+end_src

The following functions help me retrieve Org-Mode properties from the given Denote ID.

#+begin_src emacs-lisp
  (cl-defun jf/denote-org-property-from-id (&key identifier property)
    "Given an IDENTIFIER and PROPERTY return it's value or nil.

  Return nil when:

  - is not a denote file
  - IDENTIFIER leads to a non `org-mode' file
  - PROPERTY does not exist on the file"
    (when-let ((filename (denote-get-path-by-id identifier)))
      (when (string= (file-name-extension filename) "org")
	(with-current-buffer (find-file-noselect filename)
	  (cadar (org-collect-keywords (list property)))))))

  (cl-defun jf/denote-org-properties-from-id (&key identifier properties)
    "Given an IDENTIFIER and PROPERTIES list return an a-list of values.

  Return nil when:

  - is not a denote file
  - IDENTIFIER leads to a non `org-mode' file
  - PROPERTY does not exist on the file"
    (when-let ((filename (denote-get-path-by-id identifier)))
      (when (string= (file-name-extension filename) "org")
	(with-current-buffer (find-file-noselect filename)
	  (org-collect-keywords properties)))))
  ;;; Testing jf/denote-org-property-from-id
  ;; (message "%s" (jf/denote-org-property-from-id :identifier "20220930T215235"
  ;; 					      :property "ABBR"))
  ;;; Testing jf/denote-org-properties-from-id
  ;; (message "%s" (jf/denote-org-properties-from-id :identifier "20220930T215235"
  ;; 					      :properties '("TITLE" "ABBR")))
#+end_src

I’m not looking at active silo-ing and want to be able to search specifically from the top-level and all subdirectories.

#+begin_src emacs-lisp
  (defun jf/denote-file-prompt (fn &optional initial-dir)
    "An override of the provided denote-file-prompt."
    (if initial-dir
	(funcall fn initial-dir)
      (let* ((vc-dirs-ignores (mapcar
			       (lambda (dir)
				 (concat dir "/"))
			       vc-directory-exclusion-list))
	     (all-files (mapcan
			 (lambda (sub-dir)
			   (project--files-in-directory (f-join (denote-directory) sub-dir) vc-dirs-ignores))
			 jf/denote-subdirectories)))
	(funcall project-read-file-name-function
		 "Find file" all-files nil 'file-name-history))))

  (advice-add #'denote-file-prompt :around #'jf/denote-file-prompt '((name . "wrapper")))
#+end_src

From this configuration, I’ll build out my interactions.

*** Foundational Functions for my Denote Interaction

In [[id:B659BD7E-30F9-4049-87ED-C47224399B7D][Denote]]’s documentation for [[https://protesilaos.com/emacs/denote#h:887bdced-9686-4e80-906f-789e407f2e8f][Convenience commands for note creation]], they locally bind the =denote-prompts= variable then call =denote=; in [[https://protesilaos.com/emacs/denote#h:15719799-a5ff-4e9a-9f10-4ca03ef8f6c5][Maintain separate directories for notes]] they mention having silos of information by using =.dir-locals.el= to cordon off different /domains/.  See the [[*Domains][Domains]] section of this file for more infromation.

And while I might want to do that for my /domains/ I have the use case of wanting to link to a Glossary item from other domains.

I envision the =jf/denote-find-file= as the anchor for my general file finding, and then using a local binding of =denote-directory= to provide an initial narrowing default.

It doesn’t take much to see a macro emerging for these local bindings; find all sub-directories of the directory defiend by the =denote-directory= variable.  For each of those directories make an interactive function of the form =jf/denote-find-file--domain=.  That interactive function would locally bind =denote-directory= to =”denote-directory/domain”=.

Alternatively, as I create each domain’s create function, I also create the finder function.


#+begin_src emacs-lisp
  (setq jf/denote-subdirectories (list))
  (defun jf/denote-find-file ()
    "Find file in the current `denote-directory'."
    (interactive)
    (require 'consult-projectile)
    (require 'denote)
    (consult-projectile--file (denote-directory)))

  (cl-defmacro jf/denote-create-functions-for (&key domain key (create-fn nil))
    "A macro to create functions for the given DOMAIN.

	The KEY is the ASCII value of the binding key.

	Creates:

	- Wrapping function of `jf/denote-find-file' that narrows results
	to the given DOMAIN.
	- Create linking function for DOMAIN.
	- Add the domain to the `jf/denote-subdirectories'.
	- Adds DOMAIN to `consult-notes-sources'."
    (let* ((finder-fn (intern (concat "jf/denote-find-file--" domain)))
	   (subdirectory (f-join "~/git/org/denote" domain))
	   (finder-docstring (concat "Find file in \""
				     domain
				     "\" subdirectory of `denote-directory'."))
	   (default-create-fn (unless create-fn
				(intern (concat "jf/denote-create--" domain))))
	   (default-create-docstring (unless create-fn
				       (concat "Create denote in \""
					       domain
					       "\" subdirectory of `denote-directory'.")))
	   (inserter-fn (intern (concat "jf/denote-link--" domain)))
	   (inserter-docstring (concat "Link to denote in \""
				       domain
				       "\" subdirectory of `denote-directory'.")))

      `(progn
	 (add-to-list 'jf/denote-subdirectories ,domain)
	 (when (boundp 'consult-notes-sources)
	   (add-to-list 'consult-notes-sources '(,domain ,key ,subdirectory)))
	 (unless ,create-fn
	   (defun ,default-create-fn ()
	     ,default-create-docstring
	     (interactive)
	     (let ((denote-directory (f-join (denote-directory) ,domain)))
	       (call-interactively #'denote))))
	 (bind-key (format "H-d c %c" ,key) (or ,create-fn ',default-create-fn))
	 (bind-key (format "H-d f %c" ,key) ',finder-fn)
	 (defun ,finder-fn ()
	   ,finder-docstring
	   (interactive)
	   (let ((denote-directory (f-join (denote-directory) ,domain)))
	     (call-interactively #'jf/denote-find-file)))
	 (bind-key (format "H-d i %c" ,key) ',inserter-fn)
	 (defun ,inserter-fn ()
	   ,inserter-docstring
	   (interactive)
	   (let ((denote-directory (f-join (denote-directory) ,domain)))
	     (call-interactively #'denote-link)))
	 )))
#+end_src

** Domains

In [[id:7DF50246-B0AA-41C4-B986-E6DB305E653E][Migration Plan for Org-Roam Notes to Denote]] I talked about data structures and starting articulating some domains.

#+begin_marginnote
From Webster’s 1913 Dictionary: /Domain/: The territory over which dominion or authority is exerted; the possessions of a sovereign or commonwealth, or the like. Also used figuratively.

And the Mathematical concept of /Domain/: The domain of a function is the set of its possible inputs, i.e., the set of input values where for which the function is defined.
#+end_marginnote

As of <2022-10-02 Sun>, my denote finding implementation leverages =consult-projectile--file=.  This populates the mini-buffer with entries of the following format: =domain/identifier--multi-word-title_tag1_tag2.org=.  The domain is a subdirectory of my =denote-directory=.

I have the domains following:

- Blog Post :: Something I share with the world.
- Dailies :: An anchor for any time references.
- Employer :: More specifically, [[https://scientist.com][Scientist.com]].
- Epigraph :: A quote that I found interesting.
- Glossary :: A term/concept I reference.
- Indices :: A place to put the indices for referencing other documents; my various [[http://takeonrules.com/series/][Series]] would each make a great index.  As would the page Series.
- Melange :: “A mixture, a medley”; also an homage to Frank Herbert’s “Dune”
- People :: Similar to a glossary but for notes regarding people.

*** Blog Post

When I start writing a note, I am uncertain if it will be a /Blog Post/.  However, once I publish something I /think/ it makes sense to transfer the note into the /Blog Post/ domain.  By treating a /Blog Post/ as a domain it will be visually chunked at the beginning of the line (e.g. the subdirectory).

Alternatively I could add the “blog-post” keyword/tag to the note.  The primary benefit would be that something I post to my blog could be of another domain.

What might those other domains be?

I don’t think I need linger on this for too long, as I can easily migrate.  The foundational element is the =identifier=; which is dynamically queried.

#+begin_src emacs-lisp
  (jf/denote-create-functions-for :domain "blog-posts" :key ?b)
#+end_src

*** Dailies

While writing this document, I began envisioning replacing my [[id:1D7B007F-C257-412E-B329-3E85AB8BC43E][Org-Mode]] date macro with a =date= Org-Mode link protocol.  The benefits are:

1. Replacing the kludge of a macro with something that works easier with exports.
2. I would be creating a node that could provide a backlink.

None of this requires [[id:B659BD7E-30F9-4049-87ED-C47224399B7D][Denote]] but which builds on some of my musings; namely should I have a monthly timesheet in [[id:B659BD7E-30F9-4049-87ED-C47224399B7D][Denote]].  And the answer appears to be yes.

#+begin_src emacs-lisp
  (jf/denote-create-functions-for :domain "dailies" :key ?d)
#+end_src

I want to continue using my timesheets as a single document; this makes both time reporting and personal timetracking easier.

*** Employer

There are certain employer specific notes that I keep; timesheets being a distinct one.  I don’t envision a problem linking to other domains; a Scientist.com note could and would likely link to/reference a Glossary entry.

The primary advantage is that I can easily segement my git repositories for employer and not-employer.

I need a current timesheet function; this would help me jump to my time sheet and capture appropriate tasks, projects, merge requests and blockers.

I also want my =org-agenda-files= to include:

- personal agenda
- work agenda (on work machine)
- this month and last month’s time sheet

I’m okay with restarting [[denote:20220926T203507][Emacs]] each month.

#+begin_src emacs-lisp
  (jf/denote-create-functions-for :domain "scientist" :key ?s)
#+end_src

*** Epigraph

As mentioned, I collect phrases and like to reference them as epigraphs in my posts.

Something in the /Epigraph/ domain has the following properties:

- AUTHOR_NAME (required) :: The name of the author
- AUTHOR_URL :: Where can you “find” this author?
- AUTHOR_KEY :: The GLOSSARY_KEY for the given author
- WORK_TITLE (required) :: What’s the title of the work?
- WORK_URL :: Where can you “get” this work?
- WORK_KEY :: The GLOSSARY_KEY for the given work
- POEM :: Indicates if this is a poem (or not)
- PAGE :: The page in which this passage appears in the given work.
- TRANSLATOR_NAME :: The name of the translator

As part of my blog build scripts, I lookup the =KEY= properties in the Glossary and write the names and URL.
#+begin_sidenote
With all of the changes I’ve made, I need to see if I’m still looking up the =KEY= properties when I build the script.
#+end_sidenote

#+begin_src emacs-lisp
  (cl-defun jf/denote-create-epigraph (&key
				       (body (read-from-minibuffer "Epigraph Text: "))
				       ;; Todo prompt for Author Name
				       (author_name (read-from-minibuffer "Author Name: "))
				       ;; Todo prompt for Work Title
				       (work_title (read-from-minibuffer "Work Title: "))
				       (nth-words 8))
    "Create an epigraph from the given BODY, AUTHOR_NAME, and WORK TITLE.

  Default the note’s title to the first NTH-WORDS of the BODY."
    (interactive)
    (let* ((body-as-list (s-split-words body))
	   (title (s-join " " (if (> (length body-as-list) nth-words)
				  (subseq body-as-list 0 nth-words)
				body-as-list)))
	   (template (concat
		      "#+AUTHOR_NAME: " author_name "\n"
		      "#+AUTHOR_URL:\n"
		      "#+AUTHOR_KEY:\n"
		      "#+WORK_TITLE: " work_title "\n"
		      "#+WORK_URL:\n"
		      "#+WORK_KEY:\n"
		      "#+POEM:\n"
		      "#+PAGE:\n"
		      "#+TRANSLATOR_NAME:\n")))
      (denote title
	      nil
	      'org
	      (f-join (denote-directory) "epigraphs")
	      nil
	      template)))

  (jf/denote-create-functions-for :domain "epigraphs"
				  :key ?e
				  :create-fn 'jf/denote-create-epigraph)
#+end_src

*** Glossary

We’ll store glossary entries in the “glossary” subdirectory of =denote-directory=.

An entry in the glossary requires a =KEY= property.  This =KEY= is used as the entry point for [[https://github.com/jeremyf/takeonrules-hugo-theme/blob/main/layouts/shortcodes/glossary.html][my blogging =glossary.html= shortcode]].

All other properties, aside from =TITLE=, are optional.  In my writing there are two ways I directly refer to a glossary entry, when I:

- Reference a Game
- Use an Abbreviation

I might create two or three glossary entries at a time; so the easiest approach is to include all of the properties with minimal prompting.

#+begin_src emacs-lisp
  (cl-defun jf/denote-create-glossary-entry
      (&key
       (title (read-from-minibuffer "Name the Entry: "))
       (is-a-game (yes-or-no-p "Is this a game?"))
       (abbr (read-from-minibuffer "Abbreviation (empty to skip): ")))
    "Create a `denote' entry for the given TITLE and ABBR.

  And if this IS-A-GAME then amend accordingly.

  NOTE: At present there is no consideration for uniqueness."
    (interactive)
    (let* ((key (downcase (denote-sluggify (if (s-present? abbr) abbr title))))
	   (template (concat "#+GLOSSARY_KEY: " key "\n"
			     "#+ABBR:" (when (s-present? abbr) (concat " " abbr)) "\n"
			     "#+CONTENT_DISCLAIMER:\n" ;; TODO: Include a prompt of existing disclaimers
			     '			   "#+DESCRIPTION:\n"
			     (when is-a-game "#+GAME: " key "\n")
			     "#+ITEMID:\n"
			     "#+ITEMTYPE:\n"
			     "#+MENTION_AS:\n"
			     "#+OFFER:\n"
			     "#+PLURAL_ABBR:\n"
			     "#+PLURAL_TITLE:\n"
			     "#+SAME_AS:\n"
			     "#+TAG:\n" ;; TODO: Assert uniqueness
			     "#+VERBOSE_TITLE:\n"))
	   (keywords (list)))
      ;; Add both "abbr" and the abbr to the keywords; both help in searching results
      (when (s-present? abbr)
	(progn (add-to-list 'keywords "abbr") (add-to-list 'keywords abbr)))
      (when is-a-game (add-to-list 'keywords "game"))
      (denote title
	      keywords
	      'org
	      (f-join (denote-directory) "glossary")
	      nil
	      template)))

  (jf/denote-create-functions-for :domain "glossary" :key ?g :create-fn 'jf/denote-create-glossary-entry)
  ;;; Testing jf/denote-org-property-from-id
  ;; (message "%s" (jf/denote-org-property-from-id :id "20220930T215235"
  ;; 					      :property "ABBR"))
#+end_src

This builds from [[id:B22E2A14-D02B-432A-8D49-A94848C90187][On Storing Glossary Terms in Org Roam Nodes]].

Further, I want to use the =TAG= property as the controlled vocabulary for =denote-known-keywords=.  The following function creates a list of those tags.

#+begin_src emacs-lisp
  (cl-defun jf/calculated-list-of-denote-known-keywords (&key from)
    "Return a list of known keywords."
    (split-string-and-unquote
     (shell-command-to-string
      (concat
       "rg \"#\\+TAG:\\s([\\w-]+)\" "
       from
       " --only-matching"
       " --no-filename "
       " --replace '$1'"))
     "\n"))

  ;;; This should return a list
  ;; (message "%s" (jf/calculated-list-of-denote-known-keywords :from "~/git/org/denote/glossary"))
#+end_src

*** Melange

Things that don’t belong elsewhere belong here.

#+begin_src emacs-lisp
  (jf/denote-create-functions-for :domain "melange" :key ?m)
#+end_src

*** People

I do write notes about people I interact with.  Technically I have glossary entries for people.  But those entries are for folks I don’t interact with.

#+begin_src emacs-lisp
  (jf/denote-create-functions-for :domain "people" :key ?p)
#+end_src

*** Indices

On my site I write [[https://takeonrules.com/series/][series of related articles]].  I track this data in a [[abbr:20221009T115621][YAML]] file; I’d like to treat this data similar to my glossary.

#+begin_src emacs-lisp
  (cl-defun jf/denote-create-indices-entry (&key
					    (title (read-from-minibuffer "Name the Index: "))
					    (is-a-series (yes-or-no-p "Is this a Take on Rules Series?")))
    "Create a `denote' index entry for the given TITLE."
    (interactive)
    (let* ((keywords (list))
	   (template (concat (when (s-present? is-a-series)
			       "#+HIGHLIGHT: true\n"))))
      (when (s-present? is-a-series)
	(add-to-list 'keywords "series"))
      (denote title
	      nil
	      'org
	      (f-join (denote-directory) "indices")
	      nil
	      template)))

  (jf/denote-create-functions-for :domain "indices" :key ?i :create-fn 'jf/denote-create-indices-entry)
#+end_src

** Custom Hyperlinks

I have two custom hyperlinks to consider:

- Abbrevations (and their Plural)
- Date entries

*** Abbreviations (and their Plural)

#+begin_marginnote
[[date:2022-09-26][Earlier]] I wrote about [[id:B22E2A14-D02B-432A-8D49-A94848C90187][On Storing Glossary Terms in Org Roam Nodes]].  This builds from and supplants that prior work.
#+end_marginnote

As part of my writing I use of abbreviations.  I try to always provide the abbreviation’s title when I first introduce the abbrevation.  For most of those abbreviations I reference something in [[https://takeonrules.com/site-map/glossary/][my glossary]].

When I export to [[https://takeonrules.com/][my blog]], I want those abbreviations to leverage what I have in my local glossary.  I expand those abbreviatinos to use the [[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/abbr#defining_an_abbreviation][ABBR-element]].  I do this via my [[https://github.com/jeremyf/takeonrules-hugo-theme/blob/main/layouts/shortcodes/glossary.html][glossary.html shortcode]].

Below is the code that adds the =abbr= and =abbr-plural= link type into [[https://orgmode.org/manual/Handling-Links.html][Org-Mode’s link handler]]; for more information checkout the documentation on [[https://orgmode.org/manual/Adding-Hyperlink-Types.html][Adding Hyperlink Types]].

**** Building the Complete Functionality

First up is the functionality for completion.  Given that I have both =abbr= and =abbr-plural= link schemes, I’m going to create a generic function.

#+begin_marginnote
I prefer named parameters over positional parameters.  Which is why most of my Lisp functions leverage the =cl-defun= macro.
#+end_marginnote

The =jf/org-link-complete-link-for= function will pre-populate a search.  In the case of =abbr= and =abbr-plural= all entries will be in the =./glossary= subdirectory and have the keyword =_abbr=.

#+begin_src emacs-lisp
  (cl-defun jf/org-link-complete-link-for (parg &key scheme filter subdirectory)
    "Prompt for a SCHEME compatible `denote' with filename FILTER in the given SUBDIRECTORY.

  Returns a string of format: \"SCHEME:<id>\" where <id> is
  an `denote' identifier."
    (let* ((denote-directory (if subdirectory
				 (f-join (denote-directory)
					 (concat subdirectory "/"))
			       (denote-directory))))
      ;; This leverages a post v1.0.0 parameter of Denote
      ;; See https://git.sr.ht/~protesilaos/denote/commit/c6c3fc95c66ba093a266c775f411c0c8615c14c7
      (concat scheme
	      ":"
	      (denote-retrieve-filename-identifier (denote-file-prompt filter)))))
#+end_src

The above implementation assumes a post v1.0.0 implementation of Denote.  As of {{{date(2022-10-07,October 7th)}}} this is not part of a released version but is part of the =main= branch.

I was preparing to send a suggestion for that feature when I noticed the change; it is always reassuring to see folks recommend functions that are identical to what you were going to suggest.

**** Building the Export Functionality

Next is the export functionality.  There are many similarities between =abbr= and =abbr-plural=; what follows is the general function.

#+begin_src emacs-lisp
  (cl-defun jf/denote-link-ol-link-with-property (link description format protocol
						       &key
						       property-name
						       additional-hugo-parameters
						       (use_hugo_shortcode jf/exporting-org-to-tor))
    "Export a LINK with DESCRIPTION for the given PROTOCOL and FORMAT.

  FORMAT is an Org export backend. We will discard the given
  DESCRIPTION.  PROTOCOL is ignored."
    (let* ((prop-list (jf/denote-org-properties-from-id
		       :identifier link
		       :properties (list "TITLE" property-name  "GLOSSARY_KEY")))
	   (title (car (alist-get "TITLE" prop-list nil nil #'string=)))
	   (property (car (alist-get property-name prop-list nil nil #'string=)))
	   (key (car (alist-get "GLOSSARY_KEY" prop-list property nil #'string=))))
	   (cond
	    ((or (eq format 'html) (eq format 'md))
	     (if use_hugo_shortcode
		 (format "{{< glossary key=\"%s\" %s >}}"
			 property
			 additional-hugo-parameters)
	       (format "<abbr title=\"%s\">%s</abbr>"
		       title
		       property)))
	     (t (format "%s (%s)"
			title
			property)))))
#+end_src

**** Registering the Link Types

With the above preliminaries, here are the two parameter types and their configurations.

#+begin_src emacs-lisp
  (org-link-set-parameters "abbr"
			   :complete (lambda (&optional parg) (jf/org-link-complete-link-for
							       parg
							       :scheme "abbr"
							       :filter "_abbr*"
							       :subdirectory "glossary"))
			   :export (lambda (link description format protocol)
				     (jf/denote-link-ol-link-with-property link description format protocol
									   :property-name "ABBR"
									   :additional-hugo-parameters "abbr=\"t\""))
			   :face #'denote-faces-link
			   :follow #'denote-link-ol-follow
  ;;; I'm unclear if/how I want to proceed with this
			   ;; :store (lambda (jf/org-link-store-link-for :scheme "abbr"))
			   )

  (org-link-set-parameters "abbr-plural"
			   :complete (lambda (&optional parg) (jf/org-link-complete-link-for
							       parg
							       :scheme "abbr-plural"
							       :filter "_plural_abbr*"
							       :subdirectory "glossary"))
			   :export (lambda (link description format protocol)
				     (jf/denote-link-ol-link-with-property link description format protocol
									   :property-name "PLURAL_ABBR"
									   :additional-hugo-parameters "abbr=\"t\" plural=\"t\""))
			   :face #'denote-faces-link
			   :follow #'denote-link-ol-follow
  ;;; I'm unclear if/how I want to proceed with this
			   ;; :store (lambda (jf/org-link-store-link-for :scheme "abbr-plural"))
			   )
#+end_src

*** Date Entries

I want to register the =date= scheme for Org-Mode links.

#+begin_src emacs-lisp
  (org-link-set-parameters "date"
			   :complete #'jf/denote-link-complete-date
			   :export #'jf/denote-link-export-date
			   :face #'denote-faces-link
			   :follow #'jf/denote-link-follow-date
			   ;; :store (lambda (jf/org-link-store-link-for :scheme "abbr"))
			   )

  (cl-defun jf/denote-link-complete-date (&optional parg)
    "Prompt for the given DATE.

  While we are prompting for a year, month, and day; a reminder
  that this is intended to be conformant with the TIME element.
  But for my typical use I write these as either years; years and
  months; and most often year, month, and days."
    (format "date:%s" (org-read-date)))

  (cl-defun jf/denote-link-export-date (link description format protocol)
    "Export a date for the given LINK, DESCRIPTION, FORMAT, and PROTOCOL."
    (cond
     ((or (eq format 'html) (eq format 'md))
      (format "<time datetime=\"%s\">%s</time>" link description))
     (t (format "%s (%s)" description link))))


  (cl-defun jf/denote-link-follow-date (date &optional parg)
    "Follow the given DATE; uncertain what that means."
    (message "TODO, implement link for %s" date))
#+end_src

*** Epigraph Entries

I want to be able to link and export my epigraph entries.  For now, I'm going to focus on the HTML and Markdown version; as most often when I include an epigraph it is for my blog posts.

#+begin_src emacs-lisp
  (cl-defun jf/denote-link-ol-epigraph-link-with-property (link description format protocol
						       &key
						       property-name
						       additional-hugo-parameters
						       (use_hugo_shortcode jf/exporting-org-to-tor))
    "Export the epigraph for the given LINK, DESCRIPTION, PROTOCOL, and FORMAT.

  NOTE: This only works for blog export.
  TODO: Consider how to expand beyond blog support."
    (let* ((prop-list (jf/denote-org-properties-from-id
			 :identifier link
			 :properties (list "TITLE" property-name  "GLOSSARY_KEY"))))
	   (cond
	    ((and use_hugo_shortcode (or (eq format 'html) (eq format 'md)))
	     (format "{{< epigraph key=\"%s\" >}}" link))
	    (t nil))))

  (org-link-set-parameters "epigraph"
			   :complete (lambda (&optional parg) (jf/org-link-complete-link-for
							       parg
							       :scheme "epigraph"
							       :filter ""
							       :subdirectory "epigraphs"))
			   :export (lambda (link description format protocol)
				     (jf/denote-link-ol-epigraph-link-with-property link description format protocol
										    :property-name "ABBR"
										    :additional-hugo-parameters "abbr=\"t\""))
			   :face #'denote-faces-link
			   :follow #'denote-link-ol-follow
  ;;; I'm unclear if/how I want to proceed with this
			   ;; :store (lambda (jf/org-link-store-link-for :scheme "abbr"))
			   )
#+end_src

** Export Function

The below function over-writes the denote export logic.  It works in a specific case but will likely require further tweaks.

#+begin_src emacs-lisp
  (defun jf/denote-link-ol-export (link description format)
    "Export a `denote:' link from Org files.
  The LINK, DESCRIPTION, and FORMAT are handled by the export
  backend."
    (let* ((path-id (denote-link--ol-resolve-link-to-target link :path-id))
	   (title (jf/denote-org-property-from-id :identifier link :property "TITLE"))
	   (path (file-name-nondirectory (car path-id)))
	   (url (or (jf/denote-export-url-from-id link) (format "%s.%s" (file-name-sans-extension path) format)))
	   (desc (or description title)))
      (cond
       ((eq format 'html) (format "<a href=\"%s\">%s</a>" url desc))
       ((or (eq format 'latex) (eq format 'beamer)) (format "\\href{%s}{%s}" (replace-regexp-in-string "[\\{}$%&_#~^]" "\\\\\\&" path) desc))
       ((eq format 'texinfo) (format "@uref{%s,%s}" path desc))
       ((eq format 'ascii) (format "[%s] <denote:%s>" desc path)) ; NOTE 2022-06-16: May be tweaked further
       ((eq format 'md) (format "[%s](%s)" desc url))
       (t path))))

  (advice-add #'denote-link-ol-export :override #'jf/denote-link-ol-export '((name . "wrapper")))
#+end_src

When I link to glossary entries, I want to use their URLs.  I have several different fields that could have the “export url”:

- OFFER :: The URL which you can “get” the item (e.g. purchase the game, find where to check it out at a library)
- ROAM_REFS :: In past incarnations, I would add a ROAM_REFS to the Org-Roam node that was my “local” blog post.
- SAME_AS :: This could be the primary URL; however due to past implementations, I was extracting the SAME_AS URL from the ITEMID; which was typically the Wikidata URL.

As of <2022-10-14 Fri>, a future consideration is to move away from ROAM_REFS.  I would likely move that entry to the SAME_AS node.

#+begin_src emacs-lisp
  (defun jf/denote-export-url-from-id (identifier)
    "Return the appropriate url for the given `denote' identifier."
    (when-let ((filename (denote-get-path-by-id identifier)))
      (when (string= (file-name-extension filename) "org")
	(with-current-buffer (find-file-noselect filename)
	  (let* ((props-plist (jf/org-global-props-as-plist :props-regexp "\\(OFFER\\|ROAM_REFS\\|SAME_AS\\)")))
	    (cond
	     ;; Favor affiliate links
	     ((lax-plist-get props-plist "OFFER"))
	     ((when-let ((refs (lax-plist-get props-plist "ROAM_REFS")))
		(first (s-split " " refs t))))
	     ((lax-plist-get props-plist "SAME_AS"))))))))

  ;;; Should be: https://www.worldcat.org/title/dune/oclc/1241164333/editions?referer=di&editionsView=true
  ;; (message "%s" (jf/denote-export-url-from-id "20221009T115949"))
  ;;; Should be https://samvera.org
  ;; (message "%s" (jf/denote-export-url-from-id "20221009T120341"))
  ;;; Should be https://en.wikipedia.org/wiki/Jira_(software)
  ;; (message "%s" (jf/denote-export-url-from-id "20221009T120152"))
  ;;; Should be nil
  ;;(message "%s" (jf/denote-export-url-from-id "20221009T120712"))
  #+end_src

#+begin_src emacs-lisp
  (defun jf/associate-blog-post-url-with-identifier (url identifier)
    "Associate given URL with the `denote' IDENTIFIER."
    (let* ((filename (denote-get-path-by-id identifier))
	   (buffer (find-file-noselect filename)))
      (with-current-buffer buffer)
      (jf/export-org-to-tor--global-buffer-prop-ensure
			    :key "ROAM_REFS"
			    :plist (jf/org-global-props-as-plist "ROAM_REFS")
			    :default url)))
#+end_src

** Additional Tooling

*** Capture URL and Title


#+begin_src emacs-lisp
  (defun jf/menu--org-capture-firefox ()
    "Create an `denote' entry from Firefox page."
    (interactive)
    (require 'grab-mac-link)
    (let* ((link-title-pair (grab-mac-link-firefox-1))
	   (url (car link-title-pair))
	   (title (cadr link-title-pair)))
      (jf/denote-capture-reference :url url :title title)))

  (defun jf/menu--org-capture-safari ()
    "Create an `denote' entry from Safari page."
    (interactive)
    (require 'grab-mac-link)
    (let* ((link-title-pair (grab-mac-link-safari-1))
	   (url (car link-title-pair))
	   (title (cadr link-title-pair)))
      (jf/denote-capture-reference :url url :title title)))

  (defun jf/menu--org-capture-eww ()
    "Create an `denote' entry from `eww' data."
    (interactive)
    (let* ((url (plist-get eww-data :url))
	   (title (plist-get eww-data :title)))
      (jf/denote-capture-reference :url url :title title)))

  (cl-defun jf/menu--org-capture-elfeed-show (&key (entry elfeed-show-entry))
    "Create a `denote' from `elfeed' ENTRY."
    (interactive)
    (let* ((url (elfeed-entry-link entry))
	   (title (elfeed-entry-title entry)))
      (jf/denote-capture-reference :url url :title title)))

  (cl-defun jf/denote-capture-reference (&key title url keywords (subdirectory "melange"))
    "Create a `denote' entry for the TITLE and URL."
    (denote title
	    keywords
	    'org
	    (f-join (denote-directory) subdirectory)
	    nil
	    (template (concat "#+ROAM_REFS: " url "\n"))))
#+end_src

** Conclusion

I wrote this configuration with the intention of publishing to my blog.  I have locally tested things and incorporated it into [[id:4E720715-3D6E-467E-8943-B9F2518B7494][my dotemacs]].

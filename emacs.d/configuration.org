-*- org-insert-tilde-language: emacs-lisp; -*-
#+TITLE: Emacs Configuration
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+STARTUP: overview
* Introduction

On <2022-02-01 Tue> I chose to begin extracting my the various ~*.el~ into a
[[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]] format.  As with all Emacs configurations, what follows is
a work in progress.

** Tips on Troubleshooting

As I migrated from my ~*.el~ configurations, I moved one ~.el~ file at a time.
With each move, I would restart my Emacs daemon[fn:daemon].  I went so far as
to write a ~e-reboot~ alias[fn:e-reboot].  So if I “messed up”, I could easily
recover and fix the files I broke.

In other words, when I’m working on extending my Emacs configuration, I tend to
favor a bisset approach.  Make a change, verify it, and commit.  This helps
insulate me from “getting to far ahead of myself.”

** About the Current Structure

The current structure is carried over from my past structure.  As I was first
adopting Emacs, I spent time organizing the packages.  This organization is a
bit muddy, as I never quite established the nomenclature.

What I can say is the order may be important.  But I’ll be working to untangle
that.

Where feasible, I have tried to bind keys “close” to their utilization.  That
is to say, I often leverage the ~:bind~, ~:hook~, and ~:map~ keywords for
~use-package~.  But I’m not always consistent.

In the ~org-mode~ version, I’m making use of “TODO” indicators to help me track
what else I may need to do.  A node marked as “DONE” should be viewed as “I
don’t need to go back and amend any documentation in that part.  However, it
doesn’t mean I won’t put more things in that section.”

* Basic Configuration

** DONE straight.el

I have chosen to adopt ~straight.el~ for my package management.  The fact that
it rather seamlessly works with ~use-package~ has help me keep my code more
organized.

#+begin_src emacs-lisp
  ;; https://www.reddit.com/r/emacs/comments/mtb05k/emacs_init_time_decreased_65_after_i_realized_the/
  (setq straight-check-for-modifications '(check-on-save find-when-checking))

  ;; This preamble is part of straight-use-package My understanding, in
  ;; reading straight documentation is that it has better load
  ;; times. However, the configuration options I often see leverage
  ;; "use-package" which is why most of my package declarations look as
  ;; they do.
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file))

  (setq straight-repository-branch "develop")
  (straight-use-package 'use-package)
#+end_src

** DONE Early Configuration

These are some general configurations that I’ve slowly accumulated.  There’s
inline documentation in most cases.

#+begin_src emacs-lisp
  (setq user-full-name "Jeremy Friesen"
	user-mail-address "jeremy@jeremyfriesen.com")

  (defconst jnf-silence-loading-log t
    "When t log to stdout load messages from this configuration.

  In a previous iteration, I loaded lots of separate '*.el' files.
  This flag allowed me to more easily troubleshoot those load
  attempts.")

  (global-so-long-mode) ;; Handle long files.
  (electric-pair-mode)  ;; https://blog.sumtypeofway.com/posts/emacs-config.html
  (make-directory "~/.emacs.d/autosaves/" t) ;; Ensuring I have an autosave
  ;; directory.
  (recentf-mode 1) ;; Track recent
  (run-at-time nil (* 2 60) 'recentf-save-list) ;; Save files every 2 minutes
  (global-auto-revert-mode)
  (blink-cursor-mode t)

  (setq-default fill-column 79)   ;; Feeling a bit old school with 80 characters.
  (setq-default cursor-type 'bar) ;; Doing a bit of configuration of my cursors

  (setq
   backup-by-copying t         ;; Don't delink hardlinks
   backup-directory-alist '((".*" . "~/.emacs.d/backups/"))
   bookmark-default-file "~/git/jnf-emacs-bookmarks/bookmarks"
   custom-safe-themes t        ;; I may as well trust themes.
   create-lockfiles nil        ;; Don't create lock files.
   delete-old-versions t       ;; Automatically delete excess backups
   idle-update-delay 1.1       ;; Slow down the UI being updated to improve
   ;; performance
   indent-tabs-mode nil        ;; Ensure tabs are expanded, not inserted
   inhibit-startup-screen t    ;; Don't include the  emacs "start" window
   kept-new-versions 20        ;; how many of the newest versions to keep
   kept-old-versions 5         ;; and how many of the old
   kill-ring-max 120           ;; Set a generous kill ring size.
   read-process-output-max (* 1024 1024 3)  ;; Increase read size per process
   recentf-max-menu-items 50
   recentf-max-saved-items 50
   ring-bell-function 'ignore  ;; Stop ringing any bell
   split-width-threshold 100   ;; Most of the times I favor two windows
   ;; side-by-side within a frame
   vc-follow-symlinks t        ;; Follow symlinks instead of prompting.
   version-control t           ;; Use version numbers on backups
   x-underline-at-descent-line t ;; Recommendation from https://protesilaos.com/emacs/modus-themes
   )


  (global-hl-line-mode)

  ;; When you open Emacs, grab all the space on the screen
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))

  (tool-bar-mode -1) ;; Hide the icons of the Emacs toolbar
  (scroll-bar-mode -1) ;; Hide the scroll bar. Let's be clear, I don't use it.
  (defalias 'yes-or-no-p 'y-or-n-p) ;; Always "y" or "n" for yes/no

  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

  (add-hook 'text-mode-hook #'abbrev-mode)

  (add-function :after after-focus-change-function
		(defun jnf/garbage-collect-maybe ()
		  (unless (frame-focus-state)
		    (garbage-collect))))
#+end_src

** TODO Keymappings

#+begin_src emacs-lisp
  (unbind-key "C-x C-d") ;; `list-directory'
  ;; `dired' is a better interface than `list-directory'
  (global-set-key (kbd "C-x C-d") 'dired)
  (global-set-key (kbd "<M-delete>") 'kill-word)

  (global-set-key (kbd "<s-down>") 'end-of-buffer)
  (global-set-key (kbd "<s-up>") 'beginning-of-buffer)

  ;; Far to easy to type this on accident, and I'm not a fan of it's behavior.
  (unbind-key "C-z") ;; `suspend-frame'

  ;; Given that C-c C-x is common within org-mode, I found myself
  ;; accidentally invoking this transposition.  I have "s-q" command for
  ;; this.
  (unbind-key "C-x C-c") ;; was `save-buffers-kill-terminal'
#+end_src


** DONE Utility Packages

These are some “invisible” packages that do some behind the scenes work.

- ~diminish~ :: Provides a means of not displaying the :lighter of a minor mode in the modeline.

#+begin_src emacs-lisp
  (use-package diminish :straight t)
  (diminish 'eldoc-mode)
#+end_src

- ~gcmh.el~ :: Do garbage collection (GC) when the user is idle.

#+begin_src emacs-lisp
  (use-package gcmh
    :straight t
    :diminish 'gcmh-mode
    :init
    (setq gcmh-idle-delay 5
	  gcmh-high-cons-threshold (* 16 1024 1024))  ; 16mb
    :config (gcmh-mode))
#+end_src

- ~keychain-environment.el~ :: Load keychain environment variables

#+begin_src emacs-lisp
  (use-package keychain-environment
    :straight t
    :config (keychain-refresh-environment))
#+end_src

- ~dash.el~ :: A modern list API for Emacs. No 'cl required.  (See https://github.com/magnars/dash.el/)

#+begin_src emacs-lisp
  (use-package dash :straight t)
#+end_src

- ~editorconfig.el~ :: “EditorConfig helps maintain consistent coding styles
  for multiple developers working on the same project across various editors
  and IDEs.”  See https://editorconfig.org/#overview for more details.

#+begin_src emacs-lisp
  (use-package editorconfig
    :straight t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))
#+end_src

- ~f.el~ :: A modern API for working with files and directories in Emacs. (See https://github.com/rejeep/f.el/)

#+begin_src emacs-lisp
  (use-package f :straight t)
#+end_src

- ~s.el~ :: The long lost Emacs string manipulation library.  (See https://github.com/magnars/s.el/)

#+begin_src emacs-lisp
  (use-package s :straight t)
#+end_src

- ~transient.el~ :: A package for building “menus” to prompt for additional
  input before executing a command. See [[https://github.com/tecosaur/screenshot/blob/master/screenshot.el][screenshot.el]] for some examples or the
  ubiquitous [[https://magit.vc][magit.el]].

#+begin_src emacs-lisp
  (use-package transient :straight t)
#+end_src

- ~helfpul.el~ :: A package to help introspect on Emacs.  When learning Emacs,
  both then and now, I often invoke this helpful commands.

#+begin_src emacs-lisp
  ;; I have found this package quite "helpful"; When I want to know the
  ;; name of a function or key or variable, I can use the helpful
  ;; package.
  (use-package helpful
    :straight t
    :config
    (transient-define-prefix jnf/helpful-menu ()
      "Return a `transient' compliant list to apply to different transients."
      ["Help"
       ""
       ("b" "Bindings" embark-bindings)
       ("c" "Command" helpful-command)
       ("f" "Function (interactive)" helpful-callable)
       ("F" "Function (all)" helpful-function)
       ("k" "Key" helpful-key)
       ("l" "Library" find-library)
       ("m" "Macro" helpful-macro)
       ("p" "Thing at point" helpful-at-point)
       ("." "Thing at point" helpful-at-point)
       ("t" "Text properties" describe-text-properties)
       ("v" "Variable" helpful-variable)])
    :bind ("C-s-h" . jnf/helpful-menu))
#+end_src

** TODO Variable/const definitions

#+begin_src emacs-lisp

  (defconst jnf/fixed-width-font-name
    "Hack Nerd Font"
    "The name of the fixed width font.
  I have it sprinkled through too many places.

  Alternatives:
  - \"Monaco\"
  - \"JetBrains Mono\"
  - \"Hack Nerd Font\"")

  (set-frame-font jnf/fixed-width-font-name)

  (defconst jnf/tor-home-directory
    (file-truename "~/git/takeonrules.source")
    "The home directory of TakeOnRules.com Hugo repository.")

  (defconst jnf/tor-default-local-hostname
    "http://localhost:1313"
    "The scheme, host name, and port for serving up a local TakeOnRules.com.")

  (defvar jnf/data-directories
    (list
     jnf/tor-home-directory
     "~/git/takeonrules.source/themes/hugo-tufte"
     "~/git/burning_wheel_lifepaths/"
     "~/git/jnf-emacs-bookmarks"
     "~/git/dotzshrc/"
     "~/git/dotemacs/"
     "~/git/org/"
     "~/git/org/archive"
     "~/git/org/daily"
     "~/git/org/public"
     "~/git/org/personal"
     "~/git/org/personal/thel-sector"
     "~/git/org/hesburgh-libraries"
     "~/git/org/forem"
     )
    "Relevant data directories for my day to day work.")
#+end_src

** TODO pretty-hydra.el

#+begin_src emacs-lisp

  ;; I use this package to "configure" menus, hence this is in the
  ;; config section.
  (use-package pretty-hydra
    :straight (pretty-hydra
	       :type git :host github :repo "jerrypnz/major-mode-hydra.el"
	       :files (:defaults (:exclude "major-mode-hydra.el"))))
#+end_src

* WAITING Display

** DONE modus-themes.el

The modus themes (e.g. ~modus-vivendi~ and ~modus-operandi~) provide a light
and dark theme with a focus on visual accessibility.

I love [[http://protesilaos.com][Prot]]’s attention to detail with the modus themes).  Here’s my
configuration for these two sibling themes.

#+begin_src emacs-lisp
  (use-package modus-themes
    ;; :straight (modus-themes :type built-in)
    :straight (:type git :host gitlab :repo "protesilaos/modus-themes" :branch "main")
    :init
    (setq
     modus-themes-bold-constructs t
     modus-themes-completions 'opinionated ; {nil,'moderate,'opinionated}
     modus-themes-diffs nil ; {nil,'desaturated,'fg-only}
     modus-themes-fringes 'intense ; {nil,'subtle,'intense}
     modus-themes-hl-line '(accented intense)
     modus-themes-intense-markup t
     modus-themes-links '(faint background)
     modus-themes-mixed-fonts t
     modus-themes-mode-line '(accented 3d)
     modus-themes-org-blocks 'gray-background
     modus-themes-paren-match '(bold intense)
     modus-themes-prompts '(intense accented)
     modus-themes-region '(bg-only accented)
     modus-themes-scale-headings t
     modus-themes-slanted-constructs t
     modus-themes-subtle-line-numbers t
     modus-themes-syntax '(alt-syntax yellow-comments green-strings)
     modus-themes-tabs-accented t
     modus-themes-headings
     '((1 . (variable-pitch light 1.6))
       (2 . (overline semibold 1.4))
       (3 . (monochrome overline 1.2))
       (4 . (overline 1.1))
       (t . (rainbow 1.05)))))
#+end_src

With a quick bit of testing, it appears that the following ~set-face-attribute~
declarations should be made after the theme declarations.  When the following
statements were declared before the themes, and I toggled my theme, the font
changed to something unexpected.  With them declared after, I keep the fonts
between toggles.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil
		      :family jnf/fixed-width-font-name
		      :height 140)
  (set-face-attribute 'variable-pitch nil
		      :family "ETBembo"
		      :height 1.1)
  (set-face-attribute 'fixed-pitch nil
		      :family jnf/fixed-width-font-name
		      :height 1.0)
#+end_src

** DONE lin.el

- ~lin.el~ :: “LIN locally remaps the hl-line face to a style that is optimal for major modes where line selection is the primary mode of interaction.”  In otherwords, ~lin.el~ improves the highlighted line behavior for the competing contexts.

#+begin_src emacs-lisp
  (use-package lin
    :straight (lin :host gitlab :repo "protesilaos/lin")
    :config (lin-add-to-many-modes))
#+end_src

** DONE all-the-icons.el

- ~all-the-icons.el~ :: Provides a nice set of reference icons.  The various
  ~jnf/all-with--with-~ functions give access to the icons of the named set.

#+begin_src emacs-lisp
  ;; Useful for referential icons.
  (use-package all-the-icons
    :straight t
    :config
    (cl-defmacro jnf/all-the-icons--with(&key name)
      (let ((defun-fn (intern (concat "jnf/all-the-icons--with-" name)))
	    (icon-fn (intern (concat "all-the-icons-" name)))
	    (docstring (concat "Displays an ICON from `all-the-icons-" name "'.")))
	`(defun ,defun-fn (icon str &optional height v-adjust)
	   ,docstring
	   (s-concat (,icon-fn
		      icon
		      :v-adjust (or v-adjust 0)
		      :height (or height 1))
		     " " str))))
    (jnf/all-the-icons--with :name "faicon")
    (jnf/all-the-icons--with :name "material")
    (jnf/all-the-icons--with :name "octicon")
    (jnf/all-the-icons--with :name "alltheicon"))
#+end_src

** DONE all-the-icons-dired.el

- ~all-the-icons-dired.el~ :: Incorporates file icons with file listings of
  dired.  /Note/: On 2021-04-11 I was getting the following error with this
  package: "*ERROR*: Symbol's value as variable is void: file"

#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :straight t
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

** DONE spaceline.el

- ~spaceline.el~ :: A nice looking modeline enhancement

#+begin_src emacs-lisp
  (use-package spaceline :straight t)
#+end_src

** DONE spaceline-all-the-icons.el

- ~spaceline-all-the-icons.el~ ::  Add some visual flair to the modeline enhancements.  Disabled as of <2022-02-03 Thu>.

#+begin_src emacs-lisp
  ;; (use-package spaceline-all-the-icons
  ;;  :straight t
  ;;  :after spaceline
  ;;  :config (spaceline-all-the-icons-theme))
#+end_src

** DONE popper.el

- ~popper.el~ :: Treat some types of windows as popups (e.g., something easier
  to dismiss, a bit more like the mini-buffer).  Further ~jnf/popper~ can
  toggle the popup buffer.  See that method for further implementation details.

#+begin_src emacs-lisp
  (use-package popper
    :straight t
    :bind (("C-`" . jnf/popper))
    :config
    (defun jnf/popper (prefix_arg)
      "Call `popper-cycle', but with PREFIX_ARG invoke a less common popper method.

  With one PREFIX_ARG, `popper-toggle-latest'.
  With two (or more) PREFIX_ARG `popper-toggle-type'."
      (interactive "P")
      (let ((prefix (car prefix_arg)))
	(cond
	 ((not prefix)  (popper-cycle))
	 ((= prefix 4)  (popper-toggle-latest))
	 (t (popper-toggle-type)))))
    :init
    (setq popper-reference-buffers
	  '("\\*Messages\\*"
	    "Output\\*$"
	    "\\*Async Shell Command\\*"
	    help-mode
	    compilation-mode
	    "^\\*helpful.*\\*$"))
    (popper-mode +1)
    (popper-echo-mode +1))

#+end_src

** WAITING shackle.el

- ~shackle.el~ :: Enforce rules for popups.  See https://depp.brause.cc/shackle/.

#+begin_src emacs-lisp
  (use-package shackle
    :straight t
    :custom
    (shackle-rules '((compilation-mode :noselect t))
		   shackle-default-rule '(:select t)))
#+end_src

/Note:/ How does this related to ~popper.el~?

** DONE ace-window.el

- ~ace-window.el~ :: A window manager for emacs, allowing fast toggles between
  windows as well as opening or moving those windows.  See
  https://github.com/abo-abo/ace-window for more details.

#+begin_src emacs-lisp
  (use-package ace-window
    :straight t
    :bind (("M-o" . ace-window)))
#+end_src

* TODO General Emacs Configuration

I tried enabling this, and found myself sometimes lost in a labyrinth of
minibuffers.  This change ensures that there’s only one.

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers nil)
#+end_src

** MacOS Specific

*** DONE grab-mac-link.el

- ~grab-mac-link.el~ :: Grab a link from a variety of MacOS applications.

#+begin_src emacs-lisp
  (use-package grab-mac-link
    :straight t
    :config
    ;; A replacement function for existing grab-mac-link-make-html-link
    (defun jnf/grab-mac-link-make-html-link (url name)
      "Using HTML syntax, link to and cite the URL with the NAME."
      (format "<cite><a href=\"%s\" class=\"u-url p-name\" rel=\"cite\">%s</a></cite>" url name))
    ;; The function advice to override the default behavior
    (advice-add
     'grab-mac-link-make-html-link
     :override
     'jnf/grab-mac-link-make-html-link
     '((name . "jnf")))
    :bind (("C-c g" . grab-mac-link)))
#+end_src

*** DONE org-mac-link.el

- ~org-mac-link.el~ :: Similar to ~grab-mac-link.el~ this specifically grabs a link and insersts in ~org-mode~ format.

#+begin_src emacs-lisp
  (use-package org-mac-link
    :ensure t
    :straight (org-mac-link :type git :host github :repo "jeremyf/org-mac-link")
    :bind (:map org-mode-map (("C-c g" . org-mac-grab-link))))
#+end_src

*** TODO pdf-tools.el

#+begin_src emacs-lisp
  ;; Emacs comes with DocView built in.  pdf-tools is a replacement for
  ;; DocView.  I've found the rendered images a bit more crisp and the
  ;; interactions a bit more responsive.  However, I have not been able
  ;; to get `org-noter' working with `pdf-tools'.  `org-noter' provides
  ;; annotation services for PDFs.
  (use-package pdf-tools
    :pin manual ;; manually update
    :straight t
    :defer t
    :ensure t
    :config (pdf-tools-install) ;; initialise
    (setq-default pdf-view-display-size 'fit-page) ;; open pdfs scaled to fit page
    (setq pdf-annot-activate-created-annotations t) ;; automatically annotate highlights
    (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward);; use normal isearch
    )
#+end_src

*** DONE so-long.el

- ~so-long.el~ :: Really long files or long lines can cause problems for Emacs.  This mode helps with that.

#+begin_src emacs-lisp
  (use-package so-long
    :ensure t
    :defer t
    :straight t
    :bind
    (:map so-long-mode-map
	  ("C-s" . isearch-forward)
	  ("C-r" . isearch-backward))
    :config (global-so-long-mode 1))
#+end_src

* TODO Modes

Sometimes I want to edit svg files.  Often times if I open them directly in
Emacs, I want to edit them.  This setting helps with that default.  /Note:/
without this setting, Emacs will happily render the SVG as an image,

#+begin_src emacs-lisp
  (add-to-list `auto-mode-alist '("\\.svg\\'" . xml-mode))
#+end_src

** TODO emmet-mode.el

#+begin_src emacs-lisp
  (use-package emmet-mode
    :straight t
    :bind (("C-c C-e" . emmet-expand-yas ))
    :hook ((sgml-mode . emmet-mode)
	   (html-mode . emmet-mode)
	   (css-mode . emmet-mode)))
#+end_src

** TODO web-mode.el

#+begin_src emacs-lisp
  (use-package web-mode
    :straight t
    :config (setq web-mode-markup-indent-offset 2
		  web-mode-css-indent-offset 2
		  web-mode-code-indent-offset 2))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))

  ;; built-in, consider commenting
  ;; (use-package sgml-mode
  ;;   :straight nil
  ;;   :hook
  ;;   (html-mode . sgml-electric-tag-pair-mode)
  ;;   (html-mode . sgml-name-8bit-mode)
  ;;   :custom
  ;;   (sgml-basic-offset 2))
#+end_src

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :config (setq plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  plantuml-default-exec-mode 'executable
		  org-plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  org-plantuml-exec-mode 'executable)
    :mode (("\\.plantuml\\'" . plantuml-mode))
    :straight t)
#+end_src

#+begin_src emacs-lisp
  (use-package json-mode :straight t)
#+end_src

Because JSON can be quite ugly, I want something to help tidy it up.
#+begin_src emacs-lisp
  (use-package json-reformat
    :straight t
    :after json-mode
    :init (setq json-reformat:indent-width 2))

#+end_src

** DONE go-mode.el

Every so often I stumble upon a Go package.  The ~go-mode~ package gives me the
syntax highlighting that makes reading ~Go-lang~ tolerable.

#+begin_src emacs-lisp
  (use-package go-mode :straight t)
#+end_src

** TODO markdown-mode.el

#+begin_src emacs-lisp
  (use-package markdown-mode
    :straight t
    :hook ((markdown-mode . turn-on-visual-line-mode))
    ;; I use markdown for my blogging platform and very little else.
    ;; Hence, I have this keybind.
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "/usr/local/bin/pandoc"))
#+end_src

** TODO yaml-mode.el

#+begin_src emacs-lisp
  (use-package yaml-mode :straight t)
#+end_src

** TODO lua-mode.el

#+begin_src emacs-lisp
  (use-package lua-mode :straight t)
#+end_src

** TODO git-modes.el

#+begin_src emacs-lisp
  (use-package git-modes :straight t)
#+end_src

** TODO enh-ruby-mode.el

#+begin_src emacs-lisp
  (defun jnf/enh-ruby-mode-hook-hook ()
    (setq fill-column 100))
  ;; I'm provisionally addinig enh-ruby-mode and robe.  I've found that
  ;; LSP can work, but has it's own problems; namely you need solargraph
  ;; installed for all versions.
  (use-package enh-ruby-mode
    :straight t
    :config (add-hook 'enh-ruby-mode-hook #'jnf/enh-ruby-mode-hook-hook)
    :bind (:map enh-ruby-mode-map ("C-j" . avy-goto-char-timer))
    :mode (("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . enh-ruby-mode)))
  (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))
#+end_src

** TODO rspec-mode.el

#+begin_src emacs-lisp
  (use-package rspec-mode
    :straight t
    :custom (rspec-use-spring-when-possible nil)
    :diminish 'rspec-mode
    :bind (:map rspec-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :bind (:map enh-ruby-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :hook (ruby-mode . rspec-mode) ;; should this be `enh-ruby-mode'
    (ruby-mode . eldoc-mode)) ;; should this be `enh-ruby-mode'

  (eval-after-load 'rspec-mode
    '(rspec-install-snippets))
#+end_src

** TODO projectile-rails.el

#+begin_src emacs-lisp
  (use-package projectile-rails
    :after (projectile)
    :diminish 'projectile-rails-mode
    :straight t
    :config
    (defun projectile-rails-find-liquid ()
      "Find a liquid tag."
      (interactive)
      (projectile-rails-find-resource
       "liquid: "
       '(("app/liquid_tags/" "\\(.+?\\)\\.rb\\'"))
       "app/liquid_tags/${filename}.rb"))
    :bind (:map
	   projectile-rails-mode-map (("C-s-." . 'projectile-rails-goto-file-at-point)))
    :config (projectile-rails-global-mode))

  ;; (use-package rails-i18n
  ;;   :straight t)
#+end_src

** TODO ruby-interpolation.el

#+begin_src emacs-lisp
  ;; Nice and simple pakcage for string interpolation.
  (use-package ruby-interpolation
    :straight t
    :diminish 'ruby-interpolation-mode
    :hook (enh-ruby-mode . ruby-interpolation-mode))
#+end_src

** TODO ruby-electric.el

#+begin_src emacs-lisp
  (use-package ruby-electric
    :straight t
    :diminish 'ruby-electric-mode
    ;; Somtimes I want this enabled, other times not; but it's a bit
    ;;  obnoxious in spec.rb files.
    ;;
    ;; :hook (enh-ruby-mode . ruby-electric-mode)
    )
#+end_src

** TODO rails-routes.el

#+begin_src emacs-lisp
  (use-package rails-routes
    :after projectile-rails
    :straight t)
#+end_src

** TODO ruby menus

#+begin_src emacs-lisp
  (defvar jnf/projectile-rails--title (jnf/all-the-icons--with-alltheicon "ruby-alt" "Rails" 1 -0.05))
  (pretty-hydra-define jnf/projectile-rails-find-resource--menu
    (:foreign-keys warn :title jnf/projectile-rails--title :quit-key "q" :exit t)
    ("Rails > Find Resources"
     (("m" projectile-rails-find-model       "model")
      ("v" projectile-rails-find-view        "view")
      ("c" projectile-rails-find-controller  "controller")
      ("h" projectile-rails-find-helper      "helper")
      ("l" projectile-rails-find-lib         "lib")
      ("j" projectile-rails-find-javascript  "javascript")
      ("w" projectile-rails-find-component   "component")
      ("s" projectile-rails-find-stylesheet  "stylesheet")
      ("p" projectile-rails-find-spec        "spec")
      ("u" projectile-rails-find-fixture     "fixture")
      ("t" projectile-rails-find-test        "test")
      ("f" projectile-rails-find-feature     "feature")
      ("i" projectile-rails-find-initializer "initializer")
      ("o" projectile-rails-find-log         "log")
      ("t" projectile-rails-find-liquid      "liquid tag")
      ("@" projectile-rails-find-mailer      "mailer")
      ("!" projectile-rails-find-validator   "validator")
      ("y" projectile-rails-find-layout      "layout")
      ("n" projectile-rails-find-migration   "migration")
      ("k" projectile-rails-find-rake-task   "rake task")
      ("b" projectile-rails-find-job         "job")
      ("z" projectile-rails-find-serializer  "serializer"))))

  (pretty-hydra-define jnf/projectile-rails-find-current-resource--menu
    (:foreign-keys warn :title jnf/projectile-rails--title :quit-key "q" :exit t)
    ("Rails > Find Current Resources"
     (("M" projectile-rails-find-current-model      "current model")
      ("V" projectile-rails-find-current-view       "current view")
      ("C" projectile-rails-find-current-controller "current controller")
      ("H" projectile-rails-find-current-helper     "current helper")
      ("J" projectile-rails-find-current-javascript "current javascript")
      ("S" projectile-rails-find-current-stylesheet "current stylesheet")
      ("P" projectile-rails-find-current-spec       "current spec")
      ("U" projectile-rails-find-current-fixture    "current fixture")
      ("T" projectile-rails-find-current-test       "current test")
      ("N" projectile-rails-find-current-migration  "current migration")
      ("Z" projectile-rails-find-current-serializer "current serializer"))))

  (pretty-hydra-define jnf/projectile-rails-goto--menu
    (:foreign-keys warn :title jnf/projectile-rails--title :quit-key "q" :exit t)
    ("Rails > Goto"
     (("f" projectile-rails-goto-file-at-point "file at point")
      ("g" projectile-rails-goto-gemfile       "Gemfile")
      ("p" projectile-rails-goto-package       "package")
      ("r" projectile-rails-goto-routes        "routes")
      ("d" projectile-rails-goto-schema        "schema")
      ("s" projectile-rails-goto-seeds         "seeds")
      ("h" projectile-rails-goto-spec-helper   "spec helper"))))

  (pretty-hydra-define jnf/projectile-rails-run--menu
    (:foreign-keys warn :title jnf/projectile-rails--title :quit-key "q" :exit t)
    ("Rails > Run"
     (("r" projectile-rails-rake       "rake")
      ("c" projectile-rails-console    "console")
      ("b" projectile-rails-dbconsole  "dbconsole")
      ("s" projectile-rails-server     "server")
      ("g" projectile-rails-generate   "generate")
      ("d" projectile-rails-destroy    "destroy")
      ("x" projectile-rails-extract-region "extract region"))))

  (pretty-hydra-define jnf/projectile-rails--menu
    (:foreign-keys warn :title jnf/projectile-rails--title :quit-key "q" :exit t)
    ("Rails"
     (("." projectile-rails-goto-file-at-point "Goto file at point")
      ("c" jnf/projectile-rails-find-current-resource--menu/body "Find current resource…")
      ("f" jnf/projectile-rails-find-resource--menu/body "Find a resource…")
      ("g" jnf/projectile-rails-goto--menu/body "Goto…")
      ("i" rails-routes-insert-no-cache "Insert route…")
      ("I" rails-routes-insert "Insert route (from cache)…")
      ("r" jnf/projectile-rails-run--menu/body "Run & interact…"))))
#+end_src

** TODO yard-mode.el

#+begin_src emacs-lisp
  ;; I most often write documentation using yard.  See
  ;; https://yardoc.org.
  (use-package yard-mode
    :straight t
    :hook (enh-ruby-mode . yard-mode))
#+end_src

** TODO bundler.el

#+begin_src emacs-lisp
  ;; Adds the helpful `bundle-open'
  (use-package bundler
    :straight (bundler :type git :host github :repo "endofunky/bundler.el"))
#+end_src

** TODO lsp-mode.el

#+begin_src emacs-lisp
  (use-package lsp-mode
    :straight t
    :hook (
	   (ruby-mode . lsp)
	   (enh-ruby-mode . lsp)
	   ;; (js-mode . lsp)
	   ;; (html-mode . lsp)
	   ;; (bash-mode . lsp)
	   )
    :config (setq read-process-output-max (* 1024 1024 3)
		  lsp-completion-provider nil
		  lsp-completion-mode nil
		  lsp-idle-delay 1.00)
    :custom (lsp-keymap-prefix "C-c C-l")
    :commands (lsp))

  ;; See https://www.reddit.com/r/emacs/comments/ql8cyp/corfu_orderless_and_lsp/
  ;; (defun corfu-lsp-setup ()
  ;;   (setq-local completion-styles '(orderless)
  ;;               completion-category-defaults nil))
  ;; (add-hook 'lsp-mode-hook #'corfu-lsp-setup)

  (with-eval-after-load 'lsp-mode
    (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration))

#+end_src

** TODO lsp-ui.el

#+begin_src emacs-lisp
  ;; This package provides some nice UI behavior for documentation and linting
  ;;
  ;; In particular, I like 'lsp-ui-peek-find-reference
  (use-package lsp-ui
    :straight t
    :after lsp-mode
    :commands lsp-ui-mode
    :hook ((enh-ruby-mode . lsp-ui-mode)
	   (enh-ruby-mode . lsp-ui-peek-mode)
	   (enh-ruby-mode . lsp-ui-sideline-mode)))

  ;; By default indent levels are often 4; That is against what I've seen.
  (setq ruby-indent-level 2
	typescript-indent-level 2
	js-indent-level 2)

  (add-hook 'emacs-lisp-mode 'eldoc-mode)
#+end_src

** TODO tree-sitter.el

#+begin_src emacs-lisp
  ;; See https://github.com/emacs-tree-sitter/elisp-tree-sitter
  ;; Waiting on https://github.com/emacs-tree-sitter/elisp-tree-sitter/issues/197 to resolve.
  (use-package tree-sitter
    :straight (tree-sitter :host github :repo "emacs-tree-sitter/elisp-tree-sitter")
    :config
    (add-to-list 'tree-sitter-major-mode-language-alist '(enh-ruby-mode . ruby)))

  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)

  (use-package tree-sitter-langs
    :straight t)
#+end_src

** TODO el-doc

#+begin_src emacs-lisp

#+end_src

* DONE Support

** DONE ripgrep.el

For many years, I’ve used “The Silver Searcher”, or ~ag~ on the command
line.[fn:ag].  However, [[https://github.com/BurntSushi/ripgrep][ripgrep]] provides even faster searching, with an almost
identical parameter list.

#+begin_src emacs-lisp
  (use-package ripgrep
    :init (setq ripgrep-arguments "--ignore-case")
    :straight t)
#+end_src

* TODO Projects

** TODO projectile.el

Projectile provides convenient organization and commands to run over projects.

#+begin_src emacs-lisp
  (use-package projectile
    :straight t
    :diminish 'projectile-mode
    :config (projectile-mode 1)
    :custom (projectile-project-search-path '("~/git/"))
    :bind ("s-." . projectile-toggle-between-implementation-and-test))
#+end_src

/Note:/ The =CMD= + =.= is a carryover from my [[https://macromates.com][Textmate]] and [[https://www.sublimetext.com/][Sublime Text]] days.
That’s one of those hot-keys almost burned into soul.

** TODO  magit.el

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  This package includes the various configurations for git
  ;;  interactions.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; The OMG awesome git client for emacs.
  (use-package magit
    :straight t
    :init (use-package with-editor :straight t)

    ;; Adding format to git-commit-fill-column of 72 as best practice.
    (setq git-commit-fill-column 72)

    ;; Keeping the summary terse helps with legibility when you run a
    ;; report with only summary.
    (setq git-commit-summary-max-length 50)

    ;; Set the tabular display columns for the `magit-list-repositories'
    (setq magit-repolist-columns
	  '(("Name"    25 magit-repolist-column-ident ())
	    ("Version" 25 magit-repolist-column-version ())
	    ("δ"        1 magit-repolist-column-dirty ())
	    ("⇣"        3 magit-repolist-column-unpulled-from-upstream
	     ((:right-align t)
	      (:help-echo "Upstream changes not in branch")))
	    ("⇡"        3 magit-repolist-column-unpushed-to-upstream
	     ((:right-align t)
	      (:help-echo "Local changes not in upstream")))
	    ("Branch"  25 magit-repolist-column-branch ())
	    ("Path"    99 magit-repolist-column-path ())))

    ;; The default relevant `magit-list-repositories'
    (setq magit-repository-directories
	  `(("~/git/takeonrules.source/" . 1) ;; personal
	    ("~/git/burning_wheel_lifepaths/" . 1)
	    ("~/git/dotzshrc/" .  1) ;; all
	    ("~/git/dotemacs/" . 1) ;; all
	    ("~/git/jnf-emacs-bookmarks/" . 1)
	    ("~/git/org" . 1) ;; all
	    ("~/git/org/archive" . 1) ;; personal
	    ("~/git/org/daily" . 1) ;; ??
	    ("~/git/org/hesburgh-libraries" . 1) ;; work
	    ("~/git/org/forem" . 1) ;; work
	    ("~/git/org/forem-docs" . 1) ;; work
	    ("~/git/org/personal" . 1) ;; personal
	    ("~/git/org/public" . 1) ;; all
	    ("~/git/takeonrules.source/themes/hugo-tufte" . 1))) ;; personal

    ;; Have magit-status go full screen and quit to previous
    ;; configuration.  Taken from
    ;; http://whattheemacsd.com/setup-magit.el-01.html#comment-748135498
    ;; and http://irreal.org/blog/?p=2253
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))
    (defadvice magit-mode-quit-window (after magit-restore-screen activate)
      (jump-to-register :magit-fullscreen))
    :config
    (remove-hook 'magit-status-sections-hook 'magit-insert-tags-header)
    (defun jnf/magit-list-repositories ()
      "Create a `magit-list-repositories' for my personal repositories."
      (interactive)
      (setq magit-repository-directories
	    `(("~/git/takeonrules.source/" . 1)
	      ("~/git/takeonrules.source/hugo-tufte" . 1)
	      ("~/git/burning_wheel_lifepaths/" . 1)
	      ("~/git/org" . 1)
	      ("~/git/org/personal" . 1)
	      ("~/git/org/public" . 1)
	      ("~/git/org/archive" . 1)
	      ("~/git/org/daily" . 1)
	      ("~/git/org/hesburgh-libraries" . 1)
	      ("~/git/org/forem-docs" . 1)
	      ("~/git/dotemacs/" . 1)
	      ("~/git/jnf-emacs-bookmarks/" . 1)
	      ("~/git/dotzshrc/" .  1)))
      (magit-list-repositories))
    (defun jnf/magit-browse-pull-request ()
      "In `magit-log-mode' open the associated pull request
  at point.

  Assumes that the commit log title ends in the PR #, which
  is the case when you use the Squash and Merge strategy.

  This implementation is dependent on `magit' and `s'."
      (interactive)
      (let* ((beg (line-beginning-position))
	     (end (line-end-position))
	     (summary
	      (buffer-substring-no-properties
	       beg end)))
	(jnf/open-pull-request-for :summary summary)))
    (defun jnf/git-current-remote-url ()
      "Get the current remote url."
      (s-trim
       (shell-command-to-string
	(concat
	 "git remote get-url "
	 (format "%s" (magit-get-current-remote))))))
    (cl-defun jnf/open-pull-request-for (&key summary)
      "Given the SUMMARY open the related pull request."
      (let ((remote-url (jnf/git-current-remote-url)))
	(save-match-data
	  (and (string-match "(\\#\\([0-9]+\\))$" summary)
	       (eww-browse-with-external-browser
		(concat
		 ;; I tend to favor HTTPS and the repos end in ".git"
		 (s-replace ".git" "" remote-url)
		 "/pull/"
		 (match-string 1 summary)))))))
    (defun jnf/open-pull-request-for-current-line ()
      "For the current line open the applicable pull request."
      (interactive)
      (let ((summary
	     (s-trim
	      (shell-command-to-string
	       (concat "git --no-pager annotate "
		       "-w -L "
		       (format "%s" (line-number-at-pos))
		       ",+1 "
		       "--porcelain "
		       buffer-file-name
		       " | rg \"^summary\"")))))
	(jnf/open-pull-request-for :summary summary)))
    ;; In other situations I bind s-6 to `git-messenger:popup-message'
    :bind (
	   ("C-c C-g" . magit-file-dispatch)
	   ("s-7" . magit-status))
    :bind (:map magit-log-mode-map ("s-6" . 'jnf/magit-browse-pull-request))
    :hook ((with-editor-post-finish-hook . magit-status)))
#+end_src

** TODO  forge.el

#+begin_src emacs-lisp
  (use-package forge
    :config
    (setq auth-sources '("~/.authinfo"))
    ;; (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-authored-pullreqs nil 'append)
    ;; (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-requested-reviews nil 'append)
    ;; (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-assigned-issues nil 'append)
    :straight t)

#+end_src

** TODO  libgit.el

#+begin_src emacs-lisp
  (use-package libgit
    :straight t)
#+end_src

** TODO  magit-libgit.el

#+begin_src emacs-lisp
  (use-package magit-libgit
    :after (libgit magit)
    :straight t)
#+end_src

** TODO  git-timemachine.el

#+begin_src emacs-lisp
  ;; With the time machine, travel back and forth through a files history.
  ;;
  ;; While visiting a point in time, you can open
  (use-package git-timemachine
    :straight t)
#+end_src

** TODO  git-gutter-fringe.el

#+begin_src emacs-lisp
  ;; Show the current git state in the gutter Go ahead and edit a line
  ;; and look to the gutter for guidance.
  (use-package git-gutter-fringe
    :straight (git-gutter-fringe :type git :host github :repo "emacsorphanage/git-gutter-fringe")
    :diminish 'git-gutter-mode
    :config (global-git-gutter-mode 't)
    (setq git-gutter:modified-sign "Δ"
	  git-gutter:added-sign "+"
	  git-gutter:deleted-sign "-"))
#+end_src

** TODO  git-link.el

#+begin_src emacs-lisp
  ;; https://github.com/sshaw/git-link
  ;;
  ;; `M-x git-link` to add the current URL to the kill ring.  This is
  ;; particularly helpful for sharing links with other developers.  I
  ;; use this ALL OF THE TIME
  (use-package git-link
    :config
    ;; Without the following autoload directive, the call to
    ;; `eww-browse-with-external-browser' in
    ;; `jnf/git-browse-to-repository' fails (unless I've previously
    ;; called `eww').
    (autoload 'eww-browse-with-external-browser "eww.el")
    (defun jnf/git-browse-to-repository (remote)
      "Open in external browser the current repository's given REMOTE.

  Uses `eww-browse-with-external-browser' to determine external browser to use."
      (interactive (list (git-link--select-remote)))
      (git-link-homepage remote)
      (eww-browse-with-external-browser (car kill-ring)))
    (setq git-link-use-commit t) ;; URL will be SHA instead of branch
    :straight t)
#+end_src

** TODO  git-messenger.el

#+begin_src emacs-lisp
  (use-package git-messenger
    :config (setq git-messenger:show-detail t)
    (defun jnf/git-messenger-popup ()
      "Open `git-messenger' or github PR.

  With universal argument, open the github PR for current line.

  Without universal argument, open `git-messenger'."
      (interactive)
      (if (equal current-prefix-arg nil) ; no C-u
	  (git-messenger:popup-message)
	(jnf/open-pull-request-for-current-line)))
    :custom
    (git-messenger:use-magit-popup t)
    :bind (:map git-messenger-map (("p" . 'jnf/open-pull-request-for-current-line)
				   ("l" . 'git-link)))
    :bind (("s-6" . jnf/git-messenger-popup)
	   ("<f6>" . jnf/git-messenger-popup))
    :straight t)
#+end_src

** TODO  blamer.el

#+begin_src emacs-lisp
  (use-package blamer
    :straight (blamer :host github :repo "Artawower/blamer.el")
    :custom
    (blamer-idle-time 0.5)
    (blamer-author-formatter "✎ %s ")
    (blamer-datetime-formatter "[%s]")
    (blamer-commit-formatter "● %s")
    (blamer-min-offset 40)
    (blamer-max-commit-message-length 20))
#+end_src


** TODO dired.el

#+begin_src emacs-lisp
  (use-package dired-subtree
    :bind (:map dired-mode-map ("C-, t" . 'dired-subtree-toggle))
    :straight t)

  (use-package dired-sidebar
    :straight t
    :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
    :init
    (add-hook 'dired-sidebar-mode-hook
	      (lambda ()
		(unless (file-remote-p default-directory)
		  (auto-revert-mode))))
    :config
    (setq dired-sidebar-use-term-integration t
	  dired-sidebar-theme 'vscode
	  dired-sidebar-use-custom-font t)
    :commands (dired-sidebar-toggle-sidebar))
#+end_src

* TODO Completion

** DONE vertico.el

#+begin_src emacs-lisp
  (use-package vertico
    :straight t
    :config
    (vertico-mode)
    ;; Use `consult-completion-in-region' if Vertico is enabled.
    ;; Otherwise use the default `completion--in-region' function.
    (setq completion-in-region-function
	  (lambda (&rest args)
	    (apply (if vertico-mode
		       #'consult-completion-in-region
		     #'completion--in-region)
		   args)))
    (advice-add #'completing-read-multiple
		:override #'consult-completing-read-multiple)
    (setq vertico-cycle t))
#+end_src

*** Vertico Extensions

The ~vertico-indexed.elc~ extension adds a visual indicator of each candidate’s
index.  Further, I can type ~C-<num> ENT~ and select that candidate.  Often
it’s just as easy to navigate via ~TAB~ or ~C-n~ / ~C-p~ but the visual
indicator is a nice bit of polish.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-indexed.elc"
	nil
	jnf-silence-loading-log)
  (vertico-indexed-mode)
#+end_src

I’ve commented out the ~vertico-buffer.elc~ extension.  When active, instead of
using the mini-buffer it creates a new window.  I’m uncertain how I fully feel
about this function.  When I activate it, I’m sometimes “surprised” at a
different experience from what I’m accustomed to in Emacs.  Then again, at
least I’m not trapped in the recursive mini-buffer challenges.

#+begin_src emacs-lisp
  ;; (load "~/.emacs.d/straight/build/vertico/extensions/vertico-buffer.elc"
  ;;       nil
  ;;       jnf-silence-loading-log)
  ;; (vertico-buffer-mode)
  ;; (setq vertico-buffer-display-action
  ;;       '(display-buffer-at-bottom (window-height . 15)))
#+end_src

The ~vertico-repeat.elc~ extension does one simple thing: it remembers and
gives quick access to the last command you entered in the “minibuffer.”  This
can be super userful if I built up a complicated ~consult-ripgrep~.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-repeat.elc"
	nil
	jnf-silence-loading-log)
  (global-set-key (kbd "M-r") #'vertico-repeat)
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
#+end_src

Related to, but independent of ~vertico-repeat.elc~ is enabling
~savehist-mode~.  With that enabled, I have access to a few dozen of the last
minibuffer commands I issued.  These are, by default, in ~\~/.emacs.d/history~.

#+begin_src emacs-lisp
  (savehist-mode 1)
#+end_src

** Emacs Adjustments for Completion

What follows is adjustments to emacs settings as they relate to completion.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)

    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
	  '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src

** DONE marginalia.el

The ~marginalia~ package provides annotations to minibuffer completions; I
shudder to think how hard it would be to navigate Emacs’s ~M-x~ command without
annotations.

#+begin_src emacs-lisp
  (use-package marginalia
    :straight t
    :init (marginalia-mode))
#+end_src

/Note:/ The declaration of ~marginalia-mode~ must be in the ~;init~ section.
This ensures that it is enabled right away.  It also forces the loading of the
package.

** TODO consult.el

#+begin_src emacs-lisp
  ;; Example configuration for Consult
  ;; https://github.com/minad/consult
  (use-package consult
    :straight t
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
	   ("C-c h" . consult-history)
	   ;; ("C-c m" . consult-mode-command)
	   ("C-c b" . consult-bookmark)
	   ("C-c k" . consult-kmacro)
	   ;; C-x bindings (ctl-x-map)
	   ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complet-command
	   ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("s-b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
	   ("C-s-b" . consult-buffer-other-window)
	   ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
	   ;; Custom M-# bindings for fast register access
	   ("M-#" . consult-register-load)
	   ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
	   ("C-M-#" . consult-register)
	   ;; Other custom bindings
	   ("M-y" . consult-yank-from-kill-ring)                ;; orig. yank-pop
	   ("<help> a" . consult-apropos)            ;; orig. apropos-command
	   ;; M-g bindings (goto-map)
	   ("M-g e" . consult-compile-error)
	   ("M-g g" . consult-goto-line)             ;; orig. goto-line
	   ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
	   ("s-l" . consult-goto-line)           ;; orig. goto-line
	   ("M-g o" . consult-outline)
	   ("M-g m" . consult-mark)
	   ("M-g k" . consult-global-mark)
	   ("C-x C-SPC" . consult-mark)
	   ("M-g i" . consult-imenu)
	   ("M-g I" . consult-imenu-multi)
	   ;; M-s bindings (search-map)
	   ("M-s f" . consult-find)
	   ("M-s L" . consult-locate)
	   ("M-s g" . consult-grep)
	   ("M-s G" . consult-git-grep)
	   ("M-s r" . consult-ripgrep)
	   ("C-c f" . consult-ripgrep)
	   ("M-s l" . consult-line)
	   ("M-s m" . consult-multi-occur)
	   ("M-s k" . consult-keep-lines)
	   ("M-s u" . consult-focus-lines)
	   ;; Customizations that map to ivy
	   ("s-r" . consult-recent-file) ;; Deprecate
	   ("C-c r" . consult-recent-file)
	   ("C-c o" . consult-file-externally)
	   ("C-y" . yank)
	   ("C-s" . consult-line) ;; I've long favored Swiper mapped to c-s
	   ;; Isearch integration
	   ("M-s e" . consult-isearch)
	   ;; ("s-t" . jnf/consult-find-using-fd)
	   ;; ("s-3" . consult-imenu-multi)
	   :map isearch-mode-map
	   ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
	   ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
	   ("M-s l" . consult-line))                 ;; required by consult-line to detect isearch

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
	  register-preview-function #'consult-register-format)


    ;; From https://github.com/minad/consult/wiki#find-files-using-fd
    ;; Note: this requires lexical binding
    (defun jnf/consult-find-using-fd (&optional dir initial)
      "Find project files.

  A replacement for `projectile-find-file'."
      (interactive "P")
      (let ((consult-find-command "fd --color=never --hidden --exclude .git/ --full-path ARG OPTS"))
	(consult-find dir initial)))

    (defun jnf/consult-line (consult-line-function &rest rest)
      "Advising function around `CONSULT-LINE-FUNCTION'.

  When there's an active region, use that as the first parameter
  for `CONSULT-LINE-FUNCTION'.  Otherwise, use the current word as
  the first parameter.  This function handles the `REST' of the
  parameters."
      (interactive)
      (apply consult-line-function
	     (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
	     rest))

    (defun jnf/consult-ripgrep (consult-ripgrep-function &optional dir &rest rest)
      "Use region or thing at point to populate initial parameter for `CONSULT-RIPGREP-FUNCTION'.

  When there's an active region, use that as the initial parameter
  for the `CONSULT-RIPGREP-FUNCTION'.  Otherwise, use the thing at
  point.

  `DIR' use the universal argument (e.g. C-u prefix) to first set
  the directory.  `REST' is passed to the `CONSULT-RIPGREP-FUNCTION'."
      (interactive "P")
      (apply consult-ripgrep-function
	     dir
	     (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
	     rest))

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)
    (advice-add #'consult-line :around #'jnf/consult-line '((name . "wrapper")))
    (advice-add #'consult-ripgrep :around #'jnf/consult-ripgrep '((name . "wrapper")))

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
	  xref-show-definitions-function #'consult-xref)

    ;; Updating the default to include "--ignore-case"
    (setq consult-ripgrep-command "rg --null --line-buffered --color=ansi --max-columns=1000 --ignore-case --no-heading --line-number . -e ARG OPTS")

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. Note that the preview-key can also be
    ;; configured on a per-command basis via `consult-config'. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-p"))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; Probably not needed if you are using which-key.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; Optionally configure a function which returns the project root directory.
    ;; There are multiple reasonable alternatives to chose from:
    ;; * projectile-project-root
    ;; * vc-root-dir
    ;; * project-roots
    ;; * locate-dominating-file
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root)
    ;; (setq consult-project-root-function
    ;;       (lambda ()
    ;;         (when-let (project (project-current))
    ;;           (car (project-roots project)))))
    ;; (setq consult-project-root-function #'vc-root-dir)
    ;; (setq consult-project-root-function
    ;;       (lambda () (locate-dominating-file "." ".git")))
    )

#+end_src

** TODO consult-flycheck.el

#+begin_src emacs-lisp
  ;; Optionally add the `consult-flycheck' command.
  (use-package consult-flycheck
    :straight t
    :bind (:map flycheck-command-map
		("!" . consult-flycheck)))
#+end_src

** TODO embark.el

#+begin_src emacs-lisp

  ;; https://github.com/oantolin/embark
  (use-package embark
    :straight t
    :bind
    (("C-." . embark-act)       ;; pick some comfortable binding
     ("M-." . embark-dwim)
     ("C-s-e" . embark-export)
     ("C-h b" . embark-bindings))
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config

    ;;; BEGIN embark key macro target
    (defun embark-kmacro-target ()
      "Target a textual kmacro in braces."
      (save-excursion
	(let ((beg (progn (skip-chars-backward "^{}\n") (point)))
	      (end (progn (skip-chars-forward "^{}\n") (point))))
	  (when (and (eq (char-before beg) ?{) (eq (char-after end) ?}))
	    `(kmacro ,(buffer-substring-no-properties beg end)
		     . (,(1- beg) . ,(1+ end)))))))

    (add-to-list 'embark-target-finders 'embark-kmacro-target)

    (defun embark-kmacro-run (arg kmacro)
      (interactive "p\nsKmacro: ")
      (kmacro-call-macro arg t nil (kbd kmacro)))

    (defun embark-kmacro-save (kmacro)
      (interactive "sKmacro: ")
      (kmacro-push-ring)
      (setq last-kbd-macro (kbd kmacro)))

    (defun embark-kmacro-name (kmacro name)
      (interactive "sKmacro: \nSName: ")
      (let ((last-kbd-macro (kbd kmacro)))
	(kmacro-name-last-macro name)))

    (defun embark-kmacro-bind (kmacro)
      (interactive "sKmacro: \n")
      (let ((last-kbd-macro (kbd kmacro)))
	(kmacro-bind-to-key nil)))

    (embark-define-keymap embark-kmacro-map
      "Actions on kmacros."
      ("RET" embark-kmacro-run)
      ("s" embark-kmacro-save)
      ("n" embark-kmacro-name)
      ("b" embark-kmacro-bind))

    (add-to-list 'embark-keymap-alist '(kmacro . embark-kmacro-map))
    ;;; END embark key macro target
    (setq embark-action-indicator
	  (lambda (map &optional _target)
	    (which-key--show-keymap "Embark" map nil nil 'no-paging)
	    #'which-key--hide-popup-ignore-command)
	  embark-become-indicator embark-action-indicator)
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))

#+end_src

** TODO embark-consult.el

#+begin_src emacs-lisp

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :straight t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

** TODO wgrep.el

#+begin_src emacs-lisp

  ;; Useful for editing grep results:
  ;;
  ;; 1) "C-c f" invoke `consult-ripgrep'
  ;; 2) "C-s-e" invoke `embark-export' (On OS X map that's Ctrl+Cmd+e)
  ;; 3) "e" or "C-c C-p" invoke `wgrep-change-to-wgrep-mode'
  ;; 4) Save or cancel
  ;;    a) Save: "C-x C-s" invoke `save-buffer' (or "C-c C-c")
  ;;    b) Cancel: "C-c C-k"
  (use-package wgrep
    :after (embark-consult ripgrep)
    :straight t
    :bind (:map wgrep-mode-map
		;; Added keybinding to echo Magit behavior
		("C-c C-c" . save-buffer)
		:map grep-mode-map
		("e" . wgrep-change-to-wgrep-mode)
		:map ripgrep-search-mode-map
		("e" . wgrep-change-to-wgrep-mode)))
#+end_src

** TODO consult-lsp.el

#+begin_src emacs-lisp
  ;; https://github.com/gagbo/consult-lsp
  (use-package consult-lsp
    :after (consult lsp-mode)
    :straight (consult-lsp :host github :type git :repo "gagbo/consult-lsp")
    :config
    (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols)
    (consult-lsp-marginalia-mode)
    :commands consult-lsp-symbols)
#+end_src

** DONE orderless.el

The [[https://github.com/minad/orderless][orderless]] package provides completion tooling for non-strict word order.  I
spent considerable time reading through the [[https://github.com/minad/consult/wiki][Orderless section of Consult’s
wiki]].

As configured the orderless completion recognizes the following “switches”:

- Flex (~\~~) :: Just start typing characters and you’ll get matches that have
  those characters
- File Extension (~\.ext~) :: Match files with this extension.
- Regexp ~^.$~ :: Use some regular expression syntax
  - ~^~ matching beginning
  - ~.~ any ol’ character
  - ~$~ matching ending
- Initialism (~`~) :: In ~M-x~ when I typed ~`pl~ the ~previous-line~ function
  was a top match.  The initialism switch “explodes” the characters and says
  match methods who’s words start with those characters.
- Not Literal ~!~ :: Exclude candidates that match the literal
  (e.g. ~!previous~ won’t show ~previous-line~ in the ~M-x~ completion).
- Literal ~=~ :: No “fuzzy buziness”, just match exactly what I typed.

There is another case (e.g. ~%~ character fold) that I don’t yet understand.

More on these component matchings styles is available at [[https://github.com/minad/orderless#component-matching-styles][github.com/minad/orderless]].

#+begin_src emacs-lisp
  (use-package orderless
    :straight t
    :config
    (defvar +orderless-dispatch-alist
      '((?% . char-fold-to-regexp)
	(?! . orderless-without-literal)
	(?`. orderless-initialism)
	(?= . orderless-literal)
	(?~ . orderless-flex)))
    (defun +orderless-dispatch (pattern index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" pattern)
	`(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x100000-\x10FFFD]*$")))
       ;; File extensions
       ((and
	 ;; Completing filename or eshell
	 (or minibuffer-completing-file-name
	     (derived-mode-p 'eshell-mode))
	 ;; File extension
	 (string-match-p "\\`\\.." pattern))
	`(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x100000-\x10FFFD]*$")))
       ;; Ignore single !
       ((string= "!" pattern) `(orderless-literal . ""))
       ;; Prefix and suffix
       ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
	    (cons (cdr x) (substring pattern 1))
	  (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
	    (cons (cdr x) (substring pattern 0 -1)))))))

    ;; Define orderless style with initialism by default
    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

    ;; Certain dynamic completion tables (completion-table-dynamic)
    ;; do not work properly with orderless. One can add basic as a fallback.
    ;; Basic will only be used when orderless fails, which happens only for
    ;; these special tables.
    (setq completion-styles '(orderless basic)
	  completion-category-defaults nil
	    ;;; Enable partial-completion for files.
	    ;;; Either give orderless precedence or partial-completion.
	    ;;; Note that completion-category-overrides is not really an override,
	    ;;; but rather prepended to the default completion-styles.
	  ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
	  completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
					  ;; enable initialism by default for symbols
					  (command (styles +orderless-with-initialism))
					  (variable (styles +orderless-with-initialism))
					  (symbol (styles +orderless-with-initialism)))
	  orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
	  orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src

** DONE consult-projectile.el

The ~consult-projectile.el~ package provides a function I use everyday: ~M-x
consult-projectile~.  When I invoke ~consult-projectile~, I have the file
completion for the current project.  I can also type =b= + =SPACE= to narrow my
initial search to open buffers in the project.  Or =p= + =space= to narrow to
other projects; and then select a file within that project.


#+begin_src emacs-lisp
  (use-package consult-projectile
    :straight (consult-projectile
	       :type git
	       :host gitlab
	       :repo "OlMon/consult-projectile"
	       :branch "master")
    :bind ("s-t" . consult-projectile))
#+end_src

/Note:/ The =CMD= + =t= (e.g. ~s-t~ in Emacs) is a carryover from my [[https://macromates.com][Textmate]]
and [[https://www.sublimetext.com/][Sublime Text]] days.  More than any other key combination, that one is
entirely muscle memory.

** TODO corfu.el et al

#+begin_src emacs-lisp
  ;; Configure corfu
  (use-package corfu
    :straight t
    :demand t
    ;; Optionally use TAB for cycling, default is `corfu-complete'.
    :bind (:map corfu-map
		("TAB" . corfu-next)
		([tab] . corfu-next)
		("S-TAB" . corfu-previous)
		([backtab] . corfu-previous))
    :init

    ;; Recommended: Enable Corfu globally.
    ;; This is recommended since dabbrev can be used globally (M-/).
    (corfu-global-mode)

    :config
    ;; Optionally enable cycling for `corfu-next' and `corfu-previous'.
    (setq corfu-cycle t)
    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let (completion-cycle-threshold completion-cycling)
	(apply #'consult-completion-in-region completion-in-region--data)))
    (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer))

  ;; Dabbrev works with Corfu
  (use-package dabbrev
    :straight t
    ;; Swap M-/ and C-M-/
    :bind (("M-/" . dabbrev-completion)
	   ("C-M-/" . dabbrev-expand)))


  (use-package cape
    :straight t
    :bind (("C-c p" . completion-at-point)))

  (setq-local completion-at-point-functions
	      (mapcar #'cape-company-to-capf
		      (list #'company-files #'company-ispell #'company-dabbrev)))
  (use-package emacs
    :straight nil
    :init
    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
    (setq read-extended-command-predicate
	  #'command-completion-default-include-p))
#+end_src

#+RESULTS:

* TODO Window Manipulation

** DONE Tab Line

Show tabs in the current window.  The tab system is something I wrestle with,
but I appreciate it’s existence.  These configurations make it easier to use.

#+begin_src emacs-lisp
  (global-tab-line-mode t)
  (global-set-key (kbd "s-{") 'previous-buffer)
  (global-set-key (kbd "s-}") 'next-buffer)
#+end_src

** TODO buffer-move.el

From [[https://github.com/lukhas/buffer-move][lukhas/buffer-move]], this package helps me quickly move a window elsewhere.
As of <2022-02-01 Tue>, I don’t often use this command.  Consider it “on
notice” for removal.

#+begin_src emacs-lisp
  (use-package buffer-move
    :straight t
    :bind ("<C-s-f12>" . buf-move))
#+end_src

* DONE Text Manipulation

** DONE titlecase.el

The rules of “titlecase” are confounding.  The ~titlecase.el~ package provides
numerous ways to cast a string to “titlecase.”  I chose wikipedia style as a
quasi-opinionated compromise.

#+begin_src emacs-lisp
  (use-package titlecase
    :straight (titlecase :host github :repo "duckwork/titlecase.el")
    :custom (titlecase-style 'wikipedia))
#+end_src

* TODO In Buffer

** TODO savekill.el

#+begin_src emacs-lisp
  ;; Write "kill" command inputs to disk
  (use-package savekill
    :straight t)

#+end_src

** TODO link-hint.el

#+begin_src emacs-lisp
  ;; That letter is the beginning of a word. Narrow results from there.
  (use-package avy
    :bind (("C-j" . avy-goto-char-timer))
    ;; moved bind to enh-ruby-mode declaration
    ;; :bind (:map enh-ruby-mode-map ("C-j" . avy-goto-char-timer))
    :bind (:map org-mode-map ("C-j" . avy-goto-char-timer))
    :straight t)

  ;; (use-package link-hint
  ;;   :straight t
  ;;   :bind
  ;;   ("C-c l o" . link-hint-open-link)
  ;;   ("C-c l c" . link-hint-copy-link))
#+end_src

** TODO math-at-point.el

#+begin_src emacs-lisp
  ;; https://github.com/shankar2k/math-at-point
  (use-package math-at-point
    :straight (math-at-point :type git :host github :repo "shankar2k/math-at-point")
    :bind ("C-c =" . math-at-point))
#+end_src

** TODO which-key.el

#+begin_src emacs-lisp

  (use-package which-key
    :config (which-key-mode)
    :diminish 'which-key-mode
    :straight t)
#+end_src

** TODO writeroom-mode.el

#+begin_src emacs-lisp

  (use-package writeroom-mode
    :straight t)
#+end_src

** TODO vi-tilde-fringe.el

#+begin_src emacs-lisp

  (use-package vi-tilde-fringe
    :straight t
    :hook ((fundamental-mode) . vi-tilde-fringe-mode))
#+end_src

** TODO fill-sentences-correctly.el

#+begin_src emacs-lisp

  (use-package fill-sentences-correctly
    :straight (fill-sentences-correctly :host github :repo "duckwork/fill-sentences-correctly.el")
    :hook (fundamental-mode . fill-sentences-correctly-mode))
#+end_src

** TODO origami.el

#+begin_src emacs-lisp

  (use-package origami
    :straight t
    :hook (prog-mode . origami-mode))
#+end_src

** TODO hippie-exp.el

#+begin_src emacs-lisp

  ;; Using Hippie expand, I toggle through words already referenced.
  (use-package hippie-exp
    :straight t
    :config
    (setq hippie-expand-try-functions-list '(try-expand-dabbrev-visible
					     try-expand-dabbrev
					     try-expand-list
					     try-expand-all-abbrevs
					     try-expand-dabbrev-all-buffers
					     try-expand-dabbrev-from-kill
					     try-complete-file-name-partially
					     try-complete-file-name
					     try-complete-lisp-symbol-partially
					     try-complete-lisp-symbol
					     ))
    :bind (("M-SPC" . hippie-expand)))
#+end_src

** TODO expand-region.el

#+begin_src emacs-lisp

  ;; Expand or contract point/region to next logical element.
  ;;
  ;; NOTE: I use this all the time.
  (use-package expand-region
    :straight t
    :bind (("C-=" . er/expand-region)
	   ("C-+" . er/contract-region)))
#+end_src

** TODO string-inflection.el

#+begin_src emacs-lisp

  ;; This package allows me to toggle between different string cases.
  ;;
  ;; - HELLO WORLD
  ;; - HelloWorld
  ;; - helloWorld
  ;; - hello-world
  ;; - Hello_World
  ;; - hellow_world
  ;; - HELLO_WORLD
  (use-package string-inflection
    :bind (("C-M-s-i" . string-inflection-all-cycle))
    :straight (string-inflection :type git
				 :host github
				 :repo "akicho8/string-inflection"))
#+end_src

** TODO multiple-cursors.el

#+begin_src emacs-lisp

  ;; Allow to work with multipe cursors
  ;; https://melpa.org/#/multiple-cursors Aside from the
  ;; set-rectangular-region-anchor, there are several additional
  ;; features to practice
  (use-package multiple-cursors
    :bind (("C-M-SPC" . set-rectangular-region-anchor)
	   ("C->" . mc/mark-next-like-this)
	   ("C-<" . mc/mark-previous-like-this)
	   ("C-s-<mouse-1>" . mc/add-cursor-on-click)
	   ("C-c C->" . mc/mark-all-like-this)
	   ("C-c C-SPC" . mc/edit-lines)) ;; CTRL+CMD+c
    :straight t)
#+end_src

** TODO iedit.el

#+begin_src emacs-lisp

  ;; C-; to select current symbol and all matches; Then edit at multiple points.
  (use-package iedit
    :straight t)
#+end_src

** TODO crux.el

#+begin_src emacs-lisp

  ;; C-a goes to the first non-whitepsace character on the line. Type it
  ;; again, and go to the beginning of the line.
  (use-package crux
    :straight t
    :config
    (defun jnf/duplicate-current-line-or-lines-of-region (arg)
      "Duplicate ARG times current line or the lines of the current region."
      (interactive "p")
      (if (use-region-p)
	  (progn
	    (when (> (point) (mark))
	      (exchange-point-and-mark))
	    (beginning-of-line)
	    (exchange-point-and-mark)
	    (end-of-line)
	    (goto-char (+ (point) 1))
	    (exchange-point-and-mark)
	    (let* ((end (mark))
		   (beg (point))
		   (region
		    (buffer-substring-no-properties beg end)))
	      (dotimes (_i arg)
		(goto-char end)
		(insert region)
		(setq end (point)))))
	(crux-duplicate-current-line-or-region arg)))

    (cl-defun jnf/create-org-scratch-buffer (&key (mode 'org-mode))
      "Quickly open a scratch buffer and enable the given MODE."
      (interactive)
      (crux-create-scratch-buffer)
      (rename-buffer (concat "*scratch* at " (format-time-string "%Y-%m-%d %H:%M")))
      (funcall mode))
    :bind (("C-a" . crux-move-beginning-of-line)
	   ("<C-s-return>" . crux-smart-open-line-above)
	   ("C-s-k" . crux-kill-line-backwards)
	   ("<s-backspace>" . crux-kill-line-backwards)
	   ("C-M-d" . jnf/duplicate-current-line-or-lines-of-region)
	   ("C-c d" . jnf/duplicate-current-line-or-lines-of-region)
	   ("<f9>" . crux-kill-other-buffers)
	   ("<f12>" . jnf/create-org-scratch-buffer)))
#+end_src

** TODO ethan-wspace.el

#+begin_src emacs-lisp
  ;; Whitespace hygene package.  The author's documentation and
  ;; commentary echoes my sentiments
  (use-package ethan-wspace
    :straight t
    :hook (before-save . delete-trailing-whitespace)
    :init (setq-default mode-require-final-newline nil)
    :config (global-ethan-wspace-mode 1))
#+end_src

** TODO unfill.el

#+begin_src emacs-lisp
  ;; A package that is a bit of the inverse of 'fill-paragraph
  ;; (e.g. M-q).
  (use-package unfill
    :bind ("M-q" . unfill-toggle)
    :straight t)
#+end_src

** TODO undo-tree.el

#+begin_src emacs-lisp
  ;; Provides a UI for undo trees.  I'm not certain what I want to do
  ;; with this.
  (use-package undo-tree
    :diminish
    :bind (("C-z" . undo)
	   ("C-S-z" . undo-tree-redo))
    :config
    (global-undo-tree-mode +1)
    (unbind-key "M-_" undo-tree-map))

#+end_src

** TODO hungry-delete.el

#+begin_src emacs-lisp
  ;; Delete multiple spaces in one delete stroke
  (use-package hungry-delete
    :straight t
    :diminish 'hungry-delete-mode
    :config (global-hungry-delete-mode))

#+end_src

** TODO move-text.el

#+begin_src emacs-lisp
  ;; Adding ability to move lines up and down
  (use-package move-text
    :straight t
    :bind (([C-s-down] . move-text-down)
	   ([C-s-up] . move-text-up)))
#+end_src

** TODO rainbow-delimiters.el

#+begin_src emacs-lisp
  ;; A quick and useful visual queue for paranthesis
  (use-package rainbow-delimiters
    :straight t
    :hook ((fundamental-mode) . rainbow-delimiters-mode))
#+end_src

** TODO emojify.el

- ~emojify.el~ :: Ensure rendering of correct emoji’s.

#+begin_src emacs-lisp
  (use-package emojify
    :straight t
    :config
    (defun --set-emoji-font (frame)
      "Adjust the font settings of FRAME so Emacs can display emoji properly."
      (if (eq system-type 'darwin)
	  ;; For NS/Cocoa
	  (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
	;; For Linux
	(set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))

    ;; For when Emacs is started in GUI mode:
    (--set-emoji-font nil)
    ;; Hook for when a frame is created with emacsclient
    ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
    (add-hook 'after-make-frame-functions '--set-emoji-font))
#+end_src

** TODO unicode-fonts.el

#+begin_src emacs-lisp
  (use-package unicode-fonts
    :straight t
    :ensure t
    :config (unicode-fonts-setup))
#+end_src

** TODO yasnippet.el

#+begin_src emacs-lisp
  ;; A rather convenient snippet manager.  When you create a snippet, it
  ;; understands the mode you're in and puts the snippet in the right
  ;; place.
  (use-package yasnippet
    :straight t
    :diminish yas-mode
    :init (setq yas-snippet-dirs '("~/git/dotemacs/snippets"))
    (yas-global-mode 1))
#+end_src

** TODO consult-yasnippet.el

#+begin_src emacs-lisp
  (use-package consult-yasnippet
    :straight t
    :after (consult yasnippet)
    :bind ("C-c y" . consult-yasnippet))
#+end_src

** TODO tempel.el

#+begin_src emacs-lisp
  (use-package tempel
    :straight (tempel :host github :repo "minad/tempel")
    :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
	   ("M-*" . tempel-insert))

    :init

    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; The depth is set to -1, such that `tempel-expand' is tried *before* the
      ;; programming mode Capf. If a template name can be completed it takes
      ;; precedence over the programming mode completion. `tempel-expand' only
      ;; triggers on exact matches. Alternatively use `tempel-complete' if you
      ;; want to see all matches, but then Tempel will probably trigger too
      ;; often when you don't expect it.
      (add-hook 'completion-at-point-functions #'tempel-expand -1 'local))

    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)

    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
    ;; (tempel-global-abbrev-mode)
    )

#+end_src

** DONE goggles.el

- ~goggles.el~ :: Adds a little bit of visual feedback as you delete chunks.

#+begin_src emacs-lisp
  (use-package goggles
    :straight t
    :hook ((prog-mode text-mode) . goggles-mode)
    :diminish 'goggles-mode
    :config (setq-default goggles-pulse t))
#+end_src

** DONE whole-line-or-region.el

- ~whole-line-or-region.el~ :: From the package commentary, “This minor mode
  allows functions to operate on the current line if they would normally
  operate on a region and region is currently undefined.”  I’ve used this for
  awhile and believe it’s not baked into my assumptions regarding how I
  navigation Emacs.

#+begin_src emacs-lisp
  (use-package whole-line-or-region
    :straight t
    :diminish 'whole-line-or-region-local-mode
    :config (whole-line-or-region-global-mode))
#+end_src

** DONE smartparens.el

- ~smartparens.el~ :: provides some “intelligent” treatment of parentheses.  I’ve been using this for awhile, so I assume it’s baked into my memory.

#+begin_src emacs-lisp
  (use-package smartparens :straight t)
#+end_src

** TODO Functions

#+begin_src emacs-lisp

  ;;******************************************************************************
  ;;
    ;;; BEGIN Custom "in-buffer" functions
  ;;
  ;;******************************************************************************
  (global-set-key (kbd "C-w") 'jnf/kill-region-or-backward-word)
  (global-set-key (kbd "M-DEL") 'jnf/kill-region-or-backward-word)
  (global-set-key (kbd "<C-M-backspace>") 'backward-kill-paragraph)
  (defun jnf/kill-region-or-backward-word (&optional arg)
    "Kill selected region otherwise kill backwards the ARG number of words."
    (interactive "p")
    (if (region-active-p)
	(kill-region (region-beginning) (region-end))
      (backward-kill-word arg)))

  (global-set-key (kbd "C-k") 'jnf/kill-line-or-region)
  (defun jnf/kill-line-or-region (&optional ARG)
    "Kill the selected region otherwise kill the ARG number of lines."
    (interactive "P")
    (if (use-region-p)
	(kill-region (region-beginning) (region-end))
      (kill-line ARG)))

  (global-set-key (kbd "C-c n") 'jnf/nab-file-name-to-clipboard)
  (defun jnf/nab-file-name-to-clipboard ()
    "Nab, I mean copy, the current buffer file name to the clipboard.

    If you provide universal prefix (e.g. C-u), return the base
    filename.  Otherwise, use the full filename path."
    ;; https://blog.sumtypeofway.com/posts/emacs-config.html
    (interactive)
    (let* ((raw-filename
	    (if (equal major-mode 'dired-mode) default-directory (buffer-file-name)))
	   (filename
	    (if (equal current-prefix-arg nil) raw-filename (file-name-nondirectory raw-filename))))
      (when filename
	(kill-new filename)
	(message "Copied buffer file name '%s' to the clipboard." filename))))

  (defun jnf/sort-unique-lines (reverse beg end &optional adjacent keep-blanks interactive)
    "Sort lines and delete duplicates.
    By default the sort is lexigraphically ascending.  To sort as
    descending set REVERSE to non-nil.  Specify BEG and END for the
    bounds of sorting.  By default, this is the selected region.

    I've included ADJACENT, KEEP-BLANKS, and INTERACTIVE so I can
    echo the method signature of `'delete-duplicate-lines`"
    ;; This is a common function that I've used in other text editors.
    ;; It's a simple stitch together of sort-lines and
    ;; delete-duplicate-lines.
    (interactive "P\nr")
    (sort-lines reverse beg end)
    (delete-duplicate-lines beg end reverse adjacent keep-blanks interactive))

  (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
  (global-set-key (kbd "s-w") 'kill-current-buffer)

  ;; Treat dashes and underscores as part of words for navigation
  ;; (global-superword-mode t)

  (global-set-key (kbd "C-s-\\") 'jnf/display-buffer-in-side-window)
  (cl-defun jnf/display-buffer-in-side-window (&optional (buffer (current-buffer)))
    "Display BUFFER in dedicated side window."
    (interactive)
    (let ((display-buffer-mark-dedicated t))
      (display-buffer-in-side-window buffer
				     '((side . right)
				       (window-parameters
					(no-delete-other-windows . t))))))

  (global-set-key (kbd "C-s--") 'jnf/display-buffer-in-bottom-window)
  (cl-defun jnf/display-buffer-in-bottom-window (&optional (buffer (current-buffer)))
    "Display BUFFER in dedicated side window."
    (interactive)
    (let ((display-buffer-mark-dedicated t))
      (display-buffer-in-side-window buffer
				     '((side . bottom)
				       (window-parameters
					(no-delete-other-windows . t))))))

  (bind-key "C-x m" #'jnf/move-file)
  (defun jnf/move-file (target-directory)
    "Write this file to TARGET-DIRECTORY, and delete old one."
    (interactive "DTarget Directory: ")
    (let* ((source (expand-file-name (file-name-nondirectory (buffer-name)) default-directory))
	   (target (f-join target-directory (file-name-nondirectory (buffer-name)))))
      (save-buffer)
      (rename-file source target)
      (kill-current-buffer)))
#+end_src

* TODO Org Mode

** TODO org-mode.el

#+begin_src emacs-lisp
  ;; Consider https://github.com/jkitchin/org-ref as well

  (cl-defun jnf/org-agenda-files (&key paths basenames)
    "Return the list of filenames where BASENAMES exists in PATHS."
    (setq returning-list '())
    (dolist (path paths)
      (dolist (basename basenames)
	(if (f-exists-p (f-join path basename))
	    (add-to-list 'returning-list (f-join path basename)))))
    returning-list)

  (use-package org
    ;; :straight t
    ;; :straight (org
    ;;            :type git
    ;;            :url "https://git.savannah.gnu.org/git/emacs/org-mode.git"
    ;;            :commit "73875939a8b5545ac53a86ec467239f510d14de8" ;; 9.5 stable
    ;;            )
    :straight (org :type built-in)
    :hook (org-mode . turn-on-visual-line-mode)
    :config (setq
	     org-directory (file-truename "~/git/org")
	     org-agenda-files (jnf/org-agenda-files
			       :paths jnf/data-directories
			       :basenames '("agenda.org"))
	     org-default-notes-file (concat org-directory "/captured-notes.org")
	     ;; org-startup-indented t
	     org-todo-keywords
	     '((sequence "TODO" "WAITING" "|" "DONE")
	       (sequence "PENDING" "TODO" "WAITING" "|" "READ")))
    (setq org-capture-templates
	  '(
	    ("@" "All Todo" entry (file "~/git/org/agenda.org")
	     "* TODO %?\n  %i\n  %a" :empty-lines-before 1)))

    ;; https://xenodium.com/emacs-dwim-do-what-i-mean/
    (defun jnf/org-insert-link-dwim ()
      "Like `org-insert-link' but with personal dwim preferences."
      (interactive)
      (let* ((point-in-link (org-in-regexp org-link-any-re 1))
	     (clipboard-url (when (string-match-p "^http" (current-kill 0))
			      (current-kill 0)))
	     (region-content (when (region-active-p)
			       (buffer-substring-no-properties (region-beginning)
							       (region-end)))))
	(cond ((and region-content clipboard-url (not point-in-link))
	       (delete-region (region-beginning) (region-end))
	       (insert (org-make-link-string clipboard-url region-content)))
	      ((and clipboard-url (not point-in-link))
	       (insert (org-make-link-string
			clipboard-url
			(read-string "title: "
				     (with-current-buffer (url-retrieve-synchronously clipboard-url)
				       (dom-text (car
						  (dom-by-tag (libxml-parse-html-region
							       (point-min)
							       (point-max))
							      'title))))))))
	      (t
	       (call-interactively 'org-insert-link)))))

    (defun org-files-names-in-project-list ()
      "Return a list of filenames in the current files directory."
      (split-string-and-unquote
       (shell-command-to-string
	(concat
	 "ls " (file-name-directory buffer-file-name)))))


    (org-babel-do-load-languages 'org-babel-load-languages
				 (append org-babel-load-languages
					 '((emacs-lisp . t)
					   (plantuml . t)
					   (ruby . t))))
    ;; Make TAB act as if it were issued from the buffer of the languages's major mode.
    :custom (org-src-tab-acts-natively t)
    :bind (
	   :map org-mode-map
	   ("C-c l i". jnf/org-insert-link-dwim))
    :bind (
	   ("C-c l s" . org-store-link)
	   ("C-c a" . org-agenda)
	   ("C-c c" . org-capture)
	   ("C-s-t" . org-toggle-link-display)))

  (defun my-org-confirm-babel-evaluate (lang body) nil)
  (setq org-confirm-babel-evaluate #'my-org-confirm-babel-evaluate)

  ;; To make Org mode take care of versioning of attachments for you,
  ;; add the following to your Emacs config:
  (require 'org-attach-git)

  ;; See
  ;; https://www.reddit.com/r/orgmode/comments/i6hl8b/image_preview_size_in_org_mode/
  ;; for further discussion
  ;;
  ;; One consideration is that the below setq should be called as part
  ;; of the `org-toggle-inline-images`.  <2020-11-14 Sat 12:09>: I
  ;; commented out the lines below as it created a very small image
  ;; (about the size of one character).  (setq org-image-actual-width
  ;; (truncate (* (window-pixel-width) 0.8)))


  ;; I'd prefer to use the executable, but that doe not appear to be the
  ;; implementation of org-babel.
  (setq org-plantuml-jar-path (concat (string-trim (shell-command-to-string "brew-path plantuml")) "/libexec/plantuml.jar"))
#+end_src

** TODO org-contrib.el

I like the ~org-toc~ package.  I can toggle on the table of contents for
navigation.  Particularly useful for a large configuration.org file like this
one.

#+begin_src emacs-lisp
  (use-package org-contrib
    :straight (org-contrib :url "git.sr.ht/~bzg/org-contrib"))
  (require 'org-toc)
#+end_src

** TODO company-org-block.el

#+begin_src emacs-lisp
  ;; https://github.com/xenodium/company-org-block
  ;; (use-package company-org-block
  ;;   :straight t
  ;;   :after (org company)
  ;;   :custom
  ;;   (company-org-block-edit-style 'auto) ;; 'auto, 'prompt, or 'inline
  ;;   :hook ((org-mode . (lambda ()
  ;;                        (setq-local company-backends '(company-org-block))
  ;;                        (company-mode +1)))))
#+end_src

** TODO functions

#+begin_src emacs-lisp
  ;; ;; Insert immediate timestamp at point.
  (defun jnf/org-insert-immediate-active-timestamp ()
    "Insert an active date for today.  If given the universal arg (e.g., C-u) insert a timestamp instead."
    (interactive)
    (if (equal current-prefix-arg nil) ; no C-u
	(org-insert-time-stamp nil nil nil)
      (org-insert-time-stamp nil t nil)))

  (global-set-key (kbd "s-5") 'jnf/org-insert-immediate-active-timestamp)

  ;; ;; https://kitchingroup.cheme.cmu.edu/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/
  (defun jnf/formatted-copy-org-to-html ()
    "Export region to HTML, and copy it to the clipboard."
    (interactive)
    (save-window-excursion
      (let* ((buf (org-export-to-buffer 'html "*Formatted Copy*" nil nil t t))
	     (html (with-current-buffer buf (buffer-string))))
	(with-current-buffer buf
	  (shell-command-on-region
	   (point-min)
	   (point-max)
	   "textutil -stdin -format html -convert rtf -stdout | pbcopy"))
	(kill-buffer buf))))
  (global-set-key (kbd "C-M-s-c") 'jnf/formatted-copy-org-to-html)

  (eval-after-load 'ox '(require 'ox-koma-letter))

  (eval-after-load 'ox-koma-letter
    '(progn
       (add-to-list 'org-latex-classes
		    '("jnf-letter"
		      "\\documentclass\{scrlttr2\}
       \\usepackage[english]{babel}
       \\setkomavar{frombank}{(1234)\\,567\\,890}
       \[DEFAULT-PACKAGES]
       \[PACKAGES]
       \[EXTRA]"))

       (setq org-koma-letter-default-class "jnf-letter")))
#+end_src

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; BEGIN Hacks for ORG to type a bit more like markdown
  ;;
  ;; See http://mbork.pl/2022-01-17_Making_code_snippets_in_Org-mode_easier_to_type
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defun org-insert-backtick ()
    "Insert a backtick using `org-self-insert-command'."
    (interactive)
    (setq last-command-event ?`)
    (call-interactively #'org-self-insert-command))

  (defun org-insert-tilde ()
    "Insert a tilde using `org-self-insert-command'."
    (interactive)
    (setq last-command-event ?~)
    (call-interactively #'org-self-insert-command))

  (define-key org-mode-map (kbd "`") #'org-insert-tilde)
  (define-key org-mode-map (kbd "~") #'org-insert-backtick)
  (defvar-local org-insert-tilde-language nil
    "Default language name in the current Org file.
  If nil, `org-insert-tilde' after 2 tildes inserts an \"example\"
  block.  If a string, it inserts a \"src\" block with the given
  language name.")

  (defun org-insert-tilde ()
    "Insert a tilde using `org-self-insert-command'."
    (interactive)
    (if (string= (buffer-substring-no-properties (- (point) 3) (point))
		 "\n~~")
	(progn (delete-char -2)
	       (if org-insert-tilde-language
		   (insert (format "#+begin_src %s\n#+end_src"
				   org-insert-tilde-language))
		 (insert "#+begin_example\n#+end_example"))
	       (forward-line -1)
	       (if (string= org-insert-tilde-language "")
		   (move-end-of-line nil)
		 (org-edit-special)))
      (setq last-command-event ?~)
      (call-interactively #'org-self-insert-command)))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; END Hacks for ORG to type a bit more like markdown
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

#+begin_src emacs-lisp
  ;; Context dependent menu for org-mode.
  (use-package org-menu
    :straight (org-menu :host github :repo "sheijk/org-menu")
    :bind (:map org-mode-map ("C-c m" . 'org-menu)))
#+end_src

** TODO org-roam.el

This is my third iteration on an ~org-roam~.  It's goal is to address use-cases
that I've encountered while moving more of my note-taking with ~org-roam~.

One use-case is when I'm running or playing in an RPG session.  During those
sessions, when I create/find/insert nodes, I almost certainly want to use the
same tag filter.  This is something I observed while running my 13 session
"Thel Sector" campaign.

A second use-case is when I'm writing notes or thoughts related to work.  In a
past life, I might have written notes for either my employer or Samvera (a
community in which I participated).  Those notes might overlap but rarely did.

Another use case is less refined, namely I'm writing but am not "in" a specific
context.

However, v2 of my org-roam structure, didn't quite get out of the way.  I never
quite got to the speed of note taking that I had for the original Thel Sector
campaign.

What follows builds on Jethro Kuan's [[https://jethrokuan.github.io/org-roam-guide/][How I Take Notes with Org-roam]].  Reading
Jethro Kuan's post helped me see how I could do this.

The ~jnf/org-context-plist~ defines and names some of the contexts in which I
might be writing.  Each named context defines the tags.  These are the tags
that all nodes will have when they were written in the defined context.

I can use ~jnf/org-auto-tags--set~ to create a "yet to be named" context (e.g.,
an ad hoc context).  Or I can use ~jnf/org-auto-tags--set-by-context~ to
establish the current context (or clear it).

#+begin_src emacs-lisp
  (defvar jnf/org-roam-capture-templates-plist
    (list
     ;; These are references to "other people's thoughts."
     :refs '("r" "refs" plain "%?"
	     :if-new (file+head "refs/%<%Y%m%d>---${slug}.org" "#+title: ${title}\n#+FILETAGS:\n")
	     :unnarrowed t)
     ;; These are "my thoughts" with references to "other people's thoughts."
     :main '("m" "main" plain "%?"
	     :if-new (file+head "main/%<%Y%m%d>---${slug}.org"
				"#+title: ${title}\n#+FILETAGS: ${auto-tags}\n")
	     :immediate-finish t
	     :unnarrowed t)
     ;; These are publications of "my thoughts" referencing "other people's thoughts".
     :pubs '("p" "pubs" plain "%?"
	     :if-new (file+head "pubs/%<%Y%m%d>---${slug}.org" "#+title: ${title}\n#+FILETAGS:\n")
	     :immediate-finish t
	     :unnarrowed t))
    "Templates to use for `org-roam' capture.")

  (defvar jnf/org-context-plist
    (list
     :none (list
	    :name "none"
	    :tags (list))
     :burning-locusts (list
		       :name "burning-locusts"
		       :tags '("burning-locusts" "rpg" "burning-wheel"))
     :forem (list
	     :name "forem"
	     :tags '("forem"))
     :mistimed-scroll (list
		       :name "mistimed-scroll"
		       :tags '("eberron" "mistimed-scroll" "rpg" "burning-wheel"))
     :thel-sector (list
		   :name "thel-sector"
		   :tags '("thel-sector" "rpg" "swn")))
    "A list of contexts that I regularly write about.")

  (defvar jnf/org-auto-tags--current-list
    (list)
    "The list of tags to automatically apply to an `org-roam' capture.")

  (defun jnf/org-auto-tags--set (tags)
    "Prompt user or more TAGS."
    (interactive
     (list (completing-read-multiple "Tag(s): " (org-roam-tag-completions))))
    (setq jnf/org-auto-tags--current-list tags))

  (cl-defun jnf/org-auto-tags--set-by-context (context &key (context-plist jnf/org-context-plist))
    "Set auto-tags by CONTEXT.

     Prompt for CONTEXT from CONTEXT-PLIST."
    (interactive (list
		  (completing-read
		   "Context: " (jnf/org-context-list-completing-read))))
    (setq jnf/org-auto-tags--current-list
	  (plist-get (plist-get context-plist (intern (concat ":" context))) :tags)))

  (cl-defun org-roam-node-auto-tags (node &key (tag-list jnf/org-auto-tags--current-list))
    "Inject the TAG-LIST into the {auto-tags} region of captured NODE.

     See https://www.orgroam.com/manual.html#Template-Walkthrough"
    (if (and tag-list (> (length tag-list) 0))
	(concat ":" (s-join ":" tag-list) ":")
      ""))

  (cl-defun jnf/org-roam-templates-list (template &key (template-plist jnf/org-roam-capture-templates-plist))
    "List of `org-roam' capture templates based on given TEMPLATE.

     Searches the TEMPLATE-PLIST for the templates.

     Note, the :all template assumes we use the whole list."
    (if (eq template :all)
	(-non-nil (seq-map-indexed (lambda (tmp index)
				     (when (oddp index)
				       tmp))
				   template-plist))
      (list (plist-get template-plist template))))

  (cl-defun jnf/org-roam-templates-context-fn (&key (tag-list jnf/org-auto-tags--current-list))
    "Returns a set of templates based on TAG-LIST.

     A key assumption is that if there's a default tag list, use the
     :main template."
    (if (and tag-list (> (length tag-list) 0))
	(jnf/org-roam-templates-list :main)
      (jnf/org-roam-templates-list :all)))

  (cl-defun jnf/org-context-list-completing-read (&key
						  (context-plist
						   jnf/org-context-plist))
    "Create a list from the CONTEXT-PLIST for completing read.

     The form should be '((\"forem\" 1) (\"burning-loscusts\" 2))."
    ;; Skipping the even entries as those are the "keys" for the plist,
    ;; the odds are the values.
    (-non-nil (seq-map-indexed (lambda (context index)
				 (when (oddp index)
				   (list (plist-get context :name) index)))
			       context-plist)))

  (cl-defun jnf/org-roam-filter-context-fn (node &key (tag-list jnf/org-auto-tags--current-list))
    "Determine TAG-LIST is subset of NODE's tags."
    (gnus-subsetp tag-list (org-roam-node-tags node)))

     ;;; BEGIN org-roam declaration
  (use-package org-roam
    :straight t
    :config
    ;; I encountered the following message when attempting to export data:
    ;;
    ;; => "org-export-data: Unable to resolve link: EXISTING-PROPERTY-ID"
    ;;
    ;; See https://takeonrules.com/2022/01/11/resolving-an-unable-to-resolve-link-error-for-org-mode-in-emacs/ for details
    (defun jnf/force-org-rebuild-cache ()
      "Call some functions to rebuild the `org-mode' and `org-roam' cache."
      (interactive)
      (org-id-update-id-locations)
      ;; Note: you may need `org-roam-db-clear-all' followed by `org-roam-db-sync'
      (org-roam-db-sync)
      (org-roam-update-org-id-locations))
    (defun jnf/org-roam-capture (&optional goto keys)
      "Call `org-roam-capture' based on set tags."
      (interactive "P")
      (org-roam-capture goto
			keys
			:filter-fn 'jnf/org-roam-filter-context-fn
			:templates (jnf/org-roam-templates-context-fn)))

    (defun jnf/org-roam-node-insert ()
      "Call `org-roam-node-insert' based on set tags."
      (interactive)
      (org-roam-node-insert 'jnf/org-roam-filter-context-fn
			    :templates (jnf/org-roam-templates-context-fn)))

    (defun jnf/org-roam-find-node (&optional other-window initial-input)
      "Call `org-roam-node-find' based on set tags."
      (interactive current-prefix-arg)
      (org-roam-node-find other-window
			  initial-input
			  'jnf/org-roam-filter-context-fn
			  :templates 'jnf/org-roam-templates-context-fn))
    :custom
    (org-roam-directory (file-truename "~/git/org"))
    ;; Set more spaces for tags; As much as I prefer the old format,
    ;; this is the new path forward.
    (org-roam-node-display-template
     (concat "${type:4}   ${title:*} " (propertize "${tags:40}" 'face 'org-tag)))
    (org-roam-capture-templates (jnf/org-roam-templates-list :all))
    :bind (("C-s-f" . jnf/org-roam-find-node)
	   ("C-s-c" . jnf/org-roam-capture))
    :bind (:map org-mode-map (
			      ("C-s-;" . org-roam-buffer-toggle)
			      ("s-i" . jnf/org-roam-node-insert)))
    :init
    ;; Help keep the `org-roam-buffer', toggled via `org-roam-buffer-toggle', sticky.
    (add-to-list 'display-buffer-alist
		 '("\\*org-roam\\#"
		   (display-buffer-in-side-window)
		   (side . right)
		   (slot . 0)
		   (window-width . 0.33)
		   (window-parameters . ((no-other-window . t)
					 (no-delete-other-windows . t)))))
    ;; When t the autocomplete in org documents will query the org roam database
    (setq org-roam-completion-everywhere t)
    (setq org-roam-v2-ack t)
    (org-roam-db-autosync-mode))

  ;; This needs to be after the `org-roam’ declaration as it is dependent on the
  ;; structures of `org-roam'.

  (cl-defmethod org-roam-node-type ((node org-roam-node))
    "Return the TYPE of NODE."
    (condition-case nil
	(file-name-nondirectory
	 (directory-file-name
	  (file-name-directory
	   (file-relative-name (org-roam-node-file node) org-roam-directory))))
      (error "")))
#+end_src


** TODO org-d20.el

#+begin_src emacs-lisp
  (use-package org-d20
    :after org
    :bind  (("C-s-r" . jnf/roll-expression-dwim))
    :config
    (defun jnf/roll-expression-dwim (expression &optional)
      "Roll the EXPRESSION, check `thing-at-point' then prompt."
      (interactive (list (if (string-match
			      "[dD][0-9]"
			      (format "%s" (thing-at-point 'sexp t)))
			     (thing-at-point 'sexp t)
			   (read-string "Dice Expression: "))))
      (-let* (((rolls . result) (org-d20--roll expression)))
	(message "%s => %s" expression result)))
    :straight (org-d20 :host github :repo "spwhitton/org-d20"))
#+end_src
* TODO Spelling

This package provides configuration for spell checking.  It
assumes the use of ivy; See the flyspell-correct-ivy package.

By default, I don't render hints for spell checking nor grammar
checking.  Instead I rely on two checks:

1. flyspell-buffer (via kbd "C-,")
2. writegood-mode (via kbd "C-c w")

Once I've called flyspell-buffer, I can then navigate through
identified issues and address them via flyspell-popup-correct (via
kbd "C-").

** TODO flycheck.el

#+begin_src emacs-lisp
  (use-package flycheck
    :straight t
    :hook
    (org-src-mode . disable-flycheck-for-elisp)
    (after-init-hook . global-flycheck-mode)
    :custom
    (flycheck-display-errors-delay 0.1)
    (flycheck-emacs-lisp-initialize-packages t)
    :config
    (flycheck-set-indication-mode 'left-margin)

    (defun disable-flycheck-for-elisp ()
      (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

    (add-to-list 'flycheck-checkers 'proselint))
  ;; (add-hook 'after-init-hook #'global-flycheck-mode)
#+end_src

** TODO flyspell-correct

#+begin_src emacs-lisp
  (use-package flyspell-correct
    :straight t)

  (eval-when-compile (require 'cl-lib))

  (defun append-aspell-word (new-word)
    "Append the given NEW-WORD to the current dictionary, and reload the dictionary."
    (let ((header "personal_ws-1.1")
	  (file-name (substitute-in-file-name "$HOME/.aspell.en.pws"))
	  (read-words (lambda (file-name)
			(let ((all-lines (with-temp-buffer
					   (insert-file-contents file-name)
					   (split-string (buffer-string) "\n" t))))
			  (if (null all-lines)
			      ""
			    (split-string (mapconcat 'identity (cdr all-lines) "\n")
					  nil
					  t))))))
      (when (file-readable-p file-name)
	(let* ((cur-words (eval (list read-words file-name)))
	       (all-words (delq header (cons new-word cur-words)))
	       (words (delq nil (remove-duplicates all-words :test 'string=))))
	  (with-temp-file file-name
	    (insert (concat header
			    " en "
			    (number-to-string (length words))
			    "\n"
			    (mapconcat 'identity (sort words #'string<) "\n"))))))
      (unless (file-readable-p file-name)
	(with-temp-file file-name
	  (insert (concat header " en 1\n" new-word "\n")))))
    (ispell-kill-ispell t) ; restart ispell
    (flyspell-mode))

  (defun append-current-word-to-aspell-dictionary ()
    "Add current word to aspell dictionary."
    (interactive)
    (append-aspell-word (thing-at-point 'word)))

  (setq ispell-program-name "aspell"
	;; force the English dictionary, support Camel Case spelling check (tested with aspell 0.6)
	ispell-extra-args '("--sug-mode=ultra" "--lang=en_US" "--run-together"))
#+end_src

** TODO flyspell-popup.el

#+begin_src emacs-lisp
  ;; Run flyspell-buffer
  (use-package flyspell-popup
    :straight t
    :hook (flyspell-mode . flyspell-popup-auto-correct-mode))
#+end_src

** TODO writegood-mode.el

#+begin_src emacs-lisp
  ;; For grammar nerd
  (use-package writegood-mode
    :straight t
    :bind ("C-c w" . writegood-mode)
    :config
    (add-to-list 'writegood-weasel-words "actionable"))
#+end_src

* TODO Typography

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  This package serves the purpose of assisting with adding
  ;;  characters that are not readily available on an ANSI keyboard.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; BEGIN Typography Menu
  ;;
  ;;  The purpose of the typography menu is to provide easier access to
  ;;  typographic characters that I use; It also provides a bit of a
  ;;  mnemonic device (e.g. "C-x 8 RET" searches for a character to insert).
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defvar jnf/typography--title
    (jnf/all-the-icons--with-octicon "pencil" "Typography (C-x 8 RET for Search)" 1 -0.05)
    "The menu title for typography")
  (pretty-hydra-define jnf/typography--menu (:foreign-keys warn :title jnf/typography--title :quit-key "q" :exit t)
    ("Characters" (
		   ("d d" (insert "-") "- dash")
		   ("d m" (insert "—") "— em dash")
		   ("d n" (insert "–") "– en dash")
		   (". e" (insert "…") "… ellipsis")
		   (". d" (insert "·") "º degree")
		   (". m" (insert "·") "· middot")
		   ("t d" (insert "†") "† dagger")
		   ("t 2" (insert "‡") "‡ double dagger")
		   ("t s" (insert "§") "§ section")
		   ("t p" (insert "¶") "¶ paragraph")
		   ("? !" (insert "‽") "‽ Interobang")
		   )
     "Math" (
	     ("a x" (insert "×") "× Multiplication Sign")
	     ("a d" (insert "÷") "÷ Division Sign")
	     ("a m" (insert "−") "− Minus Sign")
	     ("a p" (insert "±") "± Plus or Minus Sign")
	     ("m n" (insert "¬") "¬ Negation")
	     ;; For declaring regex functions.  See
	     ;; https://www.johndcook.com/blog/2022/01/08/corner-quotes-in-unicode/
	     ;; and https://irreal.org/blog/?p=10265
	     ("c l" (insert "⌜") "⌜ Left Corner Quote")
	     ("c r" (insert " ⌟") "⌟ Right Corner Quote")
	     ;; Included as a reminder as I use these for menu structures
	     ("f h"   (insert "─") "─ Forms light horizontal")
	     ("f D l" (insert "┐") "┐ Forms light down and left")
	     ("f v"   (insert "│") "│ Forms light vertical")
	     ("f V r" (insert "├") "├ Forms light vertical and right")
	     ("f U r" (insert "└") "└ Forms light up and right")
	     )
     "Quotes" (
	       ("\" o" (insert "“") "“ Double quote open")
	       ("\" c" (insert "”") "” Doule quote close")
	       ("\" O" (insert "«") "« Guillemet open")
	       ("\" C" (insert "»") "» Guillemet close")
	       ("\" l" (insert "⌈") "⌈ Left ceiling")
	       ("' o" (insert "‘") "‘ Single quote open")
	       ("' c" (insert "’") "’ Single quote close")
	       ("' O" (insert "‹") "‹ Single guillemet open")
	       ("' C" (insert "›") "› Single guillemet close")
	       ("p 1" (insert "′") "′ Single Prime (feet, arcminutes)")
	       ("p 2" (insert "″") "″ Double Prime (inches, arcseconds)")
	       ("p 3" (insert "‴") "‴ Triple Prime"))
     ))

  (global-set-key (kbd "C-s-8") 'jnf/typography--menu/body)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; END Typography Menu
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+end_src

** TODO typopunct.el

#+begin_src emacs-lisp
  (use-package typopunct
    :straight t
    :config
    (add-hook 'org-mode-hook 'jnf/typopunct-init)
    (defun jnf/typopunct-init ()
      (require 'typopunct)
      (typopunct-change-language 'english)
      (typopunct-mode 1))
    (setq typopunct-buffer-language 'english)

    ;; To insert a typographical ellipsis sign (…) on three consecutive
    ;; dots, or a middle dot (·) on ‘^.’
    (defconst typopunct-ellipsis (decode-char 'ucs #x2026))
    (defconst typopunct-middot   (decode-char 'ucs #xB7)) ; or 2219
    (defun typopunct-insert-ellipsis-or-middot (arg)
      "Change three consecutive dots to a typographical ellipsis mark."
      (interactive "p")
      (cond
       ((and (= 1 arg)
	     (eq (char-before) ?^))
	(delete-char -1)
	(insert typopunct-middot))
       ((and (= 1 arg)
	     (eq this-command last-command)
	     (looking-back "\\.\\." 1))
	(replace-match "")
	(insert typopunct-ellipsis))
       (t
	(self-insert-command arg))))
    (define-key typopunct-map "." 'typopunct-insert-ellipsis-or-middot)


    (defconst typopunct-prime  (decode-char 'ucs #x2032)) ; feet, arcminutes, derivatives
    (defconst typopunct-dprime (decode-char 'ucs #x2033)) ; inches, arcseconds, double derivatives
    (defconst typopunct-tprime (decode-char 'ucs #x2034))

    ;; The minus sign (−) is separate from the hyphen (-), en dash (–) and
    ;; em dash (—). To build upon the clever behavior of the ‘-’ key
    (defconst typopunct-minus (decode-char 'ucs #x2212))
    (defconst typopunct-pm    (decode-char 'ucs #xB1))
    (defconst typopunct-mp    (decode-char 'ucs #x2213))
    (defadvice typopunct-insert-typographical-dashes
	(around minus-or-pm activate)
      (cond
       ((or (eq (char-before) typopunct-em-dash)
	    (looking-back "\\([[:blank:]]\\|^\\)\\^" 2))
	(delete-char -1)
	(insert typopunct-minus))
       ((looking-back "[^[:blank:]]\\^" 1)
	(insert typopunct-minus))
       ((looking-back "+/" 1)
	(progn (replace-match "")
	       (insert typopunct-pm)))
       (t ad-do-it)))
    (defun typopunct-insert-mp (arg)
      (interactive "p")
      (if (and (= 1 arg) (looking-back "-/" 2))
	  (progn (replace-match "")
		 (insert typopunct-mp))
	(self-insert-command arg)))
    (define-key typopunct-map "+" 'typopunct-insert-mp)
    (defconst typopunct-times (decode-char 'ucs #xD7))
    (defun typopunct-insert-times (arg)
      "Insert multiplication sign at ARG."
      (interactive "p")
      (if (and (= 1 arg) (looking-back "\\([[:blank:]]\\|^\\)\\^"))
	  (progn (delete-char -1)
		 (insert typopunct-times))
	(self-insert-command arg)))
    (define-key typopunct-map "x" 'typopunct-insert-times)

    (defadvice typopunct-insert-quotation-mark (around wrap-region activate)
      (let* ((lang (or (get-text-property (point) 'typopunct-language)
		       typopunct-buffer-language))
	     (omark (if single
			(typopunct-opening-single-quotation-mark lang)
		      (typopunct-opening-quotation-mark lang)))
	     (qmark (if single
			(typopunct-closing-single-quotation-mark lang)
		      (typopunct-closing-quotation-mark lang))))
	(cond
	 (mark-active
	  (let ((skeleton-end-newline nil)
		(singleo (typopunct-opening-single-quotation-mark lang))
		(singleq (typopunct-closing-single-quotation-mark lang)))
	    (if (> (point) (mark))
		(exchange-point-and-mark))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string omark)) (mark) t)
		(replace-match (regexp-quote (string singleo)) nil nil)))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string qmark)) (mark) t)
		(replace-match (regexp-quote (string singleq)) nil nil)))
	    (skeleton-insert (list nil omark '_ qmark) -1)))
	 ((looking-at (regexp-opt (list (string omark) (string qmark))))
	  (forward-char 1))
	 (t ad-do-it)))))
#+end_src

* TODO Applications

** TODO elpher.el

#+begin_src emacs-lisp
  (use-package elpher :straight t)
#+end_src

** TODO elfeed.el

This package includes the configuration for elfeed, an Emacs RSS reader.

#+begin_src emacs-lisp
  (use-package elfeed
    :straight t
    :after org
    :config
    (setq-default elfeed-search-filter "@2-days-ago +unread ")
    (defun jnf/amplify-elfeed ()
      "Amplify the current `elfeed-show-entry'"
      (interactive)
      (let* ((citeURL (elfeed-entry-link elfeed-show-entry))
	     (citeTitle (elfeed-entry-title elfeed-show-entry))
	     ;; Grab the author from the elfeed metadata.  Making the
	     ;; assumption that there's only one.
	     (citeAuthor
	      (plist-get
	       (car (plist-get
		     (elfeed-entry-meta elfeed-show-entry)
		     :authors))
	       :name)))
	(jnf/tor-post-amplifying-the-blogosphere citeTitle
						 :citeTitle citeTitle
						 :citeURL citeURL
						 :citeAuthor citeAuthor)))
    :bind (
	   (:map elfeed-search-mode-map
		 ("q" . jnf/elfeed-save-db-and-bury))
	   (:map elfeed-show-mode-map
		 ("<f7>" . jnf/amplify-elfeed)
		 ("s-7" . jnf/amplify-elfeed))))

  ;;write to disk when quiting
  (defun jnf/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

  (defun jnf/elfeed-load-db-and-open ()
    "Load the elfeed db from disk before opening"
    (interactive)
    (elfeed)
    (elfeed-update)
    (elfeed-db-load)
    (elfeed-search-update--force))
  (defalias 'rss 'jnf/elfeed-load-db-and-open)

  ;; https://github.com/alphapapa/unpackaged.el#feed-for-url
  ;;;###autoload
  (cl-defun unpackaged/feed-for-url (url &key (prefer 'atom) (all nil))
    "Return feed URL for web page at URL.
  Interactively, insert the URL at point.  PREFER may be
  `atom' (the default) or `rss'.  When ALL is non-nil, return all
  feed URLs of all types; otherwise, return only one feed URL,
  preferring the preferred type."
    (interactive (list (org-web-tools--get-first-url)))
    (require 'esxml-query)
    (require 'org-web-tools)
    (cl-flet ((feed-p (type)
		      ;; Return t if TYPE appears to be an RSS/ATOM feed
		      (string-match-p (rx "application/" (or "rss" "atom") "+xml")
				      type)))
      (let* ((preferred-type (format "application/%s+xml" (symbol-name prefer)))
	     (html (org-web-tools--get-url url))
	     (dom (with-temp-buffer
		    (insert html)
		    (libxml-parse-html-region (point-min) (point-max))))
	     (potential-feeds (esxml-query-all "link[rel=alternate]" dom))
	     (return (if all
			 ;; Return all URLs
			 (cl-loop for (_tag attrs) in potential-feeds
				  when (feed-p (alist-get 'type attrs))
				  collect (url-expand-file-name (alist-get 'href attrs) url))
		       (or
			;; Return the first URL of preferred type
			(cl-loop for (_tag attrs) in potential-feeds
				 when (equal preferred-type (alist-get 'type attrs))
				 return (url-expand-file-name (alist-get 'href attrs) url))
			;; Return the first URL of non-preferred type
			(cl-loop for (_tag attrs) in potential-feeds
				 when (feed-p (alist-get 'type attrs))
				 return (url-expand-file-name (alist-get 'href attrs) url))))))
	(if (called-interactively-p 'interactive)
	    (insert (if (listp return)
			(s-join " " return)
		      return))
	  return))))

  ;; From https://karthinks.com/blog/lazy-elfeed/
  (defun elfeed-search-show-entry-pre (&optional lines)
    "Returns a function to scroll forward or back in the Elfeed
    search results, displaying entries without switching to them."
    (lambda (times)
      (interactive "p")
      (forward-line (* times (or lines 0)))
      (recenter)
      (call-interactively #'elfeed-search-show-entry)
      (select-window (previous-window))
      (unless elfeed-search-remain-on-entry (forward-line -1))))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "n") (elfeed-search-show-entry-pre +1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "p") (elfeed-search-show-entry-pre -1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "M-RET") (elfeed-search-show-entry-pre)))
  ;; End https://karthinks.com/blog/lazy-elfeed/
#+end_src

** TODO eww.el

#+begin_src emacs-lisp
  (use-package eww
    :straight t
    :config
    (defun jnf/amplify-eww ()
      "Amplify the current `eww-data'"
      (interactive)
      (let* ((citeURL (plist-get eww-data :url))
	     (citeTitle (plist-get eww-data :title)))
	(tor-post-amplifying-the-blogosphere citeTitle
					     :citeTitle citeTitle
					     :citeURL citeURL)))
    (defun shr-tag-dfn (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-cite (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-q (dom)
      (shr-insert (car shr-around-q-tag))
      (shr-generic dom)
      (shr-insert (cdr shr-around-q-tag)))

    (defcustom shr-around-q-tag '("“" . "”")
      "The before and after quotes.  `car' is inserted before the Q-tag and `cdr' is inserted after the Q-tag.

  Alternative suggestions are: - '(\"\\\"“\" . \"\\\"\")"
      :type (cons 'string 'string))

    (defface shr-small
      '((t :height 0.8))
      "Face for <small> elements.")

    ;; Drawing inspiration from shr-tag-h1
    (defun shr-tag-small (dom)
      (shr-fontize-dom dom (when shr-use-fonts 'shr-small)))

    (defface shr-time
      '((t :inherit underline :underline (:style wave)))
      "Face for <time> elements.")

    ;; Drawing inspiration from shr-tag-abbr
    (defun shr-tag-time (dom)
      (when-let* ((datetime (or
			     (dom-attr dom 'title)
			     (dom-attr dom 'datetime)))
		  (start (point)))
	(shr-generic dom)
	(shr-add-font start (point) 'shr-time)
	(add-text-properties
	 start (point)
	 (list
	  'help-echo datetime
	  'mouse-face 'highlight))))


    ;; EWW lacks a style for article
    (defun shr-tag-article (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    ;; EWW lacks a style for section; This is quite provisional
    (defun shr-tag-section (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    (setq browse-url-browser-function 'browse-url-default-macosx-browser)
    :bind (:map eww-mode-map
		("U" . eww-up-url)
		("<f7>" . jnf/amplify-eww)
		("s-7" . jnf/amplify-eww))
    :bind (("C-s-w" . browse-url-at-point))
    :hook ((eww-mode . jnf/reader-visual)))
#+end_src

** TODO feed functions

#+begin_src emacs-lisp
  ;; A little bit of RSS beautification
  (add-hook 'elfeed-show-mode-hook 'jnf/reader-visual)
  (defun jnf/reader-visual ()
    "A method to turn on visual line mode and adjust text scale."
    (text-scale-set 2)
    (turn-on-visual-line-mode))
#+end_src

** TODO elfeed-org.el

#+begin_src emacs-lisp
  (use-package elfeed-org
    :straight t
    :after elfeed
    :config (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/git/org/elfeed.org")))
#+end_src

** TODO shrface.el

#+begin_src emacs-lisp
  (use-package shrface
    :straight t
    :after eww
    :hook
    (eww-mode . shrface-mode)
    (elfeed-mode . shrface-mode)
    :custom (shrface-toggle-bullets nil)
    :config
    (shrface-basic)
    ;; (shrface-trial)
    (setq shrface-href-versatile t)

    ;; I proposed `jnf/shrface-headlines-consult' and
    ;; `jnf/shrface-links-consult' over at
    ;; https://github.com/chenyanming/shrface/issues/14.  I added the
    ;; jnf prefix to highlight that they are my own creation.  If the
    ;; maintainer adds these functions, then I'll remove them.
    ;;
    ;; Working on `consult-headlines' from shrface package.
    (defun jnf/shrface-headlines-consult ()
      "Use consult to show all headlines in order founded in the buffer.
  Current headline will be the one of the candidates to initially select."
      (interactive)
      (let ((current (point-min)) (start (1+ (point))) point number)
	;; Scan from point-min to (1+ (point)) to find the current headline.
	;; (1+ (point)) to include under current point headline into the scan range.
	(unless (> start (point-max))
	  (while (setq point (text-property-not-all
			      current start shrface-headline-number-property nil))
	    (setq current (1+ point))))

	(cond ((equal (point) 1) (setq number 0))
	      ((equal (point) 2) (setq number 0))
	      ((equal (point) (point-max)) (setq number 0))
	      (t
	       (ignore-errors (setq number (1- (get-text-property (1- current) shrface-headline-number-property))))))

	;; Start the consult--read
	(setq start (point)) ; save the starting point
	(if (fboundp 'consult--read)
	    (consult--read (shrface-headline-selectable-list)
			   :prompt "shrface headline:"
			   :category 'shrface-headlines-consult
			   :sort nil)
	  (message "Please install 'consult' before using 'shrface-headlines-consult'"))))


    (defun jnf/shrface-links-consult ()
      "Use consult to present all urls in order founded in the buffer."
      (interactive)
      (let ((start (point)) next url)
	;; get the next nearest url
	(setq next (text-property-not-all
		    (point) (point-max) shrface-href-follow-link-property nil))
	;; only if the next url exists
	(if next
	    (setq url (get-text-property next shrface-href-property)))
	(if (fboundp 'consult--read)
	    (consult--read (shrface-links-selectable-list)
			   :prompt "shrface link:"
			   :category 'shrface-links-consult
			   :sort nil)
	  (message "Please install 'consult' before using 'shrface-links-consult'"))))

    :bind (:map
	   eww-mode-map (("<tab>" . shr-next-link)
			 ("<backtab>" . shr-previous-link)))
    :bind (:map
	   shrface-mode-map (("<C-M-tab>" . shrface-outline-cycle-buffer)
			     ("C-t" . shrface-toggle-bullets)
			     ("C-j" . shrface-next-headline)
			     ("C-k" . shrface-previous-headline)
			     ("M-l" . jnf/shrface-links-consult)
			     ("M-h" . jnf/shrface-headlines-consult))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+end_src

#+RESULTS:

* TODO Utilities

** DONE Opening multiple file names from command line

The following chunk of allows me to take multiple filenames passed via the
emacsclient and open those files in windows within the same frame.

You can see this in my [[https://codeberg.org/takeonrules/dotzshrc/src/branch/main/bin/git-edit][git-edit]] command line tool.

#+begin_src emacs-lisp
  (defvar server-visit-files-custom-find:buffer-count
    "A counter for assisting with opening multiple files via a single
  client call.")
  (defadvice server-visit-files
      (around server-visit-files-custom-find
	      activate compile)
    "Maintain a counter of visited files from a single client call."
    (let ((server-visit-files-custom-find:buffer-count 0))
      ad-do-it))
  (defun server-visit-hook-custom-find ()
    "Arrange to visit the files from a client call in separate windows."
    (if (zerop server-visit-files-custom-find:buffer-count)
	(progn
	  (delete-other-windows)
	  (switch-to-buffer (current-buffer)))
      (let ((buffer (current-buffer))
	    (window (split-window-sensibly)))
	(switch-to-buffer buffer)
	(balance-windows)))
    (setq server-visit-files-custom-find:buffer-count
	  (1+ server-visit-files-custom-find:buffer-count)))
  (add-hook 'server-visit-hook 'server-visit-hook-custom-find)
#+end_src

** TODO blogging specific

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t
  ;;
  ;;; Commentary:
  ;;
  ;;  This package includes numerous tools for helping me with my
  ;;  blogging efforts.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (use-package decide
    :straight (decide :host github :type git :repo "jeremyf/decide-mode"))

  ;;******************************************************************************
  ;;
  ;;; BEGIN Non-Interactive Utility Functions
  ;;
  ;;******************************************************************************
  (cl-defun jnf/convert-text-to-key (text &key (length 5))
    "Convert the given TEXT to an epigraph key.

  The LENGTH is how many words to use for the key."
    (let ((list-of-words (s-split-words text)))
      (if (> (length list-of-words) length)
	  (upcase (s-join "-" (subseq list-of-words 0 length)))
	"")))

  (defun jnf/tor-convert-text-to-post-title (title)
    "Convert TITLE to correct format."
    (message "Titleizing...")
    (replace-regexp-in-string
     ;; Replace "Hello World" with “Hello World”
     "\"\\([^\"]+\\)\""
     "“\\1”"
     (s-replace "'" "’" title)))

  (defun jnf/tor-convert-text-to-slug (string)
    "Convert STRING to appropriate slug."
    (s-replace "'" "" (s-dashed-words (s-downcase string))))

  (cl-defun jnf/tor-prompt-or-kill-ring-for-url (&key (url-regexp "^https?://"))
    "Prompt and return a url.

  If the `car' of `kill-ring' matches the URL-REGEXP, default the
  prompt value to the `car' of `kill-ring'."
    (let ((car-of-kill-ring (substring-no-properties (car kill-ring))))
      (read-string "URL (optional): "
		   (when (string-match url-regexp car-of-kill-ring)
		     car-of-kill-ring))))

  (cl-defun jnf/tor-post---create-or-append (&key
					     title subheading
					     (tags '("null")) series toc
					     citeTitle citeURL citeAuthor)
    "Create or append a post with TITLE.

  The following keys are optional:

  :SUBHEADING if you have an active region, use this header.
  :TAGS one or more tags, as a list or string, to add to the
	  frontmatter.
  :SERIES the series to set in the frontmatter.
  :TOC whether to include a table of contents in the post.
  :CITETITLE the title of the URL cited (if any)
  :CITEURL the URL cited (if any)
  :CITEAUTHOR the author cited (if any)

  If there's an active region, select that text and place it."
    (let* ((default-directory (f-join jnf/tor-home-directory
				      "content" "posts"
				      (format-time-string "%Y/")))

	   (slug (jnf/tor-convert-text-to-slug title))
	   (fpath (expand-file-name
		   (concat default-directory slug ".md"))))
      ;; If the file does not exist, create the file with the proper
      ;; frontmatter.
      (if (not (file-exists-p fpath))
	  (write-region
	   (concat "---"
		   "\ndate: " (format-time-string "%Y-%m-%d %H:%M:%S %z")
		   "\ndraft: true"
		   "\nlayout: post"
		   "\nlicenses:\n- all-rights-reserved"
		   "\nslug: " (format "%s" slug)
		   "\ntitle: '" (jnf/tor-convert-text-to-post-title title) "'"
		   "\ntype: post"
		   (when series (concat "\nseries: " series))
		   (when toc (concat "\ntoc: true"))
		   "\ntags:"
		   (if tags
		       (concat (mapconcat
				(lambda (tag) (concat "\n- " tag))
				(flatten-tree tags) ""))
		     "\n- null")
		   "\n---\n")
	   nil fpath))
      ;; If we have an active region, append that region's content to
      ;; the given file.
      (if (use-region-p)
	  (write-region
	   (concat
	    (if subheading
		(concat "\n## " subheading "\n")
	      (when citeTitle (concat "\n## " citeTitle "\n")))
	    (when citeURL (concat
			   "\n{{< blockquote"
			   (when citeAuthor
			     (concat " pre=\"" citeAuthor "\""))
			   " cite=\"" citeTitle
			   "\" cite_url=\"" citeURL "\" >}}\n"))
	    (buffer-substring (region-beginning) (region-end))
	    (when citeURL "\n{{< /blockquote >}}"))
	   nil fpath t)
	;; Without an active region, if we have a citeURL insert a link
	;; to it.
	(when citeURL
	  (write-region
	   (concat
	    "\n<cite><a href=\"" citeURL
	    "\" class=\"u-url p-name\" rel=\"cite\">"
	    (or (citeTitle) (citeURL)) "</a></cite>\n")
	   nil fpath t)))
      ;; Finally open that file for editing.
      (find-file fpath)
      (end-of-buffer)))
  ;;******************************************************************************
  ;;
  ;;; END Non-Interactive Utility Functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN Interactive Non-Wrapping Functions
  ;;
  ;;******************************************************************************
  (cl-defun jnf/tor-toggle-hugo-server (&key
					(directory jnf/tor-home-directory)
					(buffer-name "*Hugo Server*"))
    "This will start or stop a Hugo server in the given DIRECTORY for TakeOnRules.com.

  The BUFFER-NAME is where we'll run the Hugo process."
    (interactive)
    (if (get-buffer buffer-name)
	(progn
	  (kill-buffer buffer-name)
	  (message (concat "Stopping Hugo in \"" buffer-name "\" buffer…")))
      (let* ((default-directory directory))
	(start-process "hugo-server" buffer-name "hugo" "server" "-D")
	(message (concat "Starting Hugo in \"" buffer-name "\" buffer…")))))

  (defun jnf/tor-retitle-post (title)
    "Replace the given buffer's title with the new TITLE.

  This function will: replace the content's title, update the slug,
  and rename the buffer."
    (interactive "sNew Post's Title: ")
    (let* ((metadataTitle (concat "title: '"
				  (jnf/tor-convert-text-to-post-title title) "'"))
	   (slug (jnf/tor-convert-text-to-slug title))
	   (metadataSlug (concat "slug: " slug))
	   (filename (buffer-file-name))
	   (new-filename (concat (file-name-directory filename)
				 slug ".md")))

      ;; Replace the title metadata entry
      (goto-char (point-min))
      (while (search-forward-regexp "^title:.*$" nil t)
	(replace-match metadataTitle))

      ;; Replace the slug metadata entry
      (goto-char (point-min))
      (while (search-forward-regexp "^slug:.*$" nil t)
	(replace-match metadataSlug))

      ;; Need to save before we rename the buffer
      (save-buffer)

      ;; Rename the buffer, accounting for version control
      (cond
       ((vc-backend filename)
	(vc-rename-file filename new-filename))
       (t
	(rename-file filename new-filename t)
	(set-visited-file-name new-filename t t)))

      ;; Report filename change
      (message "Renamed %s -> %s" filename new-filename)))

  (defvar jnf/tor-hostname-regexp
    "^https?://takeonrules\.com"
    "A regular expression for checking if it's TakeOnRules.com.")

  (defvar jnf/tor-hugo-regexp-for-post-path
    (concat jnf/tor-hostname-regexp
	    "/[0-9]\\{4\\}/[0-9]\\{2\\}/[0-9]\\{2\\}/\\([^/]+\\)/?$")
    "A regular expression for matching blog posts.")

  (defvar jnf/tor-hugo-regexp-for-pages-path
    (concat jnf/tor-hostname-regexp "/\\([^z-a]*[^/]\\)/?$")
    "A regular expression for matching pages.")

  (defun jnf/tor-find-hugo-file-by-url (url)
    "Find the associated TakeOnRules.com file for the given URL."
    (interactive (list
		  (jnf/tor-prompt-or-kill-ring-for-url
		   :url-regexp jnf/tor-hostname-regexp)))
    (cond
     ;; Blog post
     ((string-match jnf/tor-hugo-regexp-for-post-path url)
      (let* ((slug (match-string-no-properties 1 url))
	     (filename (car
			(jnf/list-filenames-with-file-text
			 :matching (concat "^slug: " slug "$")
			 :in "content"))))
	(find-file (f-join jnf/tor-home-directory "content" filename))))
     ;; Pages
     ((string-match jnf/tor-hugo-regexp-for-pages-path url)
      (let* ((permalink (match-string-no-properties 1 url))
	     (filename (car
			(jnf/list-filenames-with-file-text
			 :matching (concat "^permalink: ['\\\"]?/?"
					   permalink "/?['\\\"]?$")
			 :in "content"))))
	(find-file (f-join jnf/tor-home-directory "content" filename))))
     ;; No match found
     (t (message "Unable to find post for \"%s\"" url))))

  (cl-defun jnf/tor-view-blog-post (&key
				    (hostname jnf/tor-default-local-hostname))
    "Open `eww' in a new window to preview the current buffer at the HOSTNAME.

  The front matter of blog posts contains YAML, with two
  attributes: slug and date.  Based on the site configuration, the
  URLs for one of those posts is: hostname/year/month/day/slug"
    (interactive)
    (let ((slugs))
      (save-excursion
	;; Remember we are making a list and pushing to the beginning of
	;; the list.  Hence we start with the last slug in mind.
	(goto-char 1)
	(re-search-forward "^slug: \\(.*\\)$" nil t)
	(push (match-string 1) slugs)
	(goto-char 1)
	(re-search-forward
	 "^date: \\([[:digit:]]+\\)-\\([[:digit:]]+\\)-\\([[:digit:]]+\\) "
	 nil t)
	;; Then move to day, month, then year.
	(push (match-string 3) slugs)
	(push (match-string 2) slugs)
	(push (match-string 1) slugs)
	;; And finally the host name.
	(push hostname slugs))
      (delete-other-windows)
      (split-window-horizontally)
      (other-window 1)
      (eww (format "%s" (s-join "/" slugs)))))

  (defun jnf/tor-create-post (title)
    "Create and visit a new draft post.  Prompt for a TITLE.

  The file for the blog post conforms to the path schema of posts
  for TakeOnRules.com."
    (interactive "sBlog Post Title: ")
    (jnf/tor-post---create-or-append :title title))

  (defun jnf/tor-tag-post (tags)
    "Apply the TAGS to the current TakeOnRules.com post.

  No effort is made to check if this is a post."
    (interactive (list (completing-read-multiple "Tags: " (jnf/tor-tags-list))))
    (let ((saved-point (point))
	  (to-insert (concat "\n- " (s-join "\n- " tags))))
      (replace-regexp "^tags:$" (concat "tags:" to-insert) nil 0 (point-max))
      (goto-char (+ saved-point (length to-insert)))))

  (defun jnf/tor-insert-glossary-key (key)
    "Insert the KEY at point."
    (interactive (list (completing-read "Key: " (jnf/tor-glossary-key-list))))
    (insert key))

  (defun jnf/tor-find-changelog-and-insert-entry ()
    "Find TakeOnRules glossary and begin entering a changelog entry."
    (interactive)
    (find-file (f-join jnf/tor-home-directory "data" "changelog.yml"))
    ;; The changelog is structured in date descending order.  The first
    ;; line is the YAML preamble indicating a data object (e.g. "---")
    (beginning-of-buffer)
    (end-of-line)
    (insert (concat "\n- date: "
		    (format-time-string "%Y-%m-%d")
		    "\n  entries:\n    - ")))

  (defun jnf/tor-find-series-and-insert-entry (title)
    "Find TakeOnRules series and add an entry with TITLE."
    (interactive "sSeries Entry's Title: ")
    (find-file (f-join jnf/tor-home-directory "data" "series.yml"))
    (let ((key (downcase (s-dashed-words title))))
      (end-of-buffer)
      (insert (concat
	       (if (looking-at-p "^$") "" "\n")
	       "- title: " title
	       "\n  key: " key))))

  (defun jnf/tor-find-glossary-and-insert-entry (title)
    "Find TakeOnRules glossary and add an entry with TITLE."
    (interactive "sGlossary Entry's Title: ")
    (find-file (f-join jnf/tor-home-directory "data" "glossary.yml"))
    (let ((key (upcase (s-dashed-words title))))
      (end-of-buffer)
      (insert (concat
	       (if (looking-at-p "^$") "" "\n")
	       "- title: " title
	       "\n  key: " key))))

  (defun jnf/tor-insert-epigraph-entry ()
    "Prompt for a new a new data/epigraphs.yml entry."
    (interactive)
    (find-file (f-join jnf/tor-home-directory "data" "epigraphs.yml"))
    (end-of-buffer)
    (insert (concat
	     (if (looking-at-p "^$") "" "\n")
	     "epi"))
    (end-of-buffer)
    "Assumes that the 'epi' is the correct expansion for the snippet."
    (yas-expand)
    (message "Ready to insert a new epigraph"))

  (cl-defun jnf/tor-post-amplifying-the-blogosphere (subheading
						     &key
						     citeTitle
						     citeURL
						     citeAuthor)
    "Create and visit draft post for amplifying the blogosphere.

  If there's an active region, prompt for the :SUBHEADING.  The file
  for the blog post conforms to the path schema of posts for
  TakeOnRules.com.

  We'll pass the :CITETITLE, :CITEAUTHOR, and :CITEURL to
  `jnf/tor-post---create-or-append'"
    (interactive (list (if (use-region-p)
			   (read-string "Sub-Heading: ")
			 nil)))
    (jnf/tor-post---create-or-append
     :title (format-time-string "Amplifying the Blogosphere (v%Y-%m-%d)")
     :toc "true"
     :subheading subheading
     :series "amplifying-the-blogosphere"
     :tags "response to other blogs"
     :citeTitle citeTitle
     :citeURL citeURL
     :citeAuthor citeAuthor))

  ;; Note: I needed to use `fboundp' because if I invoked this functions
  ;; before other consult functions I got a method void error.
  (cl-defun jnf/find-file-via-matching (&key prompt matching in)
    "PROMPT for files IN the directory with MATCHING content.

  If `consult--read' is defined, use that.  Otherwise fallback to `completing-read'."
    (if (fboundp 'consult--read)
	(consult--read
	 (consult--with-increased-gc
	  (jnf/list-full-filenames-with-file-text :matching matching :in in))
	 :prompt prompt
	 :sort nil
	 :require-match t
	 :category 'file
	 :history 'file-name-history
	 :state (consult--file-preview))
      (list (completing-read
	     prompt
	     (jnf/list-filenames-with-file-text
	      :matching matching
	      :in in)))))

  (defun jnf/tor-find-file-draft (filename)
    "Find a draft FILENAME in the TakeOnRules content directory."
    (interactive
     (list (jnf/find-file-via-matching
	    :prompt "Draft filename: "
	    :matching "^draft: true"
	    :in (f-join jnf/tor-home-directory "content"))))
    (find-file filename))

  (defun jnf/tor-find-file (filename)
    "Find a FILENAME in the TakeOnRules content directory."
    (interactive
     (list (jnf/find-file-via-matching
	    :prompt "Filename: "
	    :matching "^title:"
	    :in (f-join jnf/tor-home-directory "content"))))
    (find-file filename))
  ;;******************************************************************************
  ;;
  ;;; END Interactive Non-Wrapping Functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN Listing functions for TakeOnRules.com data
  ;;
  ;;******************************************************************************
  (defun jnf/tor-tags-list ()
    "Return a list of tags from TakeOnRules.com."
    (jnf/tor-list-by-key-from-filename :key "tag" :filename "data/glossary.yml"))

  (defun jnf/tor-epigraph-list ()
    "Return a list of epigraph keys from TakeOnRules.com."
    (jnf/tor-list-by-key-from-filename :key "key" :filename "data/epigraphs.yml"))

  (defun jnf/tor-game-list ()
    "Return a list of games from TakeOnRules.com."
    (jnf/tor-list-by-key-from-filename :key "game" :filename "data/glossary.yml"))

  (defun jnf/tor-glossary-title-list ()
    "Return a list of titles from TakeOnRules.com."
    (jnf/tor-list-by-key-from-filename :key "title" :filename "data/glossary.yml"))

  (defun jnf/tor-glossary-key-list ()
    "Return a list of keys from TakeOnRules.com glossary."
    (jnf/tor-list-by-key-from-filename :key "key" :filename "data/glossary.yml"))

  (defun jnf/tor-series-list ()
    "Return a list of series from TakeOnRules.com."
    (jnf/tor-list-by-key-from-filename :key "key" :filename "data/series.yml"))

  (defun jnf/tor-licenses-list ()
    "Return a list of available licenses for TakeOnRules.com."
    (jnf/tor-list-by-key-from-filename :key "Key" :filename "data/licenses.yml"))
  ;;******************************************************************************
  ;;
  ;;; END Listing functions for TakeOnRules.com data
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN querying and list generation functions
  ;;
  ;;******************************************************************************
  (cl-defun jnf/tor-list-by-key-from-filename (&key
					       key
					       filename
					       (directory jnf/tor-home-directory))
    "Build a list of entries of the KEY from the FILENAME in DIRECTORY."
    (split-string-and-unquote
     (shell-command-to-string
      (concat
       "rg \"^[- ] " key ": .*$\" "
       (f-join directory filename)
       " --only-matching --no-filename | sed 's/^[ -] " key ": //' | sort | tr '\n' '@'"))
     "@"))

  (cl-defun jnf/list-filenames-with-file-text (&key matching in)
    "Build a list of filenames MATCHING the pattern IN the given directory."
    (let ((default-directory (f-join jnf/tor-home-directory in)))
      (split-string-and-unquote
       (shell-command-to-string
	(concat
	 "rg \""
	 matching "\" --only-matching --files-with-matches --sortr modified"
	 "| tr '\n' '@'"))
       "@")))

  (cl-defun jnf/list-full-filenames-with-file-text (&key matching in)
    "Build a list of filenames MATCHING the pattern IN the given directory."
    (split-string-and-unquote
     (shell-command-to-string
      (concat
       "rg \""
       matching "\" " in " --only-matching --files-with-matches --sortr modified"
       "| tr '\n' '@'"))
     "@"))

  (defun jnf/tor-page-relative-pathname-list ()
    "Return a list of pages for TakeOnRules.com."
    (jnf/list-filenames-with-file-text :matching "^title: " :in "content"))

  (defun jnf/tor-asset-relative-pathname-list ()
    "Return a list of image filenames for TakeOnRules.com."
    (let ((default-directory (f-join jnf/tor-home-directory "assets" "images")))
      (split-string-and-unquote
       (shell-command-to-string "ls"))))

  (defun jnf/matches-in-buffer (regexp &optional buffer)
    "Return a list of matches of REGEXP in BUFFER or the current buffer if not given."
    (let ((matches))
      (save-match-data
	(save-excursion
	  (with-current-buffer (or buffer (current-buffer))
	    (save-restriction
	      (widen)
	      (goto-char 1)
	      (while (search-forward-regexp regexp nil t 1)
		(push (match-string 0) matches)))))
	matches)))

  (defun jnf/kill-new-markdown-heading-as-slug (heading)
    "Push onto the `kill-ring' a slugified version of HEADING."
    (interactive
     (list (completing-read
	    "Heading: "
	    (jnf/matches-in-buffer "^#+ +.*$"))))
    (kill-new (jnf/tor-convert-text-to-slug
	       (replace-regexp-in-string "^#+ +" "" heading))))
  ;;******************************************************************************
  ;;
  ;;; END querying and list generation functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN Wrapping Functions
  ;;
  ;;******************************************************************************
  (cl-defun jnf/tor-wrap-with-text (&key before after strategy)
    "Wrap the STRATEGY determined region with the BEFORE and AFTER text.

  Valid STRATEGY options are:

  - :lineOrRegion
  - :pointOrRegion
  - :sentenceOrRegion
  - :wordOrRegion

  TODO: I would love create a lookup table for the case statement,
  as the behavior's well defined."
    (pcase strategy
      (:lineOrRegion (pcase-let* ((origin (point))
				  (`(,begin . ,end)
				   (crux-get-positions-of-line-or-region)))
		       (goto-char end)
		       (insert after)
		       (goto-char begin)
		       (insert before)))
      (:sentenceOrRegion (let* ((begin (if (use-region-p)
					   (region-beginning)
					 (car (bounds-of-thing-at-point 'sentence))))
				(end (if (use-region-p)
					 (region-end)
				       (cdr (bounds-of-thing-at-point 'sentence)))))
			   (goto-char end)
			   (insert after)
			   (goto-char begin)
			   (insert before)))
      (:pointOrRegion (let* ((begin (if (use-region-p) (region-beginning) (point)))
			     (end (if (use-region-p) (region-end) (point))))
			(goto-char end)
			(insert after)
			(goto-char begin)
			(insert before)))
      (:wordOrRegion (let* ((begin (if (use-region-p)
				       (region-beginning)
				     (car (bounds-of-thing-at-point 'word))))
			    (end (if (use-region-p)
				     (region-end)
				   (cdr (bounds-of-thing-at-point 'word)))))
		       (goto-char end)
		       (insert after)
		       (goto-char begin)
		       (insert before)))
      ))

  (defun jnf/tor-wrap-in-html-tag (tag &optional attributes)
    "Wrap the word or region with the given TAG with optional ATTRIBUTES."
    (interactive "sHTML Tag: \nsAttributes (optional): ")
    (jnf/tor-wrap-with-text
     :before (concat "<" tag (if (s-blank? attributes)
				 ""
			       (concat " " attributes)) ">")
     :after (concat "</" tag ">")
     :strategy :wordOrRegion))

  (defun jnf/tor-wrap-in-poem ()
    "Wrap the point or region as a poem."
    (interactive)
    (jnf/tor-wrap-with-text
     :before "<pre class=\"poem\">\n"
     :after "\n</pre>"
     :strategy :pointOrRegion))

  (defun jnf/tor-wrap-date (date)
    "Wrap the point or region with the given DATE."
    (interactive (list (org-read-date nil nil nil "Date")))
    (jnf/tor-wrap-in-html-tag
     "time"
     (concat "datetime=\"" date "\" title=\"" date "\"")))

  (defun jnf/tor-wrap-as-marginnote-dwim ()
    "Wrap the line or current region as a marginnote Hugo shortcode."
    (interactive)
    (jnf/tor-wrap-with-text
     :before "{{< marginnote >}}\n"
     :after "\n{{< /marginnote >}}"
     :strategy :lineOrRegion))

  (defun jnf/tor-wrap-as-sidenote-dwim ()
    "Wrap the line or current region as a sidenote Hugo shortcode."
    (interactive)
    (jnf/tor-wrap-with-text
     :before "{{< sidenote >}}"
     :after "{{< /sidenote >}}"
     :strategy :sentenceOrRegion))

  (defun jnf/tor-wrap-link-active-region-dwim (url)
    "Wrap current region (or point) in an A-tag with the given URL.

  For the URL:

  - If `car' of `kill-ring' starts with \"http\", then use that as the URL.
  - Otherwise prompt for a URL.

  If the URL is an empty string, then send a message.  Else, if we
  have a non-0 length URL, use the URL and wrap the region in an A
  tag."
    (interactive (list (jnf/tor-prompt-or-kill-ring-for-url)))
    (if (eq (length url) 0)
	(message "No URL to use for A-tag creation")
      (jnf/tor-wrap-with-text
       :before (concat "<a href=\"" url "\">")
       :after "</a>"
       :strategy :pointOrRegion)))

  (defun jnf/tor-wrap-as-pseudo-dfn ()
    "Wrap current region (or word) in an I-tag with a DFN dom class."
    (interactive)
    (jnf/tor-wrap-with-text
     :before "<i class=\"dfn\">"
     :after "</i>"
     :strategy :wordOrRegion))

  (defun jnf/tor-wrap-cite-active-region-dwim (url)
    "Wrap current region (or point) in a CITE-tag and optional A-tag with URL.

  For the URL:

  - If `car' of `kill-ring' starts with \"http\", then use that as the URL.
  - Otherwise prompt for a URL.

  If the URL an empty string, then wrap the current region or point
  in a CITE tag. Else, if we have a non-0 length URL, wrap it in
  CITE and A tag."
    (interactive (list (jnf/tor-prompt-or-kill-ring-for-url)))

    ;; Were we to start writing at the START position, we'd invariably
    ;; change the contents such that the END position was no longer
    ;; accurate.  So instead, we append at the END position, hop back to
    ;; the START position and append to the START position.
    (if (eq (length url) 0)
	(jnf/tor-wrap-with-text
	 :before "<cite>"
	 :after "</cite >"
	 :strategy :pointOrRegion)
      (jnf/tor-wrap-with-text
       :before (concat "<cite><a href=\"" url
		       "\" class=\"u-url p-name\" rel=\"cite\">")
       :after "</a></cite>"
       :strategy :pointOrRegion)))
  ;;******************************************************************************
  ;;
  ;;; END Wrapping Functions
  ;;
  ;;******************************************************************************

#+end_src

** TODO forem specific

Provides some Forem specific shortcut tooling.

#+begin_src emacs-lisp
  (defun jnf/forem-tidy-pull-request ()
    "Perform some quick tidying of the Forem PR template."
    (interactive)
    ;; Start from the beginning.
    (beginning-of-buffer)

    ;; The text before the first HTML/Markdown
    ;; comments is the commit message.  Cut that
    ;; text...
    (search-forward "<!--")
    (kill-region 1 (- (point) 4))

    ;; ...and paste it inside the description
    ;; section.
    (replace-string
     "## Description\n\n"
     (concat "## Description\n\n"
	     (format "%s" (car kill-ring))))

    ;; We've moved point (e.g., the cursor) so let's
    ;; jump back to the beginning of the buffer.
    (beginning-of-buffer)

    ;; Remove HTML/Markdown comments
    (replace-regexp
     "\\(\n\\)*<!--\\(.\\|\n\\)*-->\\(\n\\)*"
     "")

    (beginning-of-buffer)

    ;; Clear out the text I almost always delete.
    ;;
    ;; This clears out the two or three line "please"!
    (replace-regexp ": _please.*\\(\n +.+\\)+_\n" ":\n")

    (beginning-of-buffer)

    ;; Clear out some comments.
    (replace-regexp "^\n_\\(If\\|Please\\|Will\\).*\\(\n.+\\)+_\n+" "\n")

    ;; Clean out the GIF section.  As much as I try
    ;; I just don't like adding GIFs to PRs
    (replace-regexp
     "\n## \\[optional\\] What gif\\(.\\)*\n+\\!.*"
     "")

    ;; Jump to the beginning of the buffer...again.
    (beginning-of-buffer))

  (global-set-key (kbd "C-M-s-f") 'jnf/forem-menu/body)
  (defvar jnf/forem-menu--title
    (jnf/all-the-icons--with-octicon "code" "Forem" 1 -0.05)
    "The Forem Subject Menu Title.")
  (pretty-hydra-define jnf/forem-menu (:foreign-keys warn :title jnf/forem-menu--title :quit-key "q" :exit t)
    ("Forem Workflow"
     (
      ("i" (lambda () (interactive) (browse-url "https://github.com/forem/forem/issues/")) "Browse to [i]ssues…")
      ("j" (lambda () (interactive) (browse-url "https://github.com/orgs/forem/projects/")) "Browse to pro[j]ects…")
      ("m" (lambda () (interactive) (browse-url "https://github.com/forem/forem/pulls?q=is%3Apr+is%3Aclosed")) "Browse [m]erged Pull Requests…")
      ("p" (lambda () (interactive) (browse-url "https://github.com/forem/forem/pulls/")) "Browse to pull requests…"))
     "Jeremy's Workflow"
     (
      ("I" (lambda () (interactive) (browse-url "https://github.com/forem/forem/issues/assigned/jeremyf")) "Browse to Jeremy's [I]ssues…")
      ("J" (lambda () (interactive) (browse-url "https://github.com/orgs/forem/projects/39")) "Browse to Content Experience pro[J]ects…")
      ("M" (lambda () (interactive) (browse-url "https://github.com/forem/forem/pulls/jeremyf?q=is%3Apr+is%3Aclosed")) "Browse Jeremy's [M]erged Pull Requests…")
      ("P" (lambda () (interactive) (browse-url "https://github.com/forem/forem/pulls/jeremyf")) "Browse to Jeremy's [P]ull requests…")
      ("N" (lambda () (interactive) (browse-url "https://github.com/notifications")) "Browse Github [N]otifications"))))

  (when (file-directory-p "~/git/org/forem")
    (progn
      (defconst jnf/forem-dashboard-filename
	"~/git/org/forem-dashboard.org"
	"The file to the dashboard documentation and links for Forem.")

      (cl-defun jnf/open-dashboard (&key (filename jnf/forem-dashboard-filename))
	"For the given FILENAME open the links in the default browser.

  With the universal prefix (e.g. C-u) open the file instead."
	(interactive)
	(if (equal current-prefix-arg nil) ; no C-u
	    (call-process-shell-command
	     (concat "rg \"\\[\\[(.*)\\]\\[\" "
		     filename
		     " --only-matching"
		     " | rg \"[^\\[|\\]]+\" --only-matching"
		     " | xargs open"))
	  (find-file filename)))

      (defun jnf/open-forem-todo ()
	"Open ~/git/org/forem/todo.org"
	(interactive)
	(find-file "~/git/org/forem/todo.org"))

      (defun jnf/open-forem-brag-book ()
	"Open forem brag book."
	(interactive)
	(find-file "~/git/org/forem/20211005---brag_book_for_jeremy_friesen.org"))

      (pretty-hydra-define+ jnf/forem-menu()
	("Org-Mode"
	 (
	  ("@" jnf/open-forem-todo "Open Forem Todo")
	  ("B" jnf/open-forem-brag-book "[B]rag book open…")
	  ("D" jnf/open-dashboard "[D]ashboard open…")
	  ("d" (lambda () (interactive) (find-file jnf/forem-dashboard-filename)) "Visit [d]ashboard file…"))))
      ))

#+end_src

** TODO jnf/eval-region-dwim()

#+begin_src emacs-lisp
  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'jnf/eval-region-dwim)
  (defun jnf/eval-region-dwim ()
    "When region is active, evaluate it and kill the mark. Else,
    evaluate the whole buffer."
    (interactive)
    (if (not (region-active-p))
	(progn
	  (message "Evaluating buffer...")
	  (eval-buffer))
      (progn
	(message "Evaluating region...")
	(eval-region (region-beginning) (region-end)))
      (setq-local deactivate-mark t)))
#+end_src

** TODO jnf/toggle-osx-alternate-modifier()

#+begin_src emacs-lisp

  ;; On  I use ⌘ as meta and prefer ⌥ to do nothing so I can still insert special characters easily.
  ;;
  ;; (setq mac-command-modifier 'meta
  ;;       mac-option-modifier 'none)

  ;; (setq mac-right-option-modifier nil) ;; Disable Emacs capturing meta-key and fall back to OS X (useful for diacritics)
  ;;
  ;; (setq mac-right-option-modifier 'meta) ;; Enable Emacs capturing meta-key, so right M-x will execute extended command


  (global-set-key (kbd "C-x /") 'jnf/toggle-osx-alternate-modifier)
  (defun jnf/toggle-osx-alternate-modifier ()
    "Toggle native OS-X Option modifier
  setting (e.g. ns-alternate-modifier)."
    (interactive)
    (if ns-alternate-modifier
	(progn (setq ns-alternate-modifier nil)
	       (message "Enabling OS X native Option modifier"))
      (progn (setq ns-alternate-modifier 'meta)
	     (message "Disabling OX X native Option modifier (e.g. Option as Meta)"))))
#+end_src

** TODO hammerspoon

#+begin_src emacs-lisp
  (when (file-directory-p
	 "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon")
    (load
     "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el"
     nil
     jnf-silence-loading-log))
#+end_src

** TODO help functions

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;; This file provides both a macro for generating quick-help and help buffers.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defmacro quick-help (name buffer text)
    "Macro for creating callable functions that display help.
  Where NAME is name of function, BUFFER is name of buffer, and TEXT is displayed."
    (declare (indent defun))
    `(progn
       (defun ,name nil
	 ,buffer
	 (interactive)
	 (let ((qh-buff (concat "*Quick Help: " ,buffer "*"))
	       (qh-text ,text))
	   (get-buffer-create qh-buff)
	   (with-current-buffer qh-buff
	     (insert qh-text)
	     (goto-char (point-min))
	     (not-modified)
	     (read-only-mode)
	     (special-mode)
	     ;; (local-set-key (kbd "C-g") (lambda () (interactive) (other-window -1)))
	     (local-set-key (kbd "q") 'kill-buffer-and-window))
	   (pop-to-buffer qh-buff '((display-buffer-below-selected)
				    (window-parameters . ((no-other-window . nil)))
				    (window-height . fit-window-to-buffer)))
	   (message "q - Remove Window")))))


  (cl-defmacro transient-quick-help (name buffer &key label body mode)
    "Macro for creating callable functions that display help.
  Where NAME is name of function, BUFFER is name of buffer, and TEXT is displayed."
    (declare (indent defun))
    `(progn
       (transient-define-suffix ,name nil
	 ,buffer
	 ;; :if-non-nil ,mode
	 :description ,label
	 (interactive)
	 (let ((qh-buff (concat "*Quick Help: " ,buffer "*"))
	       (qh-text ,body))
	   (get-buffer-create qh-buff)
	   (with-current-buffer qh-buff
	     (insert qh-text)
	     (goto-char (point-min))
	     (not-modified)
	     (read-only-mode)
	     (special-mode)
	     ;; (local-set-key (kbd "C-g") (lambda () (interactive) (other-window -1)))
	     (local-set-key (kbd "q") 'kill-buffer-and-window))
	   (pop-to-buffer qh-buff '((display-buffer-below-selected)
				    (window-parameters . ((no-other-window . nil)))
				    (window-height . fit-window-to-buffer)))
	   (message "q - Remove Window")))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; BEGIN Burning Wheel Gold Tables
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (transient-quick-help jnf/qh--bwg-wises
    "BWG Wises Obstacles (page 309)"
    :label "Wises"
    :mode 'jnf-bwg-minor-mode
    :body
    (concat
     "Common knowledge ............. Ob 1\n"
     "An interesting fact .......... Ob 2\n"
     "Details ...................... Ob 3\n"
     "Uncommon knowledge ........... Ob 4\n"
     "Rare goods ................... Ob 5\n"
     "Bizarre or obscure ........... Ob 7\n"
     "Freaky details or specifics .. Ob 8"))

  (transient-quick-help jnf/qh--bwg-expertise-exponent
    "BWG Expertise Exponent (page 12)"
    :label "Exponents"
    :mode 'jnf-bwg-minor-mode
    :body
    (concat
     "Exp 1  is naturally disinclined, crippled, or utterly incompetent.\n"
     "Exp 2  is untrained, raw, weak, or unpracticed.\n"
     "Exp 3  is nominally trained and practiced.\n"
     "Exp 4  is competent; everday stuff doesn't pose a challenge.\n"
     "Exp 5  is expert.\n"
     "Exp 6  is near mastery.\n"
     "Exp 7  is excellence.\n"
     "Exp 8  is total mastery, complete understanding.\n"
     "Exp 9  is uncanny; incomprehensibly good.\n"
     "Exp 10 is as near perfection as the system allows."))

  (transient-quick-help jnf/qh--bwg-absolute-difficulty
    "BWG Absolute Difficulty (page 15)"
    :label "Difficulty"
    :mode 'jnf-bwg-minor-mode
    :body
    (concat
     "Ob 1  A simple act done with little thought.\n"
     "Ob 2  An act performed routinely at your job.\n"
     "Ob 3  An act you can accomplish if you concentrate.\n"
     "Ob 4  A risky act.\n"
     "Ob 5  An act that requires expertise.\n"
     "Ob 6  An act that requires a heroic effort.\n"
     "Ob 7  An improbable feat.\n"
     "Ob 8  An act requiring preternatural ability or a lot of help.\n"
     "Ob 9  An act deemed nearly impossible.\n"
     "Ob 10 A miracle."))

  (transient-quick-help jnf/qh--bwg-circles-obstacles
    "BWG Circles Obstacles (page 380-381)"
    :label "Circles"
    :mode 'jnf-bwg-minor-mode
    :body
    (concat
     "Occupation\n"
     "  Broad occupation/profession, same life path ... +0 Ob\n"
     "  Uncommon occupation, or within same setting ... +2 Ob\n"
     "  Specific occupation, rare/unique occupation ... +3 Ob\n"
     "\n"
     "Station\n"
     "  Same station .................................. +0 Ob\n"
     "  Lower rank, station, or class ................. +1 Ob\n"
     "  Higher rank, station, or class ................ +2 Ob\n"
     "  Highest station or rank in the setting ........ +3 Ob\n"
     "\n"
     "Disposition and Knowledge\n"
     "  Common to circle .............................. +0 Ob\n"
     "  Different from circle members ................. +1-2 Ob\n"
     "  Specific, detailed, or rare ................... +3 Ob\n"
     "\n"
     "Time and Place\n"
     "  Doesn't matter ................................ +0 Ob\n"
     "  Unusual for this character .................... +1-2 Ob\n"
     "  Right here and now in the middle of trouble ... +3 Ob"))

  (transient-quick-help jnf/qh--bwg-steel-test-adjustments
    "BWG Steel Test Adjustments (page 363)"
    :label "Steel"
    :mode 'jnf-bwg-minor-mode
    :body
    (concat
     "Conditions for Steel Advantags\n"
     "  Being startled by something mundane ........ +2D\n"
     "  Feeling safe in a group of friends/allies .. +1D\n"
     "\n"
     "Conditions for Steel Disadvantages\n"
     "  Being shot at .............................. +1 Ob\n"
     "  Being directly affect by magic ............. +1 Ob\n"
     "  Witnessing a person killed ................. +1 Ob\n"
     "  Small explosions ........................... +2 Ob\n"
     "  Committing murder .......................... +2 Ob\n"
     "  Explosions ................................. +3 Ob\n"
     "  Witnessing pronounced sorcery at play ...... +3 Ob\n"
     "  Seeing a ghost ............................. +3 Ob\n"
     "  Seeing the living dead ..................... +4 Ob\n"
     "  Volcanic eruptions, cataclysm .............. +4 Ob\n"
     "  Seeing horrible magic at work .............. +4 Ob\n"
     "  Being in the presence of the supernatural .. +5 Ob\n"))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; END Burning Wheel Gold Tables
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src


** TODO Functions

- ~jnf/scroll-down-half-page~ :: See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/

#+begin_src emacs-lisp
  (global-set-key (kbd "M-n") 'jnf/scroll-down-half-page)
  (defun jnf/scroll-down-half-page ()
    "Scroll down half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) (move-to-window-line nil))
	    ((= ln lmax) (recenter (window-end)))
	    (t (progn
		 (move-to-window-line -1)
		 (recenter))))))
#+end_src

- ~jnf/scroll-up-half-page~ :: See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/

#+begin_src emacs-lisp

  (global-set-key (kbd "M-p") 'jnf/scroll-up-half-page)
  (defun jnf/scroll-up-half-page ()
    "Scroll up half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) nil)
	    ((= ln lmax) (move-to-window-line nil))
	    (t (progn
		 (move-to-window-line 0)
		 (recenter))))))
#+end_src

- ~jnf/dark~ :: Toggle from Dark to Light setting based on system preferences.

#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
      (progn
	(defun jnf/dark ()
	  "Toggle system-wide Dark or Light setting."
	  (interactive)
	  (shell-command "osascript -e 'tell application \"System Events\" to tell appearance preferences to set dark mode to not dark mode'")
	  (jnf/emacs-theme-by-osx-appearance))

	(defalias 'modus-themes-toggle 'jnf/dark)
	(defun jnf/emacs-theme-by-osx-appearance ()
	  "Set theme based on OSX apperance state."
	  (if (equal "Dark" (substring (shell-command-to-string "defaults read -g AppleInterfaceStyle") 0 4))
	      (load-theme 'modus-vivendi)
	    (load-theme 'modus-operandi)))
	(jnf/emacs-theme-by-osx-appearance))
    (progn
      (defun modus-themes-toggle ()
	"Toggle between `modus-operandi' and `modus-vivendi' themes."
	(interactive)
	(if (eq (car custom-enabled-themes) 'modus-operandi)
	    (load-theme 'modus-vivendi)
	  (load-theme 'modus-operandi)))
      (load-theme 'modus-operandi)))
#+end_src

*** TODO Window Layout Functions

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; BEGIN frame and window quick setup
  (defun gk-layouts-3col ()
    "Three column layout.

  Tries to preserve the order of window buffers and active window."
    (interactive)
    ;; Record active window buffer.
    (let ((cbuf (current-buffer)))
      ;; Switch to leftmost window.
      (ignore-errors (cl-loop do (windmove-left)))
      (let ((buffers
	     (mapcar #'window-buffer (-take 3 (window-list))))
	    (width (/ (frame-width) 3)))
	(delete-other-windows)
	(split-window-horizontally width)
	(other-window 1)
	(split-window-horizontally)
	(other-window -1)
	(dolist (b buffers)
	  (switch-to-buffer b)
	  (other-window 1)))
      ;; Switch to previously visible buffer’s window.
      (select-window (get-buffer-window cbuf))))


  (defun gk-layouts-main-and-sidekicks ()
    "One horizontal split, the right window split in two.

  Tries to preserve the order of window buffers and active window."
    (interactive)
    ;; Record active window buffer.
    (let ((cbuf (current-buffer)))
      ;; Switch to leftmost window.
      (ignore-errors (cl-loop do (windmove-left)))
      (let ((buffers
	     (mapcar #'window-buffer (-take 3 (window-list)))))
	(delete-other-windows)
	(split-window-horizontally)
	(other-window 1)
	(split-window-vertically)
	(other-window -1)
	(dolist (b buffers)
	  (switch-to-buffer b)
	  (other-window 1)))
      ;; Switch to previously visible buffer’s window.
      (select-window (get-buffer-window cbuf))))

  (bind-key "C-x \\" #'gk-layouts-main-and-sidekicks)
  ;; END frame and window quick setup
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src


* TODO Menus

** TODO jnf/menu-dwim
*** Minor Modes

In work and in play, there are several “me” specific contexts.  The
~jnf/minor-mode-maker~ macro helps me quickly and consistently make those
contexual minor modes.  My intention is to build out even more functions on
those modes.

#+begin_src emacs-lisp
  (cl-defmacro jnf/minor-mode-maker (&key title abbr hooks)
    "A macro to declare a minor mode.

  Use TITLE to derive the docstring.
  Use ABBR to derive the mode-name lighter.
  Add hook to each HOOKS provided."
    (let ((mode-name (intern (s-dashed-words (s-downcase (concat "jnf-" abbr "-minor-mode")))))
	  (lighter (concat " " abbr))
	  (docstring (concat "Minor mode for " title ".")))
      `(progn
	 (define-minor-mode ,mode-name
	   ,docstring
	   :global nil
	   :lighter ,lighter)
	 (when ,hooks
	   (-each ,hooks (lambda(hook) (add-hook hook (lambda () (,mode-name)))))))))

  (jnf/minor-mode-maker :title "Burning Wheel Gold"
			:abbr "bwg"
			:hooks (list 'org-mode-hook 'markdown-mode-hook))
  (jnf/minor-mode-maker :title "Take on Rules"
			:abbr "tor")
  (jnf/minor-mode-maker :title "Forem"
			:abbr "forem")
#+end_src

*** Org Capture Commands

Try as I may, based on my configuration, I can’t get [[https://orgmode.org/manual/Protocols.html#Protocols][org-protocol]] to work.  So
I’ve opted to take a different path; write some Emacs functions instead.

- ~jnf/org-roam-capture-ref~ :: Capture a “refs” context ~org-roam-node~ for the given title and url.
- ~jnf/menu-dwim--org-capture-elfeed-show~ :: Capture an RSS entry.
- ~jnf/menu-dwim--org-capture-firefox~ :: Capture the active tab of Firefox.
- ~jnf/menu-dwim--org-capture-safari~ :: Capture the active tab of Safari.

#+begin_src emacs-lisp
  (cl-defun jnf/org-roam-capture-ref (&key title url)
    "Capture the TITLE and URL in the `org-roam' :refs template"
    (org-roam-capture-
     :keys "r"
     ;; TODO: I would love to get tags working but I'm missing something
     :node (org-roam-node-create :title title)
     :info (list :ref url)
     :templates (jnf/org-roam-templates-list :refs)))

  (cl-defun jnf/menu-dwim--org-capture-elfeed-show (&key (entry elfeed-show-entry))
    "Create an `org-roam-node' from elfeed ENTRY."
    (interactive)
    (let ((url (elfeed-entry-link entry))
	  (title (elfeed-entry-title entry)))
      (jnf/org-roam-capture-ref :ref ref :title title)))

  (defun jnf/menu-dwim--org-capture-firefox ()
    "Create an `org-roam-node' from Firefox page.

    Depends on the `grab-mac-link' package."
    (interactive)
    (let* ((link-title-pair (grab-mac-link-firefox-1))
	   (url (car link-title-pair))
	   (title (cadr link-title-pair)))
      (jnf/org-roam-capture-ref :url url :title title)))

  (defun jnf/menu-dwim--org-capture-safari ()
    "Create an `org-roam-node' from Safari page.

    Depends on the `grab-mac-link' package."
    (interactive)
    (let* ((link-title-pair (grab-mac-link-safari-1))
	   (url (car link-title-pair))
	   (title (cadr link-title-pair)))
      (jnf/org-roam-capture-ref :url url :title title)))
#+end_src

*** TODO A Consistent Transient Menu

#+begin_src emacs-lisp
  (transient-define-prefix jnf/menu-dwim--bwg ()
    "Define the BWG help prefix."
    ["Burning Wheel"
     ("c" jnf/qh--bwg-circles-obstacles)
     ("d" jnf/qh--bwg-absolute-difficulty)
     ("e" jnf/qh--bwg-expertise-exponent)
     ("s" jnf/qh--bwg-steel-test-adjustments)
     ("w" jnf/qh--bwg-wises)
     ])

  (transient-define-prefix jnf/menu-dwim--tor ()
    "Define the Take on Rules menu."
    ["Take on Rules"
     ["Posts"
      :if-non-nil jnf-tor-minor-mode
      ("p r" "Re-title post…" jnf/tor-retitle-post)
      ("p t" "Tag post…" jnf/tor-tag-post :transient t)
      ("p v" "View post…" jnf/tor-view-blog-post)
      ]
     ["Find"
      ("f d" "in draft status…" jnf/tor-find-file-draft)
      ("f u" "by url…" jnf/tor-find-hugo-file-by-url)
      ("f f" "by filename…" jnf/tor-find-file)]
     ["Create"
      ("c a" "Amplify the Blogosphere…" jnf/tor-post-amplifying-the-blogosphere)
      ("c c" "Changelog entry…" jnf/tor-find-changelog-and-insert-entry)
      ("c e" "Epigraph entry…" jnf/tor-insert-epigraph-entry)
      ("c g" "Glossary entry…" jnf/tor-find-glossary-and-insert-entry)
      ("c p" "Post…" jnf/tor-create-post)
      ("c s" "Series…" jnf/tor-find-series-and-insert-entry)]
     ])

  (transient-define-prefix jnf/menu-dwim--hammerspoon ()
    "Define the Take on Rules find files prefix."
    ["Hammerspoon"
     :if-non-nil hammerspoon-edit-minor-mode
     ("m" "Toggle hammerspoon editor mode" hammerspoon-toggle-mode)
     ("p" "Tidy pull request" jnf/forem-tidy-pull-request)])

  (transient-define-suffix jnf/org-auto-tags--transient (tags)
    "Set the tags from minibuffer read"
    :description '(lambda ()
		    (concat
		     "Org Tags: "
		     (propertize
		      (format "%s" jnf/org-auto-tags--current-list)
		      'face 'transient-argument)))
    (interactive
     (list (completing-read-multiple "Tag(s): " (org-roam-tag-completions))))
    (setq jnf/org-auto-tags--current-list tags))

  (transient-define-prefix jnf/menu-dwim ()
    "Return a `transient' compliant list to apply to different transients."
    [["Markdown Utilities"
      ("k h" "Kill slug version of given heading…" jnf/kill-new-markdown-heading-as-slug :if-derived (or markdown-mode html-mode))
      ("w a" "A-tag at point or region…" jnf/tor-wrap-link-active-region-dwim  :if-derived (or markdown-mode html-mode))
      ("w c" "CITE-tag point or region…" jnf/tor-wrap-cite-active-region-dwim  :if-derived (or markdown-mode html-mode))
      ("w d" "DATETIME-tag point or region…" jnf/tor-wrap-date  :if-derived (or markdown-mode html-mode))
      ("w f" "Wrap word or region in pseudo-DFN…" jnf/tor-wrap-as-pseudo-dfn  :if-derived (or markdown-mode html-mode))
      ]
     [
      "" ;; Deliberate space for menu
      ("w m" "Margin-note line or region…" jnf/tor-wrap-as-marginnote-dwim  :if-derived (or markdown-mode html-mode))
      ("w p" "Wrap point or region as Poem…" jnf/tor-wrap-in-poem  :if-derived (or markdown-mode html-mode))
      ("w s" "Side-note sentence or region…" jnf/tor-wrap-as-sidenote-dwim  :if-derived (or markdown-mode html-mode))
      ("w w" "Wrap point or region in html…" jnf/tor-wrap-in-html-tag  :if-derived (or markdown-mode html-mode))
      ]]
    [["Contexts"
      ("-b" "Burning Wheel…"  jnf/menu-dwim--bwg)
      ("-f" "Forem…" jnf/forem-menu/body)
      ("-t" "TakeOnRules…" jnf/menu-dwim--tor)
      ("-h" "Hammerspoon…" jnf/menu-dwim--hammerspoon :if-non-nil hammerspoon-edit-minor-mode)
      ]
     ["Grab"
      ("g e" "Elfeed" jnf/menu-dwim--org-capture-elfeed-show :if-derived elfeed-show-mode)
      ("g f" "Firefox" jnf/menu-dwim--org-capture-firefox)
      ("g s" "Safari" jnf/menu-dwim--org-capture-safari)
      ;; ("g u" "URL")
      ]
     ["Jump to"
      ;; ("j a" "Agenda" ibuffer)
      ("j b" "Buffer" ibuffer)
      ("j g" "Global Mark" consult-global-mark)
      ("j m" "Mark" consult-mark)
      ]
     ["Modes"
      ;; I could write functions for these, but this is concise enough
      ("m t" "Typopunct ( )" typopunct-mode :if-nil typopunct-mode)
      ("m t" "Typopunct (*)" typopunct-mode :if-non-nil typopunct-mode)
      ("m o" "MacOS Native Option ( )" jnf/toggle-osx-alternate-modifier :if-non-nil ns-alternate-modifier)
      ("m o" "MacOS Native Option (*)" jnf/toggle-osx-alternate-modifier :if-nil ns-alternate-modifier)
      ]]
    [["Org Add-Ons"
      ("o c" "Context…" jnf/org-auto-tags--set-by-context :transient t)
      ("o t" "Add Org Tag…" org-roam-tag-add :if-derived org-mode)
      ("o r" "Add Org Ref…" org-roam-ref-add :if-derived org-mode)
      ("o s" jnf/org-auto-tags--transient :transient t)
      ]])

  (global-set-key (kbd "s-1") 'jnf/menu-dwim)
  (global-set-key (kbd "C-c m") 'jnf/menu-dwim)
#+end_src

* Footnotes

[fn:e-reboot] My alias is as follows: ~alias e-reboot='cd ~/git/dotemacs; git stash ; edaemon ; git stash pop ; git edit'~.

[fn:daemon] My [[https://codeberg.org/takeonrules/dotzshrc/src/ab8b781cbdddd2fdbe674e031436b7e9a8e8a024/README.org#L1][dotzshrc]] config has my ~$EDITOR~

[fn:ag] “Ag” is the chemical symbol for the Silver element.

# -*- org-insert-tilde-language: emacs-lisp; -*-
:PROPERTIES:
:ID:       82C14F1A-163D-4774-A27F-1D792495922A
:END:
:HUGO:
#+HUGO_FRONT_MATTER_FORMAT: yaml
#+HUGO_BASE_DIR: ~/git/takeonrules.source
#+HUGO_SECTION: posts/2022
:END:
#+TITLE: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :comments link
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+STARTUP: showall
#+OPTIONS: toc:3

* Introduction

On <2020-05-25> I wrote [[https://takeonrules.com/2020/05/25/principles-of-my-text-editor/][Principles of My Text Editor]].  I was exploring adopting
a new text editor, and wanted to ensure that I knew what I was looking for.
You know, “begin with the end in mind.”[fn:8]

I did not realize how inadequate I was in thinking about my text editor; but
that is a different tale.

When I first dove into Emacs, I looked into [[https://github.com/hlissner/doom-emacs][Doom]] and [[https://www.spacemacs.org][Spacemacs]].  However, in
doing that I got ahead of myself.  So I started with an empty ~init.el~ and
walked through the tutorial.

From that point forward, I committed to use Emacs as is and when I knew I
needed something, I’d look into how to do it.  The result?  A configuration
that is uniquely mine.

On <2022-02-01 Tue> I chose to begin extracting my the various ~*.el~ into a
[[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]] format.  As with all Emacs configurations, what follows is
a work in progress.

** Tips on Troubleshooting

As I migrated from my ~*.el~ configurations, I moved one ~.el~ file at a time.
With each move, I would restart my Emacs daemon[fn:5].  I went so far as
to write a ~e-reboot~ alias[fn:4].  So if I “messed up”, I could easily
recover and fix the files I broke.

In other words, when I’m working on extending my Emacs configuration, I tend to
favor a bisset approach.  Make a change, verify it, and commit.  This helps
insulate me from “getting to far ahead of myself.”  Along the way, I failed to
always apply that discipline.

** About the Current Structure

The current structure is carried over from my past structure.  As I was first
adopting Emacs, I spent time organizing the packages.  This organization is a
bit muddy, as I never quite established the nomenclature.

What I can say is the order may be important.  But I’ll be working to untangle
that.

Where feasible, I have tried to bind keys “close” to their utilization.  That
is to say, I often leverage the ~:bind~, ~:hook~, and ~:map~ keywords for
~use-package~.  But I’m not always consistent.

In the ~org-mode~ version, I’m making use of “TODO” indicators to help me track
what else I may need to do.  A node marked as “DONE” should be viewed as “I
don’t need to go back and amend any documentation in that part.  However, it
doesn’t mean I won’t put more things in that section.”

** Organizing the Ideas

I’ve thought quite a bit about how to organize this file.  How does one narrate
the intertwined concepts of a configuration that is an amalgamation of so many
other people’s work?

My approach is to think back to my experience with the tutorial.  How it walked
me through the concepts.  I also need to be mindful that as I introduce source
code concepts, they are evaluated in that order.

** Conventions

I’ve written quite a few functions to further extend the utility of Emacs.  I
try to prefix them with ~jf/~.  And if I cribbed those functions from
elsewhere, I attempt to give credit to the source.

* Into the Emacs

** Launching Emacs

As we get started in Emacs, I want to make sure I have the basics lined up.

- Core Configuration
- Basic Theming

*** Core Configuration

#+begin_src emacs-lisp
  ;;; BEGIN Core Configuration
  ;; I have chosen to adopt \"straight.el\" for my package management.  The fact
  ;; that it seamlessly works with `use-package' has help me keep my code more
  ;; organized.
  ;;
  ;; https://www.reddit.com/r/emacs/comments/mtb05k/emacs_init_time_decreased_65_after_i_realized_the/
  (setq straight-check-for-modifications '(check-on-save find-when-checking))

  ;; This preamble is part of straight-use-package My understanding, in
  ;; reading straight documentation is that it has better load
  ;; times. However, the configuration options I often see leverage
  ;; "use-package" which is why most of my package declarations look as
  ;; they do.
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file))

  (setq straight-repository-branch "develop")
  (straight-use-package 'use-package)

  ;; https://xenodium.com/trying-out-gccemacs-on-macos/
  (use-package exec-path-from-shell
    :straight t
    :config
    (exec-path-from-shell-initialize)
    (if (and (fboundp 'native-comp-available-p)
             (native-comp-available-p))
        (progn
          (message "Native comp is available")
          ;; Using Emacs.app/Contents/MacOS/bin since it was compiled with
          ;; ./configure --prefix="$PWD/nextstep/Emacs.app/Contents/MacOS"
          (add-to-list 'exec-path (concat invocation-directory "bin") t)
          (setenv "LIBRARY_PATH" (concat (getenv "LIBRARY_PATH")
                                         (when (getenv "LIBRARY_PATH")
                                           ":")
                                         ;; This is where Homebrew puts gcc libraries.
                                         (car (file-expand-wildcards
                                               "/opt/homebrew/lib/gcc/*"))))
          ;; Only set after LIBRARY_PATH can find gcc libraries.
          (setq comp-deferred-compilation t))
      (message "Native comp is *not* available")))

  ;; These are some general configurations that I’ve slowly accumulated.  There’s
  ;; inline documentation in most cases.  There might be little bits worth
  ;; teasing out but for the most part, you can move along and reference this
  ;; later.

  (setq user-full-name "Jeremy Friesen"
        user-mail-address "jeremy@jeremyfriesen.com")

  (defconst jf/silence-loading-log t
    "When t log to stdout load messages from this configuration.

       In a previous iteration, I loaded lots of separate '*.el' files.
       This flag allowed me to more easily troubleshoot those load
       attempts.")

  (defconst jf/github-username "jeremyf"
    "My username on github.")

  (global-so-long-mode) ;; Handle long files.
  (electric-pair-mode)  ;; https://blog.sumtypeofway.com/posts/emacs-config.html
  (make-directory "~/.emacs.d/autosaves/" t) ;; Ensuring I have an autosave
  ;; directory.
  (recentf-mode 1) ;; Track recent
  (run-at-time nil (* 2 60) 'recentf-save-list) ;; Save files every 2 minutes
  (global-auto-revert-mode)

  (setq-default fill-column 79)   ;; Feeling a bit old school with 80 characters.
  (setq-default cursor-type 'bar) ;; Doing a bit of configuration of my cursors
  (blink-cursor-mode t)

  (setq
   backup-by-copying t         ;; Don't delink hardlinks

   backup-directory-alist '((".*" . "~/.emacs.d/backups/"))

   bookmark-default-file "~/git/emacs-bookmarks/bookmarks"

   custom-safe-themes t        ;; I may as well trust themes.

   create-lockfiles nil        ;; Don't create lock files.

   delete-old-versions t       ;; Automatically delete excess backups

   echo-key-strokes 0.2

   global-mark-ring-max 32

   idle-update-delay 1.1       ;; Slow down the UI being updated to improve
   ;; performance

   indent-tabs-mode nil        ;; Ensure tabs are expanded, not inserted

   inhibit-startup-screen t    ;; Don't include the  emacs "start" window

   kept-new-versions 20        ;; how many of the newest versions to keep

   kept-old-versions 5         ;; and how many of the old

   kill-ring-max 120           ;; Set a generous kill ring size.

   read-process-output-max (* 6 512 1024)  ;; Increase read size per process

   recentf-max-menu-items 50

   recentf-max-saved-items 50

   ring-bell-function 'ignore  ;; Stop ringing any bell

   ;; switch-to-buffer-obey-display-actions t ;; https://www.masteringemacs.org/article/demystifying-emacs-window-manager

   split-width-threshold nil ;; 160 * 8

   split-height-threshold nil ;; 160 * 8

   vc-follow-symlinks t        ;; Follow symlinks instead of prompting.

   version-control t           ;; Use version numbers on backups

   x-underline-at-descent-line t ;; Recommendation from
   ;; https://protesilaos.com/emacs/modus-themes

   ns-right-command-modifier 'hyper ;; Exposing one additional modifier key.
   )

  ;; I vascilate between yes and no; but invariably find myself stuck in a
  ;; recursed buffer.
  (setq enable-recursive-minibuffers t)
  (use-package recursion-indicator
    :straight t
    :config
    (recursion-indicator-mode))


  (global-hl-line-mode)


  ;; When you open Emacs, grab all the space on the screen
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))

  (tool-bar-mode -1) ;; Hide the icons of the Emacs toolbar
  (scroll-bar-mode -1) ;; Hide the scroll bar. Let's be clear, I don't use it.
  (defalias 'yes-or-no-p 'y-or-n-p) ;; Always "y" or "n" for yes/no

  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

  (add-function :after after-focus-change-function
                (defun jf/garbage-collect-maybe ()
                  (unless (frame-focus-state)
                    (garbage-collect))))

  ;; And I’m going to disable a few key bindings.  These were always messing me
  ;; up a bit.  Also enable a few that I find helpful.  (I’ll enable a lot more
  ;; later).
  (unbind-key "C-z") ;; `suspend-frame'
  (unbind-key "C-c o") ;; was bound to open a file externally
  (unbind-key "C-x C-c") ;; was `save-buffers-kill-terminal'

  (global-set-key (kbd "<M-delete>") 'kill-word)
  (global-set-key (kbd "<s-down>") 'end-of-buffer)
  (global-set-key (kbd "<s-up>") 'beginning-of-buffer)
  (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
  (global-set-key (kbd "s-w") 'kill-current-buffer)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "M-RET") 'newline-and-indent)

  ;; provides a means of not displaying the :lighter of a minor mode in the
  ;; modeline.
  (use-package diminish
    :straight t
    :diminish 'eldoc-mode
    :diminish 'abbrev-mode)

  ;; *Gcmh* does garbage collection (GC) when the user is idle.
  (use-package gcmh
    :straight t
    :diminish 'gcmh-mode
    :init
    (setq gcmh-idle-delay 5
          gcmh-high-cons-threshold (* 16 1024 1024))  ; 16mb
    :config (gcmh-mode))
  ;;; END Core Configuration

  (cl-defmacro jf/minor-mode-maker (&key title abbr hooks keymap)
    "A macro to declare a minor mode.

  Use TITLE to derive the docstring.
  Use ABBR to derive the mode-name lighter.
  Add hook to each HOOKS provided."
    (let ((mode-name (intern (s-downcase (concat "jf/" abbr "-minor-mode"))))
          (lighter (concat " " abbr))
          (docstring (concat "Minor mode for " title ".")))
      `(progn
         (define-minor-mode ,mode-name
           ,docstring
           :init-value nil
           :global nil
           :keymap ,keymap
           :lighter ,lighter)
         (when ,hooks
           (-each ,hooks (lambda(hook) (add-hook hook (lambda () (,mode-name)))))))))
#+end_src


*** Basic Theming

I want to start with a basic look and feel.  First, the choice of primary font.

#+begin_src emacs-lisp
  (require 'jf-windows)

  ;; Useful for referential icons.
  (use-package all-the-icons
    :straight t
    :config
    (cl-defmacro jf/all-the-icons--with(&key name)
      "A macro to provide functions for icon names."
      (let ((defun-fn (intern (concat "jf/all-the-icons--with-" name)))
            (icon-fn (intern (concat "all-the-icons-" name)))
            (docstring (concat "Displays an ICON from `all-the-icons-" name "'.")))
        `(defun ,defun-fn (icon str &optional height v-adjust)
           ,docstring
           (s-concat (,icon-fn
                      icon
                      :v-adjust (or v-adjust 0)
                      :height (or height 1))
                     " " str))))
    (jf/all-the-icons--with :name "faicon")
    (jf/all-the-icons--with :name "material")
    (jf/all-the-icons--with :name "octicon")
    (jf/all-the-icons--with :name "alltheicon"))

  ;; Incorporates file icons with file listings of dired.  /Note/: On 2021-04-11
  ;; I was getting the following error with this package: "*ERROR*: Symbol's
  ;; value as variable is void: file"
  (use-package all-the-icons-dired
    :straight t
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

*** Tabs

#+begin_src emacs-lisp
  ;; (org-babel-load-file
  ;;  (concat user-emacs-directory "emacs-tabs.org"))
#+end_src

** How Does this Thing Work?

In this section my goal is to load some “fundamental” packages that help me
better introspect and navigate Emacs.

With the initial “setup” out of the way, let’s dive into how things work.

I want to make it easy to find help on different aspects of Emacs.  There’s
tooling baked into Emacs, but the ~helpful~ package “provides much more
contextual information.”

Futhermore, I want to make a menu to help remind me of the help I have
available.  In previous incarnations I’ve written these menus using
[[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][pretty-hydra]], but I’ve started moving these to [[https://github.com/magit/transient/tree/440a341831398b825dc2288a10821cf7be1999ca][transient]]; a package that’s a
hard requirement for packages I’ll later introduce.


#+begin_src emacs-lisp
  (use-package helpful
    :init
    (use-package transient :straight t)
    ;; I'm going to talk about this later, but I'm adding this to the menu, so I
    ;; may as well state the dependency.
    (use-package embark :straight t)
    :straight t
    :config
    (transient-define-prefix jf/helpful-menu ()
      "Return a `transient' compliant list to apply to different transients."
      ["Help"
       ""
       ("Q" "Kill Helpful Buffers" helpful-kill-buffers)
       ""
       ("b" "Bindings" embark-bindings)
       ("c" "Command" helpful-command)
       ("f" "Function (interactive)" helpful-callable)
       ("F" "Function (all)" helpful-function)
       ("k" "Key" helpful-key)
       ("l" "Library" find-library)
       ("m" "Macro" helpful-macro)
       ("p" "Thing at point" helpful-at-point)
       ("." "Thing at point" helpful-at-point)
       ("t" "Text properties" describe-text-properties)
       ("v" "Variable" helpful-variable)])
    :bind ("H-h" . jf/helpful-menu)
    ("C-s-h" . jf/helpful-menu))

  (use-package which-key
    :straight t
    :diminish 'which-key-mode
    :custom
    (which-key-side-window-max-width 70)
    (which-key-min-column-description-width 50)
    (which-key-max-description-length 50)
    :config
    (which-key-mode)
    (which-key-setup-side-window-right)
    (which-key-show-major-mode))

  (use-package embark
    :straight t
    :bind
    (("C-." . embark-act)       ;; pick some comfortable binding
     ("M-." . embark-dwim)
     ("C-s-e" . embark-export)
     ("H-e" . embark-export)
     ("C-h b" . embark-bindings))
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    (setq embark-action-indicator
	  (lambda (map &optional _target)
	    (which-key--show-keymap "Embark" map nil nil 'no-paging)
	    #'which-key--hide-popup-ignore-command)
	  embark-become-indicator embark-action-indicator)
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))
#+end_src

** Writing, Coding, Computering

*** Projects

- ~projectile.el~ :: this package provides convenient organization and commands to run over projects.

#+begin_src emacs-lisp
  ;; Convenient organization and commands
  (use-package projectile
    :straight t
    :diminish 'projectile-mode
    :config (projectile-mode 1)
    :custom (projectile-project-search-path '("~/git/"))
    :bind ("s-." . projectile-toggle-between-implementation-and-test))
#+end_src

/Note:/ The =CMD= + =.= is a carryover from my [[https://macromates.com][Textmate]] and [[https://www.sublimetext.com/][Sublime Text]] days.
That’s one of those hot-keys almost burned into soul.

*** Support Packages

When I start writing functions, there’s a few packages I want to consider.

- ~keychain-environment.el~ :: Load keychain environment variables

#+begin_src emacs-lisp
  ;;; Support packages

  ;; Load keychain environment
  (use-package keychain-environment
    :straight t
    :config (keychain-refresh-environment))

  ;; A modern list API for Emacs. No 'cl required.  (See https://github.com/magnars/dash.el/)
  (use-package dash :straight t)

  ;; A modern API for working with files and directories in Emacs. (See https://github.com/rejeep/f.el/)
  (use-package f :straight t)

  ;; The long lost Emacs string manipulation library.  (See https://github.com/magnars/s.el/)
  (use-package s :straight t)

  ;; “EditorConfig helps maintain consistent coding styles for multiple
  ;; developers working on the same project across various editors and IDEs.”
  ;; See https://editorconfig.org/#overview for more details.
  (use-package editorconfig
    :straight t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))

  (use-package rg
    :config (rg-enable-menu)
    ;; :init (setq ripgrep-arguments "--ignore-case")
    :straight t)
#+end_src

*** Completion

**** Emacs Adjustments for Completion

What follows is adjustments to emacs settings as they relate to completion.

#+begin_src emacs-lisp
  (use-package emacs
    :init

    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
    (setq read-extended-command-predicate
          #'command-completion-default-include-p)

    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)

    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    ;; With adjustments from https://git.sr.ht/~protesilaos/dotfiles/tree/master/item/emacs/.emacs.d/prot-emacs-modules/prot-emacs-completion.el
    (defun crm-indicator (args)
      (cons (format "[%s %s] %s"
                    (propertize "CRM" 'face 'error)
                    (propertize
                     (replace-regexp-in-string
                      "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                      crm-separator)
                     'face 'success)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))

  (use-package vertico
    :straight t
    :config
    (vertico-mode)
    ;; Use `consult-completion-in-region' if Vertico is enabled.
    ;; Otherwise use the default `completion--in-region' function.
    (setq completion-in-region-function
          (lambda (&rest args)
            (apply (if vertico-mode
                       #'consult-completion-in-region
                     #'completion--in-region)
                   args)))
    (setq read-file-name-completion-ignore-case t
          read-buffer-completion-ignore-case t
          completion-ignore-case t)
    (setq vertico-cycle t))

  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-indexed.elc"
        nil
        jf/silence-loading-log)
  (vertico-indexed-mode)

  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-repeat.elc"
        nil
        jf/silence-loading-log)
  (global-set-key (kbd "M-r") #'vertico-repeat)
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
  (savehist-mode 1)

  (use-package marginalia
    :straight t
    :config (setq marginalia-max-relative-age 0) ;; Set absolute value
    ;; /Note:/ The declaration of `marginalia-mode' must be in the :init
    ;; section.This ensures that it is enabled right away.  It also forces the
    ;; loading of the package.
    :init (marginalia-mode))

  (use-package consult
    :straight t
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c h" . consult-history)
           ;; ("C-c m" . consult-mode-command)
           ("C-c b" . consult-bookmark)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complet-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("s-b" . consult-buffer)                ;; orig. switch-to-buffer
           ("s-r" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-s-b" . consult-buffer-other-window)
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("M-`" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-from-kill-ring)                ;; orig. yank-pop
           ("<help> a" . consult-apropos)            ;; orig. apropos-command
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("s-l" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("C-x C-SPC" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("s-2" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s f" . consult-find)
           ("M-s L" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("C-c f" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Customizations that map to ivy
           ("C-c r" . consult-recent-file)
           ;; ("C-c o" . consult-file-externally)
           ("C-y" . yank)
           ("C-s" . consult-line) ;; I've long favored Swiper mapped to c-s
           ;; Isearch integration
           ("M-s e" . consult-isearch)
           :map isearch-mode-map
           ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
           ("M-s l" . consult-line))                 ;; required by consult-line to detect isearch

    ;; The :init configuration is always executed (Not lazy)
    :init



    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Updating the default to include "--smart-case"
    ;; Leveraging ripgrep-all https://github.com/phiresky/ripgrep-all
    (setq consult-ripgrep-command "rga --null --line-buffered --color=ansi --max-columns=1000 --smart-case --no-heading --line-number --no-ignore-vcs . -e ARG OPTS")
    (setq consult-ripgrep-args "rga --null --line-buffered --color=never --max-columns=1000 --path-separator / --no-ignore-vcs --smart-case --no-heading --line-number .")

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config
    (consult-customize consult-theme :preview-key '(:debounce 0.5 any))
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root)

    (defun jf/consult-first-param-is-initial-text (consult-fn &rest rest)
      "Advising function around CONSULT-FN.

  The CONSULT-FN's first parameter should be the initial text.

  When there's an active region, use that as the first parameter
  for CONSULT-FN.  Otherwise, use an empty string the first
  parameter.  This function handles the REST of the parameters."
      (interactive)
      (apply consult-fn
             (when (use-region-p)
               (buffer-substring
                (region-beginning) (region-end)))
             rest))

    (defun jf/consult-ripgrep-wrapper (consult-fn &optional dir given-initial)
      "Advising function around CONSULT-FN.

  DIR and GIVEN-INITIAL match the method signature of `consult-wrapper'."
      (interactive "P")
      (let ((initial (list (or given-initial
                               (when (use-region-p)
                                 (buffer-substring (region-beginning) (region-end)))))))
        (apply consult-fn dir initial)))

    (advice-add #'consult-line
                :around #'jf/consult-first-param-is-initial-text
                '((name . "wrapper")))
    (advice-add #'consult-ripgrep
                :around #'jf/consult-ripgrep-wrapper
                '((name . "wrapper")))
    )

  ;; Add adding a small delay to consult preview; this improves the UI just a bit.


  ;; This package helps ease traveling across directories by providing directory
  ;; candidates related to current buffers, bookmarks, and projects.  Further,
  ;; like other ~consult.el~ functions, you can use narrowing keys.  See
  ;; https://github.com/karthink/consult-dir.
  (use-package consult-dir
    :straight t
    :after (consult)
    :bind (("C-x C-d" . consult-dir)
           :map minibuffer-local-completion-map
           ("C-x C-d" . consult-dir)
           ("C-x C-j" . consult-dir-jump-file)))

  ;; package provides a function I use everyday: ~M-x consult-projectile~.  When
  ;; I invoke ~consult-projectile~, I have the file completion for the current
  ;; project.  I can also type =b= + =SPACE= to narrow my initial search to open
  ;; buffers in the project.  Or =p= + =space= to narrow to other projects; and
  ;; then select a file within that project.
  (use-package consult-projectile
    :commands (consult-projectile)
    :straight (consult-projectile
               :type git
               :host gitlab
               :repo "OlMon/consult-projectile"
               :branch "master")
    :bind
    ;;; This overwrite `ns-open-file-using-panel'; the operating system's "Finder"
    ("s-o" . consult-projectile)
    ;;; I have long had Cmd+t mapped to opening project files; however, I'm
    ;;; noticing the way I'm typing this and it is feeling wrong.  So now I won't
    ;;; have that way open.
    ("s-t" . consult-projectile)
    ("s-p" . consult-projectile))

  (use-package consult-yasnippet
    :straight t
    :after (consult yasnippet)
    :bind ("C-c y" . consult-yasnippet))

  ;; I use ~embark.el~ and ~consult.el~, let’s add a little bit more connective
  ;;  tissue.
  (use-package embark-consult
    :straight t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook

    (embark-collect-mode . consult-preview-at-point-mode)
    (embark-collect-mode . embark-consult-preview-minor-mode))

  (use-package corfu
    :straight t
    :demand t
    ;; Optionally use TAB for cycling, default is `corfu-complete'.
    :bind (:map corfu-map
                ("M-m" . corfu-move-to-minibuffer)
                ("<escape>". corfu-quit)
                ("<return>" . corfu-insert)
                ("M-d" . corfu-show-documentation)
                ("M-l" . 'corfu-show-location)
                ("TAB" . corfu-next)
                ([tab] . corfu-next)
                ("S-TAB" . corfu-previous)
                ([backtab] . corfu-previous))

    :custom
    ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
    ;; want to perform completion
    (tab-always-indent 'complete)
    (completion-cycle-threshold nil)      ; Always show candidates in menu

    (corfu-auto nil)
    (corfu-auto-prefix 2)
    (corfu-auto-delay 0.25)

    ;; (corfu-min-width 80)
    ;; (corfu-max-width corfu-min-width)     ; Always have the same width
    (corfu-count 14)
    (corfu-scroll-margin 4)
    (corfu-cycle nil)

    ;; (corfu-echo-documentation nil)        ; Already use corfu-doc
    (corfu-separator ?\s)                 ; Necessary for use with orderless
    (corfu-quit-no-match 'separator)

    (corfu-preview-current 'insert)       ; Preview current candidate?
    (corfu-preselect-first t)             ; Preselect first candidate?
    :config
    (defun corfu-move-to-minibuffer ()
      "Move \"popup\" completion candidates to minibuffer.

  Useful if you want a more robust view into the recommend candidates."
      (interactive)
      (let (completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))

    :init
    ;; Recommended: Enable Corfu globally.
    ;; This is recommended since dabbrev can be used globally (M-/).
    (global-corfu-mode))

  (use-package kind-icon
    :straight t
    :after corfu
    :custom
    (kind-icon-use-icons t)
    (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face background
    (kind-icon-blend-background nil)  ; Use midpoint color between foreground and background colors ("blended")?
    (kind-icon-blend-frac 0.08)

    ;; NOTE 2022-02-05: `kind-icon' depends `svg-lib' which creates a cache
    ;; directory that defaults to the `user-emacs-directory'. Here, I change that
    ;; directory to a location appropriate to `no-littering' conventions, a
    ;; package which moves directories of other packages to sane locations.
    ;; (svg-lib-icons-dir (no-littering-expand-var-file-name "svg-lib/cache/")) ; Change cache dir
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter) ; Enable `kind-icon'

    ;; Add hook to reset cache so the icon colors match my theme
    ;; NOTE 2022-02-05: This is a hook which resets the cache whenever I switch
    ;; the theme using my custom defined command for switching themes. If I don't
    ;; do this, then the backgound color will remain the same, meaning it will not
    ;; match the background color corresponding to the current theme. Important
    ;; since I have a light theme and dark theme I switch between. This has no
    ;; function unless you use something similar
    (add-hook 'kb/themes-hooks #'(lambda () (interactive) (kind-icon-reset-cache))))

  (use-package corfu-doc
    ;; NOTE 2022-02-05: At the time of writing, `corfu-doc' is not yet on melpa
    :straight (corfu-doc :type git :host github :repo "galeo/corfu-doc")
    :bind (:map corfu-map
                ;; This is a manual toggle for the documentation window.
                ([remap corfu-show-documentation] . corfu-doc-toggle) ; Remap the default doc command
                ;; Scroll in the documentation window
                ("M-n" . corfu-doc-scroll-up)
                ("M-p" . corfu-doc-scroll-down))
    :hook (corfu-mode . corfu-doc-mode)
    :custom
    (corfu-doc-delay 0.1)
    (corfu-doc-hide-threshold 10)
    (corfu-doc-max-width 60)
    (corfu-doc-max-height 10)

    ;; NOTE 2022-02-05: I've also set this in the `corfu' use-package to be
    ;; extra-safe that this is set when corfu-doc is loaded. I do not want
    ;; documentation shown in both the echo area and in the `corfu-doc' popup.
    ;; (corfu-echo-documentation nil)
    :config
    ;; NOTE 2022-02-05: This is optional. Enabling the mode means that every corfu
    ;; popup will have corfu-doc already enabled. This isn't desirable for me
    ;; since (i) most of the time I do not need to see the documentation and (ii)
    ;; when scrolling through many candidates, corfu-doc makes the corfu popup
    ;; considerably laggy when there are many candidates. Instead, I rely on
    ;; manual toggling via `corfu-doc-toggle'.
    (corfu-doc-mode))

  ;; The https://github.com/minad/orderless package provides completion tooling
  ;; for non-strict word order.  I spent considerable time reading through the
  ;; https://github.com/minad/consult/wiki
  ;;
  ;; As configured the orderless completion recognizes the following “switches”:
  ;;
  ;; - Flex (~\~~) :: Just start typing characters and you’ll get matches that have
  ;;   those characters
  ;; - File Extension (~\.ext~) :: Match files with this extension.
  ;; - Regexp ~^.$~ :: Use some regular expression syntax
  ;;   - ~^~ matching beginning
  ;;   - ~.~ any ol’ character
  ;;   - ~$~ matching ending
  ;; - Initialism (~`~) :: In ~M-x~ when I typed ~`pl~ the ~previous-line~ function
  ;;   was a top match.  The initialism switch “explodes” the characters and says
  ;;   match methods who’s words start with those characters.
  ;; - Not Literal ~!~ :: Exclude candidates that match the literal
  ;;   (e.g. ~!previous~ won’t show ~previous-line~ in the ~M-x~ completion).
  ;; - Literal ~=~ :: No “fuzzy buziness”, just match exactly what I typed.
  ;;
  ;; There is another case (e.g. ~%~ character fold) that I don’t yet understand.
  (use-package orderless
    :straight t
    :config
    (defvar +orderless-dispatch-alist
      '((?% . char-fold-to-regexp)
        (?! . orderless-without-literal)
        (?`. orderless-initialism)
        (?= . orderless-literal)
        (?~ . orderless-flex)))
    (defun +orderless-dispatch (pattern index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" pattern)
        `(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x100000-\x10FFFD]*$")))
       ;; File extensions
       ((and
         ;; Completing filename or eshell
         (or minibuffer-completing-file-name
             (derived-mode-p 'eshell-mode))
         ;; File extension
         (string-match-p "\\`\\.." pattern))
        `(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x100000-\x10FFFD]*$")))
       ;; Ignore single !
       ((string= "!" pattern) `(orderless-literal . ""))
       ;; Prefix and suffix
       ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
            (cons (cdr x) (substring pattern 1))
          (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
            (cons (cdr x) (substring pattern 0 -1)))))))

    ;; Define orderless style with initialism by default
    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

    ;; Certain dynamic completion tables (completion-table-dynamic)
    ;; do not work properly with orderless. One can add basic as a fallback.
    ;; Basic will only be used when orderless fails, which happens only for
    ;; these special tables.
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
            ;;; Enable partial-completion for files.
            ;;; Either give orderless precedence or partial-completion.
            ;;; Note that completion-category-overrides is not really an override,
            ;;; but rather prepended to the default completion-styles.
          ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
          completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
                                          ;; enable initialism by default for symbols
                                          (command (styles +orderless-with-initialism))
                                          (variable (styles +orderless-with-initialism))
                                          (symbol (styles +orderless-with-initialism)))
          orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
          orderless-style-dispatchers '(+orderless-dispatch)))

  (use-package cape
    :straight t
    :init (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    :bind (("C-c p d" . cape-dabbrev)
           ("C-c p f" . cape-file)
           ("C-c p s" . cape-symbol)
           ("C-c p i" . cape-ispell)))
#+end_src

#+RESULTS:
: cape-ispell

**** wgrep.el

- ~wgrep.el~ ::


   I use this sequence at least once a day.

#+begin_src emacs-lisp
  ;; “Edit a grep buffer and apply those changes to the file buffer.”  In other
  ;; words, after “searching” for something, sending the results to a buffer
  ;; (via `embark-export' or such thing), you can edit that search results
  ;; buffer and propogate the changes to the locations of the elements that
  ;; matched the search.
  ;;
  ;;   1.  Call `consult-ripgrep' (via ~C-c f~) to search for something.
  ;;   2.  Call `embark-export' (via ~C-s-e~) to export to a grep buffer.
  ;;   3.  Call `wgrep-change-to-wgrep-mode' (via ~e~ or ~C-c C-p~)
  ;;   4.  Edit the grep buffer as you would anywhere else.
  ;;   5.  Save (via ~C-x C-s~) or Cancel (via ~C-c C-k~).
  (use-package wgrep
    :after (embark-consult ripgrep)
    :straight t
    :bind (:map wgrep-mode-map
		;; Added keybinding to echo Magit behavior
		("C-c C-c" . wgrep-finish-edit)
		:map grep-mode-map
		("e" . wgrep-change-to-wgrep-mode)
		:map ripgrep-search-mode-map
		("e" . wgrep-change-to-wgrep-mode)))
#+end_src

**** yasnippet.el

- ~yasnippet.el~ :: A rather convenient snippet manager.  When you create a
  snippet, it understands the mode you're in and puts the snippet in the right
  place.

#+begin_src emacs-lisp
  (use-package yasnippet
    :straight t
    :diminish 'yas-minor-mode
    :init
    (setq yas-snippet-dirs '("~/git/dotemacs/snippets"))
    (yas-global-mode 1))

  (use-package tempel
    :straight (tempel :host github :repo "minad/tempel")
    :custom (tempel-path "~/git/dotemacs/templates")
    :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
	   ("M-*" . tempel-insert))

    :init

    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'. `tempel-expand'
      ;; only triggers on exact matches. Alternatively use `tempel-complete' if
      ;; you want to see all matches, but then Tempel will probably trigger too
      ;; often when you don't expect it.
      ;; NOTE: We add `tempel-expand' *before* the main programming mode Capf,
      ;; such that it will be tried first.
      (setq-local completion-at-point-functions
		  (cons #'tempel-expand
			completion-at-point-functions)))

    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)

    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
    ;; (tempel-global-abbrev-mode)
    )

  (tempel-key "C-c i" idiomatic org-mode-map)
#+end_src

*** Navigation
**** avy.el

#+begin_src emacs-lisp
  ;;; Navigation
  ;;
  ;; Pick a letter, avy finds all words with that at the beginning of it.  Narrow
  ;; results from there.
  (use-package avy
    :bind (("C-c j" . avy-goto-char))
    :straight t)

  (use-package link-hint
    :straight t
    :bind
    ("C-c l o" . link-hint-open-link)
    ("C-c l c" . link-hint-copy-link))

  (use-package imenu-list
    :custom (imenu-list-focus-after-activation t)
    (imenu-list-size 0.4)
    (imenu-list-position 'right)
    :bind ("s-4" . 'imenu-list-smart-toggle)
    :bind (:map imenu-list-major-mode-map ("o" . 'imenu-list-goto-entry))
    :straight t)
#+end_src

**** Extending the Mark

*** Display

**** highlight-indent-guides.el

#+begin_src emacs-lisp
  ;; provides column highlighting.  Useful when you start seeing too many nested
  ;; layers.
  (use-package highlight-indent-guides
    :straight t
    :custom (highlight-indent-guides-method 'character)
    (highlight-indent-guides-responsive 'top)
    :hook (prog-mode . highlight-indent-guides-mode))

  ;;  “LIN locally remaps the hl-line face to a style that is optimal for major
  ;;  modes where line selection is the primary mode of interaction.”  In
  ;;  otherwords, ~lin.el~ improves the highlighted line behavior for the
  ;;  competing contexts.
  (use-package lin
    :straight (lin :host gitlab :repo "protesilaos/lin")
    :config (lin-global-mode 1)
    (setq lin-face 'lin-blue))

  (use-package fill-column-indicator
    :straight t
    :config
    ;; :hook (prog-mode . fci-mode)
    (setq fci-rule-width 1))
#+end_src


**** popper.el

- ~popper.el~ :: Treat some types of windows as popups (e.g., something easier
  to dismiss, a bit more like the mini-buffer).  Further ~jf/popper~ can
  toggle the popup buffer.  See that method for further implementation details.

#+begin_src emacs-lisp
  (use-package popper
    :straight t
    :custom
    (popper-reference-buffers
      '("\\*Messages\\*"
	"Output\\*$"
	"^\\*Org Select"
	"\\*Async Shell Command\\*"
	help-mode
	compilation-mode
	"^\\*helpful.*\\*$"))
    (setq popper-window-height (lambda (win)
				 (fit-window-to-buffer
				  win
				  (floor (frame-height) 2))))
    (popper-mode +1)
    (popper-echo-mode +1))

  ;; Enforce rules for popups.  See https://depp.brause.cc/shackle/.
  (use-package shackle
    :straight t
    :custom
    (shackle-rules '((compilation-mode :noselect t))
		   shackle-default-rule '(:select t)))

  (use-package ace-window
      :straight t
      :bind (("M-o" . ace-window)))
#+end_src

**** Folding

#+begin_src emacs-lisp
  (use-package yafolding :straight t)

  ;; A quick and useful visual queue for paranthesis.
  (use-package rainbow-delimiters
    :straight t
    :hook ((fundamental-mode) . rainbow-delimiters-mode))

  ;; Show tilde (e.g. ~\~~) on empty trailing lines.  This is a feature ported
  ;; from https://en.wikipedia.org/wiki/Vi
  (use-package vi-tilde-fringe
    :straight t
    :diminish 'vi-tilde-fringe-mode
    :config (global-vi-tilde-fringe-mode))

  ;; A little bit of visual feedback.  See https://protesilaos.com/codelog/2022-03-14-emacs-pulsar-demo/
  (use-package pulsar
    :straight (pulsar :host gitlab :repo "protesilaos/pulsar")
    :hook
    (consult-after-jump . pulsar-recenter-top)
    (consult-after-jump . pulsar-reveal-entry)
    ;; integration with the built-in `imenu':
    (imenu-after-jump . pulsar-recenter-top)
    (imenu-after-jump . pulsar-reveal-entry)
    :config
    (pulsar-global-mode 1)
    (setq pulsar-face 'pulsar-magenta
	  pulsar-delay 0.05)
    (defun jf/pulse (parg)
      "Pulse the current line.

  If PARG (given as universal prefix), pulse between `point' and `mark'."
      (interactive "P")
      (if (car parg)
	  (pulsar--pulse nil nil (point) (mark))
	(pulsar-pulse-line)))
    :bind (("C-l" . jf/pulse)))

  (use-package emojify
    :straight t
    :config
    (defun --set-emoji-font (frame)
      "Adjust the font settings of FRAME so Emacs can display emoji properly."
      (if (eq system-type 'darwin)
	  ;; For NS/Cocoa
	  (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
	;; For Linux
	(set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))

    ;; For when Emacs is started in GUI mode:
    (--set-emoji-font nil)
    ;; Hook for when a frame is created with emacsclient
    ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
    (add-hook 'after-make-frame-functions '--set-emoji-font))
#+end_src

**** DONE unicode-fonts.el

I’m uncertain why I included this, aside from “sure would be nice to have unicode fonts.”

#+begin_src emacs-lisp
  (use-package unicode-fonts
    :straight t
    :config (unicode-fonts-setup))
#+end_src

**** flymake-proselint

#+begin_src emacs-lisp
  (use-package flymake-proselint
    :straight t)

  ;; (add-hook 'text-mode-hook (lambda ()
  ;; 			    (flymake-mode)
  ;; 			    (flymake-proselint-setup)))
#+end_src

*** Modes

Emacs has the concept of modes.  Each buffer has one major mode and can have
multiple minor modes.  A major mode may derive from another major mode.

These modes impact lots of things; key bindings being one of them.

What follows are a list of modes presented in a somewhat random order.  Some
are major modes others are minor modes.

**** bundler.el

- ~bundler.el~ :: Adds the useful ~bundle-open~ command.

#+begin_src emacs-lisp
  (use-package bundler
    :straight (bundler :type git :host github :repo "endofunky/bundler.el"))

  (use-package csv-mode :straight t
    ;; Always enter CSV mode in align mode; makes it easier to read.
    :hook (csv-mode . csv-align-mode))

  (use-package dockerfile-mode :straight t)

  (use-package eglot
    :hook ((css-mode
	    enh-ruby-mode
	    yaml-mode
	    html-mode
	    js-mode
	    scss-mode) . eglot-ensure)
    :config
    (setq eglot-ignored-server-capabilites (quote (:documentHighlightProvider))
	  completion-category-overrides '((eglot (styles orderless))))
    (add-to-list 'eglot-server-programs
		 `(enh-ruby-mode . ("solargraph" "socket" "--port" :autoport)))
    :straight t)

  (use-package emmet-mode
    :straight t
    :bind (("C-c C-e" . emmet-expand-yas ))
    :hook ((sgml-mode . emmet-mode)
	   (html-mode . emmet-mode)
	   (css-mode . emmet-mode)))

  (use-package enh-ruby-mode
    :straight t
    :hook (enh-ruby-mode . (lambda () (setq fill-column 100)))
    :hook (enh-ruby-mode . eldoc-mode)
    :hook (enh-ruby-mode . enh-ruby-imenu-create-index)
    :bind (:map enh-ruby-mode-map ("C-j" . jf/jump-to-agenda-or-mark)
				   ("M-h" . enh-ruby-mark-defun))
    :mode (("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . enh-ruby-mode)))
  (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))

  (use-package go-mode :straight t)
  (use-package json-mode :straight t)

  ;; Because JSON can be quite ugly, I want something to help tidy it up.
  (use-package json-reformat
    :straight t
    :after json-mode
    :init (setq json-reformat:indent-width 2))

  ;; For awhile, I was trying to use lsp-mode.  It might look a bit nicer, but it
  ;; was a little to “nosy”.  On my read, ~eglot~ leverages many of the built-in
  ;; APIs of Emacs.
  ;;
  ;; https://github.com/joaotavora/eglot#1-2-3-pitfall
  (use-package xref
    :straight t
    :custom
    (xref-file-name-display 'project-relative)
    (xref-search-program 'ripgrep))

  (use-package project
    :straight t)

  (use-package eldoc
    :straight t)

  ;; For working with https://www.hammerspoon.org; which provides me the
  ;; wonderful https://github.com/dmgerman/editWithEmacs.spoon/
  (use-package lua-mode :straight t)

  (use-package markdown-mode
    :straight t
    :hook ((markdown-mode . turn-on-visual-line-mode))
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "/opt/homebrew/bin/pandoc"))

  ;; A mode for working with PlantUML.  See https://plantuml.com
  (use-package plantuml-mode
    :config (setq plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  plantuml-default-exec-mode 'executable
		  org-plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  org-plantuml-exec-mode 'executable)
    :mode (("\\.plantuml\\'" . plantuml-mode))
    :straight t)

  (use-package rspec-mode
    :straight t
    ;; Ensure that we’re loading enh-ruby-mode before we do any rspec loading.
    :after enh-ruby-mode
    :custom (rspec-use-spring-when-possible nil)
    :bind (:map rspec-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :bind (:map enh-ruby-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :diminish 'rspec-mode)

  (eval-after-load 'rspec-mode '(rspec-install-snippets))

  ;; Nice and simple package for string interpolation.
  (use-package ruby-interpolation
    :straight t
    :diminish 'ruby-interpolation-mode
    :hook (enh-ruby-mode . ruby-interpolation-mode))

  (use-package so-long
    :defer t
    :straight t
    :bind
    (:map so-long-mode-map
	  ("C-s" . isearch-forward)
	  ("C-r" . isearch-backward))
    :config (global-so-long-mode 1))

  (use-package sql-indent
    :straight t
    :hook (sql-mode . sqlind-minor-mode))

  (use-package typescript-mode
    :straight t)

  ;; See https://github.com/emacs-tree-sitter/elisp-tree-sitter
  ;; Waiting on https://github.com/emacs-tree-sitter/elisp-tree-sitter/issues/197 to resolve.
  (use-package tree-sitter
    :straight (tree-sitter :host github :repo "emacs-tree-sitter/elisp-tree-sitter")
    :diminish 'tree-sitter-mode
    :config
    (add-to-list 'tree-sitter-major-mode-language-alist '(enh-ruby-mode . ruby)))

  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)

  (use-package tree-sitter-langs
    :straight t)

  (use-package web-mode
    :straight t
    :config (setq web-mode-markup-indent-offset 2
		  web-mode-css-indent-offset 2
		  web-mode-code-indent-offset 2))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))

  (add-to-list `auto-mode-alist '("\\.svg\\'" . xml-mode))

  (use-package yaml-mode :straight t)

  (use-package yard-mode
    :straight t
    :diminish 'yard-mode
    :hook (enh-ruby-mode . yard-mode))

  ;; This follows from http://mbork.pl/2017-01-14_I'm_now_using_the_right_dictionary
  (use-package sdcv-mode
    :straight (sdcv-mode :type git :host github :repo "gucong/emacs-sdcv")
    :bind ("C-c C-'" . sdcv-search))
#+end_src
*** Utilities


**** edit-indirect.el

The ~edit-indirect.el~ behaves similarly to the amazing ~org-edit-source-code~ but for any regions.  This is particularly nice for markdown “triple back-tick regions” (e.g. =```=).

#+begin_src emacs-lisp
  (use-package edit-indirect
    :straight t)
#+end_src

**** ts.el

A timestamp library.

#+begin_src emacs-lisp
  (use-package ts
    :straight t)
#+end_src

**** Custom Dictionary

#+begin_src emacs-lisp

#+end_src

**** titlecase.el

#+begin_src emacs-lisp
  ;; The rules of “titlecase” are confounding.  The ~titlecase.el~ package
  ;; provides numerous ways to cast a string to “titlecase.”  I chose wikipedia
  ;; style as a quasi-opinionated compromise.
  (use-package titlecase
    :straight (titlecase :host github :repo "duckwork/titlecase.el")
    :custom (titlecase-style 'wikipedia))
#+end_src

**** fill-sentences-correctly.el

- ~fill-sentences-correctly.el~ ::

#+BEGIN_src emacs-lisp
  ;; After using Emacs for awhile, with it’s sentence navigation, I’ve come to
  ;; strongly favor two spaces after a period.  The
  ;; `fill-sentences-correctly-mode' ensures that `fill-paragraph' (e.g. M-q)
  ;; preserves two spaces.
  (use-package fill-sentences-correctly
    :straight (fill-sentences-correctly :host github :repo "duckwork/fill-sentences-correctly.el")
    :hook (fundamental-mode . fill-sentences-correctly-mode))
#+end_src

**** savekill.el

- ~savekill.el~ :: Write "kill" command inputs to disk.

#+begin_src emacs-lisp
  (use-package savekill :straight t)
#+end_src

**** math-at-point.el

#+begin_src emacs-lisp
  ;; Calculate math functions at point and message result in minibuffer.  See
  ;; https://github.com/shankar2k/math-at-point.
  (use-package math-at-point
      :straight (math-at-point :type git :host github :repo "shankar2k/math-at-point")
      :bind ("C-c =" . math-at-point))
#+end_src

**** Expansion Options

#+begin_src emacs-lisp
  ;; The =abbrev= package is simple and powerful, providing an auto-correct that
  ;; I configure.  No more “teh” in my text.
  (use-package abbrev
    :straight (:type built-in)
    :custom (abbrev-file-name (file-truename "~/git/dotemacs/emacs.d/abbrev_defs"))
    :hook (text-mode . abbrev-mode))

  ;; Using Hippie expand, I toggle through words already referenced.
  (use-package hippie-exp
    :straight t
    :config
    (setq hippie-expand-try-functions-list '(try-expand-dabbrev-visible
					     try-expand-dabbrev
					     try-expand-dabbrev-all-buffers
					     try-expand-dabbrev-from-kill
					     try-complete-file-name-partially
					     try-complete-file-name
					     try-expand-all-abbrevs
					     try-expand-list
					     try-expand-line
					     try-complete-lisp-symbol-partially
					     try-complete-lisp-symbol))
    :bind (("M-SPC" . hippie-expand)))

  (global-set-key [remap dabbrev-expand] 'hippie-expand)
#+end_src

**** expand-region.el

- ~expand-region.el~ ::

#+begin_src emacs-lisp
  ;; A simple package that does two related things really well; expands and
  ;; contracts the current region.  I use this all the time.
  ;;
  ;; In writing, with the cursor at point, when I expand it selects the word.
  ;; The next expand the sentence, then paragraph, then page.  In programming it
  ;; leverages sexp.
  (use-package expand-region
    :straight t
    :bind (("C-=" . er/expand-region)
	   ("C-+" . er/contract-region)))
#+end_src

**** multiple-cursors.el

#+begin_src emacs-lisp
  ;; Allow Emacs to work with multiple cursors.  See
  ;; https://melpa.org/#/multiple-cursors
  (use-package multiple-cursors
      :bind (("C-M-SPC" . set-rectangular-region-anchor)
	     ("C->" . mc/mark-next-like-this)
	     ("C-<" . mc/mark-previous-like-this)
	     ("C-s-<mouse-1>" . mc/add-cursor-on-click)
	     ("C-c C->" . mc/mark-all-like-this)
	     ("C-c C-SPC" . mc/edit-lines)) ;; CTRL+CMD+c
      :straight t)

  ;; Type \"C-;\" to select current symbol and all matches; Then edit at multiple
  ;; points.
  (use-package iedit :straight t)
#+end_src

**** crux.el

#+begin_src emacs-lisp
  ;; A mix of a few odd and useful functions.
  (use-package crux
    :straight t
    :bind (("C-a" . crux-move-beginning-of-line)
	   ("<C-s-return>" . crux-smart-open-line-above)
	   ("C-s-k" . crux-kill-line-backwards)
	   ("<s-backspace>" . crux-kill-line-backwards)
	   ("<f9>" . crux-kill-other-buffers)))
#+end_src

**** ethan-wspace.el

#+begin_src emacs-lisp
  ;; Whitespace hygene package.  The author's documentation and commentary echoes
  ;; my sentiments.
  (use-package ethan-wspace
    :straight t
    :hook (before-save . delete-trailing-whitespace)
    :init (setq-default mode-require-final-newline nil)
    :config (global-ethan-wspace-mode 1))
#+end_src

**** unfill.el

#+begin_src emacs-lisp
  ;; Provides the reverse of ~fill-paragraph~, and a toggle fill and unfill.
  (use-package unfill
    :bind ("M-q" . unfill-toggle)
    :straight t)
#+end_src

**** undo-tree.el

#+begin_src emacs-lisp
  ;; Provides a UI for undo trees.  I'm not certain what I want to do with this.
  (use-package undo-tree
    :diminish
    :bind (("C-z" . undo)
           ("C-s-z" . undo-tree-redo))
    :config
    (setq undo-tree-enable-undo-in-region t)
    (global-undo-tree-mode +1)
    (unbind-key "M-_" undo-tree-map))
#+end_src

**** hungry-delete.el

#+begin_src emacs-lisp
  ;; Delete multiple spaces in one delete stroke.
  (use-package hungry-delete
      :straight t
      :diminish 'hungry-delete-mode
      :config (global-hungry-delete-mode))
#+end_src

**** move-text.el

#+begin_src emacs-lisp
  ;; A simple package ability to move lines up and down.
  (use-package move-text
    :straight t
    :bind (([C-s-down] . move-text-down)
	   ([C-s-up] . move-text-up)))
#+end_src

**** string-inflection.el

#+begin_src emacs-lisp
  (use-package string-inflection
    :straight t)
#+end_src


**** tempel.el

**** whole-line-or-region.el

- ~whole-line-or-region.el~ ::

#+begin_src emacs-lisp
  ;; From the package commentary, “This minor mode allows functions to operate on
  ;; the current line if they would normally operate on a region and region is
  ;; currently undefined.”  I’ve used this for awhile and believe it’s not baked
  ;; into my assumptions regarding how I navigate Emacs.
  (use-package whole-line-or-region
    :straight t
    :diminish 'whole-line-or-region-local-mode
    :config (whole-line-or-region-global-mode))
#+end_src

**** smartparens.el

#+begin_src emacs-lisp
  ;; provides some “intelligent” treatment of parentheses.  I’ve been using this
  ;; for awhile, so I assume it’s baked into my memory.
  (use-package smartparens :straight t)
#+end_src

**** grab-mac-link.el

#+begin_src emacs-lisp
  ;; Grab a link from a variety of MacOS applications.
  (use-package grab-mac-link
    :straight t
    ;; Ensuring we load these, as I'll need them later.
    :commands (grab-mac-link-safari-1 grab-mac-link-firefox-1)
    :config
    ;; A replacement function for existing grab-mac-link-make-html-link
    (defun jf/grab-mac-link-make-html-link (url name)
      "Using HTML syntax, link to and cite the URL with the NAME."
      (format "<cite><a href=\"%s\" class=\"u-url p-name\" rel=\"cite\">%s</a></cite>" url name))
    ;; The function advice to override the default behavior

    (advice-add 'grab-mac-link-make-html-link
		:override 'jf/grab-mac-link-make-html-link
		'((name . "jnf")))
    :bind (("C-c g" . grab-mac-link)))

  ;; Similar to `grab-mac-link' this specifically grabs a link and inserts in
  ;; `org-mode' format.
  (use-package org-mac-link
    :straight (org-mac-link :type git :host github :repo "jeremyf/org-mac-link")
    :bind (:map org-mode-map (("C-c g" . org-mac-grab-link))))
#+end_src

*** TODO Typography

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  This package serves the purpose of assisting with adding
  ;;  characters that are not readily available on an ANSI keyboard.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; BEGIN Typography Menu
  ;;
  ;;  The purpose of the typography menu is to provide easier access to
  ;;  typographic characters that I use; It also provides a bit of a
  ;;  mnemonic device (e.g. "C-x 8 RET" searches for a character to insert).
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (use-package pretty-hydra
      :straight (:type git :host github :repo "jerrypnz/major-mode-hydra.el"
		 :files (:defaults (:exclude "major-mode-hydra.el"))))

  (defvar jf/typography--title
    (jf/all-the-icons--with-octicon "pencil" "Typography (C-x 8 RET for Search)" 1 -0.05)
    "The menu title for typography")
  (pretty-hydra-define jf/typography--menu (:foreign-keys warn :title jf/typography--title :quit-key "q" :exit t)
    ("Characters" (
		   ("d d" (insert "-") "- dash")
		   ("d m" (insert "—") "— em dash")
		   ("d n" (insert "–") "– en dash")
		   (". e" (insert "…") "… ellipsis")
		   (". d" (insert "·") "º degree")
		   (". m" (insert "·") "· middot")
		   ("t d" (insert "†") "† dagger")
		   ("t 2" (insert "‡") "‡ double dagger")
		   ("t s" (insert "§") "§ section")
		   ("t p" (insert "¶") "¶ paragraph")
		   ("? !" (insert "‽") "‽ Interobang")
		   )
     "Math" (
	     ("a x" (insert "×") "× Multiplication Sign")
	     ("a d" (insert "÷") "÷ Division Sign")
	     ("a m" (insert "−") "− Minus Sign")
	     ("a p" (insert "±") "± Plus or Minus Sign")
	     ("m n" (insert "¬") "¬ Negation")
	     ;; For declaring regex functions.  See
	     ;; https://www.johndcook.com/blog/2022/01/08/corner-quotes-in-unicode/
	     ;; and https://irreal.org/blog/?p=10265
	     ("c l" (insert "⌜") "⌜ Left Corner Quote")
	     ("c r" (insert " ⌟") "⌟ Right Corner Quote")
	     ;; Included as a reminder as I use these for menu structures
	     ("f h"   (insert "─") "─ Forms light horizontal")
	     ("f D l" (insert "┐") "┐ Forms light down and left")
	     ("f v"   (insert "│") "│ Forms light vertical")
	     ("f V r" (insert "├") "├ Forms light vertical and right")
	     ("f U r" (insert "└") "└ Forms light up and right")
	     )
     "Quotes" (
	       ("\" o" (insert "“") "“ Double quote open")
	       ("\" c" (insert "”") "” Doule quote close")
	       ("\" O" (insert "«") "« Guillemet open")
	       ("\" C" (insert "»") "» Guillemet close")
	       ("\" l" (insert "⌈") "⌈ Left ceiling")
	       ("' o" (insert "‘") "‘ Single quote open")
	       ("' c" (insert "’") "’ Single quote close")
	       ("' O" (insert "‹") "‹ Single guillemet open")
	       ("' C" (insert "›") "› Single guillemet close")
	       ("p 1" (insert "′") "′ Single Prime (feet, arcminutes)")
	       ("p 2" (insert "″") "″ Double Prime (inches, arcseconds)")
	       ("p 3" (insert "‴") "‴ Triple Prime"))
     ))

  (global-set-key (kbd "C-s-8") 'jf/typography--menu/body)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; END Typography Menu
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

**** TODO typopunct.el

#+begin_src emacs-lisp
  (use-package typopunct
    :straight t
    :config
    (add-hook 'org-mode-hook 'jf/typopunct-init)
    (defun jf/typopunct-init ()
      (require 'typopunct)
      (typopunct-change-language 'english)
      (typopunct-mode 1))
    (setq typopunct-buffer-language 'english)

    ;; To insert a typographical ellipsis sign (…) on three consecutive
    ;; dots, or a middle dot (·) on ‘^.’
    (defconst typopunct-ellipsis (decode-char 'ucs #x2026))
    (defconst typopunct-middot   (decode-char 'ucs #xB7)) ; or 2219
    (defun typopunct-insert-ellipsis-or-middot (arg)
      "Change three consecutive dots to a typographical ellipsis mark."
      (interactive "p")
      (cond
       ((and (= 1 arg)
	     (eq (char-before) ?^))
	(delete-char -1)
	(insert typopunct-middot))
       ((and (= 1 arg)
	     (eq this-command last-command)
	     (looking-back "\\.\\." 1))
	(replace-match "")
	(insert typopunct-ellipsis))
       (t
	(self-insert-command arg))))
    (define-key typopunct-map "." 'typopunct-insert-ellipsis-or-middot)


    (defconst typopunct-prime  (decode-char 'ucs #x2032)) ; feet, arcminutes, derivatives
    (defconst typopunct-dprime (decode-char 'ucs #x2033)) ; inches, arcseconds, double derivatives
    (defconst typopunct-tprime (decode-char 'ucs #x2034))

    ;; The minus sign (−) is separate from the hyphen (-), en dash (–) and
    ;; em dash (—). To build upon the clever behavior of the ‘-’ key
    (defconst typopunct-minus (decode-char 'ucs #x2212))
    (defconst typopunct-pm    (decode-char 'ucs #xB1))
    (defconst typopunct-mp    (decode-char 'ucs #x2213))
    (defadvice typopunct-insert-typographical-dashes
	(around minus-or-pm activate)
      (cond
       ((or (eq (char-before) typopunct-em-dash)
	    (looking-back "\\([[:blank:]]\\|^\\)\\^" 2))
	(delete-char -1)
	(insert typopunct-minus))
       ((looking-back "[^[:blank:]]\\^" 1)
	(insert typopunct-minus))
       ((looking-back "+/" 1)
	(progn (replace-match "")
	       (insert typopunct-pm)))
       (t ad-do-it)))
    (defun typopunct-insert-mp (arg)
      (interactive "p")
      (if (and (= 1 arg) (looking-back "-/" 2))
	  (progn (replace-match "")
		 (insert typopunct-mp))
	(self-insert-command arg)))
    (define-key typopunct-map "+" 'typopunct-insert-mp)
    (defconst typopunct-times (decode-char 'ucs #xD7))
    (defun typopunct-insert-times (arg)
      "Insert multiplication sign at ARG."
      (interactive "p")
      (if (and (= 1 arg) (looking-back "\\([[:blank:]]\\|^\\)\\^"))
	  (progn (delete-char -1)
		 (insert typopunct-times))
	(self-insert-command arg)))
    (define-key typopunct-map "x" 'typopunct-insert-times)

    (defadvice typopunct-insert-quotation-mark (around wrap-region activate)
      (let* ((lang (or (get-text-property (point) 'typopunct-language)
		       typopunct-buffer-language))
	     (omark (if single
			(typopunct-opening-single-quotation-mark lang)
		      (typopunct-opening-quotation-mark lang)))
	     (qmark (if single
			(typopunct-closing-single-quotation-mark lang)
		      (typopunct-closing-quotation-mark lang))))
	(cond
	 (mark-active
	  (let ((skeleton-end-newline nil)
		(singleo (typopunct-opening-single-quotation-mark lang))
		(singleq (typopunct-closing-single-quotation-mark lang)))
	    (if (> (point) (mark))
		(exchange-point-and-mark))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string omark)) (mark) t)
		(replace-match (regexp-quote (string singleo)) nil nil)))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string qmark)) (mark) t)
		(replace-match (regexp-quote (string singleq)) nil nil)))
	    (skeleton-insert (list nil omark '_ qmark) -1)))
	 ((looking-at (regexp-opt (list (string omark) (string qmark))))
	  (forward-char 1))
	 (t ad-do-it)))))
#+end_src

** Integrated “Applications”

*** Variable and Constant Definitions

These are a few variables and cosntants that I use throughout my configuration.

#+begin_src emacs-lisp
  (defconst jf/tor-home-directory
    (file-truename "~/git/takeonrules.source")
    "The home directory of TakeOnRules.com Hugo repository.")

  (defconst jf/tor-hostname-default-local
    "http://localhost:1313"
    "The scheme, host name, and port for serving up a local TakeOnRules.com.")

  (defconst jf/tor-hostname-default-remote
    "https://takeonrules.com"
    "The scheme and host name for TakeOnRules.com.")

  (defvar jf/tor-hostname-current
    jf/tor-hostname-default-local
    "What is the current hostname for serving TakeOnRules content.")
#+end_src

*** Doc View

#+begin_src emacs-lisp
  (use-package doc-view
    :straight (doc-view :type built-in)
    :bind (:map doc-view-mode-map
                ("C-c g" . doc-view-goto-page)))
#+end_src

*** Mastodon

#+begin_src emacs-lisp
  ;; As Twitter becomes a megalomaniac’s obsession, Mastodon becomes even more
  ;; appealing.
  (use-package mastodon
    :straight t
    :config (setq mastodon-instance-url "https://tabletop.social"
		  mastodon-active-user "takeonrules"))
#+end_src

*** Knowledge Management

I use org-mode and org-roam to help manage content.  Let’s load that rather extensive configuration.

#+begin_src emacs-lisp
  ;; (org-babel-load-file
  ;;  (concat user-emacs-directory "knowledge-management-config.org"))
  (require 'jf-org-mode)
  ;; (org-babel-load-file
  ;;  (concat user-emacs-directory "denote-emacs-configuration.org"))
  (require 'jf-denote)
#+end_src

*** org-d20.el

#+begin_src emacs-lisp
  ;; I’m really only using this for the ~org-d20--roll~ function.
  (use-package org-d20
    :after org
    :bind  (("C-s-r" . jf/roll-expression-dwim))
    :config
    (defun jf/roll-expression-dwim (expression &optional)
      "Roll the EXPRESSION, check `thing-at-point' then prompt."
      (interactive (list (if (string-match
			      "[dD][0-9]"
			      (format "%s" (thing-at-point 'sexp t)))
			     (thing-at-point 'sexp t)
			   (read-string "Dice Expression: "))))
      (-let* (((rolls . result) (org-d20--roll expression)))
	(message "%s => %s" expression result)))
    :straight (org-d20 :host github :repo "spwhitton/org-d20"))
#+end_src

*** RSS Feed

**** elfeed.el

#+begin_src emacs-lisp
  ;; An Emacs RSS reader.  I’ve used Google Reader, Feedly, Inoreader, and
  ;; Newsboat.  I wrote about
  ;; https://takeonrules.com/2020/04/12/switching-from-inoreader-to-newsboat-for-rss-reader/,
  ;; and the principles apply for Elfeed.
  (use-package elfeed
    :straight t
    :after org
    :hook ((elfeed-show-mode . jf/reader-visual))
    :config
    (setq-default elfeed-search-filter "@2-days-ago +unread ")
    :bind ((:map elfeed-search-mode-map
		 ("q" . jf/elfeed-save-db-and-bury))))

  ;;write to disk when quiting
  (defun jf/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

  (defun jf/elfeed-load-db-and-open ()
    "Load the elfeed db from disk before opening"
    (interactive)
    (elfeed)
    (elfeed-update)
    (elfeed-db-load)
    (elfeed-search-update--force))
  (defalias 'rss 'jf/elfeed-load-db-and-open)

    ;; From https://karthinks.com/blog/lazy-elfeed/
  (defun elfeed-search-show-entry-pre (&optional lines)
    "Returns a function to scroll forward or back in the Elfeed
    search results, displaying entries without switching to them."
    (lambda (times)
      (interactive "p")
      (forward-line (* times (or lines 0)))
      (recenter)
      (call-interactively #'elfeed-search-show-entry)
      (select-window (previous-window))
      (unless elfeed-search-remain-on-entry (forward-line -1))))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "n") (elfeed-search-show-entry-pre +1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "p") (elfeed-search-show-entry-pre -1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "M-RET") (elfeed-search-show-entry-pre)))
  ;; End https://karthinks.com/blog/lazy-elfeed/

  ;; Maintaining my RSS subscriptions in `org-mode' format.
  (use-package elfeed-org
    :straight t
    :after elfeed
    :config (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/git/org/elfeed.org")))
#+end_src

*** Source Control

#+begin_src emacs-lisp
  (use-package git-modes :straight t)
  (use-package magit
    :straight t
    :commands (magit-process-git)
    :init (use-package with-editor :straight t)

    ;; Adding format to git-commit-fill-column of 72 as best practice.
    (setq git-commit-fill-column 72)

    ;; Keeping the summary terse helps with legibility when you run a
    ;; report with only summary.
    (setq git-commit-summary-max-length 50)

    ;; Set the tabular display columns for the `magit-list-repositories'
    (setq magit-repolist-columns
	  '(("Name"    25 magit-repolist-column-ident ())
	    ("Version" 25 magit-repolist-column-version ())
	    ("δ"        1 magit-repolist-column-dirty ())
	    ("⇣"        3 magit-repolist-column-unpulled-from-upstream
	     ((:right-align t)
	      (:help-echo "Upstream changes not in branch")))
	    ("⇡"        3 magit-repolist-column-unpushed-to-upstream
	     ((:right-align t)
	      (:help-echo "Local changes not in upstream")))
	    ("Branch"  25 magit-repolist-column-branch ())
	    ("Path"    99 magit-repolist-column-path ())))

    ;; The default relevant `magit-list-repositories'
    (setq magit-repository-directories
	  `(("~/git/takeonrules.source/" . 1)
	    ("~/git/burning_wheel_lifepaths/" . 1)
	    ("~/git/dotzshrc/" .  1)
	    ("~/git/dotemacs/" . 1)
	    ("~/git/emacs-bookmarks/" . 1)
	    ("~/git/org" . 1)
	    ("~/git/org/archive" . 1)
	    ("~/git/takeonrules.source/themes/hugo-tufte" . 1)))

    ;; Have magit-status go full screen and quit to previous
    ;; configuration.  Taken from
    ;; http://whattheemacsd.com/setup-magit.el-01.html#comment-748135498
    ;; and http://irreal.org/blog/?p=2253
    ;; (defadvice magit-status (around magit-fullscreen activate)
    ;;   (window-configuration-to-register :magit-fullscreen)
    ;;   ad-do-it
    ;;   (delete-other-windows))
    ;; (defadvice magit-mode-quit-window (after magit-restore-screen activate)
    ;;   (jump-to-register :magit-fullscreen))
    :config
    ;; (use-package libgit :straight t)
    (remove-hook 'magit-status-sections-hook 'magit-insert-tags-header)
    (defun jf/magit-browse-pull-request ()
      "In `magit-log-mode' open the associated pull request
    at point.

    Assumes that the commit log title ends in the PR #, which
    is the case when you use the Squash and Merge strategy.

    This implementation is dependent on `magit' and `s'."
      (interactive)
      (let* ((beg (line-beginning-position))
	     (end (line-end-position))
	     (summary
	      (buffer-substring-no-properties
	       beg end)))
	(jf/open-pull-request-for :summary summary)))
    (defun jf/git-current-remote-url ()
      "Get the current remote url."
      (s-trim
       (shell-command-to-string
	(concat
	 "git remote get-url "
	 (format "%s" (magit-get-current-remote))))))
    (cl-defun jf/open-pull-request-for (&key summary)
      "Given the SUMMARY open the related pull request.

    This method assumes you're using Github's Squash and Strategy."
      (let ((remote-url (jf/git-current-remote-url)))
	(save-match-data
	  (and (string-match "(\\#\\([0-9]+\\))$" summary)
	       (browse-url
		(concat
		 ;; I tend to favor HTTPS and the repos end in ".git"
		 (s-replace ".git" "" remote-url)
		 "/pull/"
		 (match-string 1 summary)))))))
    (defun jf/open-pull-request-for-current-line ()
      "For the current line open the applicable pull request."
      (interactive)
      (let ((summary
	     (s-trim
	      (shell-command-to-string
	       (concat "git --no-pager annotate "
		       "-w -L "
		       (format "%s" (line-number-at-pos))
		       ",+1 "
		       "--porcelain "
		       buffer-file-name
		       " | rg \"^summary\"")))))
	(jf/open-pull-request-for :summary summary)))
    :bind (("s-7" . magit-status)
	   ("C-x g f" . magit-file-dispatch)
	   ("C-x g d" . magit-dispatch))
    ;; In other situations I bind s-6 to `git-messenger:popup-message'
    :bind (:map magit-log-mode-map ("s-6" . 'jf/magit-browse-pull-request))
    :hook ((with-editor-post-finish-hook . magit-status)))

  ;; COMMENTED OUT FOR FUTURE REFERENCE
  ;; (transient-define-prefix jf/magit-aux-commands ()
  ;;   "My personal auxiliary magit commands."
  ;;   ["Auxiliary commands"
  ;;    ("d" "Difftastic Diff (dwim)" jf/magit-diff-with-difftastic)
  ;;    ("s" "Difftastic Show" jf/magit-show-with-difftastic)])

  ;; (require 'magit)
  ;; (transient-append-suffix 'magit-dispatch "!"
  ;;   '("#" "My Magit Cmds" jf/magit-aux-commands))

  ;; (define-key magit-status-mode-map (kbd "#") #'jf/magit-aux-commands)

  ;; With the time machine, travel back and forth through a files history.
  (use-package git-timemachine
    :straight (:host github :repo "emacsmirror/git-timemachine"))

  ;; Show the current git state in the gutter.  As you edit a line in a file
  ;; track by git, the indicators change to reflect if this is a modification,
  ;; addition, or deletion.
  (use-package git-gutter
    :straight t
    :diminish 'git-gutter-mode
    :custom (git-gutter:update-interval 0.25)
    :bind ("C-x g =" . git-gutter:popup-hunk)
    ("C-x g p" . git-gutter:previous-hunk)
    ("C-x g n" . git-gutter:next-hunk)
    :init (global-git-gutter-mode t)
    (setq git-gutter:modified-sign "Δ"
	  git-gutter:added-sign "+"
	  git-gutter:deleted-sign "-"))

  ;; Type ~M-x git-link~ and the function pushes the Git forge URL to the kill
  ;; ring; I’ve configured the URL to use the SHA of the commit of the line on
  ;; which I called `git-link'.  This is helpful for sharing links with other
  ;; folks.  I use this /all of the time./ See https://github.com/sshaw/git-link.
  (use-package git-link
    :config
    (defun jf/git-browse-to-repository (remote)
      "Open in external browser the current repository's given REMOTE."
      (interactive (list (git-link--select-remote)))
      (git-link-homepage remote)
      (browse-url (car kill-ring)))
    (setq git-link-use-commit t) ;; URL will be SHA instead of branch
    :straight t)

  ;; Sometimes I want to see more ~git~ information regarding the current line.
  ;; `git-messenger' provides a popup that shows the information and provides
  ;; some additional options.
  (use-package git-messenger
    :config (setq git-messenger:show-detail t)
    (defun jf/git-messenger-popup ()
      "Open `git-messenger' or github PR.

    With universal argument, open the github PR for current line.

    Without universal argument, open `git-messenger'."
      (interactive)
      (if (equal current-prefix-arg nil) ; no C-u
	  (git-messenger:popup-message)
	(jf/open-pull-request-for-current-line)))
    :custom
    (git-messenger:use-magit-popup t)
    :bind (:map git-messenger-map (("p" . 'jf/open-pull-request-for-current-line)
				   ("l" . 'git-link)))
    :bind (("s-6" . jf/git-messenger-popup)
	   ("<f6>" . jf/git-messenger-popup))
    :straight t)

  ;; When working in code, I want different ways to view the metadata around the
  ;; code.  This adds a quick annotation to the current line; When did the last
  ;; person touch this and what was the message.  It's most useful aspect is
  ;; seeing multiple lines without relying on the blame.
  (use-package blamer
    :straight (blamer :host github :repo "Artawower/blamer.el")
    :custom
    ;; Set to 0 because I don’t enable by default.  So I’m in a mindset of show
    ;; me who and when.
    (blamer-idle-time 0.0)
    (blamer-author-formatter "✎ %s ")
    (blamer-datetime-formatter "[%s] ")
    (blamer-commit-formatter "● %s")
    (blamer-min-offset 40)
    (blamer-max-commit-message-length 20))
#+end_src

*** tmr.el

#+begin_src emacs-lisp
  ;; Set some timers.
  (use-package tmr
    ;; My dbus install is not behaving so I'm cheating with a bit of AppleScript
    :config (defun jf/tmr-notification-notify (timer)
	      "Dispatch a notification for TIMER."
	      (let ((title "TMR May Ring (Emacs tmr package)")
		    (description (tmr--timer-description timer)))
		(ns-do-applescript (concat "display notification \"" description "\" sound name \"Glass\""))))
    :custom (tmr-notify-function #'jf/notifications-notify)
    (tmr-timer-completed-functions
     (list #'tmr-print-message-for-completed-timer
	   #'tmr-sound-play
	   #'jf/tmr-notification-notify))
    :straight (tmr :host nil :type git :repo "https://git.sr.ht/~protesilaos/tmr"))
#+end_src


*** EWW

#+begin_src emacs-lisp
  ;; A plain text browser.  Use this to see just how bad much of the web has become.
  (use-package eww
    :straight t
    :config
    (defun shr-tag-dfn (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-cite (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-q (dom)
      (shr-insert (car shr-around-q-tag))
      (shr-generic dom)
      (shr-insert (cdr shr-around-q-tag)))

    (defcustom shr-around-q-tag '("“" . "”")
      "The before and after quotes.  `car' is inserted before the Q-tag and `cdr' is inserted after the Q-tag.

  Alternative suggestions are: - '(\"\\\"“\" . \"\\\"\")"
      :type (cons 'string 'string))

    (defface shr-small
      '((t :height 0.8))
      "Face for <small> elements.")

    ;; Drawing inspiration from shr-tag-h1
    (defun shr-tag-small (dom)
      (shr-fontize-dom dom (when shr-use-fonts 'shr-small)))

    (defface shr-time
      '((t :inherit underline :underline (:style wave)))
      "Face for <time> elements.")

    ;; Drawing inspiration from shr-tag-abbr
    (defun shr-tag-time (dom)
      (when-let* ((datetime (or
			     (dom-attr dom 'title)
			     (dom-attr dom 'datetime)))
		  (start (point)))
	(shr-generic dom)
	(shr-add-font start (point) 'shr-time)
	(add-text-properties
	 start (point)
	 (list
	  'help-echo datetime
	  'mouse-face 'highlight))))


    ;; EWW lacks a style for article
    (defun shr-tag-article (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    ;; EWW lacks a style for section; This is quite provisional
    (defun shr-tag-section (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    (setq browse-url-browser-function 'browse-url-default-macosx-browser)
    :bind (:map eww-mode-map ("U" . eww-up-url))
    :bind (("C-s-w" . browse-url-at-point))
    :hook ((eww-mode . jf/reader-visual)))

  (use-package vterm
    :straight t)
#+end_src

*** Random Tables

Let’s add some [[file:random-tables.org][Random Table tooling]].

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "random-tables.org"))
#+end_src

*** Hammerspoon

Hammerspoon is Lua application that provides a consistent API for interacting
with MacOS.  The editWithEmacs.spoon allows me to copy text from one region,
edit it in Emacs, and paste it back into the Application.

#+begin_src emacs-lisp
  (when (file-directory-p
	 "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon")
    (load
     "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el"
     nil
     jf/silence-loading-log))
#+end_src

** Connective Tissue and Oddities

*** Functions

The following chunk of allows me to take multiple filenames passed via the
emacsclient and open those files in windows within the same frame.

You can see this in my [[https://codeberg.org/takeonrules/dotzshrc/src/branch/main/bin/git-edit][git-edit]] command line tool.

#+begin_src emacs-lisp
  ;;; Connective Tissue and oddity functions:
  (defvar server-visit-files-custom-find:buffer-count
    "A counter for assisting with opening multiple files via a single
    client call.")
  (defadvice server-visit-files
      (around server-visit-files-custom-find
	      activate compile)
    "Maintain a counter of visited files from a single client call."
    (let ((server-visit-files-custom-find:buffer-count 0))
      ad-do-it))
  (defun server-visit-hook-custom-find ()
    "Arrange to visit the files from a client call in separate windows."
    (if (zerop server-visit-files-custom-find:buffer-count)
	(progn
	  (delete-other-windows)
	  (switch-to-buffer (current-buffer)))
      (let ((buffer (current-buffer))
	    (window (split-window-sensibly)))
	(switch-to-buffer buffer)
	(balance-windows)))
    (setq server-visit-files-custom-find:buffer-count
	  (1+ server-visit-files-custom-find:buffer-count)))
  (add-hook 'server-visit-hook 'server-visit-hook-custom-find)

  ;; The following function facilitates a best of both worlds.  By default, I
  ;; want Option to be Meta (e.g. \"M-\") in Emacs.  However, I can toggle that
  ;; setting.  That way if I need an umlaut (e.g., \"¨\"), I can use MacOS’s
  ;; native functions to type \"⌥\" + \"u\".
  ;;
  ;; I like having MacOS’s native Option (e.g. =⌥=) modifier available.  But
  ;; using that default in Emacs would be a significant hinderance.
  (defun jf/toggle-osx-alternate-modifier ()
    "Toggle native OS-X Option modifier setting (e.g. `ns-alternate-modifier')."
    (interactive)
    (if ns-alternate-modifier
	(progn (setq ns-alternate-modifier nil)
	       (message "Enabling OS X native Option modifier"))
      (progn (setq ns-alternate-modifier 'meta)
	     (message "Disabling OX X native Option modifier (e.g. Option as Meta)"))))

  ;; I try to get quick feedback when writing emacs-lisp; the
  ;; `jf/eval-region-dwim' binds a mnemonic key sequence to an extend
  ;; `eval-region'.
  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'jf/eval-region-dwim)
  (defun jf/eval-region-dwim ()
    "When region is active, evaluate it and kill the mark. Else,
      evaluate the whole buffer."
    (interactive)
    (if (not (region-active-p))
	(progn
	  (message "Evaluating buffer...")
	  (eval-buffer))
      (progn
	(message "Evaluating region...")
	(eval-region (region-beginning) (region-end)))
      (setq-local deactivate-mark t)))

  ;; A little bit of RSS beautification.
  (defun jf/reader-visual ()
    "A method to turn on visual line mode and adjust text scale."
    (text-scale-set 2)
    (turn-on-visual-line-mode))

  ;; See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/
  (global-set-key (kbd "M-n") 'jf/scroll-down-half-page)
  (defun jf/scroll-down-half-page ()
    "Scroll down half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) (move-to-window-line nil))
	    ((= ln lmax) (recenter (window-end)))
	    (t (progn
		 (move-to-window-line -1)
		 (recenter))))))

  ;; See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/
  (global-set-key (kbd "M-p") 'jf/scroll-up-half-page)
  (defun jf/scroll-up-half-page ()
    "Scroll up half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) nil)
	    ((= ln lmax) (move-to-window-line nil))
	    (t (progn
		 (move-to-window-line 0)
		 (recenter))))))
#+end_src

#+begin_src emacs-lisp
  ;; Insert an active timestamp, with a few options.
  (global-set-key (kbd "s-5") 'jf/org-insert-immediate-active-timestamp)
  (defun jf/org-insert-immediate-active-timestamp (parg)
    "Insert an active date for today.

  One universal arg (e.g., prefix call with C-u) inserts timestamp.
  Two universal arsg (e.g., prefix call with C-u C-u) prompts for date then insertes active date."
    (interactive "P")
    (let ((prefix (car parg)))
      (cond
       ((not prefix)  (org-insert-time-stamp nil nil nil))
       ((= prefix 4)  (org-insert-time-stamp nil t nil))
       ((= prefix 16) (org-insert-time-stamp (org-read-date nil t nil "Date") nil nil)))))

  (global-set-key (kbd "C-w") 'jf/delete-region-or-backward-word)
  (global-set-key (kbd "M-DEL") 'jf/delete-region-or-backward-word)
  (global-set-key (kbd "<C-M-backspace>") 'backward-kill-paragraph)
  (defun jf/delete-region-or-backward-word (&optional arg)
    "Delete selected region otherwise delete backwards the ARG number of words."
    (interactive "p")
    (if (region-active-p)
	(delete-region (region-beginning) (region-end))
      (sp-backward-delete-word arg)))

  ;; Wedding two methods together: `kill-region' and `kill-line'.
  (global-set-key (kbd "C-k") 'jf/kill-line-or-region)
  (defun jf/kill-line-or-region (&optional parg)
    "Kill the selected region otherwise kill the PARG number of lines."
    (interactive "P")
    (if (use-region-p)
	(kill-region (region-beginning) (region-end))
      (kill-line parg)))

  ;; There are plenty of times where I want the file name.  This command helps me
  ;; get either it’s full path, or it’s base name.
  (global-set-key (kbd "C-c n") 'jf/nab-file-name-to-clipboard)
  (defun jf/nab-file-name-to-clipboard (parg)
    "Nab, I mean copy, the current buffer file name to the clipboard.

  The PARG is the universal prefix argument.

  If you pass no args, copy the filename with full path.
  If you pass one arg, copy the filename without path.
  If you pass two args, copy the path to the directory of the file."
    ;; https://blog.sumtypeofway.com/posts/emacs-config.html
    (interactive "P")
    (let* ((prefix (car parg))
	   (raw-filename
	    (if (equal major-mode 'dired-mode) default-directory (buffer-file-name)))
	   (filename
	    (cond
	     ((not prefix)  raw-filename)
	     ((= prefix 4)  (file-name-nondirectory raw-filename))
	     ((= prefix 16) (file-name-directory raw-filename)))))
      (when filename
	(kill-new filename)
	(message "Copied buffer file name '%s' to the clipboard." filename))))

  ;; A simple combination of two functions `sort-lines'
  ;; and `delete-duplicate-lines'.
  (defun jf/sort-unique-lines (reverse beg end &optional adjacent keep-blanks interactive)
    "Sort lines and delete duplicates.

  By default the sort is lexigraphically ascending.  To sort as
  descending set REVERSE to non-nil.  Specify BEG and END for the
  bounds of sorting.  By default, this is the selected region.

  I've included ADJACENT, KEEP-BLANKS, and INTERACTIVE so I can
  echo the method signature of `'delete-duplicate-lines`"
    (interactive "P\nr")
    (sort-lines reverse beg end)
    (delete-duplicate-lines beg end reverse adjacent keep-blanks interactive))

  ;; Creates a sticky side window.  Sometimes this is just the right thing for
  ;; reviewing files.  I don’t know when I need it, but when I use it I’m always
  ;; thankful I have it.
  (global-set-key (kbd "C-s-\\") 'jf/display-dedicated-buffer-in-side-window)
  (cl-defun jf/display-dedicated-buffer-in-side-window (&key (buffer (current-buffer)))
    "Display the given BUFFER in a dedicated sidebar."
    (interactive)
    (with-current-buffer buffer
      (jf/sidebar--build
       :buffer-name (concat "*Sidebar*")
       :position (point)
       :read-only t
       :body (buffer-string)
       :mode major-mode)))

  (cl-defun jf/sidebar--build (&key buffer-name body (read-only nil) (position nil) (mode nil))
    "Build the sidebar from the given buffer attributes.

  Create the BUFFER_NAME with the given BODY and move to the given
  POSITION and toggle on the MODE.  Then set the buffer to READ_ONLY."
    (interactive)
    (get-buffer-create buffer-name)
    (with-current-buffer buffer-name
      (insert body)
      (goto-char (or position (point-min)))
      (not-modified)
      (if mode (funcall mode) (special-mode))
      (when read-only
	(progn (read-only-mode) (local-set-key (kbd "s-w") 'kill-buffer-and-window)))
      (let ((display-buffer-mark-dedicated t))
	(pop-to-buffer buffer-name '((display-buffer-in-side-window)
				     (side . right)
				     (window-width 72)
				     (window-parameters
				      (tab-line-format . none)
				      (mode-line-format . none)
				      (no-delete-other-windows . t))))
	(message "Created *Sidebar*\nq - Remove Window")
	(require 'pulsar)
	(pulsar-pulse-line))))

  ;; Sometimes I want to move, without renaming, a file.  This function helps
  ;; make that easy.
  (global-set-key (kbd "C-x m") 'jf/move-file)
  (defun jf/move-file (target-directory)
    "Write this file to TARGET-DIRECTORY, and delete old one."
    (interactive "DTarget Directory: ")
    (let* ((source (expand-file-name (file-name-nondirectory (buffer-name)) default-directory))
	   (target (f-join target-directory (file-name-nondirectory (buffer-name)))))
      (save-buffer)
      (rename-file source target)
      (kill-current-buffer)))

  ;; From http://mbork.pl/2022-05-23_Copying_code_snippets
  (defun jf/copy-snippet-deindented (begin end)
    "Copy region, between BEGIN and END, untabifying and removing indentation."
    (interactive "r")
    (let ((orig-tab-width tab-width)
	  (region (buffer-substring-no-properties begin end)))
      (with-temp-buffer
	(setq tab-width orig-tab-width)
	(insert region)
	(untabify (point-min) (point-max))
	(org-do-remove-indentation)
	(kill-new (buffer-string)))))

  ;; Sometimes I just want to duplicate an area without copy and paste.  This
  ;; helps that process.  It’s not as smart as TextMate’s equivalent function,
  ;; but it’s close enough.
  (global-set-key (kbd "C-M-d") 'jf/duplicate-current-line-or-lines-of-region)
  (global-set-key (kbd "C-c d") 'jf/duplicate-current-line-or-lines-of-region)
  (defun jf/duplicate-current-line-or-lines-of-region (parg)
    "Duplicate ARG times current line or the lines of the current region."
    (interactive "p")
    (if (use-region-p)
	(progn
	  (when (> (point) (mark))
	    (exchange-point-and-mark))
	  (beginning-of-line)
	  (exchange-point-and-mark)
	  (end-of-line)
	  (goto-char (+ (point) 1))
	  (exchange-point-and-mark)
	  (let* ((end (mark))
		 (beg (point))
		 (region
		  (buffer-substring-no-properties beg end)))
	    (dotimes (_i parg)
	      (goto-char end)
	      (insert region)
	      (setq end (point)))))
      (crux-duplicate-current-line-or-region parg)))

  ;; A simple wrapper around scratch, that helps name it and sets the major mode
  ;; to `org-mode'.
  (global-set-key (kbd "<f12>") 'jf/create-scratch-buffer)
  (cl-defun jf/create-scratch-buffer (&key (mode 'org-mode))
    "Quickly open a scratch buffer and enable the given MODE."
    (interactive)
    (crux-create-scratch-buffer)
    (rename-buffer (concat "*scratch* at " (format-time-string "%Y-%m-%d %H:%M")))
    (funcall mode))
#+end_src


*** TODO Blogging Functions


#+begin_src emacs-lisp
  (org-babel-load-file
     (concat user-emacs-directory "takeonrules.org"))
#+end_src

#+begin_src emacs-lisp
  (require 'jf-quick-help)
  (require 'jf-presentation-and-focus)
#+end_src

*** Keyboard Macros

#+begin_src emacs-lisp
  (org-babel-load-file
     (concat user-emacs-directory "keyboard-macros-config.org"))
#+end_src

*** Minor Modes

In work and in play, there are several “me” specific contexts.  The
~jf/minor-mode-maker~ macro helps me quickly and consistently make those
contexual minor modes.  My intention is to build out even more functions on
those modes.

#+begin_src emacs-lisp
  (jf/minor-mode-maker :title "Take on Rules"
		       :abbr "tor")
#+end_src

** Burning Wheel

I wrote [[file:burning-wheel-emacs-config.org][some tooling to help while playing Burning Wheel]].

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "burning-wheel-emacs-config.org"))
#+end_src

** Eberron

I wrote [[file:eberron.org][some tooling to help wile playing Eberron]].

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "eberron.org"))
#+end_src

** Utility Functions

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "utility-functions.org"))
#+end_src

** Crafting Menus to Help Organize

I use Emacs for software development, knowledge management, blogging, and just
about whatever else I can.  And as I wrote in [[*Knowledge Management][Knowledge Management]], I try to
provide guidance when working within those contexts.

As I wrote earlier, I’ve settled on transient as my “menu creation” tool.  I am
thankful to the author of [[https://www.reddit.com/r/emacs/comments/m518xh/transient_api_example_alternative_bindings_part_1/][Transient API Example (Alternative Bindings Part 1) :
emacs]], as they helped me understand what is a relatively straight forward
system.

I’ll explain the language just a bit.  We have a prefix, infix, and suffix.
The prefix is what you start doing, the infix is modifications/adjustments,
before you finally invoke the suffix to “complete” the sequence.  A prefix and
a suffix are emacs-lisp functions, and transient provides a macro to make more
composable prefixes and suffixes.

I already introduced a simple transient prefix in the helpful package.  I want
to write some transient suffixes to.  As you’ll see later, you don’t need to
use the ~transient-define-suffix~ for adding a function to a transient prefix,
but a suffix can provide a description.

#+begin_src emacs-lisp
  ;; this suffix provides a dynamic description of the current major mode for a
  ;; `hammerspoon-edit-minor-mode' buffer.  And the prefix’s function toggles
  ;; that mode.
  (transient-define-suffix jf/hammerspoon-toggle-mode ()
    "Set the hammerspoon mode"
    :description '(lambda ()
		    (concat
		     "Hammerspoon Mode: "
		     (propertize
		      (format "%s" major-mode)
		      'face 'transient-argument)))
    (interactive)
    (hammerspoon-toggle-mode))

  ;; this suffix provides a dynamic description of the current host I want to use
  ;; for my blog.  And the prefix’s function toggles the host.
  (transient-define-suffix jf/tor-hostname-current-toggle (hostname)
    "Set `jf/tor-hostname-current' to HOSTNAME."
    :description '(lambda ()
		    (concat "Host: "
			    (propertize
			     (format "%s" jf/tor-hostname-current)
			     'face 'transient-argument)))
    (interactive (list (completing-read
			"Host: " (list
				  (list jf/tor-hostname-default-local 1)
				  (list jf/tor-hostname-default-remote 2)
				  ))))
    (setq jf/tor-hostname-current hostname))

  (transient-define-prefix jf/menu--tor ()
    "My Take on Rules menu; useful when developing my blog."
    ["Take on Rules"
     ["Host"
      ("-h" jf/tor-hostname-current-toggle :transient t)
      ]]
    [["Posts"
      :if-non-nil jf/tor-minor-mode
      ("p r" "Re-title post…" jf/tor-retitle-post)
      ("p t" "Tag post…" jf/tor-tag-post :transient t)
      ("p v" "View post…" jf/tor-view-blog-post)
      ]
     ["Find"
      ("f d" "in draft status…" jf/tor-find-file-draft)
      ("f u" "by url…" jf/tor-find-hugo-file-by-url)
      ("f f" "by filename…" jf/tor-find-file)]
     ["Create"
      ("c a" "Amplify the Blogosphere…" jf/tor-post-amplifying-the-blogosphere)
      ("c c" "Changelog entry…" jf/tor-find-changelog-and-insert-entry)
      ("c e" "Epigraph entry…" jf/tor-insert-epigraph-entry)
      ("c g" "Glossary entry…" jf/tor-find-glossary-and-insert-entry)
      ("c p" "Post…" jf/tor-create-post)
      ("c s" "Series…" jf/tor-find-series-and-insert-entry)]
     ])

  (global-set-key (kbd "s-1") 'jf/menu)
  (transient-define-prefix jf/menu ()
    "A context specific \"mega\" menu."
    ;; Todo, can I get this section into a function so I can duplicate it in the jf/menu--tor?
    [["Markdown Utilities"
      ("k h" "Kill slug version of given heading…" jf/kill-new-markdown-heading-as-slug :if-derived (or markdown-mode html-mode))
      ("w a" "A-tag at point or region…" jf/tor-wrap-link-active-region-dwim  :if-derived (or markdown-mode html-mode))
      ("w c" "CITE-tag point or region…" jf/tor-wrap-cite-active-region-dwim  :if-derived (or markdown-mode html-mode))
      ("w d" "DATETIME-tag point or region…" jf/tor-wrap-date  :if-derived (or markdown-mode html-mode))
      ("w f" "Wrap word or region in pseudo-DFN…" jf/tor-wrap-as-pseudo-dfn  :if-derived (or markdown-mode html-mode))
      ]
     [
      "" ;; Deliberate space for menu
      ("w m" "Margin-note line or region…" jf/tor-wrap-as-marginnote-dwim  :if-derived (or markdown-mode html-mode))
      ("w p" "Wrap point or region as Poem…" jf/tor-wrap-in-poem  :if-derived (or markdown-mode html-mode))
      ("w s" "Side-note sentence or region…" jf/tor-wrap-as-sidenote-dwim  :if-derived (or markdown-mode html-mode))
      ("w w" "Wrap point or region in html…" jf/tor-wrap-in-html-tag  :if-derived (or markdown-mode html-mode))
      ]]
    [["Contexts"
      ("-b" "Burning Wheel…"  jf/menu--bwg)
      ("-e" "Eberron…" jf/menu--eberron)
      ;; ("-f" "Forem…" jf/menu--forem)
      ("-t" "TakeOnRules…" jf/menu--tor)
      ("-w" "Register window configuration" window-configuration-to-register)
      ]
     ["Jump to"
      ("j a" "Agenda" jf/jump-to-agenda-or-mark)
      ("j b" "iBuffer" ibuffer)
      ("j g" "Global Mark" consult-global-mark)
      ("j h" "Hugo File" jf/jump_to_corresponding_hugo_file :if-derived org-mode)
      ("j m" "Mark" consult-mark)
      ("j o" "Org File" jf/jump_to_corresponding_org_file :if-non-nil jf/tor-minor-mode)
      ("j p" "Jump in PDF" doc-view-goto-page :if-derived doc-view-mode)
      ("j s" "Jump to Shortdoc" shortdoc-display-group)
      ]
     ["Modes"
      ("C-n" "MacOS Night Shift" (lambda () (interactive) (shell-command "nightlight on")))
      ;; I could write functions for these, but this is concise enough
      ("m h" jf/hammerspoon-toggle-mode  :if-non-nil hammerspoon-edit-minor-mode)
      ("m t" "Typopunct ( )" typopunct-mode :if-nil typopunct-mode)
      ("m t" "Typopunct (*)" typopunct-mode :if-non-nil typopunct-mode)
      ("m o" "MacOS Native Option ( )" jf/toggle-osx-alternate-modifier :if-non-nil ns-alternate-modifier)
      ("m o" "MacOS Native Option (*)" jf/toggle-osx-alternate-modifier :if-nil ns-alternate-modifier)
      ]]
    ["Org"

     ;; ["Add Metadata"
     ;; ("C-e a" "Add epigraph properties…" jf/org-mode-add-epigraph-keys :if-derived org-mode)
     ;; ("C-e i" "Add epigraph at point…" jf/org-roam-insert-at-point-epigraph-macro :if-derived org-mode)
     ;; ("r a" "Ref add…" org-roam-ref-add :if-derived org-mode)
     ;; ("t s" "Tag as session report…" jf/org-tag-as-session-report :if-derived org-mode)
     ;; ("t a" "Tag add…" org-roam-tag-add :if-derived org-mode)
     ;; ("t S" "Tag as session Scene…" jf/org-tag-session-scene-with-date :if-derived org-mode)]
     ;; ["Context"
     ;; ("M-c" "Context set…" jf/org-auto-tags--set-by-context :transient t)
     ;; ("M-t" jf/org-auto-tags--transient :transient t)
     ;; ]
     ["Tasks"
      ("c" "Capture region to clock…" (lambda (b e p) (interactive "r\nP") (jf/capture-region-contents-with-metadata b e p)))
      ("s" "Search note content…" (lambda () (interactive) (consult-notes-search-in-all-notes)))
      ("S" "Search note filename…" (lambda () (interactive) (consult-notes)))
      ("C-t" "Start a timer…" tmr-with-description)
      ("u" "Copy stand-up to kill ring" jf/org-mode-agenda-to-stand-up-summary)
      ("w" "Weekly hours report" jf/org-mode-weekly-report)
      ("x" "Export to TakeOnRules…" jf/export-org-to-tor :if-derived org-mode)
      ]
     ["Grab Refs"
      ("g e" "Elfeed" jf/menu--org-capture-elfeed-show :if-derived elfeed-show-mode)
      ("g f" "Firefox" jf/menu--org-capture-firefox)
      ("g s" "Safari" jf/menu--org-capture-safari)
      ("g w" "Eww" jf/menu--org-capture-eww :if-derived eww-mode)
      ]
     ])
#+end_src

* Footnotes

[fn:8] Steve Covey, and trademarked by FranklinCovey.

[fn:7] Yes, I said I didn’t want an Electron-based editor, but VS Code is a dominant player in the open source text editor.

[fn:2]  https://github.com/minad/consult#introduction

[fn:3]  These functions assume that the repository is using a [[https://rietta.com/blog/github-merge-types/#squash-and-merge][Squash and Merge strategy]].

[fn:4] My alias is as follows: ~alias e-reboot='cd ~/git/dotemacs; git stash ; edaemon ; git stash pop ; git edit'~.

[fn:5] My [[https://codeberg.org/takeonrules/dotzshrc/src/ab8b781cbdddd2fdbe674e031436b7e9a8e8a024/README.org#L1][dotzshrc]] config has my ~$EDITOR~

[fn:6] “Ag” is the chemical symbol for the Silver element.

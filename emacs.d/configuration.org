# -*- org-insert-tilde-language: emacs-lisp; -*-
#+TITLE: Emacs Configuration
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+STARTUP: showall
#+OPTIONS: toc:3

* Introduction

On <2020-05-25> I wrote [[https://takeonrules.com/2020/05/25/principles-of-my-text-editor/][Principles of My Text Editor]].  I was exploring adopting
a new text editor, and wanted to ensure that I knew what I was looking for.
You know, “begin with the end in mind.”[fn:8]

When I first dove in, I looked into [[https://github.com/hlissner/doom-emacs][Doom]] and [[https://www.spacemacs.org][Spacemacs]].  However, in doing that
I got ahead of myself.  So I started with an empty ~init.el~ and walked through
the tutorial.

From that point forward, I committed to use Emacs as is and when I knew I
needed something, I’d look into how to do it.  The result?  A configuration
that is uniquely mine.

On <2022-02-01 Tue> I chose to begin extracting my the various ~*.el~ into a
[[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]] format.  As with all Emacs configurations, what follows is
a work in progress.

** Tips on Troubleshooting

As I migrated from my ~*.el~ configurations, I moved one ~.el~ file at a time.
With each move, I would restart my Emacs daemon[fn:5].  I went so far as
to write a ~e-reboot~ alias[fn:4].  So if I “messed up”, I could easily
recover and fix the files I broke.

In other words, when I’m working on extending my Emacs configuration, I tend to
favor a bisset approach.  Make a change, verify it, and commit.  This helps
insulate me from “getting to far ahead of myself.”  Along the way, I failed to
always apply that discipline.

** About the Current Structure

The current structure is carried over from my past structure.  As I was first
adopting Emacs, I spent time organizing the packages.  This organization is a
bit muddy, as I never quite established the nomenclature.

What I can say is the order may be important.  But I’ll be working to untangle
that.

Where feasible, I have tried to bind keys “close” to their utilization.  That
is to say, I often leverage the ~:bind~, ~:hook~, and ~:map~ keywords for
~use-package~.  But I’m not always consistent.

In the ~org-mode~ version, I’m making use of “TODO” indicators to help me track
what else I may need to do.  A node marked as “DONE” should be viewed as “I
don’t need to go back and amend any documentation in that part.  However, it
doesn’t mean I won’t put more things in that section.”

** Organizing the Ideas

I’ve thought quite a bit about how to organize this file.  How does one narrate
the intertwined concepts of a configuration that is an amalgamation of so many
other people’s work?

My approach is to think back to my experience with the tutorial.  How it walked
me through the concepts.  I also need to be mindful that as I introduce source
code concepts, they are evaluated in that order.

** Conventions

I’ve written quite a few functions to further extend the utility of Emacs.  I
try to prefix them with ~jf/~.  And if I cribbed those functions from
elsewhere, I attempt to give credit to the source.

* Into the Emacs

** Launching Emacs

As we get started in Emacs, I want to make sure I have the basics lined up.

- Package Management
- Preliminary Configuration
- Basic Theming

*** Package Management

I have chosen to adopt ~straight.el~ for my package management.  The fact that
it rather seamlessly works with ~use-package~ has help me keep my code more
organized.

#+begin_src emacs-lisp
  ;; https://www.reddit.com/r/emacs/comments/mtb05k/emacs_init_time_decreased_65_after_i_realized_the/
  (setq straight-check-for-modifications '(check-on-save find-when-checking))

  ;; This preamble is part of straight-use-package My understanding, in
  ;; reading straight documentation is that it has better load
  ;; times. However, the configuration options I often see leverage
  ;; "use-package" which is why most of my package declarations look as
  ;; they do.
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file))

  (setq straight-repository-branch "develop")
  (straight-use-package 'use-package)
#+end_src

*** Preliminary Configuration

These are some general configurations that I’ve slowly accumulated.  There’s
inline documentation in most cases.  There might be little bits worth teasing
out but for the most part, you can move along and reference this later.

#+begin_src emacs-lisp
  (setq user-full-name "Jeremy Friesen"
	user-mail-address "jeremy@jeremyfriesen.com")

  (defconst jf/silence-loading-log t
    "When t log to stdout load messages from this configuration.

    In a previous iteration, I loaded lots of separate '*.el' files.
    This flag allowed me to more easily troubleshoot those load
    attempts.")

  (global-so-long-mode) ;; Handle long files.
  (electric-pair-mode)  ;; https://blog.sumtypeofway.com/posts/emacs-config.html
  (make-directory "~/.emacs.d/autosaves/" t) ;; Ensuring I have an autosave
  ;; directory.
  (recentf-mode 1) ;; Track recent
  (run-at-time nil (* 2 60) 'recentf-save-list) ;; Save files every 2 minutes
  (global-auto-revert-mode)

  (setq-default fill-column 79)   ;; Feeling a bit old school with 80 characters.
  (setq-default cursor-type 'bar) ;; Doing a bit of configuration of my cursors
  (blink-cursor-mode t)

  (setq
   backup-by-copying t         ;; Don't delink hardlinks

   backup-directory-alist '((".*" . "~/.emacs.d/backups/"))

   bookmark-default-file "~/git/emacs-bookmarks/bookmarks"

   custom-safe-themes t        ;; I may as well trust themes.

   create-lockfiles nil        ;; Don't create lock files.

   delete-old-versions t       ;; Automatically delete excess backups

   idle-update-delay 1.1       ;; Slow down the UI being updated to improve
			       ;; performance

   indent-tabs-mode nil        ;; Ensure tabs are expanded, not inserted

   inhibit-startup-screen t    ;; Don't include the  emacs "start" window

   kept-new-versions 20        ;; how many of the newest versions to keep

   kept-old-versions 5         ;; and how many of the old

   kill-ring-max 120           ;; Set a generous kill ring size.

   read-process-output-max (* 6 512 1024)  ;; Increase read size per process

   recentf-max-menu-items 50

   recentf-max-saved-items 50

   ring-bell-function 'ignore  ;; Stop ringing any bell

   split-width-threshold 100   ;; Most of the times I favor two windows
			       ;; side-by-side within a frame

   vc-follow-symlinks t        ;; Follow symlinks instead of prompting.

   version-control t           ;; Use version numbers on backups

   x-underline-at-descent-line t ;; Recommendation from
				 ;; https://protesilaos.com/emacs/modus-themes
   )

  (setq enable-recursive-minibuffers nil) ;;   I tried enabling this, and found
					  ;;   myself sometimes lost in a
					  ;;   labyrinth of minibuffers.  This
					  ;;   change ensures that there’s only
					  ;;   one.



  (global-hl-line-mode)

  ;; When you open Emacs, grab all the space on the screen
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))

  (tool-bar-mode -1) ;; Hide the icons of the Emacs toolbar
  (scroll-bar-mode -1) ;; Hide the scroll bar. Let's be clear, I don't use it.
  (defalias 'yes-or-no-p 'y-or-n-p) ;; Always "y" or "n" for yes/no

  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

  (add-hook 'text-mode-hook #'abbrev-mode)

  (add-function :after after-focus-change-function
		(defun jf/garbage-collect-maybe ()
		  (unless (frame-focus-state)
		    (garbage-collect))))
#+end_src

And I’m going to disable a few key bindings.  These were always messing me up a
bit.  Also enable a few that I find helpful.  (I’ll enable a lot more later).

#+begin_src emacs-lisp
  (unbind-key "C-z") ;; `suspend-frame'
  (unbind-key "C-x C-c") ;; was `save-buffers-kill-terminal'

  (global-set-key (kbd "<M-delete>") 'kill-word)
  (global-set-key (kbd "<s-down>") 'end-of-buffer)
  (global-set-key (kbd "<s-up>") 'beginning-of-buffer)
  (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
  (global-set-key (kbd "s-w") 'kill-current-buffer)
#+end_src

Some basic packages to keep things less chatty.

*Diminish* provides a means of not displaying the :lighter of a minor mode in the modeline.

#+begin_src emacs-lisp
  (use-package diminish :straight t)
#+end_src

*Gcmh* does garbage collection (GC) when the user is idle.

#+begin_src emacs-lisp
  (use-package gcmh
    :straight t
    :diminish 'gcmh-mode
    :init
    (setq gcmh-idle-delay 5
	  gcmh-high-cons-threshold (* 16 1024 1024))  ; 16mb
    :config (gcmh-mode))
#+end_src

*** Basic Theming

I want to start with a basic look and feel.  First, the choice of primary font.

#+begin_src emacs-lisp
  (defconst jf/fixed-width-font-name
    "Hack Nerd Font"
    "The name of the fixed width font.
    I have it sprinkled through too many places.

    Alternatives:
    - \"Monaco\"
    - \"JetBrains Mono\"
    - \"Hack Nerd Font\"")

  (set-frame-font jf/fixed-width-font-name)
#+end_src

And now the theme.  I’ve chosen the modus themes (e.g. ~modus-vivendi~ and
~modus-operandi~).  They provide a light and dark theme with a focus on visual
accessibility.

I love [[http://protesilaos.com][Prot]]’s attention to detail with the modus themes.  Here’s my
configuration for these two sibling themes.  There’s a bit of chatter, but all
told it sets things up how I like.

#+begin_src emacs-lisp
  (use-package modus-themes
    ;; :straight (modus-themes :type built-in)
    :straight (:type git :host gitlab :repo "protesilaos/modus-themes" :branch "main")
    :init
    (setq
     modus-themes-bold-constructs t
     modus-themes-completions 'opinionated
     modus-themes-diffs nil
     modus-themes-fringes 'intense
     modus-themes-hl-line '(accented intense)
     modus-themes-intense-markup t
     modus-themes-links '(faint background)
     modus-themes-mixed-fonts t
     modus-themes-mode-line '(accented 3d)
     modus-themes-org-blocks 'gray-background
     modus-themes-paren-match '(bold intense)
     modus-themes-prompts '(intense accented)
     modus-themes-region '(bg-only accented)
     modus-themes-scale-headings t
     modus-themes-slanted-constructs t
     modus-themes-subtle-line-numbers t
     modus-themes-syntax '(alt-syntax yellow-comments green-strings)
     modus-themes-tabs-accented t
     modus-themes-headings
     '((1 . (variable-pitch light 1.6))
       (2 . (overline semibold 1.4))
       (3 . (monochrome overline 1.2))
       (4 . (overline 1.1))
       (t . (rainbow 1.05)))))
#+end_src

With a quick bit of testing, it appears that the following ~set-face-attribute~
declarations should be made after the theme declarations.  When the following
statements were declared before the themes, and I toggled my theme, the font
changed to something unexpected.  With them declared after, I keep the fonts
between toggles.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil
		      :family jf/fixed-width-font-name
		      :height 140)
  (set-face-attribute 'variable-pitch nil
		      :family "ETBembo"
		      :height 1.1)
  (set-face-attribute 'fixed-pitch nil
		      :family jf/fixed-width-font-name
		      :height 1.0)
#+end_src

Next up, let’s load the theme based on my operating system’s settings
(e.g. Light or Dark mode).  /Note:/ I could just start with ~(load-theme
‘modus-operandi)~ but figure I’ll add a little bit of “nice to have up front.

#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
      (progn
	(defun jf/dark ()
	  "Toggle system-wide Dark or Light setting."
	  (interactive)
	  (shell-command "osascript -e 'tell application \"System Events\" to tell appearance preferences to set dark mode to not dark mode'")
	  (jf/emacs-theme-by-osx-appearance))

	(defalias 'modus-themes-toggle 'jf/dark)
	(defun jf/emacs-theme-by-osx-appearance ()
	  "Set theme based on OSX apperance state."
	  (if (equal "Dark" (substring (shell-command-to-string "defaults read -g AppleInterfaceStyle") 0 4))
	      (load-theme 'modus-vivendi)
	    (load-theme 'modus-operandi)))
	;; And load the appropriate theme
	(jf/emacs-theme-by-osx-appearance))
    (progn
      (defun modus-themes-toggle ()
	"Toggle between `modus-operandi' and `modus-vivendi' themes."
	(interactive)
	(if (eq (car custom-enabled-themes) 'modus-operandi)
	    (load-theme 'modus-vivendi)
	  (load-theme 'modus-operandi)))
      (load-theme 'modus-operandi)))
#+end_src

Show tabs in the current window.  The tab system is something I wrestle with,
but I appreciate it’s existence.  These configurations make it easier to use.

#+begin_src emacs-lisp
  (global-tab-line-mode t)
  ;; This maps to MacOS's tab switching keys.
  (global-set-key (kbd "s-{") 'previous-buffer)
  (global-set-key (kbd "s-}") 'next-buffer)
#+end_src

** How Does this Thing Work?

In this section my goal is to load some “fundamental” packages that help me
better introspect and navigate Emacs.

With the initial “setup” out of the way, let’s dive into how things work.

I want to make it easy to find help on different aspects of Emacs.  There’s
tooling baked into Emacs, but the ~helpful~ package “provides much more
contextual information.”

Futhermore, I want to make a menu to help remind me of the help I have
available.  In previous incarnations I’ve written these menus using
[[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][pretty-hydra]], but I’ve started moving these to [[https://github.com/magit/transient/tree/440a341831398b825dc2288a10821cf7be1999ca][transient]]; a package that’s a
hard requirement for packages I’ll later introduce.


#+begin_src emacs-lisp
  (use-package helpful
    :init
    (use-package transient :straight t)
    ;; I'm going to talk about this later, but I'm adding this to the menu, so I
    ;; may as well state the dependency.
    (use-package embark :straight t)
    :straight t
    :config
    (transient-define-prefix jf/helpful-menu ()
      "Return a `transient' compliant list to apply to different transients."
      ["Help"
       ""
       ("b" "Bindings" embark-bindings)
       ("c" "Command" helpful-command)
       ("f" "Function (interactive)" helpful-callable)
       ("F" "Function (all)" helpful-function)
       ("k" "Key" helpful-key)
       ("l" "Library" find-library)
       ("m" "Macro" helpful-macro)
       ("p" "Thing at point" helpful-at-point)
       ("." "Thing at point" helpful-at-point)
       ("t" "Text properties" describe-text-properties)
       ("v" "Variable" helpful-variable)])
    :bind ("C-s-h" . jf/helpful-menu))
#+end_src

With the above, I can now type ~C-s-h~ to bring up my helpful menu, and begin
exploring.

Emacs has lots of keybindings and many of them chain together several keys.  As
I’m learning those keys, I might remember the first prefix.

When I type the first key of a sequence and wait, ~which-key~ pops up a menu of
candidate functions and the keys to invoke each of them.  Another way to
introspect Emacs.

#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode)
    (which-key-setup-side-window-right)
    (which-key-show-major-mode)
    :straight t)
#+end_src

Related to this, when I’m in a buffer, I want to know what I can do.  The
~embark~ package provides the missing context menu (e.g. “right click”) for
Emacs.  /It provides more, but we’ll get to that later./

#+begin_src emacs-lisp
  (use-package embark
    :straight t
    :bind
    (("C-." . embark-act)       ;; pick some comfortable binding
     ("M-." . embark-dwim)
     ("C-s-e" . embark-export)
     ("C-h b" . embark-bindings))
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    (setq embark-action-indicator
	  (lambda (map &optional _target)
	    (which-key--show-keymap "Embark" map nil nil 'no-paging)
	    #'which-key--hide-popup-ignore-command)
	  embark-become-indicator embark-action-indicator)
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))
#+end_src

When I call ~embark-act~ (via ~C-.~) I get a buffer listing the actions I can
take on the target.  A contextual menu if you will.

There’s also the ~embark-dwim~ (I map that to ~M-.~).  Given a target, the
place at point, when I call ~embark-dwim~ it takes an applicable action.  For a
URL, it will open that URL in the configured browser.

As a tangent, let’s think in terms of “pairs”.  A target and an action.

With ~embark-export~ I can gather a group of targets (via ~embark-export~) and
sthen take actions on them.  I write more about this later as it relates to
~wgrep~.

Embark helps me know what actions are available, but I may want a broader
context.

Another mechanism for taking an action is ~M-x~ (or
~execute-extended-command~).  When I type ~M-x~, I’m prompted to provide the
name of a function.

It would instead of typing ~[TAB]~, I could see a list of candidate functions.
For that, I’m going to use the lightweight vertico package.

#+begin_src emacs-lisp
  (use-package vertico
    :straight t
    :config
    (vertico-mode)
    ;; Use `consult-completion-in-region' if Vertico is enabled.
    ;; Otherwise use the default `completion--in-region' function.
    (setq completion-in-region-function
	  (lambda (&rest args)
	    (apply (if vertico-mode
		       #'consult-completion-in-region
		     #'completion--in-region)
		   args)))
    (advice-add #'completing-read-multiple
		:override #'consult-completing-read-multiple)
    (setq vertico-cycle t))
#+end_src

Further more, I’m going to enable a few extensions.

The ~vertico-indexed.elc~ extension adds a visual indicator of each candidate’s
index.  Further, I can type ~C-<num> ENT~ and select that candidate.  Often
it’s just as easy to navigate via ~TAB~ or ~C-n~ / ~C-p~ but the visual
indicator is a nice bit of polish.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-indexed.elc"
	nil
	jf/silence-loading-log)
  (vertico-indexed-mode)
#+end_src

The ~vertico-repeat.elc~ extension does one simple thing: it remembers and
gives quick access to the last command you entered in the “minibuffer.”  This
can be super userful if I built up a complicated ~consult-ripgrep~.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-repeat.elc"
	nil
	jf/silence-loading-log)
  (global-set-key (kbd "M-r") #'vertico-repeat)
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
#+end_src

Related to, but independent of ~vertico-repeat.elc~ is enabling
~savehist-mode~.  With that enabled, I have access to a few dozen of the last
minibuffer commands I issued.  These are, by default, in ~\~/.emacs.d/history~.

#+begin_src emacs-lisp
  (savehist-mode 1)
#+end_src

Now that I have a list of candidates commands, it would be nice if those
candidates had some annotations.  Let’s load the ~marginalia~ package.  It
provides annotations to minibuffer completions, and pairs nicely with Vertico.

#+begin_src emacs-lisp
  (use-package marginalia
    :straight t
    ;; /Note:/ The declaration of `marginalia-mode' must be in the :init
    ;; section.This ensures that it is enabled right away.  It also forces the
    ;; loading of the package.
    :init (marginalia-mode))
#+end_src

** Writing, Coding, Computering
*** projectile.el

- ~projectile.el~ :: this package provides convenient organization and commands to run over projects.

#+begin_src emacs-lisp
  (use-package projectile
    :straight t
    :diminish 'projectile-mode
    :config (projectile-mode 1)
    :custom (projectile-project-search-path '("~/git/"))
    :bind ("s-." . projectile-toggle-between-implementation-and-test))
#+end_src

/Note:/ The =CMD= + =.= is a carryover from my [[https://macromates.com][Textmate]] and [[https://www.sublimetext.com/][Sublime Text]] days.
That’s one of those hot-keys almost burned into soul.

*** Support Packages

When I start writing functions, there’s a few packages I want to consider.

- ~keychain-environment.el~ :: Load keychain environment variables

#+begin_src emacs-lisp
  (use-package keychain-environment
    :straight t
    :config (keychain-refresh-environment))
#+end_src

- ~dash.el~ :: A modern list API for Emacs. No 'cl required.  (See https://github.com/magnars/dash.el/)

#+begin_src emacs-lisp
  (use-package dash :straight t)
#+end_src

- ~f.el~ :: A modern API for working with files and directories in Emacs. (See https://github.com/rejeep/f.el/)

#+begin_src emacs-lisp
  (use-package f :straight t)
#+end_src

- ~s.el~ :: The long lost Emacs string manipulation library.  (See https://github.com/magnars/s.el/)

#+begin_src emacs-lisp
  (use-package s :straight t)
#+end_src

- ~editorconfig.el~ :: “EditorConfig helps maintain consistent coding styles
  for multiple developers working on the same project across various editors
  and IDEs.”  See https://editorconfig.org/#overview for more details.

#+begin_src emacs-lisp
  (use-package editorconfig
    :straight t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))
#+end_src

- ~rigprep.el~ :: For many years, I’ve used “The Silver Searcher”, or ~ag~ on
  the command line.[fn:6].  However, [[https://github.com/BurntSushi/ripgrep][ripgrep]] provides even faster searching,
  with an almost identical parameter list.

#+begin_src emacs-lisp
  (use-package ripgrep
    :init (setq ripgrep-arguments "--ignore-case")
    :straight t)
#+end_src




  - Org Mode
  - Org Roam
  - Magit/Git
  - Elfeed
  - Elpher
  - Projects


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


*** Completion

**** Emacs Adjustments for Completion

What follows is adjustments to emacs settings as they relate to completion.

#+begin_src emacs-lisp
  (use-package emacs
    :init

    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
    (setq read-extended-command-predicate
	  #'command-completion-default-include-p)

    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)

    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
	  '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src


**** consult.el

- ~consult.el~ :: “Consult provides practical commands based on the Emacs
  completion function [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][completing-read]].”  I had previously used [[https://github.com/abo-abo/swiper][Ivy, Counsel,
  and Swiper]], but appreciate the design principles of Consult, namely “Consult
  fits well into existing setups and it helps you to create a full completion
  environment out of small and independent components.”[fn:2]

  With ~consult.el~ I’m able to bring in other components that focus on doing
  their “one thing” really well.

#+begin_src emacs-lisp
  (use-package consult
    :straight t
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
	   ("C-c h" . consult-history)
	   ;; ("C-c m" . consult-mode-command)
	   ("C-c b" . consult-bookmark)
	   ("C-c k" . consult-kmacro)
	   ;; C-x bindings (ctl-x-map)
	   ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complet-command
	   ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("s-b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
	   ("C-s-b" . consult-buffer-other-window)
	   ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
	   ;; Custom M-# bindings for fast register access
	   ("M-#" . consult-register-load)
	   ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
	   ("C-M-#" . consult-register)
	   ;; Other custom bindings
	   ("M-y" . consult-yank-from-kill-ring)                ;; orig. yank-pop
	   ("<help> a" . consult-apropos)            ;; orig. apropos-command
	   ;; M-g bindings (goto-map)
	   ("M-g e" . consult-compile-error)
	   ("M-g g" . consult-goto-line)             ;; orig. goto-line
	   ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
	   ("s-l" . consult-goto-line)           ;; orig. goto-line
	   ("M-g o" . consult-outline)
	   ("M-g m" . consult-mark)
	   ("M-g k" . consult-global-mark)
	   ("C-x C-SPC" . consult-mark)
	   ("M-g i" . consult-imenu)
	   ("M-g I" . consult-imenu-multi)
	   ;; M-s bindings (search-map)
	   ("M-s f" . consult-find)
	   ("M-s L" . consult-locate)
	   ("M-s g" . consult-grep)
	   ("M-s G" . consult-git-grep)
	   ("M-s r" . consult-ripgrep)
	   ("C-c f" . consult-ripgrep)
	   ("M-s l" . consult-line)
	   ("M-s m" . consult-multi-occur)
	   ("M-s k" . consult-keep-lines)
	   ("M-s u" . consult-focus-lines)
	   ;; Customizations that map to ivy
	   ("s-r" . consult-recent-file) ;; Deprecate
	   ("C-c r" . consult-recent-file)
	   ("C-c o" . consult-file-externally)
	   ("C-y" . yank)
	   ("C-s" . consult-line) ;; I've long favored Swiper mapped to c-s
	   ;; Isearch integration
	   ("M-s e" . consult-isearch)
	   :map isearch-mode-map
	   ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
	   ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
	   ("M-s l" . consult-line))                 ;; required by consult-line to detect isearch

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting.  This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.1
	  register-preview-function #'consult-register-format)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
	  xref-show-definitions-function #'consult-xref)

    ;; Updating the default to include "--ignore-case"
    (setq consult-ripgrep-command "rg --null --line-buffered --color=ansi --max-columns=1000 --ignore-case --no-heading --line-number . -e ARG OPTS")

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root))
#+end_src

***** Advising Functions

I wrote some advising functions to wrap around ~consult-line~ and
~consult-ripgrep~.  These wrapping functions use the active region as the
initial text or an empty string if there’s no active region.

There’s a macro in here somewhere.

#+begin_src emacs-lisp
  (defun jf/consult-first-param-is-initial-text (consult-fn &rest rest)
    "Advising function around CONSULT-FN.

  The CONSULT-FN's first parameter should be the initial text.

  When there's an active region, use that as the first parameter
  for CONSULT-FN.  Otherwise, use an empty string the first
  parameter.  This function handles the REST of the parameters."
    (interactive)
    (apply consult-fn
	   (when (use-region-p)
	     (buffer-substring
	      (region-beginning) (region-end)))
	   rest))

  (defun jf/consult-second-param-is-initial-text (consult-fn &optional first &rest rest)
    "Advising function around CONSULT-FN.

  We'll pass the FIRST parameter through.  The CONSULT-FN's second
  parameter should be the initial text.

  When there's an active region, use that as the first parameter
  for CONSULT-FN.  Otherwise, use an empty string the second
  parameter.  This function handles the REST of the parameters."
    (interactive "P")
    (apply consult-fn
	   first
	   (when (use-region-p)
	     (buffer-substring
	      (region-beginning) (region-end)))
	   rest))


  (advice-add #'consult-line
	      :around #'jf/consult-first-param-is-initial-text
	      '((name . "wrapper")))
  (advice-add #'consult-ripgrep
	      :around #'jf/consult-second-param-is-initial-text
	      '((name . "wrapper")))
#+end_src
***** consult-dir.el

- ~consult-dir.el~ :: This package helps ease traveling across directories by
  providing directory candidates related to current buffers, bookmarks, and
  projects.  Further, like other ~consult.el~ functions, you can use narrowing
  keys.  See https://github.com/karthink/consult-dir.

#+begin_src emacs-lisp
  (use-package consult-dir
    :straight t
    :after (consult)
    :bind (("C-x C-d" . consult-dir)
	   :map minibuffer-local-completion-map
	   ("C-x C-d" . consult-dir)
	   ("C-x C-j" . consult-dir-jump-file)))
#+end_src
***** consult-projectile.el

- ~consult-projectile.el~ :: package provides a function I use everyday: ~M-x
  consult-projectile~.  When I invoke ~consult-projectile~, I have the file
  completion for the current project.  I can also type =b= + =SPACE= to narrow
  my initial search to open buffers in the project.  Or =p= + =space= to narrow
  to other projects; and then select a file within that project.

#+begin_src emacs-lisp
  (use-package consult-projectile
    :commands (consult-projectile)
    :straight (consult-projectile
	       :type git
	       :host gitlab
	       :repo "OlMon/consult-projectile"
	       :branch "master")
    :bind ("s-t" . consult-projectile))
#+end_src

/Note:/ The =CMD= + =t= (e.g. ~s-t~ in Emacs) is a carryover from my [[https://macromates.com][Textmate]]
and [[https://www.sublimetext.com/][Sublime Text]] days.  More than any other key combination, that one is
entirely muscle memory.

**** embark-consult.el

- ~embark-consult.el~ :: I use ~embark.el~ and ~consult.el~, let’s add a little
  bit more connective tissue.

#+begin_src emacs-lisp
  (use-package embark-consult
    :straight t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook

    (embark-collect-mode . consult-preview-at-point-mode)
    (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

**** wgrep.el

- ~wgrep.el~ :: “Edit a grep buffer and apply those changes to the file
  buffer.”  In other words, after “searching” for something, sending the
  results to a buffer (via ~embark-export~ or such thing), you can edit that
  search results buffer and propogate the changes to the locations of the
  elements that matched the search.

1.  Call ~consult-ripgrep~ (via ~C-c f~) to search for something.
2.  Call ~embark-export~ (via ~C-s-e~) to export to a grep buffer.
3.  Call ~wgrep-change-to-wgrep-mode~ (via ~e~ or ~C-c C-p~)
4.  Edit the grep buffer as you would anywhere else.
5.  Save (via ~C-x C-s~) or Cancel (via ~C-c C-k~).

   I use this sequence at least once a day.

#+begin_src emacs-lisp
(use-package wgrep
    :after (embark-consult ripgrep)
    :straight t
    :bind (:map wgrep-mode-map
		;; Added keybinding to echo Magit behavior
		("C-c C-c" . save-buffer)
		:map grep-mode-map
		("e" . wgrep-change-to-wgrep-mode)
		:map ripgrep-search-mode-map
		("e" . wgrep-change-to-wgrep-mode)))
#+end_src

**** orderless.el

The [[https://github.com/minad/orderless][orderless]] package provides completion tooling for non-strict word order.  I
spent considerable time reading through the [[https://github.com/minad/consult/wiki][Orderless section of Consult’s
wiki]].

As configured the orderless completion recognizes the following “switches”:

- Flex (~\~~) :: Just start typing characters and you’ll get matches that have
  those characters
- File Extension (~\.ext~) :: Match files with this extension.
- Regexp ~^.$~ :: Use some regular expression syntax
  - ~^~ matching beginning
  - ~.~ any ol’ character
  - ~$~ matching ending
- Initialism (~`~) :: In ~M-x~ when I typed ~`pl~ the ~previous-line~ function
  was a top match.  The initialism switch “explodes” the characters and says
  match methods who’s words start with those characters.
- Not Literal ~!~ :: Exclude candidates that match the literal
  (e.g. ~!previous~ won’t show ~previous-line~ in the ~M-x~ completion).
- Literal ~=~ :: No “fuzzy buziness”, just match exactly what I typed.

There is another case (e.g. ~%~ character fold) that I don’t yet understand.

More on these component matchings styles is available at [[https://github.com/minad/orderless#component-matching-styles][github.com/minad/orderless]].

#+begin_src emacs-lisp
  (use-package orderless
    :straight t
    :config
    (defvar +orderless-dispatch-alist
      '((?% . char-fold-to-regexp)
	(?! . orderless-without-literal)
	(?`. orderless-initialism)
	(?= . orderless-literal)
	(?~ . orderless-flex)))
    (defun +orderless-dispatch (pattern index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" pattern)
	`(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x100000-\x10FFFD]*$")))
       ;; File extensions
       ((and
	 ;; Completing filename or eshell
	 (or minibuffer-completing-file-name
	     (derived-mode-p 'eshell-mode))
	 ;; File extension
	 (string-match-p "\\`\\.." pattern))
	`(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x100000-\x10FFFD]*$")))
       ;; Ignore single !
       ((string= "!" pattern) `(orderless-literal . ""))
       ;; Prefix and suffix
       ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
	    (cons (cdr x) (substring pattern 1))
	  (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
	    (cons (cdr x) (substring pattern 0 -1)))))))

    ;; Define orderless style with initialism by default
    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

    ;; Certain dynamic completion tables (completion-table-dynamic)
    ;; do not work properly with orderless. One can add basic as a fallback.
    ;; Basic will only be used when orderless fails, which happens only for
    ;; these special tables.
    (setq completion-styles '(orderless basic)
	  completion-category-defaults nil
	    ;;; Enable partial-completion for files.
	    ;;; Either give orderless precedence or partial-completion.
	    ;;; Note that completion-category-overrides is not really an override,
	    ;;; but rather prepended to the default completion-styles.
	  ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
	  completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
					  ;; enable initialism by default for symbols
					  (command (styles +orderless-with-initialism))
					  (variable (styles +orderless-with-initialism))
					  (symbol (styles +orderless-with-initialism)))
	  orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
	  orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src

**** corfu.el

- ~corfu.el~ :: An alternative to the ubiquitous [[https://github.com/company-mode/company-mode][Company]]; In [[https://takeonrules.com/2022/01/17/switching-from-company-to-corfu-for-emacs-completion/][Switching from
  Company to Corfu for Emacs Completion]] I further explain my adoption of Corfu.
  See https://github.com/minad/corfu for more details on Corfu.

  /Note:/ I may explore [[https://gitlab.com/protesilaos/mct][MCT]] and see how it compares to Corfu.

#+begin_src emacs-lisp
  (use-package corfu
    :straight t
    :demand t
    ;; Optionally use TAB for cycling, default is `corfu-complete'.
    :bind (:map corfu-map
		("TAB" . corfu-next)
		([tab] . corfu-next)
		("S-TAB" . corfu-previous)
		([backtab] . corfu-previous))
    :init

    ;; Recommended: Enable Corfu globally.
    ;; This is recommended since dabbrev can be used globally (M-/).
    (corfu-global-mode)

    :config
    ;; Optionally enable cycling for `corfu-next' and `corfu-previous'.
    (setq corfu-cycle t))
#+end_src

***** Extending corfu.el

- ~corfu-move-to-minibuffer~ :: The completion at point “popup” can sometimes
  be a little cryptic or terse.  The ~corfu-move-to-minibuffer~ provides a
  means of moving the “popup” candidates to the minibuffer for further
  inspection.

#+begin_src emacs-lisp
  (defun corfu-move-to-minibuffer ()
    "Move \"popup\" completion candidates to minibuffer.

  Useful if you want a more robust view into the recommend candidates."
    (interactive)
    (let (completion-cycle-threshold completion-cycling)
      (apply #'consult-completion-in-region completion-in-region--data)))
  (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer)
#+end_src

**** cape.el

- ~cape.el~ :: provides several Completion At Point Extensions (Capfs).  I like
  having a Capf for spelling and files.

#+begin_src emacs-lisp
  (use-package cape
    :straight t
    :bind (("C-c p p" . completion-at-point)
	   ("C-c p d" . cape-dabbrev)
	   ("C-c p f" . cape-file)
	   ("C-c p s" . cape-symbol)
	   ("C-c p i" . cape-ispell)))

  ;; Use Company backends as Capfs.
  (setq-local completion-at-point-functions
    (mapcar #'cape-company-to-capf
      (list #'company-files #'company-ispell #'company-dabbrev)))
#+end_src

**** yasnippet.el

- ~yasnippet.el~ :: A rather convenient snippet manager.  When you create a
  snippet, it understands the mode you're in and puts the snippet in the right
  place.

#+begin_src emacs-lisp
  (use-package yasnippet
    :straight t
    :diminish yas-mode
    :init
    (setq yas-snippet-dirs '("~/git/dotemacs/snippets"))
    (yas-global-mode 1))
#+end_src
**** consult-yasnippet.el

- ~consult-yasnippet.el~ :: A bit of integration with ~consult.el~ and ~yasnippet.el~.

#+begin_src emacs-lisp
  (use-package consult-yasnippet
    :straight t
    :after (consult yasnippet)
    :bind ("C-c y" . consult-yasnippet))
#+end_src

*** Navigation
**** avy.el

- ~avy.el~ :: That letter is the beginning of a word.  Narrow results from there.

#+begin_src emacs-lisp
  (use-package avy
    :bind (("C-j" . avy-goto-char-timer))
    :bind (:map org-mode-map ("C-j" . avy-goto-char-timer))
    :straight t)
#+end_src


*** Display
**** lin.el

- ~lin.el~ :: “LIN locally remaps the hl-line face to a style that is optimal for major modes where line selection is the primary mode of interaction.”  In otherwords, ~lin.el~ improves the highlighted line behavior for the competing contexts.

#+begin_src emacs-lisp
  (use-package lin
    :straight (lin :host gitlab :repo "protesilaos/lin")
    :config (lin-add-to-many-modes))
#+end_src

**** all-the-icons.el

- ~all-the-icons.el~ :: Provides a nice set of reference icons.  The various
  ~jf/all-with--with-~ functions give access to the icons of the named set.

#+begin_src emacs-lisp
  ;; Useful for referential icons.
  (use-package all-the-icons
    :straight t
    :config
    (cl-defmacro jf/all-the-icons--with(&key name)
      (let ((defun-fn (intern (concat "jf/all-the-icons--with-" name)))
	    (icon-fn (intern (concat "all-the-icons-" name)))
	    (docstring (concat "Displays an ICON from `all-the-icons-" name "'.")))
	`(defun ,defun-fn (icon str &optional height v-adjust)
	   ,docstring
	   (s-concat (,icon-fn
		      icon
		      :v-adjust (or v-adjust 0)
		      :height (or height 1))
		     " " str))))
    (jf/all-the-icons--with :name "faicon")
    (jf/all-the-icons--with :name "material")
    (jf/all-the-icons--with :name "octicon")
    (jf/all-the-icons--with :name "alltheicon"))
#+end_src

**** all-the-icons-dired.el

- ~all-the-icons-dired.el~ :: Incorporates file icons with file listings of
  dired.  /Note/: On 2021-04-11 I was getting the following error with this
  package: "*ERROR*: Symbol's value as variable is void: file"

#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :straight t
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

**** spaceline.el

- ~spaceline.el~ :: A nice looking modeline enhancement

#+begin_src emacs-lisp
  (use-package spaceline :straight t)
#+end_src

**** spaceline-all-the-icons.el

- ~spaceline-all-the-icons.el~ ::  Add some visual flair to the modeline enhancements.  Disabled as of <2022-02-03 Thu>.

#+begin_src emacs-lisp
  ;; (use-package spaceline-all-the-icons
  ;;  :straight t
  ;;  :after spaceline
  ;;  :config (spaceline-all-the-icons-theme))
#+end_src

**** popper.el

- ~popper.el~ :: Treat some types of windows as popups (e.g., something easier
  to dismiss, a bit more like the mini-buffer).  Further ~jf/popper~ can
  toggle the popup buffer.  See that method for further implementation details.

#+begin_src emacs-lisp
  (use-package popper
    :straight t
    :bind (("C-`" . jf/popper))
    :config
    (defun jf/popper (prefix_arg)
      "Call `popper-cycle', but with PREFIX_ARG invoke a less common popper method.

  With one PREFIX_ARG, `popper-toggle-latest'.
  With two (or more) PREFIX_ARG `popper-toggle-type'."
      (interactive "P")
      (let ((prefix (car prefix_arg)))
	(cond
	 ((not prefix)  (popper-cycle))
	 ((= prefix 4)  (popper-toggle-latest))
	 (t (popper-toggle-type)))))
    :init
    (setq popper-reference-buffers
	  '("\\*Messages\\*"
	    "Output\\*$"
	    "\\*Async Shell Command\\*"
	    help-mode
	    compilation-mode
	    "^\\*helpful.*\\*$"))
    (popper-mode +1)
    (popper-echo-mode +1))

#+end_src

**** shackle.el

- ~shackle.el~ :: Enforce rules for popups.  See https://depp.brause.cc/shackle/.

#+begin_src emacs-lisp
  (use-package shackle
    :straight t
    :custom
    (shackle-rules '((compilation-mode :noselect t))
		   shackle-default-rule '(:select t)))
#+end_src

/Note:/ How does this related to ~popper.el~?

**** ace-window.el

- ~ace-window.el~ :: A window manager for emacs, allowing fast toggles between
  windows as well as opening or moving those windows.  See
  https://github.com/abo-abo/ace-window for more details.

#+begin_src emacs-lisp
  (use-package ace-window
    :straight t
    :bind (("M-o" . ace-window)))
#+end_src

**** buffer-move.el

- ~buffer-move.el~ :: From [[https://github.com/lukhas/buffer-move][lukhas/buffer-move]], this package helps me quickly
  move a window elsewhre.  As of <2022-02-01 Tue>, I don’t often use this
  command.  Consider it “on notice” for removal.

#+begin_src emacs-lisp
  (use-package buffer-move
    :straight t
    :bind ("<C-s-f12>" . buf-move))
#+end_src

**** rainbow-delimiters.el

- ~rainbow-delimiters.el~ :: A quick and useful visual queue for paranthesis.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :straight t
    :hook ((fundamental-mode) . rainbow-delimiters-mode))
#+end_src

**** vi-tilde-fringe.el
- ~vi-tilde-fringt.el~ :: Show tilde (e.g. ~\~~) on empty trailing lines.  This is a feature ported from [[https://en.wikipedia.org/wiki/Vi][vi]].

#+begin_src emacs-lisp
  (use-package vi-tilde-fringe
    :straight t
    :config (global-vi-tilde-fringe-mode))
#+end_src

**** goggles.el

- ~goggles.el~ :: Adds a little bit of visual feedback as you delete chunks.

#+begin_src emacs-lisp
  (use-package goggles
    :straight t
    :hook ((prog-mode text-mode) . goggles-mode)
    :diminish 'goggles-mode
    :config (setq-default goggles-pulse t))
#+end_src

**** emojify.el

- ~emojify.el~ :: Ensure rendering of correct emoji’s.

#+begin_src emacs-lisp
  (use-package emojify
    :straight t
    :config
    (defun --set-emoji-font (frame)
      "Adjust the font settings of FRAME so Emacs can display emoji properly."
      (if (eq system-type 'darwin)
	  ;; For NS/Cocoa
	  (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
	;; For Linux
	(set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))

    ;; For when Emacs is started in GUI mode:
    (--set-emoji-font nil)
    ;; Hook for when a frame is created with emacsclient
    ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
    (add-hook 'after-make-frame-functions '--set-emoji-font))
#+end_src

**** DONE unicode-fonts.el

I’m uncertain why I included this, aside from “sure would be nice to have unicode fonts.”

#+begin_src emacs-lisp
  (use-package unicode-fonts
    :straight t
    :config (unicode-fonts-setup))
#+end_src

**** flycheck.el

- ~flycheck.el~ :: a syntax checkling package.  Paired with [[http://proselint.com][proselint]], I can check grammar and other things.  See http://flycheck.org

#+begin_src emacs-lisp
  (use-package flycheck
    :hook ((text-mode . flycheck-mode)
	   (gfm-mode . flycheck-mode)
	   (org-mode .  flycheck-mode)
	   (markdown-mode .  flycheck-mode))
    :config
    (add-to-list 'flycheck-checkers 'proselint)
    (flycheck-define-checker proselint
      "A linter for prose."
      :command ("proselint" source-inplace)
      :error-patterns
      ((warning line-start (file-name) ":" line ":" column ": "
		(id (one-or-more (not (any " "))))
		(message (one-or-more not-newline)
			 (zero-or-more "\n" (any " ") (one-or-more not-newline)))
		line-end))
      :modes (text-mode markdown-mode gfm-mode org-mode)))
#+end_src

**** consult-flycheck.el

- ~consult-flycheck.el~ :: Creates a minibuffer listing the flycheck errors and enables previews.  Quick nice for navigating the prose violations.

#+begin_src emacs-lisp
  (use-package consult-flycheck
    :after (consult flycheck)
    :straight t
    :bind (:map flycheck-command-map
		("!" . consult-flycheck)))
#+end_src

*** Modes

Emacs has the concept of modes.  Each buffer has one major mode and can have
multiple minor modes.  A major mode may derive from another major mode.

These modes impact lots of things; key bindings being one of them.

What follows are a list of modes presented in a somewhat random order.  Some
are major modes others are minor modes.

**** emmet-mode.el

- ~emmet-mode.el~ :: I’ve only scratched the surface of this.  Namely when I
  write a haiku, in my editor it type =pre.poem= followed by ~C-c C-e~ and that
  expands to a ~pre~ tag with the ~class="poem"~.  There's a lot more, but I
  write comparatively little HTML.

#+begin_src emacs-lisp
  (use-package emmet-mode
    :straight t
    :bind (("C-c C-e" . emmet-expand-yas ))
    :hook ((sgml-mode . emmet-mode)
	   (html-mode . emmet-mode)
	   (css-mode . emmet-mode)))
#+end_src

**** graphql-mode.el

- ~graphql-mode.el~ :: I started exploring graphql, so I suppose it’s time to bring in a proper mode
for syntax highlighting and what have you.

#+begin_src emacs-lisp
  (use-package graphql-mode
    :straight t)
#+end_src

**** web-mode.el

- ~web-mode.el~ :: Some configurations for web development.

#+begin_src emacs-lisp
  (use-package web-mode
    :straight t
    :config (setq web-mode-markup-indent-offset 2
		  web-mode-css-indent-offset 2
		  web-mode-code-indent-offset 2))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
#+end_src

Sometimes I want to edit svg files.  Often times if I open them directly in
Emacs, I want to edit them.  This setting helps with that default.  /Note:/
without this setting, Emacs will happily render the SVG as an image,

#+begin_src emacs-lisp
  (add-to-list `auto-mode-alist '("\\.svg\\'" . xml-mode))
#+end_src

**** plantuml-mode.el

- ~plantuml-mode.el~ :: A mode for working with PlantUML.  See https://plantuml.com.

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :config (setq plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  plantuml-default-exec-mode 'executable
		  org-plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  org-plantuml-exec-mode 'executable)
    :mode (("\\.plantuml\\'" . plantuml-mode))
    :straight t)
#+end_src

**** json-mode.el

- ~json.el~ :: In modern web-development, JSON is nigh unavoidable.

#+begin_src emacs-lisp
  (use-package json-mode :straight t)
#+end_src

**** json-reformat.el

- ~json-reformat.el~ :: Because JSON can be quite ugly, I want something to help tidy it up.

#+begin_src emacs-lisp
  (use-package json-reformat
    :straight t
    :after json-mode
    :init (setq json-reformat:indent-width 2))

#+end_src

**** go-mode.el

Every so often I stumble upon a Go package.  The ~go-mode~ package gives me the
syntax highlighting that makes reading ~Go-lang~ tolerable.

#+begin_src emacs-lisp
  (use-package go-mode :straight t)
#+end_src

**** markdown-mode.el

- ~markdown-mode.el~ :: Oh ubiquitous Markdown.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :straight t
    :hook ((markdown-mode . turn-on-visual-line-mode))
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "/usr/local/bin/pandoc"))
#+end_src

**** yaml-mode.el

- ~yaml-mode.el~ :: Visual parsing for yaml.

#+begin_src emacs-lisp
  (use-package yaml-mode :straight t)
#+end_src

**** lua-mode.el

- ~lua-mode.el~ :: For working with [[https://www.hammerspoon.org][Hammerspoon]]; which provides me the
  wonderful [[https://github.com/dmgerman/editWithEmacs.spoon/][edit with Emacs]].

#+begin_src emacs-lisp
  (use-package lua-mode :straight t)
#+end_src

**** git-modes.el

- ~git-modes.el~ :: For editing various Git configuration files.

#+begin_src emacs-lisp
  (use-package git-modes :straight t)
#+end_src

**** enh-ruby-mode.el

- ~enh-ruby-mode.el~ :: Emacs ships with ~ruby-mode.el~, but I’ve found that
  ~enh-ruby-mode.el~ has more convenient navigation functions:

  - ~enh-ruby-mark-defun~ :: Put mark at end of this Ruby definition, point at
    beginning.
  - ~enh-ruby-up-sexp~ :: Move up one balanced expression (sexp).
  - ~enh-ruby-toggle-block~ :: Toggle block type from do-end to braces or back.
  - ~enh-ruby-backward-sexp~ :: Move backward across one balanced expression
    (sexp).
  - ~enh-ruby-forward-sexp~ :: Move backward across one balanced expression
    (sexp).

#+begin_src emacs-lisp
  (use-package enh-ruby-mode
    :straight t
    :hook (enh-ruby-mode . (lambda () (setq fill-column 100)))
    :hook (enh-ruby-mode . eldoc-mode)
    :bind (:map enh-ruby-mode-map ("C-j" . avy-goto-char-timer))
    :mode (("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . enh-ruby-mode)))
  (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))
#+end_src

**** rspec-mode.el

- ~rspec-mode.el~ :: [[http://rspec.info][RSpec]] is my Ruby testing framework of choice.  As I’ve
  been doing much more extensive Ruby coding, I’ve been using a lot of:

  - ~rspec-toggle-spec-and-target~ :: Jump between spec and target;
    ~spec/models/user_spec.rb~ and ~app/models/user.rb~ respectively.
  - ~rspec-verify~ :: Run ~rspec~ for the current file; either the spec or the
    spec associated with the target.
  - ~rspec-verify-single~ :: Run ~rspec~ for the current line.

#+begin_src emacs-lisp
  (use-package rspec-mode
    :straight t
    ;; Ensure that we’re loading enh-ruby-mode before we do any rspec loading.
    :after enh-ruby-mode
    :custom (rspec-use-spring-when-possible nil)
    :bind (:map rspec-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :bind (:map enh-ruby-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :diminish 'rspec-mode)

  (eval-after-load 'rspec-mode '(rspec-install-snippets))
#+end_src

/Note:/ The =CMD= + =.= is a carryover from my [[https://macromates.com][Textmate]] and [[https://www.sublimetext.com/][Sublime Text]] days.
That’s one of those hot-keys almost burned into soul.
**** ruby-interpolation.el

- ~ruby-interpolation.el~ :: A simple package to expand ~#~ to ~#{<cursor>}~.

#+begin_src emacs-lisp
  ;; Nice and simple package for string interpolation.
  (use-package ruby-interpolation
    :straight t
    :diminish 'ruby-interpolation-mode
    :hook (enh-ruby-mode . ruby-interpolation-mode))
#+end_src

**** yard-mode.el

- ~yard-mode.el~ :: When writing Ruby documentation, I favor YARD syntax.  See https://yardoc.org fore more details.

#+begin_src emacs-lisp
  (use-package yard-mode
    :straight t
    :hook (enh-ruby-mode . yard-mode))
#+end_src

**** bundler.el

- ~bundler.el~ :: Adds the useful ~bundle-open~ command.

#+begin_src emacs-lisp
  (use-package bundler
    :straight (bundler :type git :host github :repo "endofunky/bundler.el"))
#+end_src

**** lsp-mode.el

- ~lsp-mode.el~ :: Language Server Protocol; provides some nice interactions with code.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :straight t
    :hook ((ruby-mode . lsp)
	   (enh-ruby-mode . lsp))
    :config (setq read-process-output-max (* 1024 1024 3)
		  lsp-completion-provider nil
		  lsp-completion-mode nil
		  lsp--show-message nil
		  lsp-idle-delay 1.00)
    :custom (lsp-keymap-prefix "C-c C-l")
    :commands (lsp))

  (with-eval-after-load 'lsp-mode
    (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration))
#+end_src

**** lsp-ui.el

- ~lsp-ui.el~ :: Some nice UI for LSP mode.

What I’m finding is that I occasionally use it, and it also has some flake-outs
as it relates to the minibuffer.

But a bit flakey.  For example, as I’m using ~consult-recent-file~, when I move
the minibuffer selection (via ~C-n~) to a Ruby file, ~consult-recent-file~
renders a preview of that file.  It appears that the ~lsp-mode~’s hooks loses
or pulls the focus away from the minibuffer to the previewed buffer.

This makes it hard to navigate for search candidates.  I find the preview very
helpful, so favor that over ~lsp-mode~.  With some “bisect” debugging, I’ve
found that this is related to the ~lsp-ui.el~ package.  In particular the
~lsp-ui-peek-mode~.

In other words, the functions are nice, but the interactions with other useful
packages don’t warrant including this.

#+begin_src emacs-lisp
  ;; This package provides some nice UI behavior for documentation and linting
  ;;
  ;; In particular, I like 'lsp-ui-peek-find-reference
  (use-package lsp-ui
    :straight t
    :hook ((enh-ruby-mode . lsp-ui-mode))
    :after lsp-mode)

  ;; By default indent levels are often 4; That is against what I've seen.
  (setq ruby-indent-level 2
	typescript-indent-level 2
	js-indent-level 2)

  ;; (add-hook 'emacs-lisp-mode 'eldoc-mode)
#+end_src

**** tree-sitter.el

- ~tree-sitter.el~ :: An incremental parsing library for languages.  See https://tree-sitter.github.io/tree-sitter/.

#+begin_src emacs-lisp
  ;; See https://github.com/emacs-tree-sitter/elisp-tree-sitter
  ;; Waiting on https://github.com/emacs-tree-sitter/elisp-tree-sitter/issues/197 to resolve.
  (use-package tree-sitter
    :straight (tree-sitter :host github :repo "emacs-tree-sitter/elisp-tree-sitter")
    :config
    (add-to-list 'tree-sitter-major-mode-language-alist '(enh-ruby-mode . ruby)))

  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)

  (use-package tree-sitter-langs
    :straight t)
#+end_src


  - Fringe
  - Modes

**** so-long.el

- ~so-long.el~ :: Really long files or long lines can cause problems for Emacs.  This mode helps with that.

#+begin_src emacs-lisp
  (use-package so-long
    :defer t
    :straight t
    :bind
    (:map so-long-mode-map
	  ("C-s" . isearch-forward)
	  ("C-r" . isearch-backward))
    :config (global-so-long-mode 1))
#+end_src

*** Transformations
**** titlecase.el

The rules of “titlecase” are confounding.  The ~titlecase.el~ package provides
numerous ways to cast a string to “titlecase.”  I chose wikipedia style as a
quasi-opinionated compromise.

#+begin_src emacs-lisp
  (use-package titlecase
    :straight (titlecase :host github :repo "duckwork/titlecase.el")
    :custom (titlecase-style 'wikipedia))
#+end_src
**** fill-sentences-correctly.el

- ~fill-sentences-correctly.el~ :: After using Emacs for awhile, with it’s
  sentence navigation, I’ve come to strongly favor two spaces after a period.
  The ~fill-sentences-correctly-mode~ ensures that ~fill-paragraph~
  (e.g. ~M-q~) preserves two spaces.

#+BEGIN_src emacs-lisp
  (use-package fill-sentences-correctly
    :straight (fill-sentences-correctly :host github :repo "duckwork/fill-sentences-correctly.el")
    :hook (fundamental-mode . fill-sentences-correctly-mode))
#+end_src

**** savekill.el

- ~savekill.el~ :: Write "kill" command inputs to disk.

#+begin_src emacs-lisp
  (use-package savekill :straight t)
#+end_src

**** math-at-point.el

- ~math-at-point.el~ :: Calculate math functions at point and message result in
  minibuffer.  See https://github.com/shankar2k/math-at-point.

#+begin_src emacs-lisp
  (use-package math-at-point
    :straight (math-at-point :type git :host github :repo "shankar2k/math-at-point")
    :bind ("C-c =" . math-at-point))
#+end_src

**** hippie-exp.el

- ~hippie-exp.el~ :: Using Hippie expand, I toggle through words already referenced.

#+begin_src emacs-lisp
  (use-package hippie-exp
    :straight t
    :config
    (setq hippie-expand-try-functions-list '(try-expand-dabbrev-visible
					     try-expand-dabbrev
					     try-expand-list
					     try-expand-all-abbrevs
					     try-expand-dabbrev-all-buffers
					     try-expand-dabbrev-from-kill
					     try-complete-file-name-partially
					     try-complete-file-name
					     try-complete-lisp-symbol-partially
					     try-complete-lisp-symbol
					     ))
    :bind (("M-SPC" . hippie-expand)))
#+end_src

**** expand-region.el

- ~expand-region.el~ :: a simple package that does two related things really
  well; expands and contracts the current region.  I use this all the time.

  In writing, with the cursor at point, when I expand it selects the word.  The
  next expand the sentence, then paragraph, then page.  In programming it
  leverages sexp.

#+begin_src emacs-lisp
  (use-package expand-region
    :straight t
    :bind (("C-=" . er/expand-region)
	   ("C-+" . er/contract-region)))
#+end_src

**** multiple-cursors.el

- ~multiple-cursors.el~ :: Allow Emacs to work with multiple cursors.  See
  https://melpa.org/#/multiple-cursors.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind (("C-M-SPC" . set-rectangular-region-anchor)
	   ("C->" . mc/mark-next-like-this)
	   ("C-<" . mc/mark-previous-like-this)
	   ("C-s-<mouse-1>" . mc/add-cursor-on-click)
	   ("C-c C->" . mc/mark-all-like-this)
	   ("C-c C-SPC" . mc/edit-lines)) ;; CTRL+CMD+c
    :straight t)
#+end_src

**** iedit.el

- ~iedit.el~ :: ~C-;~ to select current symbol and all matches; Then edit at
  multiple points.

#+begin_src emacs-lisp
  (use-package iedit :straight t)
#+end_src

**** crux.el

- ~crux.el~ :: A mix of a few odd and useful functions.

#+begin_src emacs-lisp
  (use-package crux
    :straight t
    :bind (("C-a" . crux-move-beginning-of-line)
	   ("<C-s-return>" . crux-smart-open-line-above)
	   ("C-s-k" . crux-kill-line-backwards)
	   ("<s-backspace>" . crux-kill-line-backwards)
	   ("<f9>" . crux-kill-other-buffers)))
#+end_src

**** ethan-wspace.el

- ~ethan-wspace-mode.el~ :: Whitespace hygene package.  The author's
  documentation and commentary echoes my sentiments.

#+begin_src emacs-lisp
  (use-package ethan-wspace
    :straight t
    :hook (before-save . delete-trailing-whitespace)
    :init (setq-default mode-require-final-newline nil)
    :config (global-ethan-wspace-mode 1))
#+end_src

**** unfill.el

- ~unfill.el~ :: Provides the reverse of ~fill-paragraph~, and a toggle fill and unfill.

#+begin_src emacs-lisp
  (use-package unfill
    :bind ("M-q" . unfill-toggle)
    :straight t)
#+end_src

**** undo-tree.el

- ~undo-tree.el~ :: Provides a UI for undo trees.  I'm not certain what I want
  to do with this.

#+begin_src emacs-lisp
  (use-package undo-tree
    :diminish
    :bind (("C-z" . undo)
	   ("C-s-z" . undo-tree-redo))
    :config
    (global-undo-tree-mode +1)
    (unbind-key "M-_" undo-tree-map))

#+end_src

**** hungry-delete.el

- ~hungry-delete.el~ :: Delete multiple spaces in one delete stroke.

#+begin_src emacs-lisp
  (use-package hungry-delete
    :straight t
    :diminish 'hungry-delete-mode
    :config (global-hungry-delete-mode))
#+end_src

**** move-text.el

- ~move-text.el~ :: A simple package ability to move lines up and down.

#+begin_src emacs-lisp
  (use-package move-text
    :straight t
    :bind (([C-s-down] . move-text-down)
	   ([C-s-up] . move-text-up)))
#+end_src

**** tempel.el

I have only provisionally adopted this.  I like the idea of abbreviations/snippets using emacs-lisp.  This is a “to be determined” package.

#+begin_src emacs-lisp
  (use-package tempel
    :straight (tempel :host github :repo "minad/tempel")
    :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
	   ("M-*" . tempel-insert))

    :init

    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; The depth is set to -1, such that `tempel-expand' is tried *before* the
      ;; programming mode Capf.  If a template name can be completed it takes
      ;; precedence over the programming mode completion. `tempel-expand' only
      ;; triggers on exact matches.  Alternatively use `tempel-complete' if you
      ;; want to see all matches, but then Tempel will probably trigger too
      ;; often when you don't expect it.
      (add-hook 'completion-at-point-functions #'tempel-expand -1 'local))

    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)

    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
    ;; (tempel-global-abbrev-mode)
    )

#+end_src

**** whole-line-or-region.el

- ~whole-line-or-region.el~ :: From the package commentary, “This minor mode
  allows functions to operate on the current line if they would normally
  operate on a region and region is currently undefined.”  I’ve used this for
  awhile and believe it’s not baked into my assumptions regarding how I
  navigation Emacs.

#+begin_src emacs-lisp
  (use-package whole-line-or-region
    :straight t
    :diminish 'whole-line-or-region-local-mode
    :config (whole-line-or-region-global-mode))
#+end_src

**** smartparens.el

- ~smartparens.el~ :: provides some “intelligent” treatment of parentheses.  I’ve been using this for awhile, so I assume it’s baked into my memory.

#+begin_src emacs-lisp
  (use-package smartparens :straight t)
#+end_src

**** grab-mac-link.el

- ~grab-mac-link.el~ :: Grab a link from a variety of MacOS applications.

#+begin_src emacs-lisp
  (use-package grab-mac-link
    :straight t
    ;; Ensuring we load these, as I'll need them later.
    :commands (grab-mac-link-safari-1 grab-mac-link-firefox-1)
    :config
    ;; A replacement function for existing grab-mac-link-make-html-link
    (defun jf/grab-mac-link-make-html-link (url name)
      "Using HTML syntax, link to and cite the URL with the NAME."
      (format "<cite><a href=\"%s\" class=\"u-url p-name\" rel=\"cite\">%s</a></cite>" url name))
    ;; The function advice to override the default behavior

    (advice-add
     'grab-mac-link-make-html-link
     :override
     'jf/grab-mac-link-make-html-link
     '((name . "jnf")))
    :bind (("C-c g" . grab-mac-link)))
#+end_src

**** org-mac-link.el

- ~org-mac-link.el~ :: Similar to ~grab-mac-link.el~ this specifically grabs a link and insersts in ~org-mode~ format.

#+begin_src emacs-lisp
  (use-package org-mac-link
    :straight (org-mac-link :type git :host github :repo "jeremyf/org-mac-link")
    :bind (:map org-mode-map (("C-c g" . org-mac-grab-link))))
#+end_src

*** TODO Typography

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  This package serves the purpose of assisting with adding
  ;;  characters that are not readily available on an ANSI keyboard.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; BEGIN Typography Menu
  ;;
  ;;  The purpose of the typography menu is to provide easier access to
  ;;  typographic characters that I use; It also provides a bit of a
  ;;  mnemonic device (e.g. "C-x 8 RET" searches for a character to insert).
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (use-package pretty-hydra
      :straight (pretty-hydra
		 :type git :host github :repo "jerrypnz/major-mode-hydra.el"
		 :files (:defaults (:exclude "major-mode-hydra.el"))))

  (defvar jf/typography--title
    (jf/all-the-icons--with-octicon "pencil" "Typography (C-x 8 RET for Search)" 1 -0.05)
    "The menu title for typography")
  (pretty-hydra-define jf/typography--menu (:foreign-keys warn :title jf/typography--title :quit-key "q" :exit t)
    ("Characters" (
		   ("d d" (insert "-") "- dash")
		   ("d m" (insert "—") "— em dash")
		   ("d n" (insert "–") "– en dash")
		   (". e" (insert "…") "… ellipsis")
		   (". d" (insert "·") "º degree")
		   (". m" (insert "·") "· middot")
		   ("t d" (insert "†") "† dagger")
		   ("t 2" (insert "‡") "‡ double dagger")
		   ("t s" (insert "§") "§ section")
		   ("t p" (insert "¶") "¶ paragraph")
		   ("? !" (insert "‽") "‽ Interobang")
		   )
     "Math" (
	     ("a x" (insert "×") "× Multiplication Sign")
	     ("a d" (insert "÷") "÷ Division Sign")
	     ("a m" (insert "−") "− Minus Sign")
	     ("a p" (insert "±") "± Plus or Minus Sign")
	     ("m n" (insert "¬") "¬ Negation")
	     ;; For declaring regex functions.  See
	     ;; https://www.johndcook.com/blog/2022/01/08/corner-quotes-in-unicode/
	     ;; and https://irreal.org/blog/?p=10265
	     ("c l" (insert "⌜") "⌜ Left Corner Quote")
	     ("c r" (insert " ⌟") "⌟ Right Corner Quote")
	     ;; Included as a reminder as I use these for menu structures
	     ("f h"   (insert "─") "─ Forms light horizontal")
	     ("f D l" (insert "┐") "┐ Forms light down and left")
	     ("f v"   (insert "│") "│ Forms light vertical")
	     ("f V r" (insert "├") "├ Forms light vertical and right")
	     ("f U r" (insert "└") "└ Forms light up and right")
	     )
     "Quotes" (
	       ("\" o" (insert "“") "“ Double quote open")
	       ("\" c" (insert "”") "” Doule quote close")
	       ("\" O" (insert "«") "« Guillemet open")
	       ("\" C" (insert "»") "» Guillemet close")
	       ("\" l" (insert "⌈") "⌈ Left ceiling")
	       ("' o" (insert "‘") "‘ Single quote open")
	       ("' c" (insert "’") "’ Single quote close")
	       ("' O" (insert "‹") "‹ Single guillemet open")
	       ("' C" (insert "›") "› Single guillemet close")
	       ("p 1" (insert "′") "′ Single Prime (feet, arcminutes)")
	       ("p 2" (insert "″") "″ Double Prime (inches, arcseconds)")
	       ("p 3" (insert "‴") "‴ Triple Prime"))
     ))

  (global-set-key (kbd "C-s-8") 'jf/typography--menu/body)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; END Typography Menu
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

**** TODO typopunct.el

#+begin_src emacs-lisp
  (use-package typopunct
    :straight t
    :config
    (add-hook 'org-mode-hook 'jf/typopunct-init)
    (defun jf/typopunct-init ()
      (require 'typopunct)
      (typopunct-change-language 'english)
      (typopunct-mode 1))
    (setq typopunct-buffer-language 'english)

    ;; To insert a typographical ellipsis sign (…) on three consecutive
    ;; dots, or a middle dot (·) on ‘^.’
    (defconst typopunct-ellipsis (decode-char 'ucs #x2026))
    (defconst typopunct-middot   (decode-char 'ucs #xB7)) ; or 2219
    (defun typopunct-insert-ellipsis-or-middot (arg)
      "Change three consecutive dots to a typographical ellipsis mark."
      (interactive "p")
      (cond
       ((and (= 1 arg)
	     (eq (char-before) ?^))
	(delete-char -1)
	(insert typopunct-middot))
       ((and (= 1 arg)
	     (eq this-command last-command)
	     (looking-back "\\.\\." 1))
	(replace-match "")
	(insert typopunct-ellipsis))
       (t
	(self-insert-command arg))))
    (define-key typopunct-map "." 'typopunct-insert-ellipsis-or-middot)


    (defconst typopunct-prime  (decode-char 'ucs #x2032)) ; feet, arcminutes, derivatives
    (defconst typopunct-dprime (decode-char 'ucs #x2033)) ; inches, arcseconds, double derivatives
    (defconst typopunct-tprime (decode-char 'ucs #x2034))

    ;; The minus sign (−) is separate from the hyphen (-), en dash (–) and
    ;; em dash (—). To build upon the clever behavior of the ‘-’ key
    (defconst typopunct-minus (decode-char 'ucs #x2212))
    (defconst typopunct-pm    (decode-char 'ucs #xB1))
    (defconst typopunct-mp    (decode-char 'ucs #x2213))
    (defadvice typopunct-insert-typographical-dashes
	(around minus-or-pm activate)
      (cond
       ((or (eq (char-before) typopunct-em-dash)
	    (looking-back "\\([[:blank:]]\\|^\\)\\^" 2))
	(delete-char -1)
	(insert typopunct-minus))
       ((looking-back "[^[:blank:]]\\^" 1)
	(insert typopunct-minus))
       ((looking-back "+/" 1)
	(progn (replace-match "")
	       (insert typopunct-pm)))
       (t ad-do-it)))
    (defun typopunct-insert-mp (arg)
      (interactive "p")
      (if (and (= 1 arg) (looking-back "-/" 2))
	  (progn (replace-match "")
		 (insert typopunct-mp))
	(self-insert-command arg)))
    (define-key typopunct-map "+" 'typopunct-insert-mp)
    (defconst typopunct-times (decode-char 'ucs #xD7))
    (defun typopunct-insert-times (arg)
      "Insert multiplication sign at ARG."
      (interactive "p")
      (if (and (= 1 arg) (looking-back "\\([[:blank:]]\\|^\\)\\^"))
	  (progn (delete-char -1)
		 (insert typopunct-times))
	(self-insert-command arg)))
    (define-key typopunct-map "x" 'typopunct-insert-times)

    (defadvice typopunct-insert-quotation-mark (around wrap-region activate)
      (let* ((lang (or (get-text-property (point) 'typopunct-language)
		       typopunct-buffer-language))
	     (omark (if single
			(typopunct-opening-single-quotation-mark lang)
		      (typopunct-opening-quotation-mark lang)))
	     (qmark (if single
			(typopunct-closing-single-quotation-mark lang)
		      (typopunct-closing-quotation-mark lang))))
	(cond
	 (mark-active
	  (let ((skeleton-end-newline nil)
		(singleo (typopunct-opening-single-quotation-mark lang))
		(singleq (typopunct-closing-single-quotation-mark lang)))
	    (if (> (point) (mark))
		(exchange-point-and-mark))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string omark)) (mark) t)
		(replace-match (regexp-quote (string singleo)) nil nil)))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string qmark)) (mark) t)
		(replace-match (regexp-quote (string singleq)) nil nil)))
	    (skeleton-insert (list nil omark '_ qmark) -1)))
	 ((looking-at (regexp-opt (list (string omark) (string qmark))))
	  (forward-char 1))
	 (t ad-do-it)))))
#+end_src

** Integrated “Applications”
*** TODO Variable/const definitions

#+begin_src emacs-lisp
  (defconst jf/tor-home-directory
    (file-truename "~/git/takeonrules.source")
    "The home directory of TakeOnRules.com Hugo repository.")

  (defconst jf/tor-hostname-default-local
    "http://localhost:1313"
    "The scheme, host name, and port for serving up a local TakeOnRules.com.")

  (defconst jf/tor-hostname-default-remote
    "https://takeonrules.com"
    "The scheme and host name for TakeOnRules.com.")

  (defvar jf/tor-hostname-current
    jf/tor-hostname-default-local
    "What is the current hostname for serving TakeOnRules content.")

  (defvar jf/data-directories
    (list
     jf/tor-home-directory
     "~/git/takeonrules.source/themes/hugo-tufte"
     "~/git/burning_wheel_lifepaths/"
     "~/git/emacs-bookmarks"
     "~/git/dotzshrc/"
     "~/git/dotemacs/"
     "~/git/org/"
     "~/git/org/archive")
    "Relevant data directories for my day to day work.")
#+end_src

*** Knowledge Management

By now, with all that I’ve written, it should be evident that knowledge
management is both a critical need and something that Emacs must certainly
support.

Another “killer feature” of Emacs is org-mode and it’s constellation of
packages.

**** org-mode.el

Oh ~org-mode~, one of the “why you should use Emacs” packages.  It’s a set of
organizational tools that allow for progressive adoption.  You can start
writing in ~org-mode~ syntax and leave it at that.  From there you can delve
further into the ~org-mode~ ecosystem.

A bit of pre-amble.  I maintain a list of data directories, each might have
“relevant to org-mode” files.  The ~jf/org-agenda-files~ reads the file
system to gather sources for ~org-mode~ agenda.

#+begin_src emacs-lisp
  (cl-defun jf/org-agenda-files (&key
				  (paths jf/data-directories)
				  (basenames '("agenda.org")))
    "Return the list of filenames where BASENAMES exists in PATHS."
    ;; I want to include my configuration file in my agenda querying.
    (setq returning-list '("~/git/dotemacs/emacs.d/configuration.org"))
    (dolist (path paths)
      (dolist (basename basenames)
	(when (f-exists-p (f-join path basename))
	    (add-to-list 'returning-list (f-join path basename)))))
    returning-list)
#+end_src

The rudimentary configuration of my ~org-mode~.  Later, I write about
~org-roam~ which introduces my more generalized note taking system.

#+begin_src emacs-lisp
  (use-package org
    :straight (org :type built-in)
    :hook (org-mode . turn-on-visual-line-mode)
    :config (setq
	     org-directory (file-truename "~/git/org")
	     org-agenda-files (jf/org-agenda-files
			       :paths jf/data-directories
			       :basenames '("agenda.org"))
	     org-default-notes-file (concat
				     org-directory
				     "/captured-notes.org")
	     org-todo-keywords '((sequence
				  "TODO"
				  "WAITING"
				  "|"
				  "DONE")))
    (setq org-capture-templates
	  '(("@"
	     "All Todo"
	     entry (file "~/git/org/agenda.org")
	     "* TODO %?\n  %i\n  %a"
	     :empty-lines-before 1)))

    (org-babel-do-load-languages 'org-babel-load-languages
				 (append org-babel-load-languages
					 '((emacs-lisp . t)
					   (plantuml . t)
					   (ruby . t))))
    ;; Make TAB act as if it were issued from the buffer of the languages's major
    ;; mode.
    :custom (org-src-tab-acts-natively t)
    :bind (:map org-mode-map
		("C-c l i". jf/org-insert-link-dwim))
    :bind (("C-c l s" . org-store-link)
	   ("C-c a" . org-agenda)
	   ("C-c c" . org-capture)
	   ("C-s-t" . org-toggle-link-display)))

  (defun my-org-confirm-babel-evaluate (lang body) nil)
  (setq org-confirm-babel-evaluate #'my-org-confirm-babel-evaluate)

  ;; To make Org mode take care of versioning of attachments for you,
  ;; add the following to your Emacs config:
  (require 'org-attach-git)

  ;; See
  ;; https://www.reddit.com/r/orgmode/comments/i6hl8b/image_preview_size_in_org_mode/
  ;; for further discussion
  ;;
  ;; One consideration is that the below setq should be called as part
  ;; of the `org-toggle-inline-images`.  <2020-11-14 Sat 12:09>: I
  ;; commented out the lines below as it created a very small image
  ;; (about the size of one character).  (setq org-image-actual-width
  ;; (truncate (* (window-pixel-width) 0.8)))


  ;; I'd prefer to use the executable, but that doe not appear to be the
  ;; implementation of org-babel.
  (setq org-plantuml-jar-path (concat (string-trim (shell-command-to-string "brew-path plantuml")) "/libexec/plantuml.jar"))
#+end_src

I cribbed the following function from [[https://xenodium.com/emacs-dwim-do-what-i-mean/][Emacs DWIM: do what ✨I✨ mean]].

#+begin_src emacs-lisp
  (defun jf/org-insert-link-dwim ()
	"Like `org-insert-link' but with personal dwim preferences."
	(interactive)
	(let* ((point-in-link (org-in-regexp org-link-any-re 1))
	       (clipboard-url (when (string-match-p "^http" (current-kill 0))
				(current-kill 0)))
	       (region-content (when (region-active-p)
				 (buffer-substring-no-properties (region-beginning)
								 (region-end)))))
	  (cond ((and region-content clipboard-url (not point-in-link))
		 (delete-region (region-beginning) (region-end))
		 (insert (org-make-link-string clipboard-url region-content)))
		((and clipboard-url (not point-in-link))
		 (insert (org-make-link-string
			  clipboard-url
			  (read-string "title: "
				       (with-current-buffer (url-retrieve-synchronously clipboard-url)
					 (dom-text (car
						    (dom-by-tag (libxml-parse-html-region
								 (point-min)
								 (point-max))
								'title))))))))
		(t
		 (call-interactively 'org-insert-link)))))
#+end_src

***** Copy Org and Paste in Rich Text Format

Org Mode has built-in capabilities for exporting to HTML (and other languages).
The following function does just a bit more.  It converts the org region to
HTML and sends it to the clipboard as an RTF datatype.

Why is that nice?  As an RTF datatype, the paste receiver better handles the
HTML (e.g., I can more readily paste into an Email and it pastes as expected).

See [[https://kitchingroup.cheme.cmu.edu/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/][Copy formatted org-mode text from Emacs to other applications]] for more details.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-s-c") 'jf/formatted-copy-org-to-html)
  (defun jf/formatted-copy-org-to-html ()
    "Export region to HTML, and copy it to the clipboard."
    (interactive)
    (save-window-excursion
      (let* ((buf (org-export-to-buffer 'html "*Formatted Copy*" nil nil t t))
	     (html (with-current-buffer buf (buffer-string))))
	(with-current-buffer buf
	  (shell-command-on-region
	   (point-min)
	   (point-max)
	   "textutil -inputencoding UTF-8 -stdin -format html -convert rtf -stdout | pbcopy"))
	(kill-buffer buf))))

  (use-package htmlize
    :straight t)
#+end_src

***** Swapping Tilde and Backtick in Org and More

I jump between Markdown and Org Mode with some frequency.  In many cases I
prefer Org Mode.  Except when it comes to code declaration.  The tilde (e.g.,
=~=) is cumbersome compared to the backtick (e.g., =`=).

What follows came from [[http://mbork.pl/2022-01-17_Making_code_snippets_in_Org-mode_easier_to_type][Marcin Borkowski: 2022-01-17 Making code snippets in
Org-mode easier to type]].

Now when I type =~~~=, I get a source block.  And I can even default that block
to a specific language (via ~org-insert-tilde-language~).

#+begin_src emacs-lisp
  (define-key org-mode-map (kbd "~") #'org-insert-backtick)
  (defun org-insert-backtick ()
    "Insert a backtick using `org-self-insert-command'."
    (interactive)
    (setq last-command-event ?`)
    (call-interactively #'org-self-insert-command))

  (defvar-local org-insert-tilde-language nil
    "Default language name in the current Org file.
  If nil, `org-insert-tilde' after 2 tildes inserts an \"example\"
  block.  If a string, it inserts a \"src\" block with the given
  language name.")

  (define-key org-mode-map (kbd "`") #'org-insert-tilde)
  (defun org-insert-tilde ()
    "Insert a tilde using `org-self-insert-command'."
    (interactive)
    (if (string= (buffer-substring-no-properties (- (point) 3) (point))
		 "\n~~")
	(progn (delete-char -2)
	       (if org-insert-tilde-language
		   (insert (format "#+begin_src %s\n#+end_src"
				   org-insert-tilde-language))
		 (insert "#+begin_example\n#+end_example"))
	       (forward-line -1)
	       (if (string= org-insert-tilde-language "")
		   (move-end-of-line nil)
		 (org-edit-special)))
      (setq last-command-event ?~)
      (call-interactively #'org-self-insert-command)))
#+end_src

**** org-menu.el

- ~org-menu.el~ :: Context dependent menu for org-mode; leverages ~transient.el~.

#+begin_src emacs-lisp
  (use-package org-menu
    :straight (org-menu :host github :repo "sheijk/org-menu")
    :bind (:map org-mode-map ("C-c m" . 'org-menu)))
#+end_src

**** OrgRoam

This is my third iteration on an ~org-roam~.  It's goal is to address use-cases
that I've encountered while moving more of my note-taking with ~org-roam~.

One use-case is when I'm running or playing in an RPG session.  During those
sessions, when I create/find/insert nodes, I almost want to leverage the same
tags.  That can be in my capturing of nodes or in my searching for nodes.  This
is something I observed while running my 13 session "Thel Sector" campaign.

A second use-case is when I'm writing notes or thoughts related to work.  In a
past life, I might have written notes for either my employer or Samvera (a
community in which I participated).  Those notes might overlap but rarely did.

While I’m writing those notes, if I’m developing out concepts, I might want to
filter my captures and searches to similar tags.

Another use case is less refined, namely I'm writing but am not "in" a specific
context.

However, v2 of my org-roam structure[fn:1], didn't quite get out of
the way.  I never quite got to the speed of note taking that I had for the
original Thel Sector campaign.

What follows builds on Jethro Kuan's [[https://jethrokuan.github.io/org-roam-guide/][How I Take Notes with Org-roam]].  Reading
Jethro Kuan's post helped me see how I could do this.

***** Preliminaries

The ~jf/org-roam-capture-templates-plist~ variable defines the possible
org-roam capture templates that I will use.  I have chosen to narrow these to
three types:

- ~refs~ :: References to other people’s thoughts.
- ~main~ :: My thoughts, still churning, referencing other thoughts.
- ~pubs~ :: My thoughts, published and ready to share.  Referencing any
  thoughts I’ve captured (and probably more).

/Note:/ I chose to go with 4 character types to minimize it’s impact on
rendering “type” in the search results (4 characters requires less visual space
than 10 characters).

#+begin_src emacs-lisp
  (defvar jf/org-roam-capture-templates-plist
    (list
     ;; These are references to "other people's thoughts."
     :refs '("r" "refs" plain "%?"
	     :if-new (file+head "refs/%<%Y%m%d>---${slug}.org" "#+title: ${title}\n#+FILETAGS:\n")
	     :unnarrowed t)
     ;; These are "my thoughts" with references to "other people's thoughts."
     :main '("m" "main" plain "%?"
	     :if-new (file+head "main/%<%Y%m%d>---${slug}.org"
				"#+title: ${title}\n#+FILETAGS: ${auto-tags}\n")
	     :immediate-finish t
	     :unnarrowed t)
     ;; These are publications of "my thoughts" referencing "other people's thoughts".
     :pubs '("p" "pubs" plain "%?"
	     :if-new (file+head "pubs/%<%Y%m%d>---${slug}.org" "#+title: ${title}\n#+FILETAGS:\n")
	     :immediate-finish t
	     :unnarrowed t))
    "Templates to use for `org-roam' capture.")
#+end_src

The ~jf/org-context-plist~ defines and names some of the contexts in which I
might be writing.  Each named context defines the associated tags.  These are
the tags that all nodes will have when they are written in the defined context.

Loosely related is the ~jf/org-auto-tags--current-list~; Contexts are a named
set of tags.  However, other functions don’t operate based on context.  They
instead operated based on the tags.

#+begin_src emacs-lisp
  (defvar jf/org-context-plist
    (list
     :none
     (list
      :name "none"
      :tags (list))

     :burning-locusts
     (list
      :name "burning-locusts"
      :tags '("burning-locusts"
	      "rpg"
	      "burning-wheel"))

     :forem
     (list
      :name "forem"
      :tags '("forem"))

     :mistimed-scroll
     (list
      :name "mistimed-scroll"
      :tags '("eberron"
	      "mistimed-scroll"
	      "rpg"
	      "burning-wheel"))
     :thel-sector
     (list
      :name "thel-sector"
      :tags '("thel-sector"
	      "rpg" "swn")))
    "A list of contexts that I regularly write about.")

  (defvar jf/org-auto-tags--current-list
    (list)
    "The list of tags to automatically apply to an `org-roam' capture.")
#+end_src

I can use ~jf/org-auto-tags--set~ to create an ad hoc context, or perhaps a
"yet to be named" context.  I can use ~jf/org-auto-tags--set-by-context~ to
establish the current context (or clear it).

#+begin_src emacs-lisp
  (defun jf/org-auto-tags--set (tags)
    "Prompt user or more TAGS."
    (interactive
     (list
      (completing-read-multiple
       "Tag(s): " (org-roam-tag-completions))))
    (setq jf/org-auto-tags--current-list tags))

  (cl-defun jf/org-context-list-completing-read
      (&key
       (context-plist
	jf/org-context-plist))
    "Create a list of contexts from the CONTEXT-PLIST for completing read.

	 The form should be '((\"forem\" 1) (\"burning-loscusts\" 2))."
    ;; Skipping the even entries as those are the "keys" for the plist,
    ;; the odds are the values.
    (-non-nil (seq-map-indexed
	       (lambda (context index)
		 (when (oddp index)
		   (list (plist-get context :name) index)))
	       context-plist)))

  (cl-defun jf/org-auto-tags--set-by-context
      (context
       &key
       (context-plist jf/org-context-plist))
    "Set auto-tags by CONTEXT.

     Prompt for CONTEXT from CONTEXT-PLIST."
    (interactive
     (list
      (completing-read
       "Context: " (jf/org-context-list-completing-read))))
    (setq jf/org-auto-tags--current-list
	  (plist-get
	   (plist-get
	    context-plist (intern (concat ":" context)))
	   :tags)))
#+end_src

With the ~jf/org-auto-tags--current-list~ variable set, I want a function to
inject those tags onto my captures.  Looking at the [[https://www.orgroam.com/manual.html#Org_002droam-Template-Expansion][org-roam docs on template
expansion]], I want to create a function named ~org-roam-node-auto-tags~.

#+begin_src emacs-lisp
  (cl-defun org-roam-node-auto-tags
      (node
       &key
       (tag-list jf/org-auto-tags--current-list))
    "Inject the TAG-LIST into the {auto-tags} region of captured NODE.

       See https://www.orgroam.com/manual.html#Template-Walkthrough"
    (if (and tag-list (> (length tag-list) 0))
	(concat ":" (s-join ":" tag-list) ":")
      ""))
#+end_src

And finally, we have functions to use for establishing what templates are
available based on the context, as well as what to setup as the default
filter-fn for org-capture.

In other words, when I have set one or more tags, I want to use the templates
appropriate for those tags and filter my org-roam-nodes so that only those
nodes that have all of the tags are candidates.

#+begin_src emacs-lisp
  (cl-defun jf/org-roam-templates-list
      (template
       &key
       (template-plist jf/org-roam-capture-templates-plist))
    "List of `org-roam' capture templates based on the given TEMPLATE.

       Searches the TEMPLATE-PLIST for the templates.

       Note, the :all template assumes we use the whole list."
    (if (eq template :all)
	(-non-nil
	 (seq-map-indexed
	  (lambda (tmp index)
	    (when (oddp index)
	      tmp))
	  template-plist))
      (list (plist-get template-plist template))))

  (cl-defun jf/org-roam-templates-context-fn
      (&key
       (tag-list jf/org-auto-tags--current-list))
    "Returns a set of templates based on TAG-LIST.

       A key assumption is that if there's a default tag list, use the
       :main template."
    (if (and tag-list (> (length tag-list) 0))
	(jf/org-roam-templates-list :main)
      (jf/org-roam-templates-list :all)))

  (cl-defun jf/org-roam-filter-context-fn
      (node
       &key
       (tag-list jf/org-auto-tags--current-list))
    "Determine TAG-LIST is subset of NODE's tags."
    ;; gnus-subsetp is a more "permissive" version of subsetp.  It doesn't
    ;; consider order.  And looks at strings as equal if their values are the
    ;; same.
    (gnus-subsetp tag-list (org-roam-node-tags node)))
#+end_src

***** Configuration

I wrote three functions to mirror three core functions of org-mode:

- ~jf/org-roam-capture~ :: find or create a node and file it away.
- ~jf/org-roam-node-insert~ :: find or create a node and insert a link to that
  node.  This is my “take notes quick” function.
- ~jf/org-roam-find-node~ :: find a node and open that node in the frame.

For each of those functions, I establish the filter based on the current
context and/or tags.  I also limit the available capture templates based on the
context.

#+begin_src emacs-lisp
  (defun jf/org-roam-capture
      (&optional
       goto
       keys)
    "Call `org-roam-capture' based on set tags."
    (interactive "P")
    (org-roam-capture
     goto
     keys
     :filter-fn 'jf/org-roam-filter-context-fn
     :templates (jf/org-roam-templates-context-fn)))

  (defun jf/org-roam-node-insert ()
    "Call `org-roam-node-insert' based on set tags."
    (interactive)
    (org-roam-node-insert
     'jf/org-roam-filter-context-fn
     :templates (jf/org-roam-templates-context-fn)))

  (defun jf/org-roam-find-node
      (&optional
       other-window
       initial-input)
    "Call `org-roam-node-find' based on set tags."
    (interactive current-prefix-arg)
    (org-roam-node-find
     other-window
     initial-input
     'jf/org-roam-filter-context-fn
     :templates 'jf/org-roam-templates-context-fn))
#+end_src

And with all of that, let’s get into the org-roam configuration.

#+begin_src emacs-lisp
  (use-package org-roam
    :straight t
    :config
    ;; I encountered the following message when attempting to export data:
    ;;
    ;; => "org-export-data: Unable to resolve link: EXISTING-PROPERTY-ID"
    ;;
    ;; See https://takeonrules.com/2022/01/11/resolving-an-unable-to-resolve-link-error-for-org-mode-in-emacs/ for details
    (defun jf/force-org-rebuild-cache ()
      "Call some functions to rebuild the `org-mode' and `org-roam' cache."
      (interactive)
      (org-id-update-id-locations)
      ;; Note: you may need `org-roam-db-clear-all' followed by `org-roam-db-sync'
      (org-roam-db-sync)
      (org-roam-update-org-id-locations))
    :custom
    (org-roam-directory (file-truename "~/git/org"))
    (org-roam-node-display-template
     (concat "${type:4}   ${title:*} "
	     (propertize "${tags:40}" 'face 'org-tag)))
    (org-roam-capture-templates (jf/org-roam-templates-list :all))
    :bind (("C-s-f" . jf/org-roam-find-node)
	   ("C-s-c" . jf/org-roam-capture))
    :bind (:map org-mode-map
		(
		 ("C-s-;" . org-roam-buffer-toggle)
		 ("s-i" . jf/org-roam-node-insert)))
    :init
    ;; Help keep the `org-roam-buffer', toggled via `org-roam-buffer-toggle', sticky.
    (add-to-list 'display-buffer-alist
		 '("\\*org-roam\\#"
		   (display-buffer-in-side-window)
		   (side . right)
		   (slot . 0)
		   (window-width . 0.33)
		   (window-parameters . ((no-other-window . t)
					 (no-delete-other-windows . t)))))
    ;; When t the autocomplete in org documents will query the org roam database
    (setq org-roam-completion-everywhere t)
    (setq org-roam-v2-ack t)
    (org-roam-db-autosync-mode))

  ;; This needs to be after the `org-roam’ declaration as it is dependent on the
  ;; structures of `org-roam'.
  (cl-defmethod org-roam-node-type ((node org-roam-node))
    "Return the TYPE of NODE."
    (condition-case nil
	(file-name-nondirectory
	 (directory-file-name
	  (file-name-directory
	   (file-relative-name
	    (org-roam-node-file node)
	    org-roam-directory))))
      (error "")))
#+end_src

All told, the past experience when running [[https://takeonrules.com/series/new-vistas-in-the-thel-sector/][New Vistas in the Thel Sector //
Take on Rules]] informed how I thought about my note taking.

***** Other Contexts

Try as I may, based on my configuration, I can’t get [[https://orgmode.org/manual/Protocols.html#Protocols][org-protocol]] to work.  So
I’ve opted to take a different path; write some Emacs functions instead.

- ~jf/org-roam-capture-ref~ :: Capture a “refs” context ~org-roam-node~ for the given title and url.
- ~jf/menu--org-capture-elfeed-show~ :: Capture an RSS entry.
- ~jf/menu--org-capture-firefox~ :: Capture the active tab of Firefox.
- ~jf/menu--org-capture-safari~ :: Capture the active tab of Safari.

These tie into my the context and auto-tags.

#+begin_src emacs-lisp
  (cl-defun jf/org-roam-capture-ref (&key title url)
    "Capture the TITLE and URL in the `org-roam' :refs template"
    ;; If your installation of org-roam includes the fix fore
    ;; https://github.com/org-roam/org-roam/issues/2078 then you can leave the
    ;; below commented out.
    ;;
    ;; This looks a bit odd, but to capture the :ref we need the callback from org-roam.
    ;; (require 'org-roam-protocol)
    ;;
    (org-roam-capture-
     :keys "r"
     ;; TODO: I would love to get tags working but I'm missing something
     :node (org-roam-node-create :title title)
     :info (list :ref url)
     :props '(:immediate-finish nil)
     :templates (jf/org-roam-templates-list :refs)))

  (cl-defun jf/menu--org-capture-elfeed-show (&key (entry elfeed-show-entry))
    "Create an `org-roam-node' from elfeed ENTRY."
    (interactive)
    (let ((url (elfeed-entry-link entry))
	  (title (elfeed-entry-title entry)))
      (jf/org-roam-capture-ref :url url :title title)))

  (defun jf/menu--org-capture-firefox ()
    "Create an `org-roam-node' from Firefox page.

    Depends on the `grab-mac-link' package."
    (interactive)
    (let* ((link-title-pair (grab-mac-link-firefox-1))
	   (url (car link-title-pair))
	   (title (cadr link-title-pair)))
      (jf/org-roam-capture-ref :url url :title title)))

  (defun jf/menu--org-capture-safari ()
    "Create an `org-roam-node' from Safari page.

    Depends on the `grab-mac-link' package."
    (interactive)
    (let* ((link-title-pair (grab-mac-link-safari-1))
	   (url (car link-title-pair))
	   (title (cadr link-title-pair)))
      (jf/org-roam-capture-ref :url url :title title)))

  (defun jf/menu--org-capture-eww ()
    "Create an `org-roam-node' from `eww' data"
    (interactive)
    (let* ((url (plist-get eww-data :url))
	   (title (plist-get eww-data :title)))
      (jf/org-roam-capture-ref :url url :title title)))
#+end_src

***** Conclusion

This is the core of my note taking engine.  It builds on the idea that I want
to reduce the number of decisions I make.  This is extremely important when I’m
writing session notes.

While I’m playing in a session, my entire context ideally collapses to the
relevant tags that I’ve established at the beginning of the session.  That way
I’m certain that I’m filing away notes to their proper location.

**** org-d20.el

- ~org-d20.el~ :: I’m really only using this for the ~org-d20--roll~ function.

#+begin_src emacs-lisp
  (use-package org-d20
    :after org
    :bind  (("C-s-r" . jf/roll-expression-dwim))
    :config
    (defun jf/roll-expression-dwim (expression &optional)
      "Roll the EXPRESSION, check `thing-at-point' then prompt."
      (interactive (list (if (string-match
			      "[dD][0-9]"
			      (format "%s" (thing-at-point 'sexp t)))
			     (thing-at-point 'sexp t)
			   (read-string "Dice Expression: "))))
      (-let* (((rolls . result) (org-d20--roll expression)))
	(message "%s => %s" expression result)))
    :straight (org-d20 :host github :repo "spwhitton/org-d20"))
#+end_src

**** Indesk

When running an RPG, I might have one or more books that I want to reference.
With physical books, I might rely on positional memory to help me navigate to
the section (e.g., it’s just a bit before the middle page).  I also rely on
both the index and the table of contents.

For this package, I’m first focusing on handling table of contents , though an
index would follow similar principles.  The reason for a “table of contents
first” approach is the tool chain for extracting table of contents is easier.
The ~pdftocio~ will extract the embedded table of contents from PDFs.

***** Data Structure

Much like my org-roam contexts, which I wrote about in [[https://takeonrules.com/2022/02/07/org-roam-emacs-and-ever-refining-the-note-taking-process/][Org Roam, Emacs, and
Ever Refining the Note Taking Process]], I am thinking of a conceptual book
shelf.  Each book on the would have the following attributes:

- title :: The title
- pdf path :: The path to the PDF
- tags :: These can be repurposed org-roam tags
- table of contents :: A parseable list of entries, each entry being the “name”
  and “page number”

/Note:/ It is my understanding that I could almost certainly use an org-mode
document for this information, and thus repurpose org-roam.  However, org-roam
would not be a required dependency.

***** Desired Functionality

I can choose the books I’m referencing; bringing them to my desk if you will.
I would then use a ~completing-read~ function to search the table of content
entries of the books on my desk.

Each candidate in the search would show the entry, page, and file basename.
Selecting a candidate opens the associated PDF to the respective page.

****** Create a reference org document

My initial thought is to store each book as an org document.  Org Mode provides
a means of describing each of those attributes.

You can see [[id:FC017488-D8EC-43DE-A35D-4D10A87B6A0D]["The Burning Wheel - Gold Edition Revised" by Luke Crane]] as the
resulting document.  An added benefit is that ~consult-imenu~ already parses
some of it; though it stops at heading level 2.  But that’s a future concern.

What this now means is I have a file that I’m confident I can parse, and can
slot into my existing note taking system.  I could see a case where that future
completing read could either take me to the org file’s node, or open the PDF to
that page.

In the case of the org file’s node, that would be a great place for annotations
and summary notes.

****** Phase 1 Functions

I want a script to convert the output of ~pdftocio~ to an org file for indesk.
That script should provide a title and a path.  I tried to use emacs-lisp for
this but ~pdftocio~ had other plans.  Instead I wrote a Ruby script.

I want to create a list of files that are on my current work desk.

#+begin_src emacs-lisp
  (defvar jf/indesk-current-files-on-desk
    nil
    "The list of files that are on the current work desk.")
#+end_src

That list of files will be populated with a completing read function.  I’m
uncertain what narrowing function I might want to consider.  For now let’s just
cheat.

#+begin_src emacs-lisp
  (cl-defun jf/indesk-file-candidates-for-cr (&key (dir org-directory) (tag ":indesk:"))
    "Get a list of files in DIR with TAG.

  This list is well suited for a completing read."
    (s-split "\n"
	     (s-trim
	      (shell-command-to-string
	       (concat "rg \"" tag "\" " dir " --files-with-matches")))))

  (cl-defun jf/indesk-current-files-on-desk--set (files)
    "Select FILES to use as source for work desk."
    (interactive
     (list
      (completing-read-multiple "Files(s): " (jf/indesk-file-candidates-for-cr))))
    (setq jf/indesk-current-files-on-desk files))
#+end_src

With that list of files on my desk, I want a function to select and jump to an
org heading element.

/Note:/ Given that I use ~consult~, experiments have lead me to believe I can
put a wrapper around ~consult-org-heading~ that passes the scope parameter.

#+begin_src emacs-lisp
  (global-set-key (kbd "s-2") 'jf/indesk-jump-to-file)
  (cl-defun jf/indesk-jump-to-file (&key (files jf/indesk-current-files-on-desk))
    "Jump to a heading from one of the FILES.

  If no FILES given, invoke `consult-imenu'."
    (interactive)
    (if (or (eq nil files) (seq-empty-p files))
	(if (derived-mode-p 'org-mode)
	    (consult-org-heading)
	  (consult-imenu))
      (consult-org-heading nil files)))
#+end_src

Given my ~jf/menu~, I probably should see what’s on my desk.  Let’s write a
transient function for that.

#+begin_src emacs-lisp
  (defun jf/indesk-current-files--shorten ()
    (-map
     (lambda (file) (file-name-nondirectory file))
     jf/indesk-current-files-on-desk))

  (transient-define-suffix jf/indesk-current-files-on-desk--transient (files)
    "Select FILES to use as source for work desk."
    :description '(lambda ()
		    (concat
		     "Indesk Files:"
		     (propertize
		      (format "%s" (jf/indesk-current-files--shorten))
		      'face 'transient-argument)))
    (interactive
     (list
      (completing-read-multiple "Files(s): " (jf/indesk-file-candidates-for-cr))))
    (setq jf/indesk-current-files-on-desk files))
#+end_src



*** RSS Feed

**** elfeed.el

- ~elfeed.el~ :: An Emacs RSS reader.  I’ve used Google Reader, Feedly,
  Inoreader, and Newsboat.  I wrote about [[https://takeonrules.com/2020/04/12/switching-from-inoreader-to-newsboat-for-rss-reader/][Switching from Inoreader to Newsboat
  for RSS Reader]], and the principles apply for Elfeed.

#+begin_src emacs-lisp
  (use-package elfeed
    :straight t
    :after org
    :hook ((elfeed-show-mode . jf/reader-visual))
    :config
    (setq-default elfeed-search-filter "@2-days-ago +unread ")
    :bind (
	   (:map elfeed-search-mode-map
		 ("q" . jf/elfeed-save-db-and-bury))))

  ;;write to disk when quiting
  (defun jf/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

  (defun jf/elfeed-load-db-and-open ()
    "Load the elfeed db from disk before opening"
    (interactive)
    (elfeed)
    (elfeed-update)
    (elfeed-db-load)
    (elfeed-search-update--force))
  (defalias 'rss 'jf/elfeed-load-db-and-open)

    ;; From https://karthinks.com/blog/lazy-elfeed/
  (defun elfeed-search-show-entry-pre (&optional lines)
    "Returns a function to scroll forward or back in the Elfeed
    search results, displaying entries without switching to them."
    (lambda (times)
      (interactive "p")
      (forward-line (* times (or lines 0)))
      (recenter)
      (call-interactively #'elfeed-search-show-entry)
      (select-window (previous-window))
      (unless elfeed-search-remain-on-entry (forward-line -1))))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "n") (elfeed-search-show-entry-pre +1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "p") (elfeed-search-show-entry-pre -1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "M-RET") (elfeed-search-show-entry-pre)))
  ;; End https://karthinks.com/blog/lazy-elfeed/
#+end_src


**** elfeed-org.el

- ~elfeed-org.el~ :: a package for maintaining and organizating my RSS
  subscriptions in ~org-mode~ format.

#+begin_src emacs-lisp
  (use-package elfeed-org
    :straight t
    :after elfeed
    :config (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/git/org/elfeed.org")))
#+end_src

*** Source Control
**** magit.el

- ~magit.el~ :: The awesome [[http://git-scm.com][git]] client for Emacs.  I’ve written a few functions
  to help me jump to the Github page for the pull request.[fn:3]

  - ~jf/magit-browse-pull-request~ :: In ‘magit-log-mode’ open the associated
    pull request.
  - ~jf/git-current-remote-url~ :: Get the current remote url.
  - ~jf/open-pull-request-for~ :: Given the SUMMARY open the related pull
    request.
  - ~jf/open-pull-request-for-current-line~ :: For the current line open the
    applicable pull request.

#+begin_src emacs-lisp
  (use-package magit
    :straight t
    :init (use-package with-editor :straight t)

    ;; Adding format to git-commit-fill-column of 72 as best practice.
    (setq git-commit-fill-column 72)

    ;; Keeping the summary terse helps with legibility when you run a
    ;; report with only summary.
    (setq git-commit-summary-max-length 50)

    ;; Set the tabular display columns for the `magit-list-repositories'
    (setq magit-repolist-columns
	  '(("Name"    25 magit-repolist-column-ident ())
	    ("Version" 25 magit-repolist-column-version ())
	    ("δ"        1 magit-repolist-column-dirty ())
	    ("⇣"        3 magit-repolist-column-unpulled-from-upstream
	     ((:right-align t)
	      (:help-echo "Upstream changes not in branch")))
	    ("⇡"        3 magit-repolist-column-unpushed-to-upstream
	     ((:right-align t)
	      (:help-echo "Local changes not in upstream")))
	    ("Branch"  25 magit-repolist-column-branch ())
	    ("Path"    99 magit-repolist-column-path ())))

    ;; The default relevant `magit-list-repositories'
    (setq magit-repository-directories
	  `(("~/git/takeonrules.source/" . 1)
	    ("~/git/burning_wheel_lifepaths/" . 1)
	    ("~/git/dotzshrc/" .  1)
	    ("~/git/dotemacs/" . 1)
	    ("~/git/emacs-bookmarks/" . 1)
	    ("~/git/org" . 1)
	    ("~/git/org/archive" . 1)
	    ("~/git/takeonrules.source/themes/hugo-tufte" . 1)))

    ;; Have magit-status go full screen and quit to previous
    ;; configuration.  Taken from
    ;; http://whattheemacsd.com/setup-magit.el-01.html#comment-748135498
    ;; and http://irreal.org/blog/?p=2253
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))
    (defadvice magit-mode-quit-window (after magit-restore-screen activate)
      (jump-to-register :magit-fullscreen))
    :config
    (remove-hook 'magit-status-sections-hook 'magit-insert-tags-header)
    (defun jf/magit-browse-pull-request ()
      "In `magit-log-mode' open the associated pull request
  at point.

  Assumes that the commit log title ends in the PR #, which
  is the case when you use the Squash and Merge strategy.

  This implementation is dependent on `magit' and `s'."
      (interactive)
      (let* ((beg (line-beginning-position))
	     (end (line-end-position))
	     (summary
	      (buffer-substring-no-properties
	       beg end)))
	(jf/open-pull-request-for :summary summary)))
    (defun jf/git-current-remote-url ()
      "Get the current remote url."
      (s-trim
       (shell-command-to-string
	(concat
	 "git remote get-url "
	 (format "%s" (magit-get-current-remote))))))
    (cl-defun jf/open-pull-request-for (&key summary)
      "Given the SUMMARY open the related pull request.

  This method assumes you're using Github's Squash and Strategy."
      (let ((remote-url (jf/git-current-remote-url)))
	(save-match-data
	  (and (string-match "(\\#\\([0-9]+\\))$" summary)
	       (browse-url
		(concat
		 ;; I tend to favor HTTPS and the repos end in ".git"
		 (s-replace ".git" "" remote-url)
		 "/pull/"
		 (match-string 1 summary)))))))
    (defun jf/open-pull-request-for-current-line ()
      "For the current line open the applicable pull request."
      (interactive)
      (let ((summary
	     (s-trim
	      (shell-command-to-string
	       (concat "git --no-pager annotate "
		       "-w -L "
		       (format "%s" (line-number-at-pos))
		       ",+1 "
		       "--porcelain "
		       buffer-file-name
		       " | rg \"^summary\"")))))
	(jf/open-pull-request-for :summary summary)))
    :bind (("s-7" . magit-status))
    ;; In other situations I bind s-6 to `git-messenger:popup-message'
    :bind (:map magit-log-mode-map ("s-6" . 'jf/magit-browse-pull-request))
    :hook ((with-editor-post-finish-hook . magit-status)))
#+end_src

**** forge.el

- ~forge.el~ :: Additional interactions interactions with [[https://en.wikipedia.org/wiki/Forge_(software)][Git forge]].  Right
  now, I’ve commented out most things, as I wasn’t figuring out how to refresh
  the appended sections.  I live this here as a reminder.

#+begin_src emacs-lisp
  (use-package forge
    :config
    (setq auth-sources '("~/.authinfo"))
    ;; (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-authored-pullreqs nil 'append)
    ;; (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-requested-reviews nil 'append)
    ;; (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-assigned-issues nil 'append)
    :straight t)

#+end_src

**** libgit.el

- ~libgit.el~ :: Provides bindings to [[https://libgit2.org][libgit2]].  These bindings help improve the speed of ~magit.el~; or so I’m told.

#+begin_src emacs-lisp
  (use-package libgit :straight t)
#+end_src

**** magit-libgit.el

- ~libgit.el~ :: Connects ~magit.el~ to ~libgit.el~, helping improve the speed of ~magit.el~; or so I’m told.

#+begin_src emacs-lisp
  (use-package magit-libgit :straight t)
#+end_src

**** git-timemachine.el

- ~git-timemachine.el~ :: With the time machine, travel back and forth through a files history.

#+begin_src emacs-lisp
  (use-package git-timemachine :straight t)
#+end_src

**** git-gutter-fringe.el

- ~git-gutter-fringe.el~ :: Show the current git state in the gutter.  As you
  edit a line in a file track by git, the fringe’s indicators change to reflect
  if this is a modification, addition, or deletion.

#+begin_src emacs-lisp
  (use-package git-gutter-fringe
    :straight (git-gutter-fringe :type git :host github :repo "emacsorphanage/git-gutter-fringe")
    :diminish 'git-gutter-mode
    :config (global-git-gutter-mode 't)
    (setq git-gutter:modified-sign "Δ"
	  git-gutter:added-sign "+"
	  git-gutter:deleted-sign "-"))
#+end_src

**** git-link.el

- ~git-link.el~ :: Type ~M-x git-link~ and the function pushes the Git forge
  URL to the kill ring; I’ve configured the URL to use the SHA of the commit of
  the line on which I called ~git-link()~.  This is helpful for sharing links
  with other folks.  I use this /all of the time./ See
  https://github.com/sshaw/git-link.

#+begin_src emacs-lisp
  (use-package git-link
    :config
    (defun jf/git-browse-to-repository (remote)
      "Open in external browser the current repository's given REMOTE."
      (interactive (list (git-link--select-remote)))
      (git-link-homepage remote)
      (browse-url (car kill-ring)))
    (setq git-link-use-commit t) ;; URL will be SHA instead of branch
    :straight t)
#+end_src

**** git-messenger.el

- ~git-messenger.el~ :: Sometimes I want to see more ~git~ information
  regarding the current line.  ~git-messenger.el~ provides a popup that shows
  the information and provides some additional options.

#+begin_src emacs-lisp
  (use-package git-messenger
    :config (setq git-messenger:show-detail t)
    (defun jf/git-messenger-popup ()
      "Open `git-messenger' or github PR.

  With universal argument, open the github PR for current line.

  Without universal argument, open `git-messenger'."
      (interactive)
      (if (equal current-prefix-arg nil) ; no C-u
	  (git-messenger:popup-message)
	(jf/open-pull-request-for-current-line)))
    :custom
    (git-messenger:use-magit-popup t)
    :bind (:map git-messenger-map (("p" . 'jf/open-pull-request-for-current-line)
				   ("l" . 'git-link)))
    :bind (("s-6" . jf/git-messenger-popup)
	   ("<f6>" . jf/git-messenger-popup))
    :straight t)
#+end_src

**** blamer.el

- ~blamer.el~ :: When working in code, I want different ways to view the
  metadata around the code.  ~blammer.el~ adds a quick annotation to the
  current line; When did the last person touch this and what was the message.

#+begin_src emacs-lisp
  (use-package blamer
    :straight (blamer :host github :repo "Artawower/blamer.el")
    :custom
    ;; Set to 0 because I don’t enable by default.  So I’m in a mindset of show
    ;; me who and when.
    (blamer-idle-time 0.0)
    (blamer-author-formatter "✎ %s ")
    (blamer-datetime-formatter "[%s] ")
    (blamer-commit-formatter "● %s")
    (blamer-min-offset 40)
    (blamer-max-commit-message-length 20))
#+end_src

*** elpher.el

- ~elpher.el~ :: A Gopher and Gemini client.

#+begin_src emacs-lisp
  (use-package elpher :straight t)
#+end_src
*** eww.el

- ~eww.el~ :: a plain text browser.  Use this to see just how bad much of the web a
#+begin_src emacs-lisp
  (use-package eww
    :straight t
    :config
    (defun shr-tag-dfn (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-cite (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-q (dom)
      (shr-insert (car shr-around-q-tag))
      (shr-generic dom)
      (shr-insert (cdr shr-around-q-tag)))

    (defcustom shr-around-q-tag '("“" . "”")
      "The before and after quotes.  `car' is inserted before the Q-tag and `cdr' is inserted after the Q-tag.

  Alternative suggestions are: - '(\"\\\"“\" . \"\\\"\")"
      :type (cons 'string 'string))

    (defface shr-small
      '((t :height 0.8))
      "Face for <small> elements.")

    ;; Drawing inspiration from shr-tag-h1
    (defun shr-tag-small (dom)
      (shr-fontize-dom dom (when shr-use-fonts 'shr-small)))

    (defface shr-time
      '((t :inherit underline :underline (:style wave)))
      "Face for <time> elements.")

    ;; Drawing inspiration from shr-tag-abbr
    (defun shr-tag-time (dom)
      (when-let* ((datetime (or
			     (dom-attr dom 'title)
			     (dom-attr dom 'datetime)))
		  (start (point)))
	(shr-generic dom)
	(shr-add-font start (point) 'shr-time)
	(add-text-properties
	 start (point)
	 (list
	  'help-echo datetime
	  'mouse-face 'highlight))))


    ;; EWW lacks a style for article
    (defun shr-tag-article (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    ;; EWW lacks a style for section; This is quite provisional
    (defun shr-tag-section (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    (setq browse-url-browser-function 'browse-url-default-macosx-browser)
    :bind (:map eww-mode-map
		("U" . eww-up-url)
		("<f7>" . jf/amplify-eww)
		("s-7" . jf/amplify-eww))
    :bind (("C-s-w" . browse-url-at-point))
    :hook ((eww-mode . jf/reader-visual)))
#+end_src

** Connective Tissue and Oddities
*** Functions

The following chunk of allows me to take multiple filenames passed via the
emacsclient and open those files in windows within the same frame.

You can see this in my [[https://codeberg.org/takeonrules/dotzshrc/src/branch/main/bin/git-edit][git-edit]] command line tool.

#+begin_src emacs-lisp
  (defvar server-visit-files-custom-find:buffer-count
    "A counter for assisting with opening multiple files via a single
  client call.")
  (defadvice server-visit-files
      (around server-visit-files-custom-find
	      activate compile)
    "Maintain a counter of visited files from a single client call."
    (let ((server-visit-files-custom-find:buffer-count 0))
      ad-do-it))
  (defun server-visit-hook-custom-find ()
    "Arrange to visit the files from a client call in separate windows."
    (if (zerop server-visit-files-custom-find:buffer-count)
	(progn
	  (delete-other-windows)
	  (switch-to-buffer (current-buffer)))
      (let ((buffer (current-buffer))
	    (window (split-window-sensibly)))
	(switch-to-buffer buffer)
	(balance-windows)))
    (setq server-visit-files-custom-find:buffer-count
	  (1+ server-visit-files-custom-find:buffer-count)))
  (add-hook 'server-visit-hook 'server-visit-hook-custom-find)
#+end_src

- ~jf/toggle-osx-alternate-modifier~ :: I like having MacOS’s native Option (e.g. =⌥=) modifier available.  But using
that default in Emacs would be a significant hinderance.

The following function facilitates a best of both worlds.  By default, I want Option to be ~M-~
in Emacs.  However, I can toggle that setting.  That way if I need an umlaut
(e.g., =¨=), I can use MacOS’s native functions to type =⌥= + =u=.

#+begin_src emacs-lisp
  (defun jf/toggle-osx-alternate-modifier ()
    "Toggle native OS-X Option modifier
    setting (e.g. ns-alternate-modifier)."
    (interactive)
    (if ns-alternate-modifier
	(progn (setq ns-alternate-modifier nil)
	       (message "Enabling OS X native Option modifier"))
      (progn (setq ns-alternate-modifier 'meta)
	     (message "Disabling OX X native Option modifier (e.g. Option as Meta)"))))
#+end_src

- ~jf/eval-region-dwim~ :: I try to get quick feedback when writing emacs-lisp;
  the ~jf/eval-region-dwim~ binds a mnemonic key sequence to an extend ~eval-region~.

#+begin_src emacs-lisp
  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'jf/eval-region-dwim)
  (defun jf/eval-region-dwim ()
    "When region is active, evaluate it and kill the mark. Else,
    evaluate the whole buffer."
    (interactive)
    (if (not (region-active-p))
	(progn
	  (message "Evaluating buffer...")
	  (eval-buffer))
      (progn
	(message "Evaluating region...")
	(eval-region (region-beginning) (region-end)))
      (setq-local deactivate-mark t)))
#+end_src

- ~jf/reader-visual~ :: A little bit of RSS beautification.

#+begin_src emacs-lisp
  (defun jf/reader-visual ()
    "A method to turn on visual line mode and adjust text scale."
    (text-scale-set 2)
    (turn-on-visual-line-mode))
#+end_src

- ~jf/scroll-down-half-page~ :: See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/

#+begin_src emacs-lisp
  (global-set-key (kbd "M-n") 'jf/scroll-down-half-page)
  (defun jf/scroll-down-half-page ()
    "Scroll down half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) (move-to-window-line nil))
	    ((= ln lmax) (recenter (window-end)))
	    (t (progn
		 (move-to-window-line -1)
		 (recenter))))))
#+end_src

- ~jf/scroll-up-half-page~ :: See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/

#+begin_src emacs-lisp
  (global-set-key (kbd "M-p") 'jf/scroll-up-half-page)
  (defun jf/scroll-up-half-page ()
    "Scroll up half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) nil)
	    ((= ln lmax) (move-to-window-line nil))
	    (t (progn
		 (move-to-window-line 0)
		 (recenter))))))
#+end_src

- ~jf/org-insert-immediate-active-timestamp~ :: Insert an active timestamp, with a few options.

#+begin_src emacs-lisp
  (global-set-key (kbd "s-5") 'jf/org-insert-immediate-active-timestamp)
  (defun jf/org-insert-immediate-active-timestamp (parg)
    "Insert an active date for today.

  One universal arg (e.g., prefix call with C-u) inserts timestamp.
  Two universal arsg (e.g., prefix call with C-u C-u) prompts for date then insertes active date."
    (interactive "P")
    (let ((prefix (car parg)))
      (cond
       ((not prefix)  (org-insert-time-stamp nil nil nil))
       ((= prefix 4)  (org-insert-time-stamp nil t nil))
       ((= prefix 16) (org-insert-time-stamp (org-read-date nil t nil "Date") nil nil)))))
#+end_src

- ~jf/forem-tidy-pull-request~ :: At [[https://forem.com][Forem]] we use a [[https://github.com/forem/forem/blob/main/.github/PULL_REQUEST_TEMPLATE.md][pull request template]] that
  has lots of instructions for contributors to complete.  The
  ~jf/forem-tidy-pull-request~ function takes the initial contents (which
  include the commit message of the first commit of the pull request) and
  tidies it up so I can fill out the primary fields.

#+begin_src emacs-lisp
  (defun jf/forem-tidy-pull-request ()
    "Perform some quick tidying of the Forem PR template."
    (interactive)
    ;; Start from the beginning.
    (beginning-of-buffer)

    ;; The text before the first HTML/Markdown
    ;; comments is the commit message.  Cut that
    ;; text…
    (search-forward "<!--")
    (kill-region 1 (- (point) 4))

    ;; ...and paste it inside the description
    ;; section.
    (replace-string
     "## Description\n\n"
     (concat "## Description\n\n"
	     (format "%s" (car kill-ring))))

    ;; We've moved point (e.g., the cursor) so let's
    ;; jump back to the beginning of the buffer.
    (beginning-of-buffer)

    ;; Remove HTML/Markdown comments
    (replace-regexp
     "\\(\n\\)*<!--\\(.\\|\n\\)*-->\\(\n\\)*"
     "")

    (beginning-of-buffer)

    ;; Clear out the text I almost always delete.
    ;;
    ;; This clears out the two or three line "please"!
    (replace-regexp ": _please.*\\(\n +.+\\)+_\n" ":\n")

    (beginning-of-buffer)

    ;; Clear out some comments.
    (replace-regexp "^\n_\\(If\\|Please\\|Will\\).*\\(\n.+\\)+_\n+" "\n")

    ;; Clean out the GIF section.  As much as I try
    ;; I just don't like adding GIFs to PRs
    (replace-regexp
     "\n## \\[optional\\] What gif\\(.\\)*\n+\\!.*"
     "")

    ;; Jump to the beginning of the buffer...again.
    (beginning-of-buffer))
#+end_src

#+begin_src emacs-lisp
  (global-set-key (kbd "C-w") 'jf/kill-region-or-backward-word)
  (global-set-key (kbd "M-DEL") 'jf/kill-region-or-backward-word)
  (global-set-key (kbd "<C-M-backspace>") 'backward-kill-paragraph)
  (defun jf/kill-region-or-backward-word (&optional arg)
    "Kill selected region otherwise kill backwards the ARG number of words."
    (interactive "p")
    (if (region-active-p)
	(kill-region (region-beginning) (region-end))
      (backward-kill-word arg)))
#+end_src

- ~jf/kill-line-org-region~ :: Wedding two methods together: ~kill-region~ and
  ~kill-line~.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-k") 'jf/kill-line-or-region)
  (defun jf/kill-line-or-region (&optional ARG)
    "Kill the selected region otherwise kill the ARG number of lines."
    (interactive "P")
    (if (use-region-p)
	(kill-region (region-beginning) (region-end))
      (kill-line ARG)))
#+end_src

- ~jf/nab-file-name-to-clipboard~ :: There are plenty of times where I want the
  file name.  This command helps me get either it’s full path, or it’s base
  name.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c n") 'jf/nab-file-name-to-clipboard)
  (defun jf/nab-file-name-to-clipboard (parg)
    "Nab, I mean copy, the current buffer file name to the clipboard.

  The PARG is the universal prefix argument.

  If you pass no args, copy the filename with full path.
  If you pass one arg, copy the filename without path.
  If you pass two args, copy the path to the directory of the file."
    ;; https://blog.sumtypeofway.com/posts/emacs-config.html
    (interactive "P")
    (let* ((prefix (car parg))
	   (raw-filename
	    (if (equal major-mode 'dired-mode) default-directory (buffer-file-name)))
	   (filename
	    (cond
	     ((not prefix)  raw-filename)
	     ((= prefix 4)  (file-name-nondirectory raw-filename))
	     ((= prefix 16) (file-name-directory raw-filename)))))
      (when filename
	(kill-new filename)
	(message "Copied buffer file name '%s' to the clipboard." filename))))
#+end_src

- ~jf/sort-unique-lines~ :: A simple combination of two functions ~sort-lines~
  and ~delete-duplicate-lines~.

#+begin_src emacs-lisp
  (defun jf/sort-unique-lines (reverse beg end &optional adjacent keep-blanks interactive)
    "Sort lines and delete duplicates.
    By default the sort is lexigraphically ascending.  To sort as
    descending set REVERSE to non-nil.  Specify BEG and END for the
    bounds of sorting.  By default, this is the selected region.

    I've included ADJACENT, KEEP-BLANKS, and INTERACTIVE so I can
    echo the method signature of `'delete-duplicate-lines`"
    ;; This is a common function that I've used in other text editors.
    ;; It's a simple stitch together of sort-lines and
    ;; delete-duplicate-lines.
    (interactive "P\nr")
    (sort-lines reverse beg end)
    (delete-duplicate-lines beg end reverse adjacent keep-blanks interactive))
#+end_src

- ~jf/display-buffer-in-side-window~ :: Creates a sticky side window on the
  right.  Sometimes this is just the right thing for reviewing files.  I don’t
  know when I need it, but when I use it I’m always thankful I have it.
- ~jf/display-buffer-in-side-window~ :: As ~jf/display-buffer-in-side-window~,
  but creates a side window on the bottom.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-s-\\") 'jf/display-buffer-in-side-window)
  (cl-defun jf/display-buffer-in-side-window (&optional (buffer (current-buffer)))
    "Display BUFFER in dedicated side window."
    (interactive)
    (let ((display-buffer-mark-dedicated t))
      (display-buffer-in-side-window buffer
				     '((side . right)
				       (window-parameters
					(no-delete-other-windows . t))))))
#+end_src

- ~jf/display-buffer-in-side-window~ :: As ~jf/display-buffer-in-side-window~,
  but creates a side window on the bottom.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-s--") 'jf/display-buffer-in-bottom-window)
  (cl-defun jf/display-buffer-in-bottom-window (&optional (buffer (current-buffer)))
    "Display BUFFER in dedicated side window."
    (interactive)
    (let ((display-buffer-mark-dedicated t))
      (display-buffer-in-side-window buffer
				     '((side . bottom)
				       (window-parameters
					(no-delete-other-windows . t))))))
#+end_src

- ~jf/move-file~ :: Sometimes I want to move, without renaming, a file.  This
  function helps make that easy.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x m") 'jf/move-file)
  (defun jf/move-file (target-directory)
    "Write this file to TARGET-DIRECTORY, and delete old one."
    (interactive "DTarget Directory: ")
    (let* ((source (expand-file-name (file-name-nondirectory (buffer-name)) default-directory))
	   (target (f-join target-directory (file-name-nondirectory (buffer-name)))))
      (save-buffer)
      (rename-file source target)
      (kill-current-buffer)))
#+end_src

- ~jf/duplicate-current-line-or-lines-of-region~ :: Sometimes I just want to
  duplicate an area without copy and paste.  This helps that process.  It’s not
  as smart as TextMate’s equivalent function, but it’s close enough.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-d") 'jf/duplicate-current-line-or-lines-of-region)
  (global-set-key (kbd "C-c d") 'jf/duplicate-current-line-or-lines-of-region)
  (defun jf/duplicate-current-line-or-lines-of-region (arg)
    "Duplicate ARG times current line or the lines of the current region."
    (interactive "p")
    (if (use-region-p)
	(progn
	  (when (> (point) (mark))
	    (exchange-point-and-mark))
	  (beginning-of-line)
	  (exchange-point-and-mark)
	  (end-of-line)
	  (goto-char (+ (point) 1))
	  (exchange-point-and-mark)
	  (let* ((end (mark))
		 (beg (point))
		 (region
		  (buffer-substring-no-properties beg end)))
	    (dotimes (_i arg)
	      (goto-char end)
	      (insert region)
	      (setq end (point)))))
      (crux-duplicate-current-line-or-region arg)))

#+end_src

- ~jf/create-scratch-buffer~ :: A simple wrapper around scratch, that helps
  name it and sets the major mode to ~org-mode~.

#+begin_src emacs-lisp
  (global-set-key (kbd "<f12>") 'jf/create-scratch-buffer)
  (cl-defun jf/create-scratch-buffer (&key (mode 'org-mode))
    "Quickly open a scratch buffer and enable the given MODE."
    (interactive)
    (crux-create-scratch-buffer)
    (rename-buffer (concat "*scratch* at " (format-time-string "%Y-%m-%d %H:%M")))
    (funcall mode))
#+end_src


**** TODO Window Layout Functions

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; BEGIN frame and window quick setup
  (defun gk-layouts-3col ()
    "Three column layout.

  Tries to preserve the order of window buffers and active window."
    (interactive)
    ;; Record active window buffer.
    (let ((cbuf (current-buffer)))
      ;; Switch to leftmost window.
      (ignore-errors (cl-loop do (windmove-left)))
      (let ((buffers
	     (mapcar #'window-buffer (-take 3 (window-list))))
	    (width (/ (frame-width) 3)))
	(delete-other-windows)
	(split-window-horizontally width)
	(other-window 1)
	(split-window-horizontally)
	(other-window -1)
	(dolist (b buffers)
	  (switch-to-buffer b)
	  (other-window 1)))
      ;; Switch to previously visible buffer’s window.
      (select-window (get-buffer-window cbuf))))


  (defun gk-layouts-main-and-sidekicks ()
    "One horizontal split, the right window split in two.

  Tries to preserve the order of window buffers and active window."
    (interactive)
    ;; Record active window buffer.
    (let ((cbuf (current-buffer)))
      ;; Switch to leftmost window.
      (ignore-errors (cl-loop do (windmove-left)))
      (let ((buffers
	     (mapcar #'window-buffer (-take 3 (window-list)))))
	(delete-other-windows)
	(split-window-horizontally)
	(other-window 1)
	(split-window-vertically)
	(other-window -1)
	(dolist (b buffers)
	  (switch-to-buffer b)
	  (other-window 1)))
      ;; Switch to previously visible buffer’s window.
      (select-window (get-buffer-window cbuf))))

  (bind-key "C-x \\" #'gk-layouts-main-and-sidekicks)
  ;; END frame and window quick setup
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src


*** Quick Help

The following ~jf/transient-quick-help~ macro helps generate “help menus” that
I want to reference.

#+begin_src emacs-lisp
  (cl-defmacro jf/transient-quick-help (name buffer &key label body)
    "Macro for creating callable functions that display help.

    Where NAME is name of function, BUFFER is name of buffer, and TEXT is displayed."
    (declare (indent defun))
    `(progn
       (transient-define-suffix ,name nil
	 ,buffer
	 :description ,label
	 (interactive)
	 (let ((qh-buff (concat "*Quick Help: " ,buffer "*"))
	       (qh-text ,body))
	   (get-buffer-create qh-buff)
	   (with-current-buffer qh-buff
	     (insert qh-text)
	     (goto-char (point-min))
	     (not-modified)
	     (read-only-mode)
	     (special-mode)
	     (local-set-key (kbd "q") 'kill-buffer-and-window))
	   (pop-to-buffer qh-buff '((display-buffer-below-selected)
				    (window-parameters . ((no-other-window . nil)))
				    (window-height . fit-window-to-buffer)))
	   (message "q - Remove Window")))))
#+end_src

/Note:/ It might make sense to extract the quick help to files, but for now
this was the least effort.

**** Burning Wheel Gold

The following “quick help” methods are tables that I commonly reference when playing Burning Wheel Gold.

#+begin_src emacs-lisp
  (jf/transient-quick-help jf/qh--bwg-wises
    "BWG Wises Obstacles (page 309)"
    :label "Wises"
    :body
    (concat
     "Common knowledge ............. Ob 1\n"
     "An interesting fact .......... Ob 2\n"
     "Details ...................... Ob 3\n"
     "Uncommon knowledge ........... Ob 4\n"
     "Rare goods ................... Ob 5\n"
     "Bizarre or obscure ........... Ob 7\n"
     "Freaky details or specifics .. Ob 8"))

  (jf/transient-quick-help jf/qh--bwg-expertise-exponent
    "BWG Expertise Exponent (page 12)"
    :label "Exponents"
    :body
    (concat
     "Exp 1  is naturally disinclined, crippled, or utterly incompetent.\n"
     "Exp 2  is untrained, raw, weak, or unpracticed.\n"
     "Exp 3  is nominally trained and practiced.\n"
     "Exp 4  is competent; everday stuff doesn't pose a challenge.\n"
     "Exp 5  is expert.\n"
     "Exp 6  is near mastery.\n"
     "Exp 7  is excellence.\n"
     "Exp 8  is total mastery, complete understanding.\n"
     "Exp 9  is uncanny; incomprehensibly good.\n"
     "Exp 10 is as near perfection as the system allows."))

  (jf/transient-quick-help jf/qh--bwg-absolute-difficulty
    "BWG Absolute Difficulty (page 15)"
    :label "Difficulty"
    :body
    (concat
     "Ob 1  A simple act done with little thought.\n"
     "Ob 2  An act performed routinely at your job.\n"
     "Ob 3  An act you can accomplish if you concentrate.\n"
     "Ob 4  A risky act.\n"
     "Ob 5  An act that requires expertise.\n"
     "Ob 6  An act that requires a heroic effort.\n"
     "Ob 7  An improbable feat.\n"
     "Ob 8  An act requiring preternatural ability or a lot of help.\n"
     "Ob 9  An act deemed nearly impossible.\n"
     "Ob 10 A miracle."))

  (jf/transient-quick-help jf/qh--bwg-circles-obstacles
    "BWG Circles Obstacles (page 380-381)"
    :label "Circles"
    :body
    (concat
     "Occupation\n"
     "  Broad occupation/profession, same life path ... +0 Ob\n"
     "  Uncommon occupation, or within same setting ... +2 Ob\n"
     "  Specific occupation, rare/unique occupation ... +3 Ob\n"
     "\n"
     "Station\n"
     "  Same station .................................. +0 Ob\n"
     "  Lower rank, station, or class ................. +1 Ob\n"
     "  Higher rank, station, or class ................ +2 Ob\n"
     "  Highest station or rank in the setting ........ +3 Ob\n"
     "\n"
     "Disposition and Knowledge\n"
     "  Common to circle .............................. +0 Ob\n"
     "  Different from circle members ................. +1-2 Ob\n"
     "  Specific, detailed, or rare ................... +3 Ob\n"
     "\n"
     "Time and Place\n"
     "  Doesn't matter ................................ +0 Ob\n"
     "  Unusual for this character .................... +1-2 Ob\n"
     "  Right here and now in the middle of trouble ... +3 Ob"))

  (jf/transient-quick-help jf/qh--bwg-steel-test-adjustments
    "BWG Steel Test Adjustments (page 363)"
    :label "Steel"
    :body
    (concat
     "Conditions for Steel Advantags\n"
     "  Being startled by something mundane ........ +2D\n"
     "  Feeling safe in a group of friends/allies .. +1D\n"
     "\n"
     "Conditions for Steel Disadvantages\n"
     "  Being shot at .............................. +1 Ob\n"
     "  Being directly affect by magic ............. +1 Ob\n"
     "  Witnessing a person killed ................. +1 Ob\n"
     "  Small explosions ........................... +2 Ob\n"
     "  Committing murder .......................... +2 Ob\n"
     "  Explosions ................................. +3 Ob\n"
     "  Witnessing pronounced sorcery at play ...... +3 Ob\n"
     "  Seeing a ghost ............................. +3 Ob\n"
     "  Seeing the living dead ..................... +4 Ob\n"
     "  Volcanic eruptions, cataclysm .............. +4 Ob\n"
     "  Seeing horrible magic at work .............. +4 Ob\n"
     "  Being in the presence of the supernatural .. +5 Ob\n"))
#+end_src



* Past Work
** TODO Utilities

*** TODO blogging specific

**** decide.el

- ~decide.el~ :: A package for random decision making.

#+begin_src emacs-lisp
  (use-package decide
    :straight (decide :host github :type git :repo "jeremyf/decide-mode"))
#+end_src

**** TODO Wrapping Functions

#+begin_src emacs-lisp
  ;;******************************************************************************
  ;;
  ;;; BEGIN Non-Interactive Utility Functions
  ;;
  ;;******************************************************************************
  (cl-defun jf/convert-text-to-key (text &key (length 5))
    "Convert the given TEXT to an epigraph key.

  The LENGTH is how many words to use for the key."
    (let ((list-of-words (s-split-words text)))
      (if (> (length list-of-words) length)
	  (upcase (s-join "-" (subseq list-of-words 0 length)))
	"")))

  (defun jf/tor-convert-text-to-post-title (title)
    "Convert TITLE to correct format."
    (message "Titleizing...")
    (replace-regexp-in-string
     ;; Replace "Hello World" with “Hello World”
     "\"\\([^\"]+\\)\""
     "“\\1”"
     (s-replace "'" "’" title)))

  (defun jf/tor-convert-text-to-slug (&optional string)
    "Convert STRING to appropriate slug."
    (s-replace "'" "" (s-dashed-words (s-downcase string))))

  (cl-defun jf/tor-prompt-or-kill-ring-for-url (&key (url-regexp "^https?://"))
    "Prompt and return a url.

  If the `car' of `kill-ring' matches the URL-REGEXP, default the
  prompt value to the `car' of `kill-ring'."
    (let ((car-of-kill-ring (substring-no-properties (car kill-ring))))
      (read-string "URL (optional): "
		   (when (string-match url-regexp car-of-kill-ring)
		     car-of-kill-ring))))

  (defun jf/slugify ()
    "Convert the active region or line to a URL friendly slug."
    (interactive)
    (let* ((range (if (region-active-p)
		      (list (region-beginning) (region-end))
		    (list (point-at-bol) (point-at-eol))))
	   (text (buffer-substring-no-properties (car range) (cadr range))))
      (save-excursion
	(delete-region (car range) (cadr range))
	(goto-char (car range))
	(insert (jf/tor-convert-text-to-slug text)))))

  (cl-defun jf/tor-post---create-or-append (&key
					     title subheading
					     (tags '("null")) series toc
					     citeTitle citeURL citeAuthor)
    "Create or append a post with TITLE.

  The following keys are optional:

  :SUBHEADING if you have an active region, use this header.
  :TAGS one or more tags, as a list or string, to add to the
	  frontmatter.
  :SERIES the series to set in the frontmatter.
  :TOC whether to include a table of contents in the post.
  :CITETITLE the title of the URL cited (if any)
  :CITEURL the URL cited (if any)
  :CITEAUTHOR the author cited (if any)

  If there's an active region, select that text and place it."
    (let* ((default-directory (f-join jf/tor-home-directory
				      "content" "posts"
				      (format-time-string "%Y/")))

	   (slug (jf/tor-convert-text-to-slug title))
	   (fpath (expand-file-name
		   (concat default-directory slug ".md"))))
      ;; If the file does not exist, create the file with the proper
      ;; frontmatter.
      (if (not (file-exists-p fpath))
	  (write-region
	   (concat "---"
		   "\ndate: " (format-time-string "%Y-%m-%d %H:%M:%S %z")
		   "\ndraft: true"
		   "\nlayout: post"
		   "\nlicenses:\n- all-rights-reserved"
		   "\nslug: " (format "%s" slug)
		   "\ntitle: '" (jf/tor-convert-text-to-post-title title) "'"
		   "\ntype: post"
		   (when series (concat "\nseries: " series))
		   (when toc (concat "\ntoc: true"))
		   "\ntags:"
		   (if tags
		       (concat (mapconcat
				(lambda (tag) (concat "\n- " tag))
				(flatten-tree tags) ""))
		     "\n- null")
		   "\n---\n")
	   nil fpath))
      ;; If we have an active region, append that region's content to
      ;; the given file.
      (if (use-region-p)
	  (write-region
	   (concat
	    (if subheading
		(concat "\n## " subheading "\n")
	      (when citeTitle (concat "\n## " citeTitle "\n")))
	    (when citeURL (concat
			   "\n{{< blockquote"
			   (when citeAuthor
			     (concat " pre=\"" citeAuthor "\""))
			   " cite=\"" citeTitle
			   "\" cite_url=\"" citeURL "\" >}}\n"))
	    (buffer-substring (region-beginning) (region-end))
	    (when citeURL "\n{{< /blockquote >}}"))
	   nil fpath t)
	;; Without an active region, if we have a citeURL insert a link
	;; to it.
	(when citeURL
	  (write-region
	   (concat
	    "\n<cite><a href=\"" citeURL
	    "\" class=\"u-url p-name\" rel=\"cite\">"
	    (or (citeTitle) (citeURL)) "</a></cite>\n")
	   nil fpath t)))
      ;; Finally open that file for editing.
      (find-file fpath)
      (end-of-buffer)))
  ;;******************************************************************************
  ;;
  ;;; END Non-Interactive Utility Functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN Interactive Non-Wrapping Functions
  ;;
  ;;******************************************************************************
  (cl-defun jf/tor-toggle-hugo-server (&key
					(directory jf/tor-home-directory)
					(buffer-name "*Hugo Server*"))
    "This will start or stop a Hugo server in the given DIRECTORY for TakeOnRules.com.

  The BUFFER-NAME is where we'll run the Hugo process."
    (interactive)
    (if (get-buffer buffer-name)
	(progn
	  (kill-buffer buffer-name)
	  (message (concat "Stopping Hugo in \"" buffer-name "\" buffer…")))
      (let* ((default-directory directory))
	(start-process "hugo-server" buffer-name "hugo" "server" "-D")
	(message (concat "Starting Hugo in \"" buffer-name "\" buffer…")))))

  (defun jf/tor-retitle-post (title)
    "Replace the given buffer's title with the new TITLE.

  This function will: replace the content's title, update the slug,
  and rename the buffer."
    (interactive "sNew Post's Title: ")
    (let* ((metadataTitle (concat "title: '"
				  (jf/tor-convert-text-to-post-title title) "'"))
	   (slug (jf/tor-convert-text-to-slug title))
	   (metadataSlug (concat "slug: " slug))
	   (filename (buffer-file-name))
	   (new-filename (concat (file-name-directory filename)
				 slug ".md")))

      ;; Replace the title metadata entry
      (goto-char (point-min))
      (while (search-forward-regexp "^title:.*$" nil t)
	(replace-match metadataTitle))

      ;; Replace the slug metadata entry
      (goto-char (point-min))
      (while (search-forward-regexp "^slug:.*$" nil t)
	(replace-match metadataSlug))

      ;; Need to save before we rename the buffer
      (save-buffer)

      ;; Rename the buffer, accounting for version control
      (cond
       ((vc-backend filename)
	(vc-rename-file filename new-filename))
       (t
	(rename-file filename new-filename t)
	(set-visited-file-name new-filename t t)))

      ;; Report filename change
      (message "Renamed %s -> %s" filename new-filename)))

  (defvar jf/tor-hostname-regexp
    "^https?://takeonrules\.com"
    "A regular expression for checking if it's TakeOnRules.com.")

  (defvar jf/tor-hugo-regexp-for-post-path
    (concat jf/tor-hostname-regexp
	    "/[0-9]\\{4\\}/[0-9]\\{2\\}/[0-9]\\{2\\}/\\([^/]+\\)/?$")
    "A regular expression for matching blog posts.")

  (defvar jf/tor-hugo-regexp-for-pages-path
    (concat jf/tor-hostname-regexp "/\\([^z-a]*[^/]\\)/?$")
    "A regular expression for matching pages.")

  (defun jf/tor-find-hugo-file-by-url (url)
    "Find the associated TakeOnRules.com file for the given URL."
    (interactive (list
		  (jf/tor-prompt-or-kill-ring-for-url
		   :url-regexp jf/tor-hostname-regexp)))
    (cond
     ;; Blog post
     ((string-match jf/tor-hugo-regexp-for-post-path url)
      (let* ((slug (match-string-no-properties 1 url))
	     (filename (car
			(jf/list-filenames-with-file-text
			 :matching (concat "^slug: " slug "$")
			 :in "content"))))
	(find-file (f-join jf/tor-home-directory "content" filename))))
     ;; Pages
     ((string-match jf/tor-hugo-regexp-for-pages-path url)
      (let* ((permalink (match-string-no-properties 1 url))
	     (filename (car
			(jf/list-filenames-with-file-text
			 :matching (concat "^permalink: ['\\\"]?/?"
					   permalink "/?['\\\"]?$")
			 :in "content"))))
	(find-file (f-join jf/tor-home-directory "content" filename))))
     ;; No match found
     (t (message "Unable to find post for \"%s\"" url))))

  (cl-defun jf/tor-view-blog-post (&key
				    (hostname jf/tor-hostname-current))
    "Browse the url for the HOSTNAME

  The front matter of blog posts contains YAML, with two
  attributes: slug and date.  Based on the site configuration, the
  URLs for one of those posts is: hostname/year/month/day/slug"
    (interactive)
    (let ((slugs))
      (save-excursion
	;; Remember we are making a list and pushing to the beginning of
	;; the list.  Hence we start with the last slug in mind.
	(goto-char 1)
	(re-search-forward "^slug: \\(.*\\)$" nil t)
	(push (match-string 1) slugs)
	(goto-char 1)
	(re-search-forward
	 "^date: \\([[:digit:]]+\\)-\\([[:digit:]]+\\)-\\([[:digit:]]+\\) "
	 nil t)
	;; Then move to day, month, then year.
	(push (match-string 3) slugs)
	(push (match-string 2) slugs)
	(push (match-string 1) slugs)
	;; And finally the host name.
	(push hostname slugs))
      (browse-url (format "%s" (s-join "/" slugs)))))

  (defun jf/tor-create-post (title)
    "Create and visit a new draft post.  Prompt for a TITLE.

  The file for the blog post conforms to the path schema of posts
  for TakeOnRules.com."
    (interactive "sBlog Post Title: ")
    (jf/tor-post---create-or-append :title title))

  (defun jf/tor-tag-post (tags)
    "Apply the TAGS to the current TakeOnRules.com post.

  No effort is made to check if this is a post."
    (interactive (list (completing-read-multiple "Tags: " (jf/tor-tags-list))))
    (let ((saved-point (point))
	  (to-insert (concat "\n- " (s-join "\n- " tags))))
      (replace-regexp "^tags:$" (concat "tags:" to-insert) nil 0 (point-max))
      (goto-char (+ saved-point (length to-insert)))))

  (defun jf/tor-insert-glossary-key (key)
    "Insert the KEY at point."
    (interactive (list (completing-read "Key: " (jf/tor-glossary-key-list))))
    (insert key))

  (defun jf/tor-find-changelog-and-insert-entry ()
    "Find TakeOnRules glossary and begin entering a changelog entry."
    (interactive)
    (find-file (f-join jf/tor-home-directory "data" "changelog.yml"))
    ;; The changelog is structured in date descending order.  The first
    ;; line is the YAML preamble indicating a data object (e.g. "---")
    (beginning-of-buffer)
    (end-of-line)
    (insert (concat "\n- date: "
		    (format-time-string "%Y-%m-%d")
		    "\n  entries:\n    - ")))

  (defun jf/tor-find-series-and-insert-entry (title)
    "Find TakeOnRules series and add an entry with TITLE."
    (interactive "sSeries Entry's Title: ")
    (find-file (f-join jf/tor-home-directory "data" "series.yml"))
    (let ((key (downcase (s-dashed-words title))))
      (end-of-buffer)
      (insert (concat
	       (if (looking-at-p "^$") "" "\n")
	       "- title: " title
	       "\n  key: " key))))

  (defun jf/tor-find-glossary-and-insert-entry (title)
    "Find TakeOnRules glossary and add an entry with TITLE."
    (interactive "sGlossary Entry's Title: ")
    (find-file (f-join jf/tor-home-directory "data" "glossary.yml"))
    (let ((key (upcase (s-dashed-words title))))
      (end-of-buffer)
      (insert (concat
	       (if (looking-at-p "^$") "" "\n")
	       "- title: " title
	       "\n  key: " key))))

  (defun jf/tor-insert-epigraph-entry ()
    "Prompt for a new a new data/epigraphs.yml entry."
    (interactive)
    (find-file (f-join jf/tor-home-directory "data" "epigraphs.yml"))
    (end-of-buffer)
    (insert (concat
	     (if (looking-at-p "^$") "" "\n")
	     "epi"))
    (end-of-buffer)
    "Assumes that the 'epi' is the correct expansion for the snippet."
    (yas-expand)
    (message "Ready to insert a new epigraph"))

  (cl-defun jf/tor-post-amplifying-the-blogosphere (subheading
						     &key
						     citeTitle
						     citeURL
						     citeAuthor)
    "Create and visit draft post for amplifying the blogosphere.

  If there's an active region, prompt for the :SUBHEADING.  The file
  for the blog post conforms to the path schema of posts for
  TakeOnRules.com.

  We'll pass the :CITETITLE, :CITEAUTHOR, and :CITEURL to
  `jf/tor-post---create-or-append'"
    (interactive (list (if (use-region-p)
			   (read-string "Sub-Heading: ")
			 nil)))
    (jf/tor-post---create-or-append
     :title (format-time-string "Amplifying the Blogosphere (v%Y-%m-%d)")
     :toc "true"
     :subheading subheading
     :series "amplifying-the-blogosphere"
     :tags "response to other blogs"
     :citeTitle citeTitle
     :citeURL citeURL
     :citeAuthor citeAuthor))

  ;; Note: I needed to use `fboundp' because if I invoked this functions
  ;; before other consult functions I got a method void error.
  (cl-defun jf/find-file-via-matching (&key prompt matching in)
    "PROMPT for files IN the directory with MATCHING content.

  If `consult--read' is defined, use that.  Otherwise fallback to `completing-read'."
    (if (fboundp 'consult--read)
	(consult--read
	 (consult--with-increased-gc
	  (jf/list-full-filenames-with-file-text :matching matching :in in))
	 :prompt prompt
	 :sort nil
	 :require-match t
	 :category 'file
	 :history 'file-name-history
	 :state (consult--file-preview))
      (list (completing-read
	     prompt
	     (jf/list-filenames-with-file-text
	      :matching matching
	      :in in)))))

  (defun jf/tor-find-file-draft (filename)
    "Find a draft FILENAME in the TakeOnRules content directory."
    (interactive
     (list (jf/find-file-via-matching
	    :prompt "Draft filename: "
	    :matching "^draft: true"
	    :in (f-join jf/tor-home-directory "content"))))
    (find-file filename))

  (defun jf/tor-find-file (filename)
    "Find a FILENAME in the TakeOnRules content directory."
    (interactive
     (list (jf/find-file-via-matching
	    :prompt "Filename: "
	    :matching "^title:"
	    :in (f-join jf/tor-home-directory "content"))))
    (find-file filename))
  ;;******************************************************************************
  ;;
  ;;; END Interactive Non-Wrapping Functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN Listing functions for TakeOnRules.com data
  ;;
  ;;******************************************************************************
  (defun jf/tor-tags-list ()
    "Return a list of tags from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "tag" :filename "data/glossary.yml"))

  (defun jf/tor-epigraph-list ()
    "Return a list of epigraph keys from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "key" :filename "data/epigraphs.yml"))

  (defun jf/tor-game-list ()
    "Return a list of games from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "game" :filename "data/glossary.yml"))

  (defun jf/tor-glossary-title-list ()
    "Return a list of titles from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "title" :filename "data/glossary.yml"))

  (defun jf/tor-glossary-key-list ()
    "Return a list of keys from TakeOnRules.com glossary."
    (jf/tor-list-by-key-from-filename :key "key" :filename "data/glossary.yml"))

  (defun jf/tor-series-list ()
    "Return a list of series from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "key" :filename "data/series.yml"))

  (defun jf/tor-licenses-list ()
    "Return a list of available licenses for TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "Key" :filename "data/licenses.yml"))
  ;;******************************************************************************
  ;;
  ;;; END Listing functions for TakeOnRules.com data
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN querying and list generation functions
  ;;
  ;;******************************************************************************
  (cl-defun jf/tor-list-by-key-from-filename (&key
					       key
					       filename
					       (directory jf/tor-home-directory))
    "Build a list of entries of the KEY from the FILENAME in DIRECTORY."
    (split-string-and-unquote
     (shell-command-to-string
      (concat
       "rg \"^[- ] " key ": .*$\" "
       (f-join directory filename)
       " --only-matching --no-filename | sed 's/^[ -] " key ": //' | sort | tr '\n' '@'"))
     "@"))

  (cl-defun jf/list-filenames-with-file-text (&key matching in)
    "Build a list of filenames MATCHING the pattern IN the given directory."
    (let ((default-directory (f-join jf/tor-home-directory in)))
      (split-string-and-unquote
       (shell-command-to-string
	(concat
	 "rg \""
	 matching "\" --only-matching --files-with-matches --sortr modified"
	 "| tr '\n' '@'"))
       "@")))

  (cl-defun jf/list-full-filenames-with-file-text (&key matching in)
    "Build a list of filenames MATCHING the pattern IN the given directory."
    (split-string-and-unquote
     (shell-command-to-string
      (concat
       "rg \""
       matching "\" " in " --only-matching --files-with-matches --sortr modified"
       "| tr '\n' '@'"))
     "@"))

  (defun jf/tor-page-relative-pathname-list ()
    "Return a list of pages for TakeOnRules.com."
    (jf/list-filenames-with-file-text :matching "^title: " :in "content"))

  (defun jf/tor-asset-relative-pathname-list ()
    "Return a list of image filenames for TakeOnRules.com."
    (let ((default-directory (f-join jf/tor-home-directory "assets" "images")))
      (split-string-and-unquote
       (shell-command-to-string "ls"))))

  (defun jf/matches-in-buffer (regexp &optional buffer)
    "Return a list of matches of REGEXP in BUFFER or the current buffer if not given."
    (let ((matches))
      (save-match-data
	(save-excursion
	  (with-current-buffer (or buffer (current-buffer))
	    (save-restriction
	      (widen)
	      (goto-char 1)
	      (while (search-forward-regexp regexp nil t 1)
		(push (match-string 0) matches)))))
	matches)))

  (defun jf/kill-new-markdown-heading-as-slug (heading)
    "Push onto the `kill-ring' a slugified version of HEADING."
    (interactive
     (list (completing-read
	    "Heading: "
	    (jf/matches-in-buffer "^#+ +.*$"))))
    (kill-new (jf/tor-convert-text-to-slug
	       (replace-regexp-in-string "^#+ +" "" heading))))
  ;;******************************************************************************
  ;;
  ;;; END querying and list generation functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN Wrapping Functions
  ;;
  ;;******************************************************************************
  (cl-defun jf/tor-wrap-with-text (&key before after strategy)
    "Wrap the STRATEGY determined region with the BEFORE and AFTER text.

  Valid STRATEGY options are:

  - :lineOrRegion
  - :pointOrRegion
  - :sentenceOrRegion
  - :wordOrRegion

  TODO: I would love create a lookup table for the case statement,
  as the behavior's well defined."
    (pcase strategy
      (:lineOrRegion (pcase-let* ((origin (point))
				  (`(,begin . ,end)
				   (crux-get-positions-of-line-or-region)))
		       (goto-char end)
		       (insert after)
		       (goto-char begin)
		       (insert before)))
      (:sentenceOrRegion (let* ((begin (if (use-region-p)
					   (region-beginning)
					 (car (bounds-of-thing-at-point 'sentence))))
				(end (if (use-region-p)
					 (region-end)
				       (cdr (bounds-of-thing-at-point 'sentence)))))
			   (goto-char end)
			   (insert after)
			   (goto-char begin)
			   (insert before)))
      (:pointOrRegion (let* ((begin (if (use-region-p) (region-beginning) (point)))
			     (end (if (use-region-p) (region-end) (point))))
			(goto-char end)
			(insert after)
			(goto-char begin)
			(insert before)))
      (:wordOrRegion (let* ((begin (if (use-region-p)
				       (region-beginning)
				     (car (bounds-of-thing-at-point 'word))))
			    (end (if (use-region-p)
				     (region-end)
				   (cdr (bounds-of-thing-at-point 'word)))))
		       (goto-char end)
		       (insert after)
		       (goto-char begin)
		       (insert before)))
      ))

  (defun jf/tor-wrap-in-html-tag (tag &optional attributes)
    "Wrap the word or region with the given TAG with optional ATTRIBUTES."
    (interactive "sHTML Tag: \nsAttributes (optional): ")
    (jf/tor-wrap-with-text
     :before (concat "<" tag (if (s-blank? attributes)
				 ""
			       (concat " " attributes)) ">")
     :after (concat "</" tag ">")
     :strategy :wordOrRegion))

  (defun jf/tor-wrap-in-poem ()
    "Wrap the point or region as a poem."
    (interactive)
    (jf/tor-wrap-with-text
     :before "<pre class=\"poem\">\n"
     :after "\n</pre>"
     :strategy :pointOrRegion))

  (defun jf/tor-wrap-date (date)
    "Wrap the point or region with the given DATE."
    (interactive (list (org-read-date nil nil nil "Date")))
    (jf/tor-wrap-in-html-tag
     "time"
     (concat "datetime=\"" date "\" title=\"" date "\"")))

  (defun jf/tor-wrap-as-marginnote-dwim ()
    "Wrap the line or current region as a marginnote Hugo shortcode."
    (interactive)
    (jf/tor-wrap-with-text
     :before "{{< marginnote >}}\n"
     :after "\n{{< /marginnote >}}"
     :strategy :lineOrRegion))

  (defun jf/tor-wrap-as-sidenote-dwim ()
    "Wrap the line or current region as a sidenote Hugo shortcode."
    (interactive)
    (jf/tor-wrap-with-text
     :before "{{< sidenote >}}"
     :after "{{< /sidenote >}}"
     :strategy :sentenceOrRegion))

  (defun jf/tor-wrap-link-active-region-dwim (url)
    "Wrap current region (or point) in an A-tag with the given URL.

  For the URL:

  - If `car' of `kill-ring' starts with \"http\", then use that as the URL.
  - Otherwise prompt for a URL.

  If the URL is an empty string, then send a message.  Else, if we
  have a non-0 length URL, use the URL and wrap the region in an A
  tag."
    (interactive (list (jf/tor-prompt-or-kill-ring-for-url)))
    (if (eq (length url) 0)
	(message "No URL to use for A-tag creation")
      (jf/tor-wrap-with-text
       :before (concat "<a href=\"" url "\">")
       :after "</a>"
       :strategy :pointOrRegion)))

  (defun jf/tor-wrap-as-pseudo-dfn ()
    "Wrap current region (or word) in an I-tag with a DFN dom class."
    (interactive)
    (jf/tor-wrap-with-text
     :before "<i class=\"dfn\">"
     :after "</i>"
     :strategy :wordOrRegion))

  (defun jf/tor-wrap-cite-active-region-dwim (url)
    "Wrap current region (or point) in a CITE-tag and optional A-tag with URL.

  For the URL:

  - If `car' of `kill-ring' starts with \"http\", then use that as the URL.
  - Otherwise prompt for a URL.

  If the URL an empty string, then wrap the current region or point
  in a CITE tag.  Else, if we have a non-0 length URL, wrap it in
  CITE and A tag."
    (interactive (list (jf/tor-prompt-or-kill-ring-for-url)))

    ;; Were we to start writing at the START position, we'd invariably
    ;; change the contents such that the END position was no longer
    ;; accurate.  So instead, we append at the END position, hop back to
    ;; the START position and append to the START position.
    (if (eq (length url) 0)
	(jf/tor-wrap-with-text
	 :before "<cite>"
	 :after "</cite >"
	 :strategy :pointOrRegion)
      (jf/tor-wrap-with-text
       :before (concat "<cite><a href=\"" url
		       "\" class=\"u-url p-name\" rel=\"cite\">")
       :after "</a></cite>"
       :strategy :pointOrRegion)))
  ;;******************************************************************************
  ;;
  ;;; END Wrapping Functions
  ;;
  ;;******************************************************************************
#+end_src

*** TODO hammerspoon

#+begin_src emacs-lisp
  (when (file-directory-p
	 "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon")
    (load
     "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el"
     nil
     jf/silence-loading-log))
#+end_src

** TODO Menus

*** TODO jf/menu
**** Minor Modes

In work and in play, there are several “me” specific contexts.  The
~jf/minor-mode-maker~ macro helps me quickly and consistently make those
contexual minor modes.  My intention is to build out even more functions on
those modes.

#+begin_src emacs-lisp
  (cl-defmacro jf/minor-mode-maker (&key title abbr hooks)
    "A macro to declare a minor mode.

  Use TITLE to derive the docstring.
  Use ABBR to derive the mode-name lighter.
  Add hook to each HOOKS provided."
    (let ((mode-name (intern (s-downcase (concat "jf/" abbr "-minor-mode"))))
	  (lighter (concat " " abbr))
	  (docstring (concat "Minor mode for " title ".")))
      `(progn
	 (define-minor-mode ,mode-name
	   ,docstring
	   :global nil
	   :lighter ,lighter)
	 (when ,hooks
	   (-each ,hooks (lambda(hook) (add-hook hook (lambda () (,mode-name)))))))))

  (jf/minor-mode-maker :title "Burning Wheel Gold"
			:abbr "bwg"
			:hooks (list 'org-mode-hook 'markdown-mode-hook))
  (jf/minor-mode-maker :title "Take on Rules"
			:abbr "tor")
  (jf/minor-mode-maker :title "Forem"
			:abbr "forem")
#+end_src

**** TODO A Consistent Transient Menu

#+begin_src emacs-lisp
  (defconst jf/forem-dashboard-filename
    "~/git/org/forem-dashboard.org"
    "The file to the dashboard documentation and links for Forem.")

  (cl-defun jf/open-dashboard (&key (filename jf/forem-dashboard-filename))
    "For the given FILENAME open the links in the default browser.

      With the universal prefix (e.g. C-u) open the file instead."
    (interactive)
    (if (equal current-prefix-arg nil) ; no C-u
	(call-process-shell-command
	 (concat "rg \"\\[\\[(.*)\\]\\[\" "
		 filename
		 " --only-matching"
		 " | rg \"[^\\[|\\]]+\" --only-matching"
		 " | xargs open"))
      (find-file filename)))
#+end_src

Next I want some transient suffixes (e.g. functions that I call at the end of
my foray into a transient prefix, or menu).

#+begin_src emacs-lisp
  (transient-define-suffix jf/org-auto-tags--transient (tags)
    "Set the TAGS from minibuffer read"
    :description '(lambda ()
		    (concat
		     "Org Tags: "
		     (propertize
		      (format "%s" jf/org-auto-tags--current-list)
		      'face 'transient-argument)))
    (interactive (list
		  (completing-read-multiple
		   "Tag(s): " (org-roam-tag-completions))))
    (setq jf/org-auto-tags--current-list tags))

  (transient-define-suffix jf/hammerspoon-toggle-mode ()
    "Set the hammerspoon mode"
    :description '(lambda ()
		    (concat
		     "Hammerspoon Mode: "
		     (propertize
		      (format "%s" major-mode)
		      'face 'transient-argument)))
    (interactive)
    (hammerspoon-toggle-mode))

  (transient-define-suffix jf/tor-hostname-current-toggle (hostname)
    "Set `jf/tor-hostname-current' to HOSTNAME."
    :description '(lambda ()
		    (concat "Host: "
		    (propertize
		      (format "%s" jf/tor-hostname-current)
		      'face 'transient-argument)))
    (interactive (list (completing-read
			"Host: " (list
				  (list jf/tor-hostname-default-local 1)
				  (list jf/tor-hostname-default-remote 2)
				  ))))
    (setq jf/tor-hostname-current hostname))

  (transient-define-suffix jf/org-auto-tags--transient (tags)
    "Set the TAGS from minibuffer read"
    :description '(lambda ()
		    (concat
		     "Org Tags: "
		     (propertize
		      (format "%s" jf/org-auto-tags--current-list)
		      'face 'transient-argument)))
    (interactive
     (list (completing-read-multiple "Tag(s): " (org-roam-tag-completions))))
    (setq jf/org-auto-tags--current-list tags))
#+end_src

Next up is defining the transient prefixes.  The prefixes are the “start of” a
command sequence.  In this case, I’m using them as menu’s which expose
additional actions.

First up, the Forem menu:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-s-f") 'jf/menu--forem)
  (transient-define-prefix jf/menu--forem ()
    [["Hammerspoon"
      :if-non-nil hammerspoon-edit-minor-mode
      ("C-t" "Tidy pull request" jf/forem-tidy-pull-request)
      ]]
    [["Forem's Workflow"
      ("i" "Browse to [i]ssues…" (lambda () (interactive) (browse-url "https://github.com/forem/forem/issues/")))
      ("j" "Browse to pro[j]ects…" (lambda () (interactive) (browse-url "https://github.com/orgs/forem/projects/")))
      ("m" "Browse [m]erged Pull Requests…" (lambda () (interactive) (browse-url "https://github.com/forem/forem/pulls?q=is%3Apr+is%3Aclosed")))
      ("p" "Browse to pull requests…" (lambda () (interactive) (browse-url "https://github.com/forem/forem/pulls/")))
      ]
     ["Jeremy's Workflow"
      ("a" "Browse Authorization System Project 46" (lambda () (interactive) (browse-url "https://github.com/orgs/forem/projects/46")))
      ("I" "Browse to Jeremy's [I]ssues…" (lambda () (interactive) (browse-url "https://github.com/forem/forem/issues/assigned/jeremyf")))
      ("J" "Browse to Content Experience pro[J]ects…" (lambda () (interactive) (browse-url "https://github.com/orgs/forem/projects/39")))
      ("M" "Browse Jeremy's [M]erged Pull Requests…" (lambda () (interactive) (browse-url "https://github.com/forem/forem/pulls/jeremyf?q=is%3Apr+is%3Aclosed")))
      ("P" "Browse to Jeremy's [P]ull requests…" (lambda () (interactive) (browse-url "https://github.com/forem/forem/pulls/jeremyf")))
      ("N" "Browse Github [N]otifications" (lambda () (interactive) (browse-url "https://github.com/notifications")))
      ]
     ["Org-Mode"
      ("D" "[D]ashboard open…" jf/open-dashboard)
      ("d" "Visit [d]ashboard file…" (lambda () (interactive) (find-file jf/forem-dashboard-filename)))
      ]])
#+end_src

The following menu is for quick help while playing Burning Wheel games.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-s-b") 'jf/menu--bwg)
  (transient-define-prefix jf/menu--bwg ()
    "Define the BWG help prefix."
    ["Burning Wheel"
     ("c" jf/qh--bwg-circles-obstacles)
     ("d" jf/qh--bwg-absolute-difficulty)
     ("e" jf/qh--bwg-expertise-exponent)
     ("s" jf/qh--bwg-steel-test-adjustments)
     ("w" jf/qh--bwg-wises)
     ])
#+end_src

A menu for my TakeOnRules blogging tasks.

#+begin_src emacs-lisp
  (transient-define-prefix jf/menu--tor ()
    "Define the Take on Rules menu."
    ["Take on Rules"
     ["Host"
      ("-h" jf/tor-hostname-current-toggle :transient t)
     ]]
     [["Posts"
      :if-non-nil jf/tor-minor-mode
      ("p r" "Re-title post…" jf/tor-retitle-post)
      ("p t" "Tag post…" jf/tor-tag-post :transient t)
      ("p v" "View post…" jf/tor-view-blog-post)
      ]
     ["Find"
      ("f d" "in draft status…" jf/tor-find-file-draft)
      ("f u" "by url…" jf/tor-find-hugo-file-by-url)
      ("f f" "by filename…" jf/tor-find-file)]
     ["Create"
      ("c a" "Amplify the Blogosphere…" jf/tor-post-amplifying-the-blogosphere)
      ("c c" "Changelog entry…" jf/tor-find-changelog-and-insert-entry)
      ("c e" "Epigraph entry…" jf/tor-insert-epigraph-entry)
      ("c g" "Glossary entry…" jf/tor-find-glossary-and-insert-entry)
      ("c p" "Post…" jf/tor-create-post)
      ("c s" "Series…" jf/tor-find-series-and-insert-entry)]
     ])
#+end_src

Finally the main menu that connects all of the above together, and provides
some additional options.

#+begin_src emacs-lisp
  (global-set-key (kbd "s-1") 'jf/menu)
  (transient-define-prefix jf/menu ()
    "Return a `transient' compliant list to apply to different transients."
    ;; Todo, can I get this section into a function so I can duplicate it in the jf/menu--tor?
    [["Markdown Utilities"
      ("k h" "Kill slug version of given heading…" jf/kill-new-markdown-heading-as-slug :if-derived (or markdown-mode html-mode))
      ("w a" "A-tag at point or region…" jf/tor-wrap-link-active-region-dwim  :if-derived (or markdown-mode html-mode))
      ("w c" "CITE-tag point or region…" jf/tor-wrap-cite-active-region-dwim  :if-derived (or markdown-mode html-mode))
      ("w d" "DATETIME-tag point or region…" jf/tor-wrap-date  :if-derived (or markdown-mode html-mode))
      ("w f" "Wrap word or region in pseudo-DFN…" jf/tor-wrap-as-pseudo-dfn  :if-derived (or markdown-mode html-mode))
      ]
     [
      "" ;; Deliberate space for menu
      ("w m" "Margin-note line or region…" jf/tor-wrap-as-marginnote-dwim  :if-derived (or markdown-mode html-mode))
      ("w p" "Wrap point or region as Poem…" jf/tor-wrap-in-poem  :if-derived (or markdown-mode html-mode))
      ("w s" "Side-note sentence or region…" jf/tor-wrap-as-sidenote-dwim  :if-derived (or markdown-mode html-mode))
      ("w w" "Wrap point or region in html…" jf/tor-wrap-in-html-tag  :if-derived (or markdown-mode html-mode))
      ]]
    [["Contexts"
      ("-b" "Burning Wheel…"  jf/menu--bwg)
      ("-f" "Forem…" jf/menu--forem)
      ("-t" "TakeOnRules…" jf/menu--tor)
      ]
     ["Grab"
      ("g e" "Elfeed" jf/menu--org-capture-elfeed-show :if-derived elfeed-show-mode)
      ("g f" "Firefox" jf/menu--org-capture-firefox)
      ("g s" "Safari" jf/menu--org-capture-safari)
      ("g w" "Eww" jf/menu--org-capture-eww :if-derived eww-mode)
      ;; ("g u" "URL")
      ]
     ["Jump to"
      ;; ("j a" "Agenda" ibuffer)
      ("j b" "iBuffer" ibuffer)
      ("j f" "Flycheck" consult-flycheck :if-derived (or markdown-mode org-mode))
      ("j g" "Global Mark" consult-global-mark)
      ("j i" "Indesk" jf/indesk-jump-to-file :if-non-nil jf/indesk-current-files-on-desk)
      ("j m" "Mark" consult-mark)
      ]
     ["Modes"
      ;; I could write functions for these, but this is concise enough
      ("m h" jf/hammerspoon-toggle-mode  :if-non-nil hammerspoon-edit-minor-mode)
      ("m t" "Typopunct ( )" typopunct-mode :if-nil typopunct-mode)
      ("m t" "Typopunct (*)" typopunct-mode :if-non-nil typopunct-mode)
      ("m o" "MacOS Native Option ( )" jf/toggle-osx-alternate-modifier :if-non-nil ns-alternate-modifier)
      ("m o" "MacOS Native Option (*)" jf/toggle-osx-alternate-modifier :if-nil ns-alternate-modifier)
      ]]
    [["Org Add-Ons"
      ("o c" "Context set…" jf/org-auto-tags--set-by-context :transient t)
      ("o t" "Tag add…" org-roam-tag-add :if-derived org-mode)
      ("o r" "Ref add…" org-roam-ref-add :if-derived org-mode)
      ("o s" jf/org-auto-tags--transient :transient t)
      ("o i" jf/indesk-current-files-on-desk--transient)
      ]])
#+end_src

* Footnotes

[fn:8] Steve Covey, and trademarked by FranklinCovey.

[fn:7] Yes, I said I didn’t want an Electron-based editor, but VS Code is a dominant player in the open source text editor.

[fn:1] Iterating on my v2 ~org-roam~ setup was critical in learning more about Emacs.  I will certainly [[https://codeberg.org/takeonrules/dotemacs/src/commit/2f5d6c81d68aaa0d4de9cc7b409c090c0886300a/jnf-emacs-packages/jnf-org-roam-v2.el][reference my v2 org roam configuration]] as I continue my Emacs usage.

[fn:2]  https://github.com/minad/consult#introduction

[fn:3]  These functions assume that the repository is using a [[https://rietta.com/blog/github-merge-types/#squash-and-merge][Squash and Merge strategy]].

[fn:4] My alias is as follows: ~alias e-reboot='cd ~/git/dotemacs; git stash ; edaemon ; git stash pop ; git edit'~.

[fn:5] My [[https://codeberg.org/takeonrules/dotzshrc/src/ab8b781cbdddd2fdbe674e031436b7e9a8e8a024/README.org#L1][dotzshrc]] config has my ~$EDITOR~

[fn:6] “Ag” is the chemical symbol for the Silver element.

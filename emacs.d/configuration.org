# -*- org-insert-tilde-language: emacs-lisp; -*-
:PROPERTIES:
:ID:       82C14F1A-163D-4774-A27F-1D792495922A
:END:
:HUGO:
#+HUGO_FRONT_MATTER_FORMAT: yaml
#+HUGO_BASE_DIR: ~/git/takeonrules.source
#+HUGO_SECTION: posts/2022
:END:
#+TITLE: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :comments link
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+STARTUP: showall
#+OPTIONS: toc:3

* Introduction

On <2020-05-25> I wrote [[https://takeonrules.com/2020/05/25/principles-of-my-text-editor/][Principles of My Text Editor]].  I was exploring adopting
a new text editor, and wanted to ensure that I knew what I was looking for.
You know, “begin with the end in mind.”[fn:8]

When I first dove in, I looked into [[https://github.com/hlissner/doom-emacs][Doom]] and [[https://www.spacemacs.org][Spacemacs]].  However, in doing that
I got ahead of myself.  So I started with an empty ~init.el~ and walked through
the tutorial.

From that point forward, I committed to use Emacs as is and when I knew I
needed something, I’d look into how to do it.  The result?  A configuration
that is uniquely mine.

On <2022-02-01 Tue> I chose to begin extracting my the various ~*.el~ into a
[[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]] format.  As with all Emacs configurations, what follows is
a work in progress.

** Tips on Troubleshooting

As I migrated from my ~*.el~ configurations, I moved one ~.el~ file at a time.
With each move, I would restart my Emacs daemon[fn:5].  I went so far as
to write a ~e-reboot~ alias[fn:4].  So if I “messed up”, I could easily
recover and fix the files I broke.

In other words, when I’m working on extending my Emacs configuration, I tend to
favor a bisset approach.  Make a change, verify it, and commit.  This helps
insulate me from “getting to far ahead of myself.”  Along the way, I failed to
always apply that discipline.

** About the Current Structure

The current structure is carried over from my past structure.  As I was first
adopting Emacs, I spent time organizing the packages.  This organization is a
bit muddy, as I never quite established the nomenclature.

What I can say is the order may be important.  But I’ll be working to untangle
that.

Where feasible, I have tried to bind keys “close” to their utilization.  That
is to say, I often leverage the ~:bind~, ~:hook~, and ~:map~ keywords for
~use-package~.  But I’m not always consistent.

In the ~org-mode~ version, I’m making use of “TODO” indicators to help me track
what else I may need to do.  A node marked as “DONE” should be viewed as “I
don’t need to go back and amend any documentation in that part.  However, it
doesn’t mean I won’t put more things in that section.”

** Organizing the Ideas

I’ve thought quite a bit about how to organize this file.  How does one narrate
the intertwined concepts of a configuration that is an amalgamation of so many
other people’s work?

My approach is to think back to my experience with the tutorial.  How it walked
me through the concepts.  I also need to be mindful that as I introduce source
code concepts, they are evaluated in that order.

** Conventions

I’ve written quite a few functions to further extend the utility of Emacs.  I
try to prefix them with ~jf/~.  And if I cribbed those functions from
elsewhere, I attempt to give credit to the source.

* Into the Emacs

** Launching Emacs

As we get started in Emacs, I want to make sure I have the basics lined up.

- Package Management
- Preliminary Configuration
- Basic Theming

*** Package Management

I have chosen to adopt ~straight.el~ for my package management.  The fact that
it rather seamlessly works with ~use-package~ has help me keep my code more
organized.

#+begin_src emacs-lisp
  ;; https://www.reddit.com/r/emacs/comments/mtb05k/emacs_init_time_decreased_65_after_i_realized_the/
  (setq straight-check-for-modifications '(check-on-save find-when-checking))

  ;; This preamble is part of straight-use-package My understanding, in
  ;; reading straight documentation is that it has better load
  ;; times. However, the configuration options I often see leverage
  ;; "use-package" which is why most of my package declarations look as
  ;; they do.
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file))

  (setq straight-repository-branch "develop")
  (straight-use-package 'use-package)
#+end_src

*** Preliminary Configuration

These are some general configurations that I’ve slowly accumulated.  There’s
inline documentation in most cases.  There might be little bits worth teasing
out but for the most part, you can move along and reference this later.

#+begin_src emacs-lisp
  (setq user-full-name "Jeremy Friesen"
	user-mail-address "jeremy@jeremyfriesen.com")

  (defconst jf/silence-loading-log t
    "When t log to stdout load messages from this configuration.

    In a previous iteration, I loaded lots of separate '*.el' files.
    This flag allowed me to more easily troubleshoot those load
    attempts.")

  (defconst jf/github-username "jeremyf"
    "My username on github.")

  (global-so-long-mode) ;; Handle long files.
  (electric-pair-mode)  ;; https://blog.sumtypeofway.com/posts/emacs-config.html
  (make-directory "~/.emacs.d/autosaves/" t) ;; Ensuring I have an autosave
  ;; directory.
  (recentf-mode 1) ;; Track recent
  (run-at-time nil (* 2 60) 'recentf-save-list) ;; Save files every 2 minutes
  (global-auto-revert-mode)

  (setq-default fill-column 79)   ;; Feeling a bit old school with 80 characters.
  (setq-default cursor-type 'bar) ;; Doing a bit of configuration of my cursors
  (blink-cursor-mode t)

  (setq
   backup-by-copying t         ;; Don't delink hardlinks

   backup-directory-alist '((".*" . "~/.emacs.d/backups/"))

   bookmark-default-file "~/git/emacs-bookmarks/bookmarks"

   custom-safe-themes t        ;; I may as well trust themes.

   create-lockfiles nil        ;; Don't create lock files.

   delete-old-versions t       ;; Automatically delete excess backups

   echo-key-strokes 0.2

   global-mark-ring-max 32

   idle-update-delay 1.1       ;; Slow down the UI being updated to improve
			       ;; performance

   indent-tabs-mode nil        ;; Ensure tabs are expanded, not inserted

   inhibit-startup-screen t    ;; Don't include the  emacs "start" window

   kept-new-versions 20        ;; how many of the newest versions to keep

   kept-old-versions 5         ;; and how many of the old

   kill-ring-max 120           ;; Set a generous kill ring size.

   read-process-output-max (* 6 512 1024)  ;; Increase read size per process

   recentf-max-menu-items 50

   recentf-max-saved-items 50

   ring-bell-function 'ignore  ;; Stop ringing any bell

   split-width-threshold 160

   vc-follow-symlinks t        ;; Follow symlinks instead of prompting.

   version-control t           ;; Use version numbers on backups

   x-underline-at-descent-line t ;; Recommendation from
				 ;; https://protesilaos.com/emacs/modus-themes
   )

  (setq enable-recursive-minibuffers t)

  (use-package recursion-indicator
    :straight t
    :config
    (recursion-indicator-mode))

  (global-hl-line-mode)

  ;; When you open Emacs, grab all the space on the screen
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))

  (tool-bar-mode -1) ;; Hide the icons of the Emacs toolbar
  (scroll-bar-mode -1) ;; Hide the scroll bar. Let's be clear, I don't use it.
  (defalias 'yes-or-no-p 'y-or-n-p) ;; Always "y" or "n" for yes/no

  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)



  (use-package abbrev
    :straight (:type built-in)
    :custom (abbrev-file-name (file-truename "~/git/dotemacs/emacs.d/abbrev_defs"))
    :hook (text-mode . abbrev-mode))

  (add-function :after after-focus-change-function
		(defun jf/garbage-collect-maybe ()
		  (unless (frame-focus-state)
		    (garbage-collect))))
#+end_src

And I’m going to disable a few key bindings.  These were always messing me up a
bit.  Also enable a few that I find helpful.  (I’ll enable a lot more later).

#+begin_src emacs-lisp
  (unbind-key "C-z") ;; `suspend-frame'
  (unbind-key "C-c o") ;; was bound to open a file externally
  (unbind-key "C-x C-c") ;; was `save-buffers-kill-terminal'

  (global-set-key (kbd "<M-delete>") 'kill-word)
  (global-set-key (kbd "<s-down>") 'end-of-buffer)
  (global-set-key (kbd "<s-up>") 'beginning-of-buffer)
  (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
  (global-set-key (kbd "s-w") 'kill-current-buffer)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

In using a literate config, I have a mixture of two types of text: prose and code.  The following ~imenu-literate-emacs-lisp~ was pulled from [[https://www.reddit.com/r/emacs/comments/t6noeb/literate_imenu/][Literate imenu? : emacs]].

#+begin_src emacs-lisp
  (global-set-key (kbd "s-4") 'imenu-list-minor-mode)
  (use-package imenu-list
    :custom (imenu-list-focus-after-activation t)
    :straight t)

  (defvar imenu-literate-modes-alist
    '((lisp-mode . (:expressions lisp-imenu-generic-expression))
      (emacs-lisp-mode . (:expressions lisp-imenu-generic-expression))))

  (defvar imenu-literate-current-mode nil)

  (defun imenu-literate-set-mode ()
    (interactive)
    (let ((mode (intern
		 (completing-read "Imenu literate mode: "
				  (mapcar #'car imenu-literate-modes-alist)))))
      (setq-local imenu-literate-current-mode mode)))

  (defun imenu-literate (src-edit?)
    "Imenu of expressions in a literate file.

    When provided SRC-EDIT? via the Universal Parameter
    prefix (e.g. C-u), open the selected imenu subject using
    `org-edit-special'."
    (interactive "P")
    (unless imenu-literate-current-mode (imenu-literate-set-mode))
    (let* ((pair (or (alist-get imenu-literate-current-mode
				imenu-literate-modes-alist)
		     (error "Mode %s not found!" imenu-literate-current-mode)))
	   (expressions (getf pair :expressions))
	   (index-function (getf pair :index-function
				 #'imenu-default-create-index-function))
	   ;;
	   (imenu-generic-expression (eval expressions))
	   (imenu-create-index-function index-function))
      (imenu-list-update-safe)
      (imenu-list-refresh)
      (call-interactively #'imenu)
      (when src-edit?
	(org-edit-special))))

  (global-set-key (kbd "C-s-2") 'imenu-literate)
#+end_src

Some basic packages to keep things less chatty.

*Diminish* provides a means of not displaying the :lighter of a minor mode in the modeline.

#+begin_src emacs-lisp
  (use-package diminish
    :straight t
    :diminish 'eldoc-mode
    :diminish 'abbrev-mode)
#+end_src

*Gcmh* does garbage collection (GC) when the user is idle.

#+begin_src emacs-lisp
  (use-package gcmh
    :straight t
    :diminish 'gcmh-mode
    :init
    (setq gcmh-idle-delay 5
	  gcmh-high-cons-threshold (* 16 1024 1024))  ; 16mb
    :config (gcmh-mode))
#+end_src

*** Basic Theming

I want to start with a basic look and feel.  First, the choice of primary font.

#+begin_src emacs-lisp
  (defvar jf/fixed-width-font-name
    "Iosevka Term"
    "The name of the fixed width font.
    I have it sprinkled through too many places.

    Alternatives:
    - \"Iosevka Nerd Font Mono\"
    - \"Iosevka Term\"
    - \"Monaco\"
    - \"JetBrains Mono\"
    - \"Hack Nerd Font\"")

  (set-frame-font jf/fixed-width-font-name)
#+end_src

And now the theme.  I’ve chosen the modus themes (e.g. ~modus-vivendi~ and
~modus-operandi~).  They provide a light and dark theme with a focus on visual
accessibility.

I love [[http://protesilaos.com][Prot]]’s attention to detail with the modus themes.  Here’s my
configuration for these two sibling themes.  There’s a bit of chatter, but all
told it sets things up how I like.

#+begin_src emacs-lisp
  (use-package modus-themes
    ;; :straight (modus-themes :type built-in)
    :straight (:type git :host gitlab :repo "protesilaos/modus-themes" :branch "main")
    :init
    (setq
     modus-themes-vivendi-color-overrides
     ;; '((bg-region-accent-subtle . "#240f55")) ;; Default
     ;; '((bg-region-accent-subtle . "#323da2"));; Good candidate
     '((bg-region-accent-subtle . "#304466"))

     modus-themes-bold-constructs t
     modus-themes-completions '((matches . (extrabold))
				(selection . (semibold accented))
				(popup . (accented intense)))
     modus-themes-diffs nil
     modus-themes-fringes 'intense
     modus-themes-hl-line '(accented intense)
     modus-themes-intense-markup t
     modus-themes-links '(faint background)
     modus-themes-mixed-fonts t
     modus-themes-mode-line '(accented 3d)
     modus-themes-org-blocks 'gray-background
     modus-themes-paren-match '(bold intense)
     modus-themes-prompts '(intense accented)
     modus-themes-region '(bg-only accented)
     modus-themes-scale-headings t
     modus-themes-slanted-constructs t
     modus-themes-subtle-line-numbers t
     modus-themes-syntax '(alt-syntax yellow-comments green-strings)
     modus-themes-tabs-accented t
     modus-themes-headings
     '((1 . (variable-pitch light 1.6))
       (2 . (overline semibold 1.4))
       (3 . (monochrome overline 1.2))
       (4 . (overline 1.1))
       (t . (rainbow 1.05)))))
#+end_src

With a quick bit of testing, it appears that the following ~set-face-attribute~
declarations should be made after the theme declarations.  When the following
statements were declared before the themes, and I toggled my theme, the font
changed to something unexpected.  With them declared after, I keep the fonts
between toggles.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil
		      :family jf/fixed-width-font-name
		      :height 140)
  (set-face-attribute 'variable-pitch nil
		      :family "ETBembo"
		      :height 1.1)
  (set-face-attribute 'fixed-pitch nil
		      :family jf/fixed-width-font-name
		      :height 1.0)
#+end_src

Next up, let’s load the theme based on my operating system’s settings
(e.g. Light or Dark mode).  /Note:/ I could just start with ~(load-theme
‘modus-operandi)~ but figure I’ll add a little bit of “nice to have up front.

#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
      (progn
	(defun jf/dark ()
	  "Toggle system-wide Dark or Light setting."
	  (interactive)
	  (shell-command "osascript -e 'tell application \"System Events\" to tell appearance preferences to set dark mode to not dark mode'")
	  (jf/emacs-theme-by-osx-appearance))

	(defalias 'modus-themes-toggle 'jf/dark)
	(defun jf/emacs-theme-by-osx-appearance ()
	  "Set theme based on OSX apperance state."
	  (if (equal "Dark" (substring (shell-command-to-string "defaults read -g AppleInterfaceStyle") 0 4))
	      (load-theme 'modus-vivendi)
	    (load-theme 'modus-operandi)))
	;; And load the appropriate theme
	(jf/emacs-theme-by-osx-appearance))
    (progn
      (defun modus-themes-toggle ()
	"Toggle between `modus-operandi' and `modus-vivendi' themes."
	(interactive)
	(if (eq (car custom-enabled-themes) 'modus-operandi)
	    (load-theme 'modus-vivendi)
	  (load-theme 'modus-operandi)))
      (load-theme 'modus-operandi)))
#+end_src

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "emacs-tabs.org"))
#+end_src

** How Does this Thing Work?

In this section my goal is to load some “fundamental” packages that help me
better introspect and navigate Emacs.

With the initial “setup” out of the way, let’s dive into how things work.

I want to make it easy to find help on different aspects of Emacs.  There’s
tooling baked into Emacs, but the ~helpful~ package “provides much more
contextual information.”

Futhermore, I want to make a menu to help remind me of the help I have
available.  In previous incarnations I’ve written these menus using
[[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][pretty-hydra]], but I’ve started moving these to [[https://github.com/magit/transient/tree/440a341831398b825dc2288a10821cf7be1999ca][transient]]; a package that’s a
hard requirement for packages I’ll later introduce.


#+begin_src emacs-lisp
  (use-package helpful
    :init
    (use-package transient :straight t)
    ;; I'm going to talk about this later, but I'm adding this to the menu, so I
    ;; may as well state the dependency.
    (use-package embark :straight t)
    :straight t
    :config
    (transient-define-prefix jf/helpful-menu ()
      "Return a `transient' compliant list to apply to different transients."
      ["Help"
       ""
       ("b" "Bindings" embark-bindings)
       ("c" "Command" helpful-command)
       ("f" "Function (interactive)" helpful-callable)
       ("F" "Function (all)" helpful-function)
       ("k" "Key" helpful-key)
       ("l" "Library" find-library)
       ("m" "Macro" helpful-macro)
       ("p" "Thing at point" helpful-at-point)
       ("." "Thing at point" helpful-at-point)
       ("t" "Text properties" describe-text-properties)
       ("v" "Variable" helpful-variable)])
    :bind ("C-s-h" . jf/helpful-menu))
#+end_src

With the above, I can now type ~C-s-h~ to bring up my helpful menu, and begin
exploring.

Emacs has lots of keybindings and many of them chain together several keys.  As
I’m learning those keys, I might remember the first prefix.

When I type the first key of a sequence and wait, ~which-key~ pops up a menu of
candidate functions and the keys to invoke each of them.  Another way to
introspect Emacs.

#+begin_src emacs-lisp
  (use-package which-key
    :diminish 'which-key-mode
    :config
    (which-key-mode)
    (which-key-setup-side-window-right)
    (which-key-show-major-mode)
    :straight t)
#+end_src

Related to this, when I’m in a buffer, I want to know what I can do.  The
~embark~ package provides the missing context menu (e.g. “right click”) for
Emacs.  /It provides more, but we’ll get to that later./

#+begin_src emacs-lisp
  (use-package embark
    :straight t
    :bind
    (("C-." . embark-act)       ;; pick some comfortable binding
     ("M-." . embark-dwim)
     ("C-s-e" . embark-export)
     ("C-h b" . embark-bindings))
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    (setq embark-action-indicator
	  (lambda (map &optional _target)
	    (which-key--show-keymap "Embark" map nil nil 'no-paging)
	    #'which-key--hide-popup-ignore-command)
	  embark-become-indicator embark-action-indicator)
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))
#+end_src

When I call ~embark-act~ (via ~C-.~) I get a buffer listing the actions I can
take on the target.  A contextual menu if you will.

There’s also the ~embark-dwim~ (I map that to ~M-.~).  Given a target, the
place at point, when I call ~embark-dwim~ it takes an applicable action.  For a
URL, it will open that URL in the configured browser.

As a tangent, let’s think in terms of “pairs”.  A target and an action.

With ~embark-export~ I can gather a group of targets (via ~embark-export~) and
sthen take actions on them.  I write more about this later as it relates to
~wgrep~.

Embark helps me know what actions are available, but I may want a broader
context.

Another mechanism for taking an action is ~M-x~ (or
~execute-extended-command~).  When I type ~M-x~, I’m prompted to provide the
name of a function.

It would instead of typing ~[TAB]~, I could see a list of candidate functions.
For that, I’m going to use the lightweight vertico package.

#+begin_src emacs-lisp
  (use-package vertico
    :straight t
    :config
    (vertico-mode)
    ;; Use `consult-completion-in-region' if Vertico is enabled.
    ;; Otherwise use the default `completion--in-region' function.
    (setq completion-in-region-function
	  (lambda (&rest args)
	    (apply (if vertico-mode
		       #'consult-completion-in-region
		     #'completion--in-region)
		   args)))
    (setq read-file-name-completion-ignore-case t
	  read-buffer-completion-ignore-case t
	  completion-ignore-case t)
    (advice-add #'completing-read-multiple
		:override #'consult-completing-read-multiple)
    (setq vertico-cycle t))
#+end_src

Further more, I’m going to enable a few extensions.

The ~vertico-indexed.elc~ extension adds a visual indicator of each candidate’s
index.  Further, I can type ~C-<num> ENT~ and select that candidate.  Often
it’s just as easy to navigate via ~TAB~ or ~C-n~ / ~C-p~ but the visual
indicator is a nice bit of polish.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-indexed.elc"
	nil
	jf/silence-loading-log)
  (vertico-indexed-mode)
#+end_src

The ~vertico-repeat.elc~ extension does one simple thing: it remembers and
gives quick access to the last command you entered in the “minibuffer.”  This
can be super userful if I built up a complicated ~consult-ripgrep~.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-repeat.elc"
	nil
	jf/silence-loading-log)
  (global-set-key (kbd "M-r") #'vertico-repeat)
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
#+end_src

Related to, but independent of ~vertico-repeat.elc~ is enabling
~savehist-mode~.  With that enabled, I have access to a few dozen of the last
minibuffer commands I issued.  These are, by default, in ~\~/.emacs.d/history~.

#+begin_src emacs-lisp
  (savehist-mode 1)
#+end_src

Giving a go at ~vertico-posframe~ to render a “pop-up” instead of the minibuffer.

#+begin_src emacs-lisp
  (use-package vertico-posframe
    :straight t
    :config (vertico-posframe-mode 1)
    (setq vertico-posframe-width 170)
    (setq vertico-posframe-height nil)
    (setq vertico-posframe-parameters
	'((left-fringe . 8)
	  (right-fringe . 8))))
#+end_src

Now that I have a list of candidates commands, it would be nice if those
candidates had some annotations.  Let’s load the ~marginalia~ package.  It
provides annotations to minibuffer completions, and pairs nicely with Vertico.

#+begin_src emacs-lisp
  (use-package marginalia
    :straight t
    ;; /Note:/ The declaration of `marginalia-mode' must be in the :init
    ;; section.This ensures that it is enabled right away.  It also forces the
    ;; loading of the package.
    :init (marginalia-mode))
#+end_src

** Writing, Coding, Computering

*** Projects

- ~projectile.el~ :: this package provides convenient organization and commands to run over projects.

#+begin_src emacs-lisp
  (use-package projectile
    :straight t
    :diminish 'projectile-mode
    :config (projectile-mode 1)
    :custom (projectile-project-search-path '("~/git/"))
    :bind ("s-." . projectile-toggle-between-implementation-and-test))
#+end_src

/Note:/ The =CMD= + =.= is a carryover from my [[https://macromates.com][Textmate]] and [[https://www.sublimetext.com/][Sublime Text]] days.
That’s one of those hot-keys almost burned into soul.

*** Support Packages

When I start writing functions, there’s a few packages I want to consider.

- ~keychain-environment.el~ :: Load keychain environment variables

#+begin_src emacs-lisp
  (use-package keychain-environment
    :straight t
    :config (keychain-refresh-environment))
#+end_src

- ~dash.el~ :: A modern list API for Emacs. No 'cl required.  (See https://github.com/magnars/dash.el/)

#+begin_src emacs-lisp
  (use-package dash :straight t)
#+end_src

- ~f.el~ :: A modern API for working with files and directories in Emacs. (See https://github.com/rejeep/f.el/)

#+begin_src emacs-lisp
  (use-package f :straight t)
#+end_src

- ~s.el~ :: The long lost Emacs string manipulation library.  (See https://github.com/magnars/s.el/)

#+begin_src emacs-lisp
  (use-package s :straight t)
#+end_src

- ~editorconfig.el~ :: “EditorConfig helps maintain consistent coding styles
  for multiple developers working on the same project across various editors
  and IDEs.”  See https://editorconfig.org/#overview for more details.

#+begin_src emacs-lisp
  (use-package editorconfig
    :straight t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))
#+end_src

- ~rigprep.el~ :: For many years, I’ve used “The Silver Searcher”, or ~ag~ on
  the command line.[fn:6].  However, [[https://github.com/BurntSushi/ripgrep][ripgrep]] provides even faster searching,
  with an almost identical parameter list.

#+begin_src emacs-lisp
  (use-package rg
    :config (rg-enable-menu)
    ;; :init (setq ripgrep-arguments "--ignore-case")
    :straight t)
#+end_src

*** Completion

**** Emacs Adjustments for Completion

What follows is adjustments to emacs settings as they relate to completion.

#+begin_src emacs-lisp
  (use-package emacs
    :init

    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
    (setq read-extended-command-predicate
	  #'command-completion-default-include-p)

    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)

    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
	  '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src

**** consult.el

- ~consult.el~ :: “Consult provides practical commands based on the Emacs
  completion function [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][completing-read]].”  I had previously used [[https://github.com/abo-abo/swiper][Ivy, Counsel,
  and Swiper]], but appreciate the design principles of Consult, namely “Consult
  fits well into existing setups and it helps you to create a full completion
  environment out of small and independent components.”[fn:2]

  With ~consult.el~ I’m able to bring in other components that focus on doing
  their “one thing” really well.

#+begin_src emacs-lisp
  (use-package consult
    :straight t
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
	   ("C-c h" . consult-history)
	   ;; ("C-c m" . consult-mode-command)
	   ("C-c b" . consult-bookmark)
	   ("C-c k" . consult-kmacro)
	   ;; C-x bindings (ctl-x-map)
	   ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complet-command
	   ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("s-b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
	   ("C-s-b" . consult-buffer-other-window)
	   ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
	   ;; Custom M-# bindings for fast register access
	   ("M-#" . consult-register-load)
	   ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
	   ("M-`" . consult-register)
	   ;; Other custom bindings
	   ("M-y" . consult-yank-from-kill-ring)                ;; orig. yank-pop
	   ("<help> a" . consult-apropos)            ;; orig. apropos-command
	   ;; M-g bindings (goto-map)
	   ("M-g e" . consult-compile-error)
	   ("M-g g" . consult-goto-line)             ;; orig. goto-line
	   ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
	   ("s-l" . consult-goto-line)           ;; orig. goto-line
	   ("M-g o" . consult-outline)
	   ("M-g m" . consult-mark)
	   ("M-g k" . consult-global-mark)
	   ("C-x C-SPC" . consult-global-mark)
	   ("M-g i" . consult-imenu)
	   ("s-2" . consult-imenu)
	   ("M-g I" . consult-imenu-multi)
	   ;; M-s bindings (search-map)
	   ("M-s f" . consult-find)
	   ("M-s L" . consult-locate)
	   ("M-s g" . consult-grep)
	   ("M-s G" . consult-git-grep)
	   ("M-s r" . consult-ripgrep)
	   ("C-c f" . consult-ripgrep)
	   ("M-s l" . consult-line)
	   ("M-s m" . consult-multi-occur)
	   ("M-s k" . consult-keep-lines)
	   ("M-s u" . consult-focus-lines)
	   ;; Customizations that map to ivy
	   ("s-r" . consult-recent-file) ;; Deprecate
	   ("C-c r" . consult-recent-file)
	   ;; ("C-c o" . consult-file-externally)
	   ("C-y" . yank)
	   ("C-s" . consult-line) ;; I've long favored Swiper mapped to c-s
	   ;; Isearch integration
	   ("M-s e" . consult-isearch)
	   :map isearch-mode-map
	   ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
	   ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
	   ("M-s l" . consult-line))                 ;; required by consult-line to detect isearch

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting.  This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.1
	  register-preview-function #'consult-register-format)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
	  xref-show-definitions-function #'consult-xref)

    ;; Updating the default to include "--smart-case"
    ;; Leveraging ripgrep-all https://github.com/phiresky/ripgrep-all
    (setq consult-ripgrep-command "rga --null --line-buffered --color=ansi --max-columns=1000 --smart-case --no-heading --line-number . -e ARG OPTS")
    (setq consult-ripgrep-args "rga --null --line-buffered --color=never --max-columns=1000 --path-separator /   --smart-case --no-heading --line-number .")

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root))
#+end_src

***** Advising Functions

I wrote some advising functions to wrap around ~consult-line~ and
~consult-ripgrep~.  These wrapping functions use the active region as the
initial text or an empty string if there’s no active region.

There’s a macro in here somewhere.

#+begin_src emacs-lisp
  (defun jf/consult-first-param-is-initial-text (consult-fn &rest rest)
    "Advising function around CONSULT-FN.

  The CONSULT-FN's first parameter should be the initial text.

  When there's an active region, use that as the first parameter
  for CONSULT-FN.  Otherwise, use an empty string the first
  parameter.  This function handles the REST of the parameters."
    (interactive)
    (apply consult-fn
	   (when (use-region-p)
	     (buffer-substring
	      (region-beginning) (region-end)))
	   rest))

  (defun jf/consult-ripgrep-wrapper (consult-fn &optional dir given-initial)
    "Advising function around CONSULT-FN.

  DIR and GIVEN-INITIAL match the method signature of `consult-wrapper'."
    (interactive "P")
    (let ((initial (list (or given-initial
		    (when (use-region-p)
		      (buffer-substring (region-beginning) (region-end)))))))
      (apply consult-fn dir initial)))

  (advice-add #'consult-line
	      :around #'jf/consult-first-param-is-initial-text
	      '((name . "wrapper")))
  (advice-add #'consult-ripgrep
	      :around #'jf/consult-ripgrep-wrapper
	      '((name . "wrapper")))
#+end_src
***** consult-dir.el

- ~consult-dir.el~ :: This package helps ease traveling across directories by
  providing directory candidates related to current buffers, bookmarks, and
  projects.  Further, like other ~consult.el~ functions, you can use narrowing
  keys.  See https://github.com/karthink/consult-dir.

#+begin_src emacs-lisp
  (use-package consult-dir
    :straight t
    :after (consult)
    :bind (("C-x C-d" . consult-dir)
	   :map minibuffer-local-completion-map
	   ("C-x C-d" . consult-dir)
	   ("C-x C-j" . consult-dir-jump-file)))
#+end_src
***** consult-projectile.el

- ~consult-projectile.el~ :: package provides a function I use everyday: ~M-x
  consult-projectile~.  When I invoke ~consult-projectile~, I have the file
  completion for the current project.  I can also type =b= + =SPACE= to narrow
  my initial search to open buffers in the project.  Or =p= + =space= to narrow
  to other projects; and then select a file within that project.

#+begin_src emacs-lisp
  (use-package consult-projectile
    :commands (consult-projectile)
    :straight (consult-projectile
	       :type git
	       :host gitlab
	       :repo "OlMon/consult-projectile"
	       :branch "master")
    :bind ("s-t" . consult-projectile))
#+end_src

/Note:/ The =CMD= + =t= (e.g. ~s-t~ in Emacs) is a carryover from my [[https://macromates.com][Textmate]]
and [[https://www.sublimetext.com/][Sublime Text]] days.  More than any other key combination, that one is
entirely muscle memory.

**** embark-consult.el

- ~embark-consult.el~ :: I use ~embark.el~ and ~consult.el~, let’s add a little
  bit more connective tissue.

#+begin_src emacs-lisp
  (use-package embark-consult
    :straight t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook

    (embark-collect-mode . consult-preview-at-point-mode)
    (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

**** wgrep.el

- ~wgrep.el~ :: “Edit a grep buffer and apply those changes to the file
  buffer.”  In other words, after “searching” for something, sending the
  results to a buffer (via ~embark-export~ or such thing), you can edit that
  search results buffer and propogate the changes to the locations of the
  elements that matched the search.

1.  Call ~consult-ripgrep~ (via ~C-c f~) to search for something.
2.  Call ~embark-export~ (via ~C-s-e~) to export to a grep buffer.
3.  Call ~wgrep-change-to-wgrep-mode~ (via ~e~ or ~C-c C-p~)
4.  Edit the grep buffer as you would anywhere else.
5.  Save (via ~C-x C-s~) or Cancel (via ~C-c C-k~).

   I use this sequence at least once a day.

#+begin_src emacs-lisp
(use-package wgrep
    :after (embark-consult ripgrep)
    :straight t
    :bind (:map wgrep-mode-map
		;; Added keybinding to echo Magit behavior
		("C-c C-c" . save-buffer)
		:map grep-mode-map
		("e" . wgrep-change-to-wgrep-mode)
		:map ripgrep-search-mode-map
		("e" . wgrep-change-to-wgrep-mode)))
#+end_src

**** orderless.el

The [[https://github.com/minad/orderless][orderless]] package provides completion tooling for non-strict word order.  I
spent considerable time reading through the [[https://github.com/minad/consult/wiki][Orderless section of Consult’s
wiki]].

As configured the orderless completion recognizes the following “switches”:

- Flex (~\~~) :: Just start typing characters and you’ll get matches that have
  those characters
- File Extension (~\.ext~) :: Match files with this extension.
- Regexp ~^.$~ :: Use some regular expression syntax
  - ~^~ matching beginning
  - ~.~ any ol’ character
  - ~$~ matching ending
- Initialism (~`~) :: In ~M-x~ when I typed ~`pl~ the ~previous-line~ function
  was a top match.  The initialism switch “explodes” the characters and says
  match methods who’s words start with those characters.
- Not Literal ~!~ :: Exclude candidates that match the literal
  (e.g. ~!previous~ won’t show ~previous-line~ in the ~M-x~ completion).
- Literal ~=~ :: No “fuzzy buziness”, just match exactly what I typed.

There is another case (e.g. ~%~ character fold) that I don’t yet understand.

More on these component matchings styles is available at [[https://github.com/minad/orderless#component-matching-styles][github.com/minad/orderless]].

#+begin_src emacs-lisp
  (use-package orderless
    :straight t
    :config
    (defvar +orderless-dispatch-alist
      '((?% . char-fold-to-regexp)
	(?! . orderless-without-literal)
	(?`. orderless-initialism)
	(?= . orderless-literal)
	(?~ . orderless-flex)))
    (defun +orderless-dispatch (pattern index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" pattern)
	`(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x100000-\x10FFFD]*$")))
       ;; File extensions
       ((and
	 ;; Completing filename or eshell
	 (or minibuffer-completing-file-name
	     (derived-mode-p 'eshell-mode))
	 ;; File extension
	 (string-match-p "\\`\\.." pattern))
	`(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x100000-\x10FFFD]*$")))
       ;; Ignore single !
       ((string= "!" pattern) `(orderless-literal . ""))
       ;; Prefix and suffix
       ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
	    (cons (cdr x) (substring pattern 1))
	  (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
	    (cons (cdr x) (substring pattern 0 -1)))))))

    ;; Define orderless style with initialism by default
    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

    ;; Certain dynamic completion tables (completion-table-dynamic)
    ;; do not work properly with orderless. One can add basic as a fallback.
    ;; Basic will only be used when orderless fails, which happens only for
    ;; these special tables.
    (setq completion-styles '(orderless basic)
	  completion-category-defaults nil
	    ;;; Enable partial-completion for files.
	    ;;; Either give orderless precedence or partial-completion.
	    ;;; Note that completion-category-overrides is not really an override,
	    ;;; but rather prepended to the default completion-styles.
	  ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
	  completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
					  ;; enable initialism by default for symbols
					  (command (styles +orderless-with-initialism))
					  (variable (styles +orderless-with-initialism))
					  (symbol (styles +orderless-with-initialism)))
	  orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
	  orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src

**** corfu.el

- ~corfu.el~ :: An alternative to the ubiquitous [[https://github.com/company-mode/company-mode][Company]]; In [[https://takeonrules.com/2022/01/17/switching-from-company-to-corfu-for-emacs-completion/][Switching from
  Company to Corfu for Emacs Completion]] I further explain my adoption of Corfu.
  See https://github.com/minad/corfu for more details on Corfu.

  /Note:/ I may explore [[https://gitlab.com/protesilaos/mct][MCT]] and see how it compares to Corfu.

#+begin_src emacs-lisp
  (use-package corfu
    :straight t
    :demand t
    ;; Optionally use TAB for cycling, default is `corfu-complete'.
    :bind (:map corfu-map
		("<escape>". corfu-quit)
		("<return>" . corfu-insert)
		("M-d" . corfu-show-documentation)
		("M-l" . 'corfu-show-location)
		("TAB" . corfu-next)
		([tab] . corfu-next)
		("S-TAB" . corfu-previous)
		([backtab] . corfu-previous))

    :custom
    ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
    ;; want to perform completion
    (tab-always-indent 'complete)
    (completion-cycle-threshold nil)      ; Always show candidates in menu

    (corfu-auto nil)
    (corfu-auto-prefix 2)
    (corfu-auto-delay 0.25)

    ;; (corfu-min-width 80)
    ;; (corfu-max-width corfu-min-width)     ; Always have the same width
    (corfu-count 14)
    (corfu-scroll-margin 4)
    (corfu-cycle nil)

    ;; (corfu-echo-documentation nil)        ; Already use corfu-doc
    (corfu-separator ?\s)                 ; Necessary for use with orderless
    (corfu-quit-no-match 'separator)

    (corfu-preview-current 'insert)       ; Preview current candidate?
    (corfu-preselect-first t)             ; Preselect first candidate?

    :init
  ;; Recommended: Enable Corfu globally.
    ;; This is recommended since dabbrev can be used globally (M-/).
    (corfu-global-mode))
#+end_src

***** Extending corfu.el

- ~corfu-move-to-minibuffer~ :: The completion at point “popup” can sometimes
  be a little cryptic or terse.  The ~corfu-move-to-minibuffer~ provides a
  means of moving the “popup” candidates to the minibuffer for further
  inspection.

#+begin_src emacs-lisp
  (defun corfu-move-to-minibuffer ()
    "Move \"popup\" completion candidates to minibuffer.

  Useful if you want a more robust view into the recommend candidates."
    (interactive)
    (let (completion-cycle-threshold completion-cycling)
      (apply #'consult-completion-in-region completion-in-region--data)))
  (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer)
#+end_src

- ~kind-icons~ :: From [[https://kristofferbalintona.me/posts/corfu-kind-icon-and-corfu-doc/][Corfu, Kind-icon, and Corfu-doc | Kristoffer Balintona]]

#+begin_src emacs-lisp
  (use-package kind-icon
    :straight t
    :after corfu
    :custom
    (kind-icon-use-icons t)
    (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face background
    (kind-icon-blend-background nil)  ; Use midpoint color between foreground and background colors ("blended")?
    (kind-icon-blend-frac 0.08)

    ;; NOTE 2022-02-05: `kind-icon' depends `svg-lib' which creates a cache
    ;; directory that defaults to the `user-emacs-directory'. Here, I change that
    ;; directory to a location appropriate to `no-littering' conventions, a
    ;; package which moves directories of other packages to sane locations.
    ;; (svg-lib-icons-dir (no-littering-expand-var-file-name "svg-lib/cache/")) ; Change cache dir
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter) ; Enable `kind-icon'

    ;; Add hook to reset cache so the icon colors match my theme
    ;; NOTE 2022-02-05: This is a hook which resets the cache whenever I switch
    ;; the theme using my custom defined command for switching themes. If I don't
    ;; do this, then the backgound color will remain the same, meaning it will not
    ;; match the background color corresponding to the current theme. Important
    ;; since I have a light theme and dark theme I switch between. This has no
    ;; function unless you use something similar
    (add-hook 'kb/themes-hooks #'(lambda () (interactive) (kind-icon-reset-cache))))
#+end_src

- ~corfu-doc~ :: From [[https://kristofferbalintona.me/posts/corfu-kind-icon-and-corfu-doc/][Corfu, Kind-icon, and Corfu-doc | Kristoffer Balintona]]

#+begin_src emacs-lisp
  (use-package corfu-doc
    ;; NOTE 2022-02-05: At the time of writing, `corfu-doc' is not yet on melpa
    :straight (corfu-doc :type git :host github :repo "galeo/corfu-doc")
    :bind (:map corfu-map
		;; This is a manual toggle for the documentation window.
		([remap corfu-show-documentation] . corfu-doc-toggle) ; Remap the default doc command
		;; Scroll in the documentation window
		("M-n" . corfu-doc-scroll-up)
		("M-p" . corfu-doc-scroll-down))
    :hook (corfu-mode . corfu-doc-mode)
    :custom
    (corfu-doc-delay 0.1)
    (corfu-doc-hide-threshold 10)
    (corfu-doc-max-width 60)
    (corfu-doc-max-height 10)

    ;; NOTE 2022-02-05: I've also set this in the `corfu' use-package to be
    ;; extra-safe that this is set when corfu-doc is loaded. I do not want
    ;; documentation shown in both the echo area and in the `corfu-doc' popup.
    ;; (corfu-echo-documentation nil)
    :config
    ;; NOTE 2022-02-05: This is optional. Enabling the mode means that every corfu
    ;; popup will have corfu-doc already enabled. This isn't desirable for me
    ;; since (i) most of the time I do not need to see the documentation and (ii)
    ;; when scrolling through many candidates, corfu-doc makes the corfu popup
    ;; considerably laggy when there are many candidates. Instead, I rely on
    ;; manual toggling via `corfu-doc-toggle'.
    (corfu-doc-mode))
#+end_src

**** cape.el

- ~cape.el~ :: provides several Completion At Point Extensions (Capfs).  I like
  having a Capf for spelling and files.

#+begin_src emacs-lisp
  (use-package cape
    :straight t
    :bind (("C-c p p" . completion-at-point)
	   ("C-c p d" . cape-dabbrev)
	   ("C-c p f" . cape-file)
	   ("C-c p s" . cape-symbol)
	   ("C-c p i" . cape-ispell)))

  ;; Use Company backends as Capfs.
  (setq-local completion-at-point-functions
    (mapcar #'cape-company-to-capf
      (list #'company-files #'company-ispell #'company-dabbrev)))
#+end_src

**** yasnippet.el

- ~yasnippet.el~ :: A rather convenient snippet manager.  When you create a
  snippet, it understands the mode you're in and puts the snippet in the right
  place.

#+begin_src emacs-lisp
  (use-package yasnippet
    :straight t
    :diminish 'yas-minor-mode
    :init
    (setq yas-snippet-dirs '("~/git/dotemacs/snippets"))
    (yas-global-mode 1))
#+end_src
**** consult-yasnippet.el

- ~consult-yasnippet.el~ :: A bit of integration with ~consult.el~ and ~yasnippet.el~.

#+begin_src emacs-lisp
  (use-package consult-yasnippet
    :straight t
    :after (consult yasnippet)
    :bind ("C-c y" . consult-yasnippet))
#+end_src

*** Navigation
**** avy.el

- ~avy.el~ :: That letter is the beginning of a word.  Narrow results from there.

#+begin_src emacs-lisp
  (use-package avy
    :bind (("C-j" . avy-goto-char-timer))
    :bind (:map org-mode-map ("C-j" . avy-goto-char-timer))
    :straight t)
#+end_src

**** link-hint.el

- ~link-hint.el~ :: Jump to a registered link type.

#+begin_src emacs-lisp
  (use-package link-hint
    :straight t
    :bind
    ("C-c l o" . link-hint-open-link)
    ("C-c l c" . link-hint-copy-link))
#+end_src

**** ibuffer-sidebar.el

Prioir to Emacs, I might use a side panel for directory/file navigation.
However, that’s something I just don’t use in Emacs.  Instead, I’m thinking
about buffers.

The ~ibuffer-sidebar~ package provides an interesting take on the side panel.
It shows me what I’ve opened.  I like that.

#+begin_src emacs-lisp
  (global-set-key (kbd "s-3") 'ibuffer-sidebar-toggle-sidebar)
  (use-package ibuffer-sidebar
    :straight t
    :commands (ibuffer-sidebar-toggle-sidebar))
#+end_src

**** Extending the Mark

From [[https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode][Fixing the mark commands in transient mark mode - Mastering Emacs]]:

#+begin_src emacs-lisp
  (defun jf/mark-without-transient (parg)
    "Push `point' to `mark-ring' or jump to front of `mark-ring' without activating the region.

  When given Universal PARG jump to the mark.  When not given
  Universal PARG set the mark.

  Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
    (interactive "P")
    (if (car parg)
	(progn
	  (set-mark-command 1))
      (progn
	(push-mark (point) t nil)
	(message "Pushed mark to ring"))))

  (global-set-key (kbd "C-`") 'jf/mark-without-transient)
#+end_src

*** Display
**** lin.el

- ~lin.el~ :: “LIN locally remaps the hl-line face to a style that is optimal for major modes where line selection is the primary mode of interaction.”  In otherwords, ~lin.el~ improves the highlighted line behavior for the competing contexts.

#+begin_src emacs-lisp
  (use-package lin
    :straight (lin :host gitlab :repo "protesilaos/lin")
    ;; :config (lin-add-to-many-modes))
    :config (lin-setup))
#+end_src

**** all-the-icons.el

- ~all-the-icons.el~ :: Provides a nice set of reference icons.  The various
  ~jf/all-with--with-~ functions give access to the icons of the named set.

#+begin_src emacs-lisp
  ;; Useful for referential icons.
  (use-package all-the-icons
    :straight t
    :config
    (cl-defmacro jf/all-the-icons--with(&key name)
      (let ((defun-fn (intern (concat "jf/all-the-icons--with-" name)))
	    (icon-fn (intern (concat "all-the-icons-" name)))
	    (docstring (concat "Displays an ICON from `all-the-icons-" name "'.")))
	`(defun ,defun-fn (icon str &optional height v-adjust)
	   ,docstring
	   (s-concat (,icon-fn
		      icon
		      :v-adjust (or v-adjust 0)
		      :height (or height 1))
		     " " str))))
    (jf/all-the-icons--with :name "faicon")
    (jf/all-the-icons--with :name "material")
    (jf/all-the-icons--with :name "octicon")
    (jf/all-the-icons--with :name "alltheicon"))
#+end_src

**** all-the-icons-dired.el

- ~all-the-icons-dired.el~ :: Incorporates file icons with file listings of
  dired.  /Note/: On 2021-04-11 I was getting the following error with this
  package: "*ERROR*: Symbol's value as variable is void: file"

#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :straight t
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

**** spaceline.el

- ~spaceline.el~ :: A nice looking modeline enhancement

#+begin_src emacs-lisp
  (use-package spaceline :straight t)
#+end_src

**** spaceline-all-the-icons.el

- ~spaceline-all-the-icons.el~ ::  Add some visual flair to the modeline enhancements.  Disabled as of <2022-02-03 Thu>.

#+begin_src emacs-lisp
  ;; (use-package spaceline-all-the-icons
  ;;  :straight t
  ;;  :after spaceline
  ;;  :config (spaceline-all-the-icons-theme))
#+end_src

**** popper.el

- ~popper.el~ :: Treat some types of windows as popups (e.g., something easier
  to dismiss, a bit more like the mini-buffer).  Further ~jf/popper~ can
  toggle the popup buffer.  See that method for further implementation details.

#+begin_src emacs-lisp
  (use-package popper
    :straight t
    :bind (("C-`" . jf/popper))
    :config
    (defun jf/popper (prefix_arg)
      "Call `popper-cycle', but with PREFIX_ARG invoke a less common popper method.

  With one PREFIX_ARG, `popper-toggle-latest'.
  With two (or more) PREFIX_ARG `popper-toggle-type'."
      (interactive "P")
      (let ((prefix (car prefix_arg)))
	(cond
	 ((not prefix)  (popper-cycle))
	 ((= prefix 4)  (popper-toggle-latest))
	 (t (popper-toggle-type)))))
    :init
    (setq popper-reference-buffers
	  '("\\*Messages\\*"
	    "Output\\*$"
	    "\\*Async Shell Command\\*"
	    help-mode
	    compilation-mode
	    "^\\*helpful.*\\*$"))
    (popper-mode +1)
    (popper-echo-mode +1))

#+end_src

**** shackle.el

- ~shackle.el~ :: Enforce rules for popups.  See https://depp.brause.cc/shackle/.

#+begin_src emacs-lisp
  (use-package shackle
    :straight t
    :custom
    (shackle-rules '((compilation-mode :noselect t))
		   shackle-default-rule '(:select t)))
#+end_src

/Note:/ How does this related to ~popper.el~?

**** ace-window.el

- ~ace-window.el~ :: A window manager for emacs, allowing fast toggles between
  windows as well as opening or moving those windows.  See
  https://github.com/abo-abo/ace-window for more details.

#+begin_src emacs-lisp
  (use-package ace-window
    :straight t
    :bind (("M-o" . ace-window)))
#+end_src

**** buffer-move.el

- ~buffer-move.el~ :: From [[https://github.com/lukhas/buffer-move][lukhas/buffer-move]], this package helps me quickly
  move a window elsewhre.  As of <2022-02-01 Tue>, I don’t often use this
  command.  Consider it “on notice” for removal.

#+begin_src emacs-lisp
  (use-package buffer-move
    :straight t
    :bind ("<C-s-f12>" . buf-move))
#+end_src

**** Folding

#+begin_src emacs-lisp
  (use-package yafolding
    :straight t)
#+end_src

**** rainbow-delimiters.el

- ~rainbow-delimiters.el~ :: A quick and useful visual queue for paranthesis.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :straight t
    :hook ((fundamental-mode) . rainbow-delimiters-mode))
#+end_src

**** vi-tilde-fringe.el
- ~vi-tilde-fringt.el~ :: Show tilde (e.g. ~\~~) on empty trailing lines.  This is a feature ported from [[https://en.wikipedia.org/wiki/Vi][vi]].

#+begin_src emacs-lisp
  (use-package vi-tilde-fringe
    :straight t
    :diminish 'vi-tilde-fringe-mode
    :config (global-vi-tilde-fringe-mode))
#+end_src

**** pulsar.el

- ~pulsar.el~ :: A a little bit of visual feedback.  See [[https://protesilaos.com/codelog/2022-03-14-emacs-pulsar-demo/][Emacs: demonstration of pulsar.el | Protesilaos Stavrou]]

#+begin_src emacs-lisp
  (use-package pulsar
    :straight (pulsar :host gitlab :repo "protesilaos/pulsar")
    :custom
    (pulsar-pulse-functions ; Read the doc string for why not `setq'
     '(recenter-top-bottom
       move-to-window-line-top-bottom
       reposition-window
       bookmark-jump
       other-window
       delete-window
       delete-other-windows
       forward-page
       backward-page
       scroll-up-command
       scroll-down-command
       windmove-right
       windmove-left
       windmove-up
       windmove-down
       windmove-swap-states-right
       windmove-swap-states-left
       windmove-swap-states-up
       windmove-swap-states-down
       tab-new
       tab-close
       tab-next
       org-next-visible-heading
       org-previous-visible-heading
       org-forward-heading-same-level
       org-backward-heading-same-level
       outline-backward-same-level
       outline-forward-same-level
       outline-next-visible-heading
       outline-previous-visible-heading
       ace-window
       outline-up-heading))
    :hook
    (consult-after-jump . pulsar-recenter-top)
    (consult-after-jump . pulsar-reveal-entry)
    ;; integration with the built-in `imenu':
    (imenu-after-jump . pulsar-recenter-top)
    (imenu-after-jump . pulsar-reveal-entry)
    :config
    (pulsar-global-mode 1)
    (setq pulsar-face 'pulsar-magenta
	  pulsar-delay 0.05)
    (defun jf/pulse (parg)
      "Pulse the current line.

  If PARG (given as universal prefix), pulse between `point' and `mark'."
      (interactive "P")
      (if (car parg)
	  (pulsar--pulse nil nil (point) (mark))
	(pulsar-pulse-line)))
    :bind (("C-x l" . jf/pulse)))
#+end_src

#+RESULTS:
: pulsar-pulse-line

**** emojify.el

- ~emojify.el~ :: Ensure rendering of correct emoji’s.

#+begin_src emacs-lisp
  (use-package emojify
    :straight t
    :config
    (defun --set-emoji-font (frame)
      "Adjust the font settings of FRAME so Emacs can display emoji properly."
      (if (eq system-type 'darwin)
	  ;; For NS/Cocoa
	  (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
	;; For Linux
	(set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))

    ;; For when Emacs is started in GUI mode:
    (--set-emoji-font nil)
    ;; Hook for when a frame is created with emacsclient
    ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
    (add-hook 'after-make-frame-functions '--set-emoji-font))
#+end_src

**** DONE unicode-fonts.el

I’m uncertain why I included this, aside from “sure would be nice to have unicode fonts.”

#+begin_src emacs-lisp
  (use-package unicode-fonts
    :straight t
    :config (unicode-fonts-setup))
#+end_src

**** flymake-proselint

#+begin_src emacs-lisp
  (use-package flymake-proselint
    :straight t)

  (add-hook 'text-mode-hook (lambda ()
			      (flymake-mode)
			      (flymake-proselint-setup)))
#+end_src

*** Modes

Emacs has the concept of modes.  Each buffer has one major mode and can have
multiple minor modes.  A major mode may derive from another major mode.

These modes impact lots of things; key bindings being one of them.

What follows are a list of modes presented in a somewhat random order.  Some
are major modes others are minor modes.

**** bundler.el

- ~bundler.el~ :: Adds the useful ~bundle-open~ command.

#+begin_src emacs-lisp
  (use-package bundler
    :straight (bundler :type git :host github :repo "endofunky/bundler.el"))
#+end_src

**** csv-mode.el

#+begin_src emacs-lisp
  (use-package csv-mode :straight t)
#+end_src

**** emmet-mode.el

- ~emmet-mode.el~ :: I’ve only scratched the surface of this.  Namely when I
  write a haiku, in my editor it type =pre.poem= followed by ~C-c C-e~ and that
  expands to a ~pre~ tag with the ~class="poem"~.  There's a lot more, but I
  write comparatively little HTML.

#+begin_src emacs-lisp
  (use-package emmet-mode
    :straight t
    :bind (("C-c C-e" . emmet-expand-yas ))
    :hook ((sgml-mode . emmet-mode)
	   (html-mode . emmet-mode)
	   (css-mode . emmet-mode)))
#+end_src

**** enh-ruby-mode.el

- ~enh-ruby-mode.el~ :: Emacs ships with ~ruby-mode.el~, but I’ve found that
  ~enh-ruby-mode.el~ has more convenient navigation functions:

  - ~enh-ruby-mark-defun~ :: Put mark at end of this Ruby definition, point at
    beginning.
  - ~enh-ruby-up-sexp~ :: Move up one balanced expression (sexp).
  - ~enh-ruby-toggle-block~ :: Toggle block type from do-end to braces or back.
  - ~enh-ruby-backward-sexp~ :: Move backward across one balanced expression
    (sexp).
  - ~enh-ruby-forward-sexp~ :: Move backward across one balanced expression
    (sexp).

#+begin_src emacs-lisp
  (use-package enh-ruby-mode
    :straight t
    :hook (enh-ruby-mode . (lambda () (setq fill-column 100)))
    :hook (enh-ruby-mode . eldoc-mode)
    :hook (enh-ruby-mode . enh-ruby-imenu-create-index)
    :bind (:map enh-ruby-mode-map ("C-j" . avy-goto-char-timer))
    :mode (("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . enh-ruby-mode)))
  (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))
#+end_src

**** git-modes.el

- ~git-modes.el~ :: For editing various Git configuration files.

#+begin_src emacs-lisp
  (use-package git-modes :straight t)
#+end_src

**** go-mode.el

Every so often I stumble upon a Go package.  The ~go-mode~ package gives me the
syntax highlighting that makes reading ~Go-lang~ tolerable.

#+begin_src emacs-lisp
  (use-package go-mode :straight t)
#+end_src

**** graphql-mode.el

- ~graphql-mode.el~ :: I started exploring graphql, so I suppose it’s time to bring in a proper mode
for syntax highlighting and what have you.

#+begin_src emacs-lisp
  (use-package graphql-mode
    :straight t)
#+end_src

**** json-mode.el

- ~json.el~ :: In modern web-development, JSON is nigh unavoidable.

#+begin_src emacs-lisp
  (use-package json-mode :straight t)
#+end_src

**** json-reformat.el

- ~json-reformat.el~ :: Because JSON can be quite ugly, I want something to help tidy it up.

#+begin_src emacs-lisp
  (use-package json-reformat
    :straight t
    :after json-mode
    :init (setq json-reformat:indent-width 2))

#+end_src


For awhile, I was trying to use lsp-mode.  It might look a bit nicer, but it was a little to “nosy”.  On my read, ~eglot~ leverages many of the built-in APIs of Emacs.

#+begin_src emacs-lisp
  (use-package eglot
    :hook ((css-mode
	    enh-ruby-mode
	    html-mode
	    js-mode
	    scss-mode) . eglot-ensure)
    :config
    (setq eglot-ignored-server-capabilites (quote (:documentHighlightProvider)))
    (add-to-list 'eglot-server-programs
		 `(enh-ruby-mode . ("solargraph" "socket" "--port" :autoport)))
    :straight t)

  (setq completion-category-overrides '((eglot (styles orderless))))
#+end_src

**** lua-mode.el

- ~lua-mode.el~ :: For working with [[https://www.hammerspoon.org][Hammerspoon]]; which provides me the
  wonderful [[https://github.com/dmgerman/editWithEmacs.spoon/][edit with Emacs]].

#+begin_src emacs-lisp
  (use-package lua-mode :straight t)
#+end_src

**** markdown-mode.el

- ~markdown-mode.el~ :: Oh ubiquitous Markdown.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :straight t
    :hook ((markdown-mode . turn-on-visual-line-mode))
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "/usr/local/bin/pandoc"))
#+end_src

**** plantuml-mode.el

- ~plantuml-mode.el~ :: A mode for working with PlantUML.  See https://plantuml.com.

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :config (setq plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  plantuml-default-exec-mode 'executable
		  org-plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  org-plantuml-exec-mode 'executable)
    :mode (("\\.plantuml\\'" . plantuml-mode))
    :straight t)
#+end_src

**** rspec-mode.el

- ~rspec-mode.el~ :: [[http://rspec.info][RSpec]] is my Ruby testing framework of choice.  As I’ve
  been doing much more extensive Ruby coding, I’ve been using a lot of:

  - ~rspec-toggle-spec-and-target~ :: Jump between spec and target;
    ~spec/models/user_spec.rb~ and ~app/models/user.rb~ respectively.
  - ~rspec-verify~ :: Run ~rspec~ for the current file; either the spec or the
    spec associated with the target.
  - ~rspec-verify-single~ :: Run ~rspec~ for the current line.

#+begin_src emacs-lisp
  (use-package rspec-mode
    :straight t
    ;; Ensure that we’re loading enh-ruby-mode before we do any rspec loading.
    :after enh-ruby-mode
    :custom (rspec-use-spring-when-possible nil)
    :bind (:map rspec-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :bind (:map enh-ruby-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :diminish 'rspec-mode)

  (eval-after-load 'rspec-mode '(rspec-install-snippets))
#+end_src

/Note:/ The =CMD= + =.= is a carryover from my [[https://macromates.com][Textmate]] and [[https://www.sublimetext.com/][Sublime Text]] days.
That’s one of those hot-keys almost burned into soul.
**** ruby-interpolation.el

- ~ruby-interpolation.el~ :: A simple package to expand ~#~ to ~#{<cursor>}~.

#+begin_src emacs-lisp
  ;; Nice and simple package for string interpolation.
  (use-package ruby-interpolation
    :straight t
    :diminish 'ruby-interpolation-mode
    :hook (enh-ruby-mode . ruby-interpolation-mode))
#+end_src

**** so-long.el

- ~so-long.el~ :: Really long files or long lines can cause problems for Emacs.  This mode helps with that.

#+begin_src emacs-lisp
  (use-package so-long
    :defer t
    :straight t
    :bind
    (:map so-long-mode-map
	  ("C-s" . isearch-forward)
	  ("C-r" . isearch-backward))
    :config (global-so-long-mode 1))
#+end_src
**** tree-sitter.el

- ~tree-sitter.el~ :: An incremental parsing library for languages.  See https://tree-sitter.github.io/tree-sitter/.

#+begin_src emacs-lisp
  ;; See https://github.com/emacs-tree-sitter/elisp-tree-sitter
  ;; Waiting on https://github.com/emacs-tree-sitter/elisp-tree-sitter/issues/197 to resolve.
  (use-package tree-sitter
    :straight (tree-sitter :host github :repo "emacs-tree-sitter/elisp-tree-sitter")
    :diminish 'tree-sitter-mode
    :config
    (add-to-list 'tree-sitter-major-mode-language-alist '(enh-ruby-mode . ruby)))

  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)

  (use-package tree-sitter-langs
    :straight t)
#+end_src


  - Fringe
  - Modes

**** web-mode.el

- ~web-mode.el~ :: Some configurations for web development.

#+begin_src emacs-lisp
  (use-package web-mode
    :straight t
    :config (setq web-mode-markup-indent-offset 2
		  web-mode-css-indent-offset 2
		  web-mode-code-indent-offset 2))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
#+end_src

Sometimes I want to edit svg files.  Often times if I open them directly in
Emacs, I want to edit them.  This setting helps with that default.  /Note:/
without this setting, Emacs will happily render the SVG as an image,

#+begin_src emacs-lisp
  (add-to-list `auto-mode-alist '("\\.svg\\'" . xml-mode))
#+end_src

**** yaml-mode.el

- ~yaml-mode.el~ :: Visual parsing for yaml.

#+begin_src emacs-lisp
  (use-package yaml-mode :straight t)
#+end_src

**** yard-mode.el

- ~yard-mode.el~ :: When writing Ruby documentation, I favor YARD syntax.  See https://yardoc.org fore more details.

#+begin_src emacs-lisp
  (use-package yard-mode
    :straight t
    :diminish 'yard-mode
    :hook (enh-ruby-mode . yard-mode))
#+end_src
*** Utilities

**** edit-indirect.el

The ~edit-indirect.el~ behaves similarly to the amazing ~org-edit-source-code~ but for any regions.  This is particularly nice for markdown “triple back-tick regions” (e.g. =```=).

#+begin_src emacs-lisp
  (use-package edit-indirect
    :straight t)
#+end_src

**** ts.el

#+begin_src emacs-lisp
  (use-package ts
    :straight t)
#+end_src

**** titlecase.el

The rules of “titlecase” are confounding.  The ~titlecase.el~ package provides
numerous ways to cast a string to “titlecase.”  I chose wikipedia style as a
quasi-opinionated compromise.

#+begin_src emacs-lisp
  (use-package titlecase
    :straight (titlecase :host github :repo "duckwork/titlecase.el")
    :custom (titlecase-style 'wikipedia))
#+end_src
**** fill-sentences-correctly.el

- ~fill-sentences-correctly.el~ :: After using Emacs for awhile, with it’s
  sentence navigation, I’ve come to strongly favor two spaces after a period.
  The ~fill-sentences-correctly-mode~ ensures that ~fill-paragraph~
  (e.g. ~M-q~) preserves two spaces.

#+BEGIN_src emacs-lisp
  (use-package fill-sentences-correctly
    :straight (fill-sentences-correctly :host github :repo "duckwork/fill-sentences-correctly.el")
    :hook (fundamental-mode . fill-sentences-correctly-mode))
#+end_src

**** savekill.el

- ~savekill.el~ :: Write "kill" command inputs to disk.

#+begin_src emacs-lisp
  (use-package savekill :straight t)
#+end_src

**** math-at-point.el

- ~math-at-point.el~ :: Calculate math functions at point and message result in
  minibuffer.  See https://github.com/shankar2k/math-at-point.

#+begin_src emacs-lisp
  (use-package math-at-point
    :straight (math-at-point :type git :host github :repo "shankar2k/math-at-point")
    :bind ("C-c =" . math-at-point))
#+end_src

**** hippie-exp.el

- ~hippie-exp.el~ :: Using Hippie expand, I toggle through words already referenced.

#+begin_src emacs-lisp
  (use-package hippie-exp
    :straight t
    :config
    (setq hippie-expand-try-functions-list '(try-expand-dabbrev-visible
					     try-expand-dabbrev
					     try-expand-dabbrev-all-buffers
					     try-expand-dabbrev-from-kill
					     try-complete-file-name-partially
					     try-complete-file-name
					     try-expand-all-abbrevs
					     try-expand-list
					     try-expand-line
					     try-complete-lisp-symbol-partially
					     try-complete-lisp-symbol))
    :bind (("M-SPC" . hippie-expand)))

  (global-set-key [remap dabbrev-expand] 'hippie-expand)
#+end_src

**** expand-region.el

- ~expand-region.el~ :: a simple package that does two related things really
  well; expands and contracts the current region.  I use this all the time.

  In writing, with the cursor at point, when I expand it selects the word.  The
  next expand the sentence, then paragraph, then page.  In programming it
  leverages sexp.

#+begin_src emacs-lisp
  (use-package expand-region
    :straight t
    :bind (("C-=" . er/expand-region)
	   ("C-+" . er/contract-region)))
#+end_src

**** multiple-cursors.el

- ~multiple-cursors.el~ :: Allow Emacs to work with multiple cursors.  See
  https://melpa.org/#/multiple-cursors.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind (("C-M-SPC" . set-rectangular-region-anchor)
	   ("C->" . mc/mark-next-like-this)
	   ("C-<" . mc/mark-previous-like-this)
	   ("C-s-<mouse-1>" . mc/add-cursor-on-click)
	   ("C-c C->" . mc/mark-all-like-this)
	   ("C-c C-SPC" . mc/edit-lines)) ;; CTRL+CMD+c
    :straight t)
#+end_src

**** iedit.el

- ~iedit.el~ :: ~C-;~ to select current symbol and all matches; Then edit at
  multiple points.

#+begin_src emacs-lisp
  (use-package iedit :straight t)
#+end_src

**** crux.el

- ~crux.el~ :: A mix of a few odd and useful functions.

#+begin_src emacs-lisp
  (use-package crux
    :straight t
    :bind (("C-a" . crux-move-beginning-of-line)
	   ("<C-s-return>" . crux-smart-open-line-above)
	   ("C-s-k" . crux-kill-line-backwards)
	   ("<s-backspace>" . crux-kill-line-backwards)
	   ("<f9>" . crux-kill-other-buffers)))
#+end_src

**** ethan-wspace.el

- ~ethan-wspace-mode.el~ :: Whitespace hygene package.  The author's
  documentation and commentary echoes my sentiments.

#+begin_src emacs-lisp
  (use-package ethan-wspace
    :straight t
    :hook (before-save . delete-trailing-whitespace)
    :init (setq-default mode-require-final-newline nil)
    :config (global-ethan-wspace-mode 1))
#+end_src

**** unfill.el

- ~unfill.el~ :: Provides the reverse of ~fill-paragraph~, and a toggle fill and unfill.

#+begin_src emacs-lisp
  (use-package unfill
    :bind ("M-q" . unfill-toggle)
    :straight t)
#+end_src

**** undo-tree.el

- ~undo-tree.el~ :: Provides a UI for undo trees.  I'm not certain what I want
  to do with this.

#+begin_src emacs-lisp
  (use-package undo-tree
    :diminish
    :bind (("C-z" . undo)
	   ("C-s-z" . undo-tree-redo))
    :config
    (global-undo-tree-mode +1)
    (unbind-key "M-_" undo-tree-map))

#+end_src

**** hungry-delete.el

- ~hungry-delete.el~ :: Delete multiple spaces in one delete stroke.

#+begin_src emacs-lisp
  (use-package hungry-delete
    :straight t
    :diminish 'hungry-delete-mode
    :config (global-hungry-delete-mode))
#+end_src

**** move-text.el

- ~move-text.el~ :: A simple package ability to move lines up and down.

#+begin_src emacs-lisp
  (use-package move-text
    :straight t
    :bind (([C-s-down] . move-text-down)
	   ([C-s-up] . move-text-up)))
#+end_src

**** tempel.el

I have only provisionally adopted this.  I like the idea of abbreviations/snippets using emacs-lisp.  This is a “to be determined” package.

#+begin_src emacs-lisp
  (use-package tempel
    :straight (tempel :host github :repo "minad/tempel")
    :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
	   ("M-*" . tempel-insert))

    :init

    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'. `tempel-expand'
      ;; only triggers on exact matches. Alternatively use `tempel-complete' if
      ;; you want to see all matches, but then Tempel will probably trigger too
      ;; often when you don't expect it.
      ;; NOTE: We add `tempel-expand' *before* the main programming mode Capf,
      ;; such that it will be tried first.
      (setq-local completion-at-point-functions
		  (cons #'tempel-expand
			completion-at-point-functions)))

    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)

    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
    ;; (tempel-global-abbrev-mode)
    )

  (tempel-key "C-c i" idiomatic org-mode-map)
#+end_src

**** whole-line-or-region.el

- ~whole-line-or-region.el~ :: From the package commentary, “This minor mode
  allows functions to operate on the current line if they would normally
  operate on a region and region is currently undefined.”  I’ve used this for
  awhile and believe it’s not baked into my assumptions regarding how I
  navigation Emacs.

#+begin_src emacs-lisp
  (use-package whole-line-or-region
    :straight t
    :diminish 'whole-line-or-region-local-mode
    :config (whole-line-or-region-global-mode))
#+end_src

**** smartparens.el

- ~smartparens.el~ :: provides some “intelligent” treatment of parentheses.  I’ve been using this for awhile, so I assume it’s baked into my memory.

#+begin_src emacs-lisp
  (use-package smartparens :straight t)
#+end_src

**** grab-mac-link.el

- ~grab-mac-link.el~ :: Grab a link from a variety of MacOS applications.

#+begin_src emacs-lisp
  (use-package grab-mac-link
    :straight t
    ;; Ensuring we load these, as I'll need them later.
    :commands (grab-mac-link-safari-1 grab-mac-link-firefox-1)
    :config
    ;; A replacement function for existing grab-mac-link-make-html-link
    (defun jf/grab-mac-link-make-html-link (url name)
      "Using HTML syntax, link to and cite the URL with the NAME."
      (format "<cite><a href=\"%s\" class=\"u-url p-name\" rel=\"cite\">%s</a></cite>" url name))
    ;; The function advice to override the default behavior

    (advice-add
     'grab-mac-link-make-html-link
     :override
     'jf/grab-mac-link-make-html-link
     '((name . "jnf")))
    :bind (("C-c g" . grab-mac-link)))
#+end_src

**** org-mac-link.el

- ~org-mac-link.el~ :: Similar to ~grab-mac-link.el~ this specifically grabs a link and insersts in ~org-mode~ format.

#+begin_src emacs-lisp
  (use-package org-mac-link
    :straight (org-mac-link :type git :host github :repo "jeremyf/org-mac-link")
    :bind (:map org-mode-map (("C-c g" . org-mac-grab-link))))
#+end_src

*** TODO Typography

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  This package serves the purpose of assisting with adding
  ;;  characters that are not readily available on an ANSI keyboard.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; BEGIN Typography Menu
  ;;
  ;;  The purpose of the typography menu is to provide easier access to
  ;;  typographic characters that I use; It also provides a bit of a
  ;;  mnemonic device (e.g. "C-x 8 RET" searches for a character to insert).
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (use-package pretty-hydra
      :straight (pretty-hydra
		 :type git :host github :repo "jerrypnz/major-mode-hydra.el"
		 :files (:defaults (:exclude "major-mode-hydra.el"))))

  (defvar jf/typography--title
    (jf/all-the-icons--with-octicon "pencil" "Typography (C-x 8 RET for Search)" 1 -0.05)
    "The menu title for typography")
  (pretty-hydra-define jf/typography--menu (:foreign-keys warn :title jf/typography--title :quit-key "q" :exit t)
    ("Characters" (
		   ("d d" (insert "-") "- dash")
		   ("d m" (insert "—") "— em dash")
		   ("d n" (insert "–") "– en dash")
		   (". e" (insert "…") "… ellipsis")
		   (". d" (insert "·") "º degree")
		   (". m" (insert "·") "· middot")
		   ("t d" (insert "†") "† dagger")
		   ("t 2" (insert "‡") "‡ double dagger")
		   ("t s" (insert "§") "§ section")
		   ("t p" (insert "¶") "¶ paragraph")
		   ("? !" (insert "‽") "‽ Interobang")
		   )
     "Math" (
	     ("a x" (insert "×") "× Multiplication Sign")
	     ("a d" (insert "÷") "÷ Division Sign")
	     ("a m" (insert "−") "− Minus Sign")
	     ("a p" (insert "±") "± Plus or Minus Sign")
	     ("m n" (insert "¬") "¬ Negation")
	     ;; For declaring regex functions.  See
	     ;; https://www.johndcook.com/blog/2022/01/08/corner-quotes-in-unicode/
	     ;; and https://irreal.org/blog/?p=10265
	     ("c l" (insert "⌜") "⌜ Left Corner Quote")
	     ("c r" (insert " ⌟") "⌟ Right Corner Quote")
	     ;; Included as a reminder as I use these for menu structures
	     ("f h"   (insert "─") "─ Forms light horizontal")
	     ("f D l" (insert "┐") "┐ Forms light down and left")
	     ("f v"   (insert "│") "│ Forms light vertical")
	     ("f V r" (insert "├") "├ Forms light vertical and right")
	     ("f U r" (insert "└") "└ Forms light up and right")
	     )
     "Quotes" (
	       ("\" o" (insert "“") "“ Double quote open")
	       ("\" c" (insert "”") "” Doule quote close")
	       ("\" O" (insert "«") "« Guillemet open")
	       ("\" C" (insert "»") "» Guillemet close")
	       ("\" l" (insert "⌈") "⌈ Left ceiling")
	       ("' o" (insert "‘") "‘ Single quote open")
	       ("' c" (insert "’") "’ Single quote close")
	       ("' O" (insert "‹") "‹ Single guillemet open")
	       ("' C" (insert "›") "› Single guillemet close")
	       ("p 1" (insert "′") "′ Single Prime (feet, arcminutes)")
	       ("p 2" (insert "″") "″ Double Prime (inches, arcseconds)")
	       ("p 3" (insert "‴") "‴ Triple Prime"))
     ))

  (global-set-key (kbd "C-s-8") 'jf/typography--menu/body)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; END Typography Menu
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

**** TODO typopunct.el

#+begin_src emacs-lisp
  (use-package typopunct
    :straight t
    :config
    (add-hook 'org-mode-hook 'jf/typopunct-init)
    (defun jf/typopunct-init ()
      (require 'typopunct)
      (typopunct-change-language 'english)
      (typopunct-mode 1))
    (setq typopunct-buffer-language 'english)

    ;; To insert a typographical ellipsis sign (…) on three consecutive
    ;; dots, or a middle dot (·) on ‘^.’
    (defconst typopunct-ellipsis (decode-char 'ucs #x2026))
    (defconst typopunct-middot   (decode-char 'ucs #xB7)) ; or 2219
    (defun typopunct-insert-ellipsis-or-middot (arg)
      "Change three consecutive dots to a typographical ellipsis mark."
      (interactive "p")
      (cond
       ((and (= 1 arg)
	     (eq (char-before) ?^))
	(delete-char -1)
	(insert typopunct-middot))
       ((and (= 1 arg)
	     (eq this-command last-command)
	     (looking-back "\\.\\." 1))
	(replace-match "")
	(insert typopunct-ellipsis))
       (t
	(self-insert-command arg))))
    (define-key typopunct-map "." 'typopunct-insert-ellipsis-or-middot)


    (defconst typopunct-prime  (decode-char 'ucs #x2032)) ; feet, arcminutes, derivatives
    (defconst typopunct-dprime (decode-char 'ucs #x2033)) ; inches, arcseconds, double derivatives
    (defconst typopunct-tprime (decode-char 'ucs #x2034))

    ;; The minus sign (−) is separate from the hyphen (-), en dash (–) and
    ;; em dash (—). To build upon the clever behavior of the ‘-’ key
    (defconst typopunct-minus (decode-char 'ucs #x2212))
    (defconst typopunct-pm    (decode-char 'ucs #xB1))
    (defconst typopunct-mp    (decode-char 'ucs #x2213))
    (defadvice typopunct-insert-typographical-dashes
	(around minus-or-pm activate)
      (cond
       ((or (eq (char-before) typopunct-em-dash)
	    (looking-back "\\([[:blank:]]\\|^\\)\\^" 2))
	(delete-char -1)
	(insert typopunct-minus))
       ((looking-back "[^[:blank:]]\\^" 1)
	(insert typopunct-minus))
       ((looking-back "+/" 1)
	(progn (replace-match "")
	       (insert typopunct-pm)))
       (t ad-do-it)))
    (defun typopunct-insert-mp (arg)
      (interactive "p")
      (if (and (= 1 arg) (looking-back "-/" 2))
	  (progn (replace-match "")
		 (insert typopunct-mp))
	(self-insert-command arg)))
    (define-key typopunct-map "+" 'typopunct-insert-mp)
    (defconst typopunct-times (decode-char 'ucs #xD7))
    (defun typopunct-insert-times (arg)
      "Insert multiplication sign at ARG."
      (interactive "p")
      (if (and (= 1 arg) (looking-back "\\([[:blank:]]\\|^\\)\\^"))
	  (progn (delete-char -1)
		 (insert typopunct-times))
	(self-insert-command arg)))
    (define-key typopunct-map "x" 'typopunct-insert-times)

    (defadvice typopunct-insert-quotation-mark (around wrap-region activate)
      (let* ((lang (or (get-text-property (point) 'typopunct-language)
		       typopunct-buffer-language))
	     (omark (if single
			(typopunct-opening-single-quotation-mark lang)
		      (typopunct-opening-quotation-mark lang)))
	     (qmark (if single
			(typopunct-closing-single-quotation-mark lang)
		      (typopunct-closing-quotation-mark lang))))
	(cond
	 (mark-active
	  (let ((skeleton-end-newline nil)
		(singleo (typopunct-opening-single-quotation-mark lang))
		(singleq (typopunct-closing-single-quotation-mark lang)))
	    (if (> (point) (mark))
		(exchange-point-and-mark))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string omark)) (mark) t)
		(replace-match (regexp-quote (string singleo)) nil nil)))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string qmark)) (mark) t)
		(replace-match (regexp-quote (string singleq)) nil nil)))
	    (skeleton-insert (list nil omark '_ qmark) -1)))
	 ((looking-at (regexp-opt (list (string omark) (string qmark))))
	  (forward-char 1))
	 (t ad-do-it)))))
#+end_src

** Integrated “Applications”

*** Variable and Constant Definitions

These are a few variables and cosntants that I use throughout my configuration.

#+begin_src emacs-lisp
  (defconst jf/tor-home-directory
    (file-truename "~/git/takeonrules.source")
    "The home directory of TakeOnRules.com Hugo repository.")

  (defconst jf/tor-hostname-default-local
    "http://localhost:1313"
    "The scheme, host name, and port for serving up a local TakeOnRules.com.")

  (defconst jf/tor-hostname-default-remote
    "https://takeonrules.com"
    "The scheme and host name for TakeOnRules.com.")

  (defvar jf/tor-hostname-current
    jf/tor-hostname-default-local
    "What is the current hostname for serving TakeOnRules content.")

  (defvar jf/data-directories
    (list
     jf/tor-home-directory
     "~/git/takeonrules.source/themes/hugo-tufte"
     "~/git/burning_wheel_lifepaths/"
     "~/git/emacs-bookmarks"
     "~/git/dotzshrc/"
     "~/git/dotemacs/"
     "~/git/org/"
     "~/git/org/archive")
    "Relevant data directories for my day to day work.")
#+end_src

*** Writeroom

The ~writeroom-mode.el~ package provides some quick adjustments for writing; creating a “distractions free” buffer.

#+begin_src emacs-lisp
  (use-package writeroom-mode
    :config (setq writeroom-width 80)
    :straight t)
#+end_src

*** Doc View

#+begin_src emacs-lisp
  (use-package doc-view
    :straight (doc-view :type built-in)
    :bind (:map doc-view-mode-map
		("C-c g" . doc-view-goto-page)))
#+end_src

*** Mastodon

As Twitter becomes a megalomaniac’s obsession, Mastodon becomes even more appealing.

#+begin_src emacs-lisp
  (use-package mastodon
    :straight t
    :config (setq mastodon-instance-url "https://tabletop.social"
		  mastodon-active-user "takeonrules"))
#+end_src
*** Knowledge Management

I use org-mode and org-roam to help manage content.  Let’s load that rather extensive configuration.

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "knowledge-management-config.org"))
#+end_src

*** org-d20.el

- ~org-d20.el~ :: I’m really only using this for the ~org-d20--roll~ function.

#+begin_src emacs-lisp
  (use-package org-d20
    :after org
    :bind  (("C-s-r" . jf/roll-expression-dwim))
    :config
    (defun jf/roll-expression-dwim (expression &optional)
      "Roll the EXPRESSION, check `thing-at-point' then prompt."
      (interactive (list (if (string-match
			      "[dD][0-9]"
			      (format "%s" (thing-at-point 'sexp t)))
			     (thing-at-point 'sexp t)
			   (read-string "Dice Expression: "))))
      (-let* (((rolls . result) (org-d20--roll expression)))
	(message "%s => %s" expression result)))
    :straight (org-d20 :host github :repo "spwhitton/org-d20"))
#+end_src

*** RSS Feed

**** elfeed.el

- ~elfeed.el~ :: An Emacs RSS reader.  I’ve used Google Reader, Feedly,
  Inoreader, and Newsboat.  I wrote about [[https://takeonrules.com/2020/04/12/switching-from-inoreader-to-newsboat-for-rss-reader/][Switching from Inoreader to Newsboat
  for RSS Reader]], and the principles apply for Elfeed.

#+begin_src emacs-lisp
  (use-package elfeed
    :straight t
    :after org
    :hook ((elfeed-show-mode . jf/reader-visual))
    :config
    (setq-default elfeed-search-filter "@2-days-ago +unread ")
    :bind (
	   (:map elfeed-search-mode-map
		 ("q" . jf/elfeed-save-db-and-bury))))

  ;;write to disk when quiting
  (defun jf/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

  (defun jf/elfeed-load-db-and-open ()
    "Load the elfeed db from disk before opening"
    (interactive)
    (elfeed)
    (elfeed-update)
    (elfeed-db-load)
    (elfeed-search-update--force))
  (defalias 'rss 'jf/elfeed-load-db-and-open)

    ;; From https://karthinks.com/blog/lazy-elfeed/
  (defun elfeed-search-show-entry-pre (&optional lines)
    "Returns a function to scroll forward or back in the Elfeed
    search results, displaying entries without switching to them."
    (lambda (times)
      (interactive "p")
      (forward-line (* times (or lines 0)))
      (recenter)
      (call-interactively #'elfeed-search-show-entry)
      (select-window (previous-window))
      (unless elfeed-search-remain-on-entry (forward-line -1))))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "n") (elfeed-search-show-entry-pre +1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "p") (elfeed-search-show-entry-pre -1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "M-RET") (elfeed-search-show-entry-pre)))
  ;; End https://karthinks.com/blog/lazy-elfeed/
#+end_src


**** elfeed-org.el

- ~elfeed-org.el~ :: a package for maintaining and organizating my RSS
  subscriptions in ~org-mode~ format.

#+begin_src emacs-lisp
  (use-package elfeed-org
    :straight t
    :after elfeed
    :config (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/git/org/elfeed.org")))
#+end_src

*** Source Control
**** magit.el

- ~magit.el~ :: The awesome [[http://git-scm.com][git]] client for Emacs.  I’ve written a few functions
  to help me jump to the Github page for the pull request.[fn:3]

  - ~jf/magit-browse-pull-request~ :: In ‘magit-log-mode’ open the associated
    pull request.
  - ~jf/git-current-remote-url~ :: Get the current remote url.
  - ~jf/open-pull-request-for~ :: Given the SUMMARY open the related pull
    request.
  - ~jf/open-pull-request-for-current-line~ :: For the current line open the
    applicable pull request.

#+begin_src emacs-lisp
  (use-package magit
    :straight t
    :commands (magit-process-git)
    :init (use-package with-editor :straight t)

    ;; Adding format to git-commit-fill-column of 72 as best practice.
    (setq git-commit-fill-column 72)

    ;; Keeping the summary terse helps with legibility when you run a
    ;; report with only summary.
    (setq git-commit-summary-max-length 50)

    ;; Set the tabular display columns for the `magit-list-repositories'
    (setq magit-repolist-columns
	  '(("Name"    25 magit-repolist-column-ident ())
	    ("Version" 25 magit-repolist-column-version ())
	    ("δ"        1 magit-repolist-column-dirty ())
	    ("⇣"        3 magit-repolist-column-unpulled-from-upstream
	     ((:right-align t)
	      (:help-echo "Upstream changes not in branch")))
	    ("⇡"        3 magit-repolist-column-unpushed-to-upstream
	     ((:right-align t)
	      (:help-echo "Local changes not in upstream")))
	    ("Branch"  25 magit-repolist-column-branch ())
	    ("Path"    99 magit-repolist-column-path ())))

    ;; The default relevant `magit-list-repositories'
    (setq magit-repository-directories
	  `(("~/git/takeonrules.source/" . 1)
	    ("~/git/burning_wheel_lifepaths/" . 1)
	    ("~/git/dotzshrc/" .  1)
	    ("~/git/dotemacs/" . 1)
	    ("~/git/emacs-bookmarks/" . 1)
	    ("~/git/org" . 1)
	    ("~/git/org/archive" . 1)
	    ("~/git/takeonrules.source/themes/hugo-tufte" . 1)))

    ;; Have magit-status go full screen and quit to previous
    ;; configuration.  Taken from
    ;; http://whattheemacsd.com/setup-magit.el-01.html#comment-748135498
    ;; and http://irreal.org/blog/?p=2253
    ;; (defadvice magit-status (around magit-fullscreen activate)
    ;;   (window-configuration-to-register :magit-fullscreen)
    ;;   ad-do-it
    ;;   (delete-other-windows))
    ;; (defadvice magit-mode-quit-window (after magit-restore-screen activate)
    ;;   (jump-to-register :magit-fullscreen))
    :config
    (remove-hook 'magit-status-sections-hook 'magit-insert-tags-header)
    (defun jf/magit-browse-pull-request ()
      "In `magit-log-mode' open the associated pull request
  at point.

  Assumes that the commit log title ends in the PR #, which
  is the case when you use the Squash and Merge strategy.

  This implementation is dependent on `magit' and `s'."
      (interactive)
      (let* ((beg (line-beginning-position))
	     (end (line-end-position))
	     (summary
	      (buffer-substring-no-properties
	       beg end)))
	(jf/open-pull-request-for :summary summary)))
    (defun jf/git-current-remote-url ()
      "Get the current remote url."
      (s-trim
       (shell-command-to-string
	(concat
	 "git remote get-url "
	 (format "%s" (magit-get-current-remote))))))
    (cl-defun jf/open-pull-request-for (&key summary)
      "Given the SUMMARY open the related pull request.

  This method assumes you're using Github's Squash and Strategy."
      (let ((remote-url (jf/git-current-remote-url)))
	(save-match-data
	  (and (string-match "(\\#\\([0-9]+\\))$" summary)
	       (browse-url
		(concat
		 ;; I tend to favor HTTPS and the repos end in ".git"
		 (s-replace ".git" "" remote-url)
		 "/pull/"
		 (match-string 1 summary)))))))
    (defun jf/open-pull-request-for-current-line ()
      "For the current line open the applicable pull request."
      (interactive)
      (let ((summary
	     (s-trim
	      (shell-command-to-string
	       (concat "git --no-pager annotate "
		       "-w -L "
		       (format "%s" (line-number-at-pos))
		       ",+1 "
		       "--porcelain "
		       buffer-file-name
		       " | rg \"^summary\"")))))
	(jf/open-pull-request-for :summary summary)))
    :bind (("s-7" . magit-status))
    ;; In other situations I bind s-6 to `git-messenger:popup-message'
    :bind (:map magit-log-mode-map ("s-6" . 'jf/magit-browse-pull-request))
    :hook ((with-editor-post-finish-hook . magit-status)))
#+end_src

**** forge.el

- ~forge.el~ :: Additional interactions interactions with [[https://en.wikipedia.org/wiki/Forge_(software)][Git forge]].  Right
  now, I’ve commented out most things, as I wasn’t figuring out how to refresh
  the appended sections.  I live this here as a reminder.

#+begin_src emacs-lisp
  (use-package forge
    :after magit
    :config
    (setq auth-sources '("~/.authinfo"))
    (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-authored-pullreqs nil 'append)
    (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-requested-reviews nil 'append)
    (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-assigned-issues nil 'append)
    (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-authored-issues nil 'append)
    :straight t)
#+end_src

**** libgit.el

- ~libgit.el~ :: Provides bindings to [[https://libgit2.org][libgit2]].  These bindings help improve the speed of ~magit.el~; or so I’m told.

#+begin_src emacs-lisp
  (use-package libgit :straight t)
#+end_src

**** magit-libgit.el

- ~libgit.el~ :: Connects ~magit.el~ to ~libgit.el~, helping improve the speed of ~magit.el~; or so I’m told.

#+begin_src emacs-lisp
  (use-package magit-libgit :straight t)
#+end_src

**** git-timemachine.el

- ~git-timemachine.el~ :: With the time machine, travel back and forth through a files history.

#+begin_src emacs-lisp
  (use-package git-timemachine :straight t)
#+end_src

**** git-gutter-fringe.el

- ~git-gutter-fringe.el~ :: Show the current git state in the gutter.  As you
  edit a line in a file track by git, the fringe’s indicators change to reflect
  if this is a modification, addition, or deletion.

#+begin_src emacs-lisp
  (use-package git-gutter-fringe
    :straight (git-gutter-fringe :type git :host github :repo "emacsorphanage/git-gutter-fringe")
    :diminish 'git-gutter-mode
    :config (global-git-gutter-mode 't)
    (setq git-gutter:modified-sign "Δ"
	  git-gutter:added-sign "+"
	  git-gutter:deleted-sign "-"))
#+end_src

**** git-link.el

- ~git-link.el~ :: Type ~M-x git-link~ and the function pushes the Git forge
  URL to the kill ring; I’ve configured the URL to use the SHA of the commit of
  the line on which I called ~git-link()~.  This is helpful for sharing links
  with other folks.  I use this /all of the time./ See
  https://github.com/sshaw/git-link.

#+begin_src emacs-lisp
  (use-package git-link
    :config
    (defun jf/git-browse-to-repository (remote)
      "Open in external browser the current repository's given REMOTE."
      (interactive (list (git-link--select-remote)))
      (git-link-homepage remote)
      (browse-url (car kill-ring)))
    (setq git-link-use-commit t) ;; URL will be SHA instead of branch
    :straight t)
#+end_src

**** git-messenger.el

- ~git-messenger.el~ :: Sometimes I want to see more ~git~ information
  regarding the current line.  ~git-messenger.el~ provides a popup that shows
  the information and provides some additional options.

#+begin_src emacs-lisp
  (use-package git-messenger
    :config (setq git-messenger:show-detail t)
    (defun jf/git-messenger-popup ()
      "Open `git-messenger' or github PR.

  With universal argument, open the github PR for current line.

  Without universal argument, open `git-messenger'."
      (interactive)
      (if (equal current-prefix-arg nil) ; no C-u
	  (git-messenger:popup-message)
	(jf/open-pull-request-for-current-line)))
    :custom
    (git-messenger:use-magit-popup t)
    :bind (:map git-messenger-map (("p" . 'jf/open-pull-request-for-current-line)
				   ("l" . 'git-link)))
    :bind (("s-6" . jf/git-messenger-popup)
	   ("<f6>" . jf/git-messenger-popup))
    :straight t)
#+end_src

**** blamer.el

- ~blamer.el~ :: When working in code, I want different ways to view the
  metadata around the code.  ~blammer.el~ adds a quick annotation to the
  current line; When did the last person touch this and what was the message.

#+begin_src emacs-lisp
  (use-package blamer
    :straight (blamer :host github :repo "Artawower/blamer.el")
    :custom
    ;; Set to 0 because I don’t enable by default.  So I’m in a mindset of show
    ;; me who and when.
    (blamer-idle-time 0.0)
    (blamer-author-formatter "✎ %s ")
    (blamer-datetime-formatter "[%s] ")
    (blamer-commit-formatter "● %s")
    (blamer-min-offset 40)
    (blamer-max-commit-message-length 20))
#+end_src

*** Timer

Powered by ~tmr.el~ to set a timer.

#+begin_src emacs-lisp
  (use-package tmr
    :custom (tmr-notify-function #'jf/notifications-notify)
    :straight (tmr :type git :repo "https://git.sr.ht/~protesilaos/tmr"))

  (defun jf/notifications-notify (title message)
    (ns-do-applescript (concat "display notification \"" message "\" sound name \"Glass\"")))
#+end_src

*** elpher.el

- ~elpher.el~ :: A Gopher and Gemini client.

#+begin_src emacs-lisp
  (use-package elpher :straight t)
#+end_src

*** EWW

- ~eww.el~ :: a plain text browser.  Use this to see just how bad much of the web has become.

#+begin_src emacs-lisp
  (use-package eww
    :straight t
    :config
    (defun shr-tag-dfn (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-cite (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-q (dom)
      (shr-insert (car shr-around-q-tag))
      (shr-generic dom)
      (shr-insert (cdr shr-around-q-tag)))

    (defcustom shr-around-q-tag '("“" . "”")
      "The before and after quotes.  `car' is inserted before the Q-tag and `cdr' is inserted after the Q-tag.

  Alternative suggestions are: - '(\"\\\"“\" . \"\\\"\")"
      :type (cons 'string 'string))

    (defface shr-small
      '((t :height 0.8))
      "Face for <small> elements.")

    ;; Drawing inspiration from shr-tag-h1
    (defun shr-tag-small (dom)
      (shr-fontize-dom dom (when shr-use-fonts 'shr-small)))

    (defface shr-time
      '((t :inherit underline :underline (:style wave)))
      "Face for <time> elements.")

    ;; Drawing inspiration from shr-tag-abbr
    (defun shr-tag-time (dom)
      (when-let* ((datetime (or
			     (dom-attr dom 'title)
			     (dom-attr dom 'datetime)))
		  (start (point)))
	(shr-generic dom)
	(shr-add-font start (point) 'shr-time)
	(add-text-properties
	 start (point)
	 (list
	  'help-echo datetime
	  'mouse-face 'highlight))))


    ;; EWW lacks a style for article
    (defun shr-tag-article (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    ;; EWW lacks a style for section; This is quite provisional
    (defun shr-tag-section (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    (setq browse-url-browser-function 'browse-url-default-macosx-browser)
    :bind (:map eww-mode-map ("U" . eww-up-url))
    :bind (("C-s-w" . browse-url-at-point))
    :hook ((eww-mode . jf/reader-visual)))
#+end_src

*** Random Tables

Let’s add some [[file:random-tables.org][Random Table tooling]].

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "random-tables.org"))
#+end_src

*** Hammerspoon

Hammerspoon is Lua application that provides a consistent API for interacting
with MacOS.  The editWithEmacs.spoon allows me to copy text from one region,
edit it in Emacs, and paste it back into the Application.

#+begin_src emacs-lisp
  (when (file-directory-p
	 "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon")
    (load
     "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el"
     nil
     jf/silence-loading-log))
#+end_src

** Connective Tissue and Oddities
*** Functions

The following chunk of allows me to take multiple filenames passed via the
emacsclient and open those files in windows within the same frame.

You can see this in my [[https://codeberg.org/takeonrules/dotzshrc/src/branch/main/bin/git-edit][git-edit]] command line tool.

#+begin_src emacs-lisp
  (defvar server-visit-files-custom-find:buffer-count
    "A counter for assisting with opening multiple files via a single
  client call.")
  (defadvice server-visit-files
      (around server-visit-files-custom-find
	      activate compile)
    "Maintain a counter of visited files from a single client call."
    (let ((server-visit-files-custom-find:buffer-count 0))
      ad-do-it))
  (defun server-visit-hook-custom-find ()
    "Arrange to visit the files from a client call in separate windows."
    (if (zerop server-visit-files-custom-find:buffer-count)
	(progn
	  (delete-other-windows)
	  (switch-to-buffer (current-buffer)))
      (let ((buffer (current-buffer))
	    (window (split-window-sensibly)))
	(switch-to-buffer buffer)
	(balance-windows)))
    (setq server-visit-files-custom-find:buffer-count
	  (1+ server-visit-files-custom-find:buffer-count)))
  (add-hook 'server-visit-hook 'server-visit-hook-custom-find)
#+end_src

- ~jf/toggle-osx-alternate-modifier~ :: I like having MacOS’s native Option (e.g. =⌥=) modifier available.  But using
that default in Emacs would be a significant hinderance.

The following function facilitates a best of both worlds.  By default, I want Option to be ~M-~
in Emacs.  However, I can toggle that setting.  That way if I need an umlaut
(e.g., =¨=), I can use MacOS’s native functions to type =⌥= + =u=.

#+begin_src emacs-lisp
  (defun jf/toggle-osx-alternate-modifier ()
    "Toggle native OS-X Option modifier
    setting (e.g. ns-alternate-modifier)."
    (interactive)
    (if ns-alternate-modifier
	(progn (setq ns-alternate-modifier nil)
	       (message "Enabling OS X native Option modifier"))
      (progn (setq ns-alternate-modifier 'meta)
	     (message "Disabling OX X native Option modifier (e.g. Option as Meta)"))))
#+end_src

- ~jf/eval-region-dwim~ :: I try to get quick feedback when writing emacs-lisp;
  the ~jf/eval-region-dwim~ binds a mnemonic key sequence to an extend ~eval-region~.

#+begin_src emacs-lisp
  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'jf/eval-region-dwim)
  (defun jf/eval-region-dwim ()
    "When region is active, evaluate it and kill the mark. Else,
    evaluate the whole buffer."
    (interactive)
    (if (not (region-active-p))
	(progn
	  (message "Evaluating buffer...")
	  (eval-buffer))
      (progn
	(message "Evaluating region...")
	(eval-region (region-beginning) (region-end)))
      (setq-local deactivate-mark t)))
#+end_src

- ~jf/reader-visual~ :: A little bit of RSS beautification.

#+begin_src emacs-lisp
  (defun jf/reader-visual ()
    "A method to turn on visual line mode and adjust text scale."
    (text-scale-set 2)
    (turn-on-visual-line-mode))
#+end_src

- ~jf/scroll-down-half-page~ :: See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/

#+begin_src emacs-lisp
  (global-set-key (kbd "M-n") 'jf/scroll-down-half-page)
  (defun jf/scroll-down-half-page ()
    "Scroll down half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) (move-to-window-line nil))
	    ((= ln lmax) (recenter (window-end)))
	    (t (progn
		 (move-to-window-line -1)
		 (recenter))))))
#+end_src

- ~jf/scroll-up-half-page~ :: See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/

#+begin_src emacs-lisp
  (global-set-key (kbd "M-p") 'jf/scroll-up-half-page)
  (defun jf/scroll-up-half-page ()
    "Scroll up half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) nil)
	    ((= ln lmax) (move-to-window-line nil))
	    (t (progn
		 (move-to-window-line 0)
		 (recenter))))))
#+end_src

- ~jf/org-insert-immediate-active-timestamp~ :: Insert an active timestamp, with a few options.

#+begin_src emacs-lisp
  (global-set-key (kbd "s-5") 'jf/org-insert-immediate-active-timestamp)
  (defun jf/org-insert-immediate-active-timestamp (parg)
    "Insert an active date for today.

  One universal arg (e.g., prefix call with C-u) inserts timestamp.
  Two universal arsg (e.g., prefix call with C-u C-u) prompts for date then insertes active date."
    (interactive "P")
    (let ((prefix (car parg)))
      (cond
       ((not prefix)  (org-insert-time-stamp nil nil nil))
       ((= prefix 4)  (org-insert-time-stamp nil t nil))
       ((= prefix 16) (org-insert-time-stamp (org-read-date nil t nil "Date") nil nil)))))
#+end_src

#+begin_src emacs-lisp
  (global-set-key (kbd "C-w") 'jf/kill-region-or-backward-word)
  (global-set-key (kbd "M-DEL") 'jf/kill-region-or-backward-word)
  (global-set-key (kbd "<C-M-backspace>") 'backward-kill-paragraph)
  (defun jf/kill-region-or-backward-word (&optional arg)
    "Kill selected region otherwise kill backwards the ARG number of words."
    (interactive "p")
    (if (region-active-p)
	(kill-region (region-beginning) (region-end))
      (backward-kill-word arg)))
#+end_src

- ~jf/kill-line-org-region~ :: Wedding two methods together: ~kill-region~ and
  ~kill-line~.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-k") 'jf/kill-line-or-region)
  (defun jf/kill-line-or-region (&optional ARG)
    "Kill the selected region otherwise kill the ARG number of lines."
    (interactive "P")
    (if (use-region-p)
	(kill-region (region-beginning) (region-end))
      (kill-line ARG)))
#+end_src

- ~jf/nab-file-name-to-clipboard~ :: There are plenty of times where I want the
  file name.  This command helps me get either it’s full path, or it’s base
  name.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c n") 'jf/nab-file-name-to-clipboard)
  (defun jf/nab-file-name-to-clipboard (parg)
    "Nab, I mean copy, the current buffer file name to the clipboard.

  The PARG is the universal prefix argument.

  If you pass no args, copy the filename with full path.
  If you pass one arg, copy the filename without path.
  If you pass two args, copy the path to the directory of the file."
    ;; https://blog.sumtypeofway.com/posts/emacs-config.html
    (interactive "P")
    (let* ((prefix (car parg))
	   (raw-filename
	    (if (equal major-mode 'dired-mode) default-directory (buffer-file-name)))
	   (filename
	    (cond
	     ((not prefix)  raw-filename)
	     ((= prefix 4)  (file-name-nondirectory raw-filename))
	     ((= prefix 16) (file-name-directory raw-filename)))))
      (when filename
	(kill-new filename)
	(message "Copied buffer file name '%s' to the clipboard." filename))))
#+end_src

- ~jf/sort-unique-lines~ :: A simple combination of two functions ~sort-lines~
  and ~delete-duplicate-lines~.

#+begin_src emacs-lisp
  (defun jf/sort-unique-lines (reverse beg end &optional adjacent keep-blanks interactive)
    "Sort lines and delete duplicates.
    By default the sort is lexigraphically ascending.  To sort as
    descending set REVERSE to non-nil.  Specify BEG and END for the
    bounds of sorting.  By default, this is the selected region.

    I've included ADJACENT, KEEP-BLANKS, and INTERACTIVE so I can
    echo the method signature of `'delete-duplicate-lines`"
    ;; This is a common function that I've used in other text editors.
    ;; It's a simple stitch together of sort-lines and
    ;; delete-duplicate-lines.
    (interactive "P\nr")
    (sort-lines reverse beg end)
    (delete-duplicate-lines beg end reverse adjacent keep-blanks interactive))
#+end_src

- ~jf/display-buffer-in-side-window~ :: Creates a sticky side window on the
  right.  Sometimes this is just the right thing for reviewing files.  I don’t
  know when I need it, but when I use it I’m always thankful I have it.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-s-\\") 'jf/display-buffer-in-side-window)
  (cl-defun jf/display-buffer-in-side-window (&optional (buffer (current-buffer)))
    "Display BUFFER in dedicated side window."
    (interactive)
    (let ((display-buffer-mark-dedicated t))
      (display-buffer-in-side-window buffer
				     '((side . right)
				       (window-parameters
					(no-delete-other-windows . t))))))
#+end_src

- ~jf/display-buffer-in-bottom-window~ :: As ~jf/display-buffer-in-side-window~,
  but creates a side window on the bottom.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-s--") 'jf/display-buffer-in-bottom-window)
  (cl-defun jf/display-buffer-in-bottom-window (&optional (buffer (current-buffer)))
    "Display BUFFER in dedicated side window."
    (interactive)
    (let ((display-buffer-mark-dedicated t))
      (display-buffer-in-side-window buffer
				     '((side . bottom)
				       (window-parameters
					(no-delete-other-windows . t))))))
#+end_src

- ~jf/move-file~ :: Sometimes I want to move, without renaming, a file.  This
  function helps make that easy.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x m") 'jf/move-file)
  (defun jf/move-file (target-directory)
    "Write this file to TARGET-DIRECTORY, and delete old one."
    (interactive "DTarget Directory: ")
    (let* ((source (expand-file-name (file-name-nondirectory (buffer-name)) default-directory))
	   (target (f-join target-directory (file-name-nondirectory (buffer-name)))))
      (save-buffer)
      (rename-file source target)
      (kill-current-buffer)))
#+end_src

- ~jf/copy-snippet-deindented~ :: From [[http://mbork.pl/2022-05-23_Copying_code_snippets][Marcin Borkowski: 2022-05-23 Copying code snippets]]

#+begin_src emacs-lisp
  (defun jf/copy-snippet-deindented (begin end)
    "Copy region, between BEGIN and END, untabifying and removing indentation."
    (interactive "r")
    (let ((orig-tab-width tab-width)
	  (region (buffer-substring-no-properties begin end)))
      (with-temp-buffer
	(setq tab-width orig-tab-width)
	(insert region)
	(untabify (point-min) (point-max))
	(org-do-remove-indentation)
	(kill-new (buffer-string)))))
#+end_src

- ~jf/duplicate-current-line-or-lines-of-region~ :: Sometimes I just want to
  duplicate an area without copy and paste.  This helps that process.  It’s not
  as smart as TextMate’s equivalent function, but it’s close enough.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-d") 'jf/duplicate-current-line-or-lines-of-region)
  (global-set-key (kbd "C-c d") 'jf/duplicate-current-line-or-lines-of-region)
  (defun jf/duplicate-current-line-or-lines-of-region (arg)
    "Duplicate ARG times current line or the lines of the current region."
    (interactive "p")
    (if (use-region-p)
	(progn
	  (when (> (point) (mark))
	    (exchange-point-and-mark))
	  (beginning-of-line)
	  (exchange-point-and-mark)
	  (end-of-line)
	  (goto-char (+ (point) 1))
	  (exchange-point-and-mark)
	  (let* ((end (mark))
		 (beg (point))
		 (region
		  (buffer-substring-no-properties beg end)))
	    (dotimes (_i arg)
	      (goto-char end)
	      (insert region)
	      (setq end (point)))))
      (crux-duplicate-current-line-or-region arg)))

#+end_src

- ~jf/create-scratch-buffer~ :: A simple wrapper around scratch, that helps
  name it and sets the major mode to ~org-mode~.

#+begin_src emacs-lisp
  (global-set-key (kbd "<f12>") 'jf/create-scratch-buffer)
  (cl-defun jf/create-scratch-buffer (&key (mode 'org-mode))
    "Quickly open a scratch buffer and enable the given MODE."
    (interactive)
    (crux-create-scratch-buffer)
    (rename-buffer (concat "*scratch* at " (format-time-string "%Y-%m-%d %H:%M")))
    (funcall mode))
#+end_src


**** TODO Window Layout Functions

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; BEGIN frame and window quick setup
  (defun gk-layouts-3col ()
    "Three column layout.

  Tries to preserve the order of window buffers and active window."
    (interactive)
    ;; Record active window buffer.
    (let ((cbuf (current-buffer)))
      ;; Switch to leftmost window.
      (ignore-errors (cl-loop do (windmove-left)))
      (let ((buffers
	     (mapcar #'window-buffer (-take 3 (window-list))))
	    (width (/ (frame-width) 3)))
	(delete-other-windows)
	(split-window-horizontally width)
	(other-window 1)
	(split-window-horizontally)
	(other-window -1)
	(dolist (b buffers)
	  (switch-to-buffer b)
	  (other-window 1)))
      ;; Switch to previously visible buffer’s window.
      (select-window (get-buffer-window cbuf))))


  (defun gk-layouts-main-and-sidekicks ()
    "One horizontal split, the right window split in two.

  Tries to preserve the order of window buffers and active window."
    (interactive)
    ;; Record active window buffer.
    (let ((cbuf (current-buffer)))
      ;; Switch to leftmost window.
      (ignore-errors (cl-loop do (windmove-left)))
      (let ((buffers
	     (mapcar #'window-buffer (-take 3 (window-list)))))
	(delete-other-windows)
	(split-window-horizontally)
	(other-window 1)
	(split-window-vertically)
	(other-window -1)
	(dolist (b buffers)
	  (switch-to-buffer b)
	  (other-window 1)))
      ;; Switch to previously visible buffer’s window.
      (select-window (get-buffer-window cbuf))))

  (bind-key "C-x \\" #'gk-layouts-main-and-sidekicks)
  ;; END frame and window quick setup
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src


*** TODO Blogging Functions


#+begin_src emacs-lisp
  (org-babel-load-file
     (concat user-emacs-directory "takeonrules.org"))
#+end_src


#+begin_src emacs-lisp
  ;;******************************************************************************
  ;;
  ;;; BEGIN Non-Interactive Utility Functions
  ;;
  ;;******************************************************************************
  (cl-defun jf/convert-text-to-key (text &key (length 5))
    "Convert the given TEXT to an epigraph key.

  The LENGTH is how many words to use for the key."
    (let ((list-of-words (s-split-words text)))
      (if (> (length list-of-words) length)
	  (upcase (s-join "-" (subseq list-of-words 0 length)))
	"")))

  (defun jf/tor-convert-text-to-post-title (title)
    "Convert TITLE to correct format."
    (message "Titleizing...")
    (replace-regexp-in-string
     ;; Replace "Hello World" with “Hello World”
     "\"\\([^\"]+\\)\""
     "“\\1”"
     (s-replace "'" "’" title)))

  (defun jf/tor-convert-text-to-slug (&optional string)
    "Convert STRING to appropriate slug."
    (s-replace "'" "" (s-dashed-words (s-downcase string))))

  (cl-defun jf/tor-prompt-or-kill-ring-for-url (&key (url-regexp "^https?://"))
    "Prompt and return a url.

  If the `car' of `kill-ring' matches the URL-REGEXP, default the
  prompt value to the `car' of `kill-ring'."
    (let ((car-of-kill-ring (substring-no-properties (car kill-ring))))
      (read-string "URL (optional): "
		   (when (string-match url-regexp car-of-kill-ring)
		     car-of-kill-ring))))

  (defun jf/slugify ()
    "Convert the active region or line to a URL friendly slug."
    (interactive)
    (let* ((range (if (region-active-p)
		      (list (region-beginning) (region-end))
		    (list (point-at-bol) (point-at-eol))))
	   (text (buffer-substring-no-properties (car range) (cadr range))))
      (save-excursion
	(delete-region (car range) (cadr range))
	(goto-char (car range))
	(insert (jf/tor-convert-text-to-slug text)))))

  (cl-defun jf/tor-post---create-or-append (&key
					     title subheading
					     (tags '("null")) series toc
					     citeTitle citeURL citeAuthor)
    "Create or append a post with TITLE.

  The following keys are optional:

  :SUBHEADING if you have an active region, use this header.
  :TAGS one or more tags, as a list or string, to add to the
	  frontmatter.
  :SERIES the series to set in the frontmatter.
  :TOC whether to include a table of contents in the post.
  :CITETITLE the title of the URL cited (if any)
  :CITEURL the URL cited (if any)
  :CITEAUTHOR the author cited (if any)

  If there's an active region, select that text and place it."
    (let* ((default-directory (f-join jf/tor-home-directory
				      "content" "posts"
				      (format-time-string "%Y/")))

	   (slug (jf/tor-convert-text-to-slug title))
	   (fpath (expand-file-name
		   (concat default-directory slug ".md"))))
      ;; If the file does not exist, create the file with the proper
      ;; frontmatter.
      (if (not (file-exists-p fpath))
	  (write-region
	   (concat "---"
		   "\ndate: " (format-time-string "%Y-%m-%d %H:%M:%S %z")
		   "\ndraft: true"
		   "\nlayout: post"
		   "\nlicenses:\n- all-rights-reserved"
		   "\nslug: " (format "%s" slug)
		   "\ntitle: '" (jf/tor-convert-text-to-post-title title) "'"
		   "\ntype: post"
		   (when series (concat "\nseries: " series))
		   (when toc (concat "\ntoc: true"))
		   "\ntags:"
		   (if tags
		       (concat (mapconcat
				(lambda (tag) (concat "\n- " tag))
				(flatten-tree tags) ""))
		     "\n- null")
		   "\n---\n")
	   nil fpath))
      ;; If we have an active region, append that region's content to
      ;; the given file.
      (if (use-region-p)
	  (write-region
	   (concat
	    (if subheading
		(concat "\n## " subheading "\n")
	      (when citeTitle (concat "\n## " citeTitle "\n")))
	    (when citeURL (concat
			   "\n{{< blockquote"
			   (when citeAuthor
			     (concat " pre=\"" citeAuthor "\""))
			   " cite=\"" citeTitle
			   "\" cite_url=\"" citeURL "\" >}}\n"))
	    (buffer-substring (region-beginning) (region-end))
	    (when citeURL "\n{{< /blockquote >}}"))
	   nil fpath t)
	;; Without an active region, if we have a citeURL insert a link
	;; to it.
	(when citeURL
	  (write-region
	   (concat
	    "\n<cite><a href=\"" citeURL
	    "\" class=\"u-url p-name\" rel=\"cite\">"
	    (or (citeTitle) (citeURL)) "</a></cite>\n")
	   nil fpath t)))
      ;; Finally open that file for editing.
      (find-file fpath)
      (end-of-buffer)))
  ;;******************************************************************************
  ;;
  ;;; END Non-Interactive Utility Functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN Interactive Non-Wrapping Functions
  ;;
  ;;******************************************************************************
  (cl-defun jf/tor-toggle-hugo-server (&key
					(directory jf/tor-home-directory)
					(buffer-name "*Hugo Server*"))
    "This will start or stop a Hugo server in the given DIRECTORY for TakeOnRules.com.

  The BUFFER-NAME is where we'll run the Hugo process."
    (interactive)
    (if (get-buffer buffer-name)
	(progn
	  (kill-buffer buffer-name)
	  (message (concat "Stopping Hugo in \"" buffer-name "\" buffer…")))
      (let* ((default-directory directory))
	(start-process "hugo-server" buffer-name "hugo" "server" "-D")
	(message (concat "Starting Hugo in \"" buffer-name "\" buffer…")))))

  (defun jf/tor-retitle-post (title)
    "Replace the given buffer's title with the new TITLE.

  This function will: replace the content's title, update the slug,
  and rename the buffer."
    (interactive "sNew Post's Title: ")
    (let* ((metadataTitle (concat "title: '"
				  (jf/tor-convert-text-to-post-title title) "'"))
	   (slug (jf/tor-convert-text-to-slug title))
	   (metadataSlug (concat "slug: " slug))
	   (filename (buffer-file-name))
	   (new-filename (concat (file-name-directory filename)
				 slug ".md")))

      ;; Replace the title metadata entry
      (goto-char (point-min))
      (while (search-forward-regexp "^title:.*$" nil t)
	(replace-match metadataTitle))

      ;; Replace the slug metadata entry
      (goto-char (point-min))
      (while (search-forward-regexp "^slug:.*$" nil t)
	(replace-match metadataSlug))

      ;; Need to save before we rename the buffer
      (save-buffer)

      ;; Rename the buffer, accounting for version control
      (cond
       ((vc-backend filename)
	(vc-rename-file filename new-filename))
       (t
	(rename-file filename new-filename t)
	(set-visited-file-name new-filename t t)))

      ;; Report filename change
      (message "Renamed %s -> %s" filename new-filename)))

  (defvar jf/tor-hostname-regexp
    "^https?://takeonrules\.com"
    "A regular expression for checking if it's TakeOnRules.com.")

  (defvar jf/tor-hugo-regexp-for-post-path
    (concat jf/tor-hostname-regexp
	    "/[0-9]\\{4\\}/[0-9]\\{2\\}/[0-9]\\{2\\}/\\([^/]+\\)/?$")
    "A regular expression for matching blog posts.")

  (defvar jf/tor-hugo-regexp-for-pages-path
    (concat jf/tor-hostname-regexp "/\\([^z-a]*[^/]\\)/?$")
    "A regular expression for matching pages.")

  (defun jf/tor-find-hugo-file-by-url (url)
    "Find the associated TakeOnRules.com file for the given URL."
    (interactive (list
		  (jf/tor-prompt-or-kill-ring-for-url
		   :url-regexp jf/tor-hostname-regexp)))
    (cond
     ;; Blog post
     ((string-match jf/tor-hugo-regexp-for-post-path url)
      (let* ((slug (match-string-no-properties 1 url))
	     (filename (car
			(jf/list-filenames-with-file-text
			 :matching (concat "^slug: " slug "$")
			 :in "content"))))
	(find-file (f-join jf/tor-home-directory "content" filename))))
     ;; Pages
     ((string-match jf/tor-hugo-regexp-for-pages-path url)
      (let* ((permalink (match-string-no-properties 1 url))
	     (filename (car
			(jf/list-filenames-with-file-text
			 :matching (concat "^permalink: ['\\\"]?/?"
					   permalink "/?['\\\"]?$")
			 :in "content"))))
	(find-file (f-join jf/tor-home-directory "content" filename))))
     ;; No match found
     (t (message "Unable to find post for \"%s\"" url))))

  (cl-defun jf/tor-view-blog-post (&key
				    (hostname jf/tor-hostname-current))
    "Browse the url for the HOSTNAME

  The front matter of blog posts contains YAML, with two
  attributes: slug and date.  Based on the site configuration, the
  URLs for one of those posts is: hostname/year/month/day/slug"
    (interactive)
    (let ((slugs))
      (save-excursion
	;; Remember we are making a list and pushing to the beginning of
	;; the list.  Hence we start with the last slug in mind.
	(goto-char 1)
	(re-search-forward "^slug: \\(.*\\)$" nil t)
	(push (match-string 1) slugs)
	(goto-char 1)
	(re-search-forward
	 "^date: \\([[:digit:]]+\\)-\\([[:digit:]]+\\)-\\([[:digit:]]+\\) "
	 nil t)
	;; Then move to day, month, then year.
	(push (match-string 3) slugs)
	(push (match-string 2) slugs)
	(push (match-string 1) slugs)
	;; And finally the host name.
	(push hostname slugs))
      (browse-url (format "%s" (s-join "/" slugs)))))

  (defun jf/tor-create-post (title)
    "Create and visit a new draft post.  Prompt for a TITLE.

  The file for the blog post conforms to the path schema of posts
  for TakeOnRules.com."
    (interactive "sBlog Post Title: ")
    (jf/tor-post---create-or-append :title title))

  (defun jf/tor-tag-post (tags)
    "Apply the TAGS to the current TakeOnRules.com post.

  No effort is made to check if this is a post."
    (interactive (list (completing-read-multiple "Tags: " (jf/tor-tags-list))))
    (let ((saved-point (point))
	  (to-insert (concat "\n- " (s-join "\n- " tags))))
      (replace-regexp "^tags:$" (concat "tags:" to-insert) nil 0 (point-max))
      (goto-char (+ saved-point (length to-insert)))))

  (defun jf/tor-insert-glossary-key (key)
    "Insert the KEY at point."
    (interactive (list (completing-read "Key: " (jf/tor-glossary-key-list))))
    (insert key))

  (defun jf/tor-find-changelog-and-insert-entry ()
    "Find TakeOnRules glossary and begin entering a changelog entry."
    (interactive)
    (find-file (f-join jf/tor-home-directory "data" "changelog.yml"))
    ;; The changelog is structured in date descending order.  The first
    ;; line is the YAML preamble indicating a data object (e.g. "---")
    (beginning-of-buffer)
    (end-of-line)
    (insert (concat "\n- date: "
		    (format-time-string "%Y-%m-%d")
		    "\n  entries:\n    - ")))

  (defun jf/tor-find-series-and-insert-entry (title)
    "Find TakeOnRules series and add an entry with TITLE."
    (interactive "sSeries Entry's Title: ")
    (find-file (f-join jf/tor-home-directory "data" "series.yml"))
    (let ((key (downcase (s-dashed-words title))))
      (end-of-buffer)
      (insert (concat
	       (if (looking-at-p "^$") "" "\n")
	       "- title: " title
	       "\n  key: " key))))

  (defun jf/tor-find-glossary-and-insert-entry (title)
    "Find TakeOnRules glossary and add an entry with TITLE."
    (interactive "sGlossary Entry's Title: ")
    (find-file (f-join jf/tor-home-directory "data" "glossary.yml"))
    (let ((key (upcase (s-dashed-words title))))
      (end-of-buffer)
      (insert (concat
	       (if (looking-at-p "^$") "" "\n")
	       "- title: " title
	       "\n  key: " key))))

  (defun jf/tor-insert-epigraph-entry ()
    "Prompt for a new a new data/epigraphs.yml entry."
    (interactive)
    (find-file (f-join jf/tor-home-directory "data" "epigraphs.yml"))
    (end-of-buffer)
    (insert (concat
	     (if (looking-at-p "^$") "" "\n")
	     "epi"))
    (end-of-buffer)
    "Assumes that the 'epi' is the correct expansion for the snippet."
    (yas-expand)
    (message "Ready to insert a new epigraph"))

  (cl-defun jf/tor-post-amplifying-the-blogosphere (subheading
						     &key
						     citeTitle
						     citeURL
						     citeAuthor)
    "Create and visit draft post for amplifying the blogosphere.

  If there's an active region, prompt for the :SUBHEADING.  The file
  for the blog post conforms to the path schema of posts for
  TakeOnRules.com.

  We'll pass the :CITETITLE, :CITEAUTHOR, and :CITEURL to
  `jf/tor-post---create-or-append'"
    (interactive (list (if (use-region-p)
			   (read-string "Sub-Heading: ")
			 nil)))
    (jf/tor-post---create-or-append
     :title (format-time-string "Amplifying the Blogosphere (v%Y-%m-%d)")
     :toc "true"
     :subheading subheading
     :series "amplifying-the-blogosphere"
     :tags "response to other blogs"
     :citeTitle citeTitle
     :citeURL citeURL
     :citeAuthor citeAuthor))

  ;; Note: I needed to use `fboundp' because if I invoked this functions
  ;; before other consult functions I got a method void error.
  (cl-defun jf/find-file-via-matching (&key prompt matching in)
    "PROMPT for files IN the directory with MATCHING content.

  If `consult--read' is defined, use that.  Otherwise fallback to `completing-read'."
    (if (fboundp 'consult--read)
	(consult--read
	 (consult--with-increased-gc
	  (jf/list-full-filenames-with-file-text :matching matching :in in))
	 :prompt prompt
	 :sort nil
	 :require-match t
	 :category 'file
	 :history 'file-name-history
	 :state (consult--file-preview))
      (list (completing-read
	     prompt
	     (jf/list-filenames-with-file-text
	      :matching matching
	      :in in)))))

  (defun jf/tor-find-file-draft (filename)
    "Find a draft FILENAME in the TakeOnRules content directory."
    (interactive
     (list (jf/find-file-via-matching
	    :prompt "Draft filename: "
	    :matching "^draft: true"
	    :in (f-join jf/tor-home-directory "content"))))
    (find-file filename))

  (defun jf/tor-find-file (filename)
    "Find a FILENAME in the TakeOnRules content directory."
    (interactive
     (list (jf/find-file-via-matching
	    :prompt "Filename: "
	    :matching "^title:"
	    :in (f-join jf/tor-home-directory "content"))))
    (find-file filename))
  ;;******************************************************************************
  ;;
  ;;; END Interactive Non-Wrapping Functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN Listing functions for TakeOnRules.com data
  ;;
  ;;******************************************************************************
  (defun jf/tor-tags-list ()
    "Return a list of tags from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "tag" :filename "data/glossary.yml"))

  (defun jf/tor-epigraph-list ()
    "Return a list of epigraph keys from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "key" :filename "data/epigraphs.yml"))

  (defun jf/tor-game-list ()
    "Return a list of games from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "game" :filename "data/glossary.yml"))

  (defun jf/tor-glossary-title-list ()
    "Return a list of titles from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "title" :filename "data/glossary.yml"))

  (defun jf/tor-glossary-key-list ()
    "Return a list of keys from TakeOnRules.com glossary."
    (jf/tor-list-by-key-from-filename :key "key" :filename "data/glossary.yml"))

  (defun jf/tor-series-list ()
    "Return a list of series from TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "key" :filename "data/series.yml"))

  (defun jf/tor-licenses-list ()
    "Return a list of available licenses for TakeOnRules.com."
    (jf/tor-list-by-key-from-filename :key "Key" :filename "data/licenses.yml"))
  ;;******************************************************************************
  ;;
  ;;; END Listing functions for TakeOnRules.com data
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN querying and list generation functions
  ;;
  ;;******************************************************************************
  (cl-defun jf/tor-list-by-key-from-filename (&key
					       key
					       filename
					       (directory jf/tor-home-directory))
    "Build a list of entries of the KEY from the FILENAME in DIRECTORY."
    (split-string-and-unquote
     (shell-command-to-string
      (concat
       "rg \"^[- ] " key ": .*$\" "
       (f-join directory filename)
       " --only-matching --no-filename | sed 's/^[ -] " key ": //' | sort | tr '\n' '@'"))
     "@"))

  (cl-defun jf/list-filenames-with-file-text (&key matching in)
    "Build a list of filenames MATCHING the pattern IN the given directory."
    (let ((default-directory (f-join jf/tor-home-directory in)))
      (split-string-and-unquote
       (shell-command-to-string
	(concat
	 "rg \""
	 matching "\" --only-matching --files-with-matches --sortr modified"
	 "| tr '\n' '@'"))
       "@")))

  (cl-defun jf/list-full-filenames-with-file-text (&key matching in)
    "Build a list of filenames MATCHING the pattern IN the given directory."
    (split-string-and-unquote
     (shell-command-to-string
      (concat
       "rg \""
       matching "\" " in " --only-matching --files-with-matches --sortr modified"
       "| tr '\n' '@'"))
     "@"))

  (defun jf/tor-page-relative-pathname-list ()
    "Return a list of pages for TakeOnRules.com."
    (jf/list-filenames-with-file-text :matching "^title: " :in "content"))

  (defun jf/tor-asset-relative-pathname-list ()
    "Return a list of image filenames for TakeOnRules.com."
    (let ((default-directory (f-join jf/tor-home-directory "assets" "images")))
      (split-string-and-unquote
       (shell-command-to-string "ls"))))

  (defun jf/matches-in-buffer (regexp &optional buffer)
    "Return a list of matches of REGEXP in BUFFER or the current buffer if not given."
    (let ((matches))
      (save-match-data
	(save-excursion
	  (with-current-buffer (or buffer (current-buffer))
	    (save-restriction
	      (widen)
	      (goto-char 1)
	      (while (search-forward-regexp regexp nil t 1)
		(push (match-string 0) matches)))))
	matches)))

  (defun jf/kill-new-markdown-heading-as-slug (heading)
    "Push onto the `kill-ring' a slugified version of HEADING."
    (interactive
     (list (completing-read
	    "Heading: "
	    (jf/matches-in-buffer "^#+ +.*$"))))
    (kill-new (jf/tor-convert-text-to-slug
	       (replace-regexp-in-string "^#+ +" "" heading))))
  ;;******************************************************************************
  ;;
  ;;; END querying and list generation functions
  ;;
  ;;******************************************************************************

  ;;******************************************************************************
  ;;
  ;;; BEGIN Wrapping Functions
  ;;
  ;;******************************************************************************
  (cl-defun jf/tor-wrap-with-text (&key before after strategy)
    "Wrap the STRATEGY determined region with the BEFORE and AFTER text.

  Valid STRATEGY options are:

  - :lineOrRegion
  - :pointOrRegion
  - :sentenceOrRegion
  - :wordOrRegion

  TODO: I would love create a lookup table for the case statement,
  as the behavior's well defined."
    (pcase strategy
      (:lineOrRegion (pcase-let* ((origin (point))
				  (`(,begin . ,end)
				   (crux-get-positions-of-line-or-region)))
		       (goto-char end)
		       (insert after)
		       (goto-char begin)
		       (insert before)))
      (:sentenceOrRegion (let* ((begin (if (use-region-p)
					   (region-beginning)
					 (car (bounds-of-thing-at-point 'sentence))))
				(end (if (use-region-p)
					 (region-end)
				       (cdr (bounds-of-thing-at-point 'sentence)))))
			   (goto-char end)
			   (insert after)
			   (goto-char begin)
			   (insert before)))
      (:pointOrRegion (let* ((begin (if (use-region-p) (region-beginning) (point)))
			     (end (if (use-region-p) (region-end) (point))))
			(goto-char end)
			(insert after)
			(goto-char begin)
			(insert before)))
      (:wordOrRegion (let* ((begin (if (use-region-p)
				       (region-beginning)
				     (car (bounds-of-thing-at-point 'word))))
			    (end (if (use-region-p)
				     (region-end)
				   (cdr (bounds-of-thing-at-point 'word)))))
		       (goto-char end)
		       (insert after)
		       (goto-char begin)
		       (insert before)))
      ))

  (defun jf/tor-wrap-in-html-tag (tag &optional attributes)
    "Wrap the word or region with the given TAG with optional ATTRIBUTES."
    (interactive "sHTML Tag: \nsAttributes (optional): ")
    (jf/tor-wrap-with-text
     :before (concat "<" tag (if (s-blank? attributes)
				 ""
			       (concat " " attributes)) ">")
     :after (concat "</" tag ">")
     :strategy :wordOrRegion))

  (defun jf/tor-wrap-in-poem ()
    "Wrap the point or region as a poem."
    (interactive)
    (jf/tor-wrap-with-text
     :before "<pre class=\"poem\">\n"
     :after "\n</pre>"
     :strategy :pointOrRegion))

  (defun jf/tor-wrap-date (date)
    "Wrap the point or region with the given DATE."
    (interactive (list (org-read-date nil nil nil "Date")))
    (jf/tor-wrap-in-html-tag
     "time"
     (concat "datetime=\"" date "\" title=\"" date "\"")))

  (defun jf/tor-wrap-as-marginnote-dwim ()
    "Wrap the line or current region as a marginnote Hugo shortcode."
    (interactive)
    (jf/tor-wrap-with-text
     :before "{{< marginnote >}}\n"
     :after "\n{{< /marginnote >}}"
     :strategy :lineOrRegion))

  (defun jf/tor-wrap-as-sidenote-dwim ()
    "Wrap the line or current region as a sidenote Hugo shortcode."
    (interactive)
    (jf/tor-wrap-with-text
     :before "{{< sidenote >}}"
     :after "{{< /sidenote >}}"
     :strategy :sentenceOrRegion))

  (defun jf/tor-wrap-link-active-region-dwim (url)
    "Wrap current region (or point) in an A-tag with the given URL.

  For the URL:

  - If `car' of `kill-ring' starts with \"http\", then use that as the URL.
  - Otherwise prompt for a URL.

  If the URL is an empty string, then send a message.  Else, if we
  have a non-0 length URL, use the URL and wrap the region in an A
  tag."
    (interactive (list (jf/tor-prompt-or-kill-ring-for-url)))
    (if (eq (length url) 0)
	(message "No URL to use for A-tag creation")
      (jf/tor-wrap-with-text
       :before (concat "<a href=\"" url "\">")
       :after "</a>"
       :strategy :pointOrRegion)))

  (defun jf/tor-wrap-as-pseudo-dfn ()
    "Wrap current region (or word) in an I-tag with a DFN dom class."
    (interactive)
    (jf/tor-wrap-with-text
     :before "<i class=\"dfn\">"
     :after "</i>"
     :strategy :wordOrRegion))

  (defun jf/tor-wrap-cite-active-region-dwim (url)
    "Wrap current region (or point) in a CITE-tag and optional A-tag with URL.

  For the URL:

  - If `car' of `kill-ring' starts with \"http\", then use that as the URL.
  - Otherwise prompt for a URL.

  If the URL an empty string, then wrap the current region or point
  in a CITE tag.  Else, if we have a non-0 length URL, wrap it in
  CITE and A tag."
    (interactive (list (jf/tor-prompt-or-kill-ring-for-url)))

    ;; Were we to start writing at the START position, we'd invariably
    ;; change the contents such that the END position was no longer
    ;; accurate.  So instead, we append at the END position, hop back to
    ;; the START position and append to the START position.
    (if (eq (length url) 0)
	(jf/tor-wrap-with-text
	 :before "<cite>"
	 :after "</cite >"
	 :strategy :pointOrRegion)
      (jf/tor-wrap-with-text
       :before (concat "<cite><a href=\"" url
		       "\" class=\"u-url p-name\" rel=\"cite\">")
       :after "</a></cite>"
       :strategy :pointOrRegion)))
  ;;******************************************************************************
  ;;
  ;;; END Wrapping Functions
  ;;
  ;;******************************************************************************
#+end_src

*** Quick Help

The following ~jf/transient-quick-help~ macro helps generate “help menus” that
I want to reference.

#+begin_src emacs-lisp
  (cl-defun jf/quick-help (&key header body)
    "Create a help window with HEADER and BODY."
    (let ((qh-buff (concat "*Quick Help: " header "*"))
	  (qh-text body))
      (get-buffer-create qh-buff)
      (with-current-buffer qh-buff
	(insert qh-text)
	(goto-char (point-min))
	(not-modified)
	(read-only-mode)
	(special-mode)
	(local-set-key (kbd "q") 'kill-buffer-and-window))
      (pop-to-buffer qh-buff '((display-buffer-below-selected)
			       (window-parameters . ((no-other-window . nil)))
			       (window-height . fit-window-to-buffer)))
      (message "q - Remove Window")))

  (cl-defmacro jf/transient-quick-help (name &key header label body)
    "Macro for creating callable functions that display help.

    NAME is name of function,
    LABEL is label for the menu
    HEADER is name of buffer, and TEXT is displayed."
    (declare (indent defun))
    `(progn
       (transient-define-suffix ,name nil
	 ,header
	 :description ,label
	 (interactive)
	 (jf/quick-help :header ,header :body ,body))))
#+end_src

/Note:/ It might make sense to extract the quick help to files, but for now
this was the least effort.

*** Keyboard Macros

#+begin_src emacs-lisp
  (org-babel-load-file
     (concat user-emacs-directory "keyboard-macros-config.org"))
#+end_src

*** Minor Modes

In work and in play, there are several “me” specific contexts.  The
~jf/minor-mode-maker~ macro helps me quickly and consistently make those
contexual minor modes.  My intention is to build out even more functions on
those modes.

#+begin_src emacs-lisp
  (cl-defmacro jf/minor-mode-maker (&key title abbr hooks)
    "A macro to declare a minor mode.

  Use TITLE to derive the docstring.
  Use ABBR to derive the mode-name lighter.
  Add hook to each HOOKS provided."
    (let ((mode-name (intern (s-downcase (concat "jf/" abbr "-minor-mode"))))
	  (lighter (concat " " abbr))
	  (docstring (concat "Minor mode for " title ".")))
      `(progn
	 (define-minor-mode ,mode-name
	   ,docstring
	   :global nil
	   :lighter ,lighter)
	 (when ,hooks
	   (-each ,hooks (lambda(hook) (add-hook hook (lambda () (,mode-name)))))))))


  (jf/minor-mode-maker :title "Take on Rules"
			:abbr "tor")
#+end_src

** Burning Wheel

I wrote [[file:burning-wheel-emacs-config.org][some tooling to help while playing Burning Wheel]].

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "burning-wheel-emacs-config.org"))
#+end_src

** Eberron

I wrote [[file:eberron.org][some tooling to help wile playing Eberron]].

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "eberron.org"))
#+end_src

** Forem, or Where I Work

Let’s add some [[file:forem-config.org][Forem tooling]].

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "forem-config.org"))
#+end_src

** Crafting Menus to Help Organize

I use Emacs for software development, knowledge management, blogging, and just
about whatever else I can.  And as I wrote in [[*Knowledge Management][Knowledge Management]], I try to
provide guidance when working within those contexts.

As I wrote earlier, I’ve settled on transient as my “menu creation” tool.  I am
thankful to the author of [[https://www.reddit.com/r/emacs/comments/m518xh/transient_api_example_alternative_bindings_part_1/][Transient API Example (Alternative Bindings Part 1) :
emacs]], as they helped me understand what is a relatively straight forward
system.

I’ll explain the language just a bit.  We have a prefix, infix, and suffix.
The prefix is what you start doing, the infix is modifications/adjustments,
before you finally invoke the suffix to “complete” the sequence.  A prefix and
a suffix are emacs-lisp functions, and transient provides a macro to make more
composable prefixes and suffixes.

I already introduced a simple transient prefix in the helpful package.  I want
to write some transient suffixes to.  As you’ll see later, you don’t need to
use the ~transient-define-suffix~ for adding a function to a transient prefix,
but a suffix can provide a description.

- ~jf/org-auto-tags--transient~ :: provides a description and a function.  The
description is dynamic (hence the ~lambda~); it shows the tags that are
currently set in ~jf/org-auto-tags--transient~.  The function prompts me to
adjust those tags and store them in the aforementioned variable.

#+begin_src emacs-lisp
  (transient-define-suffix jf/org-auto-tags--transient (tags)
    "Set the TAGS from minibuffer read"
    :description '(lambda ()
		    (concat
		     "Org Tags: "
		     (propertize
		      (format "%s" jf/org-auto-tags--current-list)
		      'face 'transient-argument)))
    (interactive
     (list (completing-read-multiple "Tag(s): " (org-roam-tag-completions))))
    (setq jf/org-auto-tags--current-list tags))
#+end_src

- ~jf/hammerspoon-toggle-mode~ :: this suffix provides a dynamic description of
  the current major mode for a ~hammerspoon-edit-minor-mode~ buffer.  And the
  prefix’s function toggles that mode.

#+begin_src emacs-lisp
  (transient-define-suffix jf/hammerspoon-toggle-mode ()
    "Set the hammerspoon mode"
    :description '(lambda ()
		    (concat
		     "Hammerspoon Mode: "
		     (propertize
		      (format "%s" major-mode)
		      'face 'transient-argument)))
    (interactive)
    (hammerspoon-toggle-mode))
#+end_src

- ~jf/tor-hostname-current-toggle~ :: this suffix provides a dynamic
  description of the current host I want to use for my blog.  And the prefix’s
  function toggles the host.

#+begin_src emacs-lisp
  (transient-define-suffix jf/tor-hostname-current-toggle (hostname)
      "Set `jf/tor-hostname-current' to HOSTNAME."
      :description '(lambda ()
		      (concat "Host: "
		      (propertize
			(format "%s" jf/tor-hostname-current)
			'face 'transient-argument)))
      (interactive (list (completing-read
			  "Host: " (list
				    (list jf/tor-hostname-default-local 1)
				    (list jf/tor-hostname-default-remote 2)
				    ))))
      (setq jf/tor-hostname-current hostname))
#+end_src

Next up is defining the transient prefixes, as I’m using them “menus.”  The
prefixes are the “start of” a command sequence.  In this case, I’m using them
as menu’s which expose additional actions.

Right away, I’m going to leverage the ~org-menu.el~ package; it leverages
~transient.el~ for context specific options.

#+begin_src emacs-lisp
  (use-package org-menu
    :straight (org-menu :host github :repo "sheijk/org-menu")
    :bind (:map org-mode-map ("C-c m" . 'org-menu)))
#+end_src

A menu for my TakeOnRules blogging tasks.

#+begin_src emacs-lisp
  (transient-define-prefix jf/menu--tor ()
    "My Take on Rules menu; useful when developing my blog."
    ["Take on Rules"
     ["Host"
      ("-h" jf/tor-hostname-current-toggle :transient t)
     ]]
     [["Posts"
      :if-non-nil jf/tor-minor-mode
      ("p r" "Re-title post…" jf/tor-retitle-post)
      ("p t" "Tag post…" jf/tor-tag-post :transient t)
      ("p v" "View post…" jf/tor-view-blog-post)
      ]
     ["Find"
      ("f d" "in draft status…" jf/tor-find-file-draft)
      ("f u" "by url…" jf/tor-find-hugo-file-by-url)
      ("f f" "by filename…" jf/tor-find-file)]
     ["Create"
      ("c a" "Amplify the Blogosphere…" jf/tor-post-amplifying-the-blogosphere)
      ("c c" "Changelog entry…" jf/tor-find-changelog-and-insert-entry)
      ("c e" "Epigraph entry…" jf/tor-insert-epigraph-entry)
      ("c g" "Glossary entry…" jf/tor-find-glossary-and-insert-entry)
      ("c p" "Post…" jf/tor-create-post)
      ("c s" "Series…" jf/tor-find-series-and-insert-entry)]
     ])
#+end_src

Finally the main menu that connects all of the above together, and provides
some additional options.

#+begin_src emacs-lisp
  (global-set-key (kbd "s-1") 'jf/menu)
  (setq jf/pairing-font-p nil)
  (transient-define-prefix jf/menu ()
    "A context specific \"mega\" menu."
    ;; Todo, can I get this section into a function so I can duplicate it in the jf/menu--tor?
    [["Markdown Utilities"
      ("k h" "Kill slug version of given heading…" jf/kill-new-markdown-heading-as-slug :if-derived (or markdown-mode html-mode))
      ("w a" "A-tag at point or region…" jf/tor-wrap-link-active-region-dwim  :if-derived (or markdown-mode html-mode))
      ("w c" "CITE-tag point or region…" jf/tor-wrap-cite-active-region-dwim  :if-derived (or markdown-mode html-mode))
      ("w d" "DATETIME-tag point or region…" jf/tor-wrap-date  :if-derived (or markdown-mode html-mode))
      ("w f" "Wrap word or region in pseudo-DFN…" jf/tor-wrap-as-pseudo-dfn  :if-derived (or markdown-mode html-mode))
      ]
     [
      "" ;; Deliberate space for menu
      ("w m" "Margin-note line or region…" jf/tor-wrap-as-marginnote-dwim  :if-derived (or markdown-mode html-mode))
      ("w p" "Wrap point or region as Poem…" jf/tor-wrap-in-poem  :if-derived (or markdown-mode html-mode))
      ("w s" "Side-note sentence or region…" jf/tor-wrap-as-sidenote-dwim  :if-derived (or markdown-mode html-mode))
      ("w w" "Wrap point or region in html…" jf/tor-wrap-in-html-tag  :if-derived (or markdown-mode html-mode))
      ]]
    [["Contexts"
      ("-b" "Burning Wheel…"  jf/menu--bwg)
      ("-e" "Eberron…" jf/menu--eberron)
      ("-f" "Forem…" jf/menu--forem)
      ("-t" "TakeOnRules…" jf/menu--tor)
      ("-w" "Register window configuration" window-configuration-to-register)
      ]
     ["Jump to"
      ("j a" "Agenda" (lambda () (interactive) (find-file "~/git/org/agenda.org")))
      ("j b" "iBuffer" ibuffer)
      ;; ("j f" "Flycheck" consult-flycheck :if-derived (or markdown-mode org-mode))
      ("j g" "Global Mark" consult-global-mark)
      ("j h" "Hugo File" jf/jump_to_corresponding_hugo_file :if-derived org-mode)
      ("j m" "Mark" consult-mark)
      ("j o" "Org File" jf/jump_to_corresponding_org_file :if-non-nil jf/tor-minor-mode)
      ("j p" "Jump in PDF" doc-view-goto-page :if-derived doc-view-mode)
      ]
     ["Dailies"
      ("d p" "Pick a daily" org-roam-dailies-goto-date)
      ("d t" "Today's daily" org-roam-dailies-goto-today)
      ("d T" "Tomorrow's daily" org-roam-dailies-goto-tomorrow)
      ("d y" "Yesterday's daily" org-roam-dailies-goto-yesterday)
      ]
     ["Modes"
      ;; I could write functions for these, but this is concise enough
      ("m h" jf/hammerspoon-toggle-mode  :if-non-nil hammerspoon-edit-minor-mode)
      ("m f" "Pairing Font (*)" (lambda () (interactive) (progn (setq jf/pairing-font-p nil) (set-face-attribute 'default nil :family jf/fixed-width-font-name :height 140))) :if-non-nil jf/pairing-font-p)
      ("m f" "Pairing Font ( )" (lambda () (interactive) (progn (setq jf/pairing-font-p t) (set-face-attribute 'default nil :family jf/fixed-width-font-name :height 200))) :if-nil jf/pairing-font-p)
      ("m t" "Typopunct ( )" typopunct-mode :if-nil typopunct-mode)
      ("m t" "Typopunct (*)" typopunct-mode :if-non-nil typopunct-mode)
      ("m o" "MacOS Native Option ( )" jf/toggle-osx-alternate-modifier :if-non-nil ns-alternate-modifier)
      ("m o" "MacOS Native Option (*)" jf/toggle-osx-alternate-modifier :if-nil ns-alternate-modifier)
      ("m w" "Writeroom ( )" writeroom-mode :if-nil writeroom-mode)
      ("m w" "Writeroom (*)" writeroom-mode :if-non-nil writeroom-mode)
      ("C-t" "Group by Projects ( )" jf/centaur-tabs-toggle-grouping :if jf/centaur-tabs-grouping-by-buffer-groups?)
      ("C-t" "Group by Projects (*)" jf/centaur-tabs-toggle-grouping :if-not jf/centaur-tabs-grouping-by-buffer-groups?)
      ]]
    ["Org"
     ["Add Metadata"
      ("C-e a" "Add epigraph properties…" jf/org-mode-add-epigraph-keys :if-derived org-mode)
      ("C-e i" "Add epigraph at point…" jf/org-roam-insert-at-point-epigraph-macro :if-derived org-mode)
      ("r a" "Ref add…" org-roam-ref-add :if-derived org-mode)
      ("t s" "Tag as session report…" jf/org-tag-as-session-report :if-derived org-mode)
      ("t a" "Tag add…" org-roam-tag-add :if-derived org-mode)
      ("t S" "Tag as session Scene…" jf/org-tag-session-scene-with-date :if-derived org-mode)]
     ["Context"
      ("s" "Search…" (lambda () (interactive) (consult-ripgrep org-directory)))
      ("M-c" "Context set…" jf/org-auto-tags--set-by-context :transient t)
      ("M-s" jf/org-auto-tags--transient :transient t)
      ("x" "Export to TakeOnRules…" jf/export-org-to-tor :if-derived org-mode)
      ]
     ["Grag Refs"
      ("g e" "Elfeed" jf/menu--org-capture-elfeed-show :if-derived elfeed-show-mode)
      ("g f" "Firefox" jf/menu--org-capture-firefox)
      ("g s" "Safari" jf/menu--org-capture-safari)
      ("g w" "Eww" jf/menu--org-capture-eww :if-derived eww-mode)
      ]
     ])
#+end_src

#+begin_src emacs-lisp
  (autoload 'org-buffer-list "org")
  (defvar org-buffer-source
    `(:name     "Org"
		:narrow   ?o
		:category buffer
		:state    ,#'consult--buffer-state
		:items    ,(lambda () (mapcar #'buffer-name (org-buffer-list)))))
#+end_src

* Footnotes

[fn:8] Steve Covey, and trademarked by FranklinCovey.

[fn:7] Yes, I said I didn’t want an Electron-based editor, but VS Code is a dominant player in the open source text editor.

[fn:2]  https://github.com/minad/consult#introduction

[fn:3]  These functions assume that the repository is using a [[https://rietta.com/blog/github-merge-types/#squash-and-merge][Squash and Merge strategy]].

[fn:4] My alias is as follows: ~alias e-reboot='cd ~/git/dotemacs; git stash ; edaemon ; git stash pop ; git edit'~.

[fn:5] My [[https://codeberg.org/takeonrules/dotzshrc/src/ab8b781cbdddd2fdbe674e031436b7e9a8e8a024/README.org#L1][dotzshrc]] config has my ~$EDITOR~

[fn:6] “Ag” is the chemical symbol for the Silver element.

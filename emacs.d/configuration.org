# -*- org-insert-tilde-language: emacs-lisp; -*-
:PROPERTIES:
:ID:       82C14F1A-163D-4774-A27F-1D792495922A
:END:
:HUGO:
#+HUGO_FRONT_MATTER_FORMAT: yaml
#+HUGO_BASE_DIR: ~/git/takeonrules.source
#+HUGO_SECTION: posts/2022
:END:
#+TITLE: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :comments link
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+STARTUP: showall
#+OPTIONS: toc:3

* Introduction

On <2020-05-25> I wrote [[https://takeonrules.com/2020/05/25/principles-of-my-text-editor/][Principles of My Text Editor]].  I was exploring adopting
a new text editor, and wanted to ensure that I knew what I was looking for.
You know, “begin with the end in mind.”[fn:8]

I did not realize how inadequate I was in thinking about my text editor; but
that is a different tale.

When I first dove into Emacs, I looked into [[https://github.com/hlissner/doom-emacs][Doom]] and [[https://www.spacemacs.org][Spacemacs]].  However, in
doing that I got ahead of myself.  So I started with an empty ~init.el~ and
walked through the tutorial.

From that point forward, I committed to use Emacs as is and when I knew I
needed something, I’d look into how to do it.  The result?  A configuration
that is uniquely mine.

On <2022-02-01 Tue> I chose to begin extracting my the various ~*.el~ into a
[[https://en.wikipedia.org/wiki/Literate_programming][Literate programming]] format.  As with all Emacs configurations, what follows is
a work in progress.

** Tips on Troubleshooting

As I migrated from my ~*.el~ configurations, I moved one ~.el~ file at a time.
With each move, I would restart my Emacs daemon[fn:5].  I went so far as
to write a ~e-reboot~ alias[fn:4].  So if I “messed up”, I could easily
recover and fix the files I broke.

In other words, when I’m working on extending my Emacs configuration, I tend to
favor a bisset approach.  Make a change, verify it, and commit.  This helps
insulate me from “getting to far ahead of myself.”  Along the way, I failed to
always apply that discipline.

** About the Current Structure

The current structure is carried over from my past structure.  As I was first
adopting Emacs, I spent time organizing the packages.  This organization is a
bit muddy, as I never quite established the nomenclature.

What I can say is the order may be important.  But I’ll be working to untangle
that.

Where feasible, I have tried to bind keys “close” to their utilization.  That
is to say, I often leverage the ~:bind~, ~:hook~, and ~:map~ keywords for
~use-package~.  But I’m not always consistent.

In the ~org-mode~ version, I’m making use of “TODO” indicators to help me track
what else I may need to do.  A node marked as “DONE” should be viewed as “I
don’t need to go back and amend any documentation in that part.  However, it
doesn’t mean I won’t put more things in that section.”

** Organizing the Ideas

I’ve thought quite a bit about how to organize this file.  How does one narrate
the intertwined concepts of a configuration that is an amalgamation of so many
other people’s work?

My approach is to think back to my experience with the tutorial.  How it walked
me through the concepts.  I also need to be mindful that as I introduce source
code concepts, they are evaluated in that order.

** Conventions

I’ve written quite a few functions to further extend the utility of Emacs.  I
try to prefix them with ~jf/~.  And if I cribbed those functions from
elsewhere, I attempt to give credit to the source.

* Into the Emacs

** Launching Emacs

As we get started in Emacs, I want to make sure I have the basics lined up.

- Core Configuration
- Basic Theming

*** Core Configuration

#+begin_src emacs-lisp
  (require 'jf-launching)
  (require 'jf-minor-mode-maker)
  (require 'jf-illuminating)
#+end_src


*** Basic Theming

I want to start with a basic look and feel.  First, the choice of primary font.

#+begin_src emacs-lisp
  (require 'jf-fonts-and-iconography)
  (require 'jf-windows)
#+end_src

*** Tabs

#+begin_src emacs-lisp
  ;; (org-babel-load-file
  ;;  (concat user-emacs-directory "emacs-tabs.org"))
#+end_src

** How Does this Thing Work?

In this section my goal is to load some “fundamental” packages that help me
better introspect and navigate Emacs.

With the initial “setup” out of the way, let’s dive into how things work.

I want to make it easy to find help on different aspects of Emacs.  There’s
tooling baked into Emacs, but the ~helpful~ package “provides much more
contextual information.”

Futhermore, I want to make a menu to help remind me of the help I have
available.  In previous incarnations I’ve written these menus using
[[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][pretty-hydra]], but I’ve started moving these to [[https://github.com/magit/transient/tree/440a341831398b825dc2288a10821cf7be1999ca][transient]]; a package that’s a
hard requirement for packages I’ll later introduce.

** Writing, Coding, Computering

*** Projects

- ~projectile.el~ :: this package provides convenient organization and commands to run over projects.

#+begin_src emacs-lisp
  ;; Convenient organization and commands
  (use-package projectile
    :straight t
    :diminish 'projectile-mode
    :config (projectile-mode 1)
    :custom (projectile-project-search-path '("~/git/"))
    :bind ("s-." . projectile-toggle-between-implementation-and-test))
#+end_src

/Note:/ The =CMD= + =.= is a carryover from my [[https://macromates.com][Textmate]] and [[https://www.sublimetext.com/][Sublime Text]] days.
That’s one of those hot-keys almost burned into soul.

*** Support Packages

When I start writing functions, there’s a few packages I want to consider.

- ~keychain-environment.el~ :: Load keychain environment variables

#+begin_src emacs-lisp
  ;;; Support packages

  ;; Load keychain environment
  (use-package keychain-environment
    :straight t
    :config (keychain-refresh-environment))

  ;; A modern list API for Emacs. No 'cl required.  (See https://github.com/magnars/dash.el/)
  (use-package dash :straight t)

  ;; A modern API for working with files and directories in Emacs. (See https://github.com/rejeep/f.el/)
  (use-package f :straight t)

  ;; The long lost Emacs string manipulation library.  (See https://github.com/magnars/s.el/)
  (use-package s :straight t)

  ;; “EditorConfig helps maintain consistent coding styles for multiple
  ;; developers working on the same project across various editors and IDEs.”
  ;; See https://editorconfig.org/#overview for more details.
  (use-package editorconfig
    :straight t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))

  (use-package rg
    :config (rg-enable-menu)
    ;; :init (setq ripgrep-arguments "--ignore-case")
    :straight t)
#+end_src

*** Completion

**** Emacs Adjustments for Completion

What follows is adjustments to emacs settings as they relate to completion.

#+begin_src emacs-lisp
  (use-package savehist
    :init
    (savehist-mode))
  (require 'jf-completing)
#+end_src

#+RESULTS:
: cape-ispell

**** wgrep.el

- ~wgrep.el~ ::


   I use this sequence at least once a day.

#+begin_src emacs-lisp
  ;; “Edit a grep buffer and apply those changes to the file buffer.”  In other
  ;; words, after “searching” for something, sending the results to a buffer
  ;; (via `embark-export' or such thing), you can edit that search results
  ;; buffer and propogate the changes to the locations of the elements that
  ;; matched the search.
  ;;
  ;;   1.  Call `consult-ripgrep' (via ~C-c f~) to search for something.
  ;;   2.  Call `embark-export' (via ~C-s-e~) to export to a grep buffer.
  ;;   3.  Call `wgrep-change-to-wgrep-mode' (via ~e~ or ~C-c C-p~)
  ;;   4.  Edit the grep buffer as you would anywhere else.
  ;;   5.  Save (via ~C-x C-s~) or Cancel (via ~C-c C-k~).
  (use-package wgrep
    :after (embark-consult ripgrep)
    :straight t
    :bind (:map wgrep-mode-map
		;; Added keybinding to echo Magit behavior
		("C-c C-c" . wgrep-finish-edit)
		:map grep-mode-map
		("e" . wgrep-change-to-wgrep-mode)
		:map ripgrep-search-mode-map
		("e" . wgrep-change-to-wgrep-mode)))
#+end_src

**** yasnippet.el

- ~yasnippet.el~ :: A rather convenient snippet manager.  When you create a
  snippet, it understands the mode you're in and puts the snippet in the right
  place.

#+begin_src emacs-lisp

#+end_src

*** Navigation
**** avy.el

#+begin_src emacs-lisp
  ;;; Navigation
  ;;
  ;; Pick a letter, avy finds all words with that at the beginning of it.  Narrow
  ;; results from there.
  (use-package avy
    :bind (("C-c j" . avy-goto-char))
    :straight t)

  (use-package link-hint
    :straight t
    :bind
    ("C-c l o" . link-hint-open-link)
    ("C-c l c" . link-hint-copy-link))

  (use-package imenu-list
    :custom (imenu-list-focus-after-activation t)
    (imenu-list-size 0.4)
    (imenu-list-position 'right)
    :bind ("s-4" . 'imenu-list-smart-toggle)
    :bind (:map imenu-list-major-mode-map ("o" . 'imenu-list-goto-entry))
    :straight t)
#+end_src

**** Extending the Mark

*** Display

**** highlight-indent-guides.el

#+begin_src emacs-lisp
  ;; provides column highlighting.  Useful when you start seeing too many nested
  ;; layers.
  (use-package highlight-indent-guides
    :straight t
    :custom (highlight-indent-guides-method 'character)
    (highlight-indent-guides-responsive 'top)
    :hook (prog-mode . highlight-indent-guides-mode))

  ;;  “LIN locally remaps the hl-line face to a style that is optimal for major
  ;;  modes where line selection is the primary mode of interaction.”  In
  ;;  otherwords, ~lin.el~ improves the highlighted line behavior for the
  ;;  competing contexts.
  (use-package lin
    :straight (lin :host gitlab :repo "protesilaos/lin")
    :config (lin-global-mode 1)
    (setq lin-face 'lin-blue))

  (use-package fill-column-indicator
    :straight t
    :config
    ;; :hook (prog-mode . fci-mode)
    (setq fci-rule-width 1))

  ;; Enforce rules for popups.  See https://depp.brause.cc/shackle/.


  (use-package ace-window
      :straight t
      :bind (("M-o" . ace-window)))
#+end_src

**** Folding

#+begin_src emacs-lisp
  (use-package yafolding :straight t)

  ;; A quick and useful visual queue for paranthesis.
  (use-package rainbow-delimiters
    :straight t
    :hook ((fundamental-mode) . rainbow-delimiters-mode))

  ;; Show tilde (e.g. ~\~~) on empty trailing lines.  This is a feature ported
  ;; from https://en.wikipedia.org/wiki/Vi
  (use-package vi-tilde-fringe
    :straight t
    :diminish 'vi-tilde-fringe-mode
    :config (global-vi-tilde-fringe-mode))

  ;; A little bit of visual feedback.  See https://protesilaos.com/codelog/2022-03-14-emacs-pulsar-demo/
  (use-package pulsar
    :straight (pulsar :host gitlab :repo "protesilaos/pulsar")
    :hook
    (consult-after-jump . pulsar-recenter-top)
    (consult-after-jump . pulsar-reveal-entry)
    ;; integration with the built-in `imenu':
    (imenu-after-jump . pulsar-recenter-top)
    (imenu-after-jump . pulsar-reveal-entry)
    :config
    (pulsar-global-mode 1)
    (setq pulsar-face 'pulsar-magenta
	  pulsar-delay 0.05)
    (defun jf/pulse (parg)
      "Pulse the current line.

  If PARG (given as universal prefix), pulse between `point' and `mark'."
      (interactive "P")
      (if (car parg)
	  (pulsar--pulse nil nil (point) (mark))
	(pulsar-pulse-line)))
    :bind (("C-l" . jf/pulse)))

  (use-package emojify
    :straight t
    :config
    (defun --set-emoji-font (frame)
      "Adjust the font settings of FRAME so Emacs can display emoji properly."
      (if (eq system-type 'darwin)
	  ;; For NS/Cocoa
	  (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
	;; For Linux
	(set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))

    ;; For when Emacs is started in GUI mode:
    (--set-emoji-font nil)
    ;; Hook for when a frame is created with emacsclient
    ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
    (add-hook 'after-make-frame-functions '--set-emoji-font))
#+end_src

**** DONE unicode-fonts.el

I’m uncertain why I included this, aside from “sure would be nice to have unicode fonts.”

#+begin_src emacs-lisp
  (use-package unicode-fonts
    :straight t
    :config (unicode-fonts-setup))
#+end_src

**** flymake-proselint

#+begin_src emacs-lisp
  (use-package flymake-proselint
    :straight t)

  ;; (add-hook 'text-mode-hook (lambda ()
  ;; 			    (flymake-mode)
  ;; 			    (flymake-proselint-setup)))
#+end_src

*** Modes

Emacs has the concept of modes.  Each buffer has one major mode and can have
multiple minor modes.  A major mode may derive from another major mode.

These modes impact lots of things; key bindings being one of them.

What follows are a list of modes presented in a somewhat random order.  Some
are major modes others are minor modes.

**** bundler.el

- ~bundler.el~ :: Adds the useful ~bundle-open~ command.

#+begin_src emacs-lisp
  (require 'jf-coding)
  (require 'jf-organizing)
  (require 'jf-framing)
  (require 'jf-utility)
  (require 'jf-writing)
#+end_src
*** Utilities


**** edit-indirect.el

The ~edit-indirect.el~ behaves similarly to the amazing ~org-edit-source-code~ but for any regions.  This is particularly nice for markdown “triple back-tick regions” (e.g. =```=).

#+begin_src emacs-lisp

#+end_src

**** ts.el

A timestamp library.

#+begin_src emacs-lisp
  (use-package ts
    :straight t)
#+end_src

**** Custom Dictionary

#+begin_src emacs-lisp

#+end_src

**** titlecase.el

#+begin_src emacs-lisp
  ;; The rules of “titlecase” are confounding.  The ~titlecase.el~ package
  ;; provides numerous ways to cast a string to “titlecase.”  I chose wikipedia
  ;; style as a quasi-opinionated compromise.
  (use-package titlecase
    :straight (titlecase :host github :repo "duckwork/titlecase.el")
    :custom (titlecase-style 'wikipedia))


  ;; After using Emacs for awhile, with it’s sentence navigation, I’ve come to
  ;; strongly favor two spaces after a period.  The

  ;; Write "kill" command inputs to disk.
  (use-package savekill :straight t)

  ;; Calculate math functions at point and message result in minibuffer.  See
  ;; https://github.com/shankar2k/math-at-point.
  (use-package math-at-point
      :straight (math-at-point :type git :host github :repo "shankar2k/math-at-point")
      :bind ("C-c =" . math-at-point))
#+end_src

**** Expansion Options

#+begin_src emacs-lisp
  ;; The =abbrev= package is simple and powerful, providing an auto-correct that
  ;; I configure.  No more “teh” in my text.
  (use-package abbrev
    :straight (:type built-in)
    :custom (abbrev-file-name (file-truename "~/git/dotemacs/emacs.d/abbrev_defs"))
    :hook (text-mode . abbrev-mode))

  ;; Using Hippie expand, I toggle through words already referenced.

  ;; A simple package that does two related things really well; expands and
  ;; contracts the current region.  I use this all the time.
  ;;
  ;; In writing, with the cursor at point, when I expand it selects the word.
  ;; The next expand the sentence, then paragraph, then page.  In programming it
  ;; leverages sexp.
  (use-package expand-region
    :straight t
    :bind (("C-=" . er/expand-region)
           ("C-+" . er/contract-region)))

  ;; Allow Emacs to work with multiple cursors.  See
  ;; https://melpa.org/#/multiple-cursors
  (use-package multiple-cursors
      :bind (("C-M-SPC" . set-rectangular-region-anchor)
             ("C->" . mc/mark-next-like-this)
             ("C-<" . mc/mark-previous-like-this)
             ("C-s-<mouse-1>" . mc/add-cursor-on-click)
             ("C-c C->" . mc/mark-all-like-this)
             ("C-c C-SPC" . mc/edit-lines)) ;; CTRL+CMD+c
      :straight t)

  ;; Type \"C-;\" to select current symbol and all matches; Then edit at multiple
  ;; points.
  (use-package iedit :straight t)
#+end_src

**** crux.el

#+begin_src emacs-lisp
  ;; A mix of a few odd and useful functions.
  (use-package crux
    :straight t
    :bind (("C-a" . crux-move-beginning-of-line)
	   ("<C-s-return>" . crux-smart-open-line-above)
	   ("C-s-k" . crux-kill-line-backwards)
	   ("<s-backspace>" . crux-kill-line-backwards)
	   ("<f9>" . crux-kill-other-buffers)))
#+end_src

**** ethan-wspace.el

#+begin_src emacs-lisp
  ;; Whitespace hygene package.  The author's documentation and commentary echoes
  ;; my sentiments.
  (use-package ethan-wspace
    :straight t
    :hook (before-save . delete-trailing-whitespace)
    :init (setq-default mode-require-final-newline nil)
    :config (global-ethan-wspace-mode 1))
#+end_src

**** unfill.el

#+begin_src emacs-lisp
  ;; Provides the reverse of ~fill-paragraph~, and a toggle fill and unfill.
  (use-package unfill
    :bind ("M-q" . unfill-toggle)
    :straight t)

  ;; Provides a UI for undo trees.  I'm not certain what I want to do with this.
  (use-package undo-tree
    :diminish
    :bind (("C-z" . undo)
           ("C-s-z" . undo-tree-redo))
    :config
    (setq undo-tree-enable-undo-in-region t)
    (global-undo-tree-mode +1)
    (unbind-key "M-_" undo-tree-map))

  ;; Delete multiple spaces in one delete stroke.
  (use-package hungry-delete
      :straight t
      :diminish 'hungry-delete-mode
      :config (global-hungry-delete-mode))

  ;; A simple package ability to move lines up and down.
  (use-package move-text
    :straight t
    :bind (([C-s-down] . move-text-down)
           ([C-s-up] . move-text-up)))

  (use-package string-inflection
    :straight t)

  ;; From the package commentary, “This minor mode allows functions to operate on
  ;; the current line if they would normally operate on a region and region is
  ;; currently undefined.”  I’ve used this for awhile and believe it’s not baked
  ;; into my assumptions regarding how I navigate Emacs.
  (use-package whole-line-or-region
    :straight t
    :diminish 'whole-line-or-region-local-mode
    :config (whole-line-or-region-global-mode))

  ;; provides some “intelligent” treatment of parentheses.  I’ve been using this
  ;; for awhile, so I assume it’s baked into my memory.
  (use-package smartparens :straight t)
#+end_src

**** grab-mac-link.el

#+begin_src emacs-lisp

#+end_src

*** TODO Typography

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  This package serves the purpose of assisting with adding
  ;;  characters that are not readily available on an ANSI keyboard.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; BEGIN Typography Menu
  ;;
  ;;  The purpose of the typography menu is to provide easier access to
  ;;  typographic characters that I use; It also provides a bit of a
  ;;  mnemonic device (e.g. "C-x 8 RET" searches for a character to insert).
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; (use-package pretty-hydra
  ;;     :straight (:type git :host github :repo "jerrypnz/major-mode-hydra.el"
  ;; 	       :files (:defaults (:exclude "major-mode-hydra.el"))))

  ;; (defvar jf/typography--title
  ;;   (jf/all-the-icons--with-octicon "pencil" "Typography (C-x 8 RET for Search)" 1 -0.05)
  ;;   "The menu title for typography")
  ;; (pretty-hydra-define jf/typography--menu (:foreign-keys warn :title jf/typography--title :quit-key "q" :exit t)
  ;;   ("Characters" (
  ;; 		 ("d d" (insert "-") "- dash")
  ;; 		 ("d m" (insert "—") "— em dash")
  ;; 		 ("d n" (insert "–") "– en dash")
  ;; 		 (". e" (insert "…") "… ellipsis")
  ;; 		 (". d" (insert "·") "º degree")
  ;; 		 (". m" (insert "·") "· middot")
  ;; 		 ("t d" (insert "†") "† dagger")
  ;; 		 ("t 2" (insert "‡") "‡ double dagger")
  ;; 		 ("t s" (insert "§") "§ section")
  ;; 		 ("t p" (insert "¶") "¶ paragraph")
  ;; 		 ("? !" (insert "‽") "‽ Interobang")
  ;; 		 )
  ;;    "Math" (
  ;; 	   ("a x" (insert "×") "× Multiplication Sign")
  ;; 	   ("a d" (insert "÷") "÷ Division Sign")
  ;; 	   ("a m" (insert "−") "− Minus Sign")
  ;; 	   ("a p" (insert "±") "± Plus or Minus Sign")
  ;; 	   ("m n" (insert "¬") "¬ Negation")
  ;; 	   ;; For declaring regex functions.  See
  ;; 	   ;; https://www.johndcook.com/blog/2022/01/08/corner-quotes-in-unicode/
  ;; 	   ;; and https://irreal.org/blog/?p=10265
  ;; 	   ("c l" (insert "⌜") "⌜ Left Corner Quote")
  ;; 	   ("c r" (insert " ⌟") "⌟ Right Corner Quote")
  ;; 	   ;; Included as a reminder as I use these for menu structures
  ;; 	   ("f h"   (insert "─") "─ Forms light horizontal")
  ;; 	   ("f D l" (insert "┐") "┐ Forms light down and left")
  ;; 	   ("f v"   (insert "│") "│ Forms light vertical")
  ;; 	   ("f V r" (insert "├") "├ Forms light vertical and right")
  ;; 	   ("f U r" (insert "└") "└ Forms light up and right")
  ;; 	   )
  ;;    "Quotes" (
  ;; 	     ("\" o" (insert "“") "“ Double quote open")
  ;; 	     ("\" c" (insert "”") "” Doule quote close")
  ;; 	     ("\" O" (insert "«") "« Guillemet open")
  ;; 	     ("\" C" (insert "»") "» Guillemet close")
  ;; 	     ("\" l" (insert "⌈") "⌈ Left ceiling")
  ;; 	     ("' o" (insert "‘") "‘ Single quote open")
  ;; 	     ("' c" (insert "’") "’ Single quote close")
  ;; 	     ("' O" (insert "‹") "‹ Single guillemet open")
  ;; 	     ("' C" (insert "›") "› Single guillemet close")
  ;; 	     ("p 1" (insert "′") "′ Single Prime (feet, arcminutes)")
  ;; 	     ("p 2" (insert "″") "″ Double Prime (inches, arcseconds)")
  ;; 	     ("p 3" (insert "‴") "‴ Triple Prime"))
  ;;    ))

  ;; (global-set-key (kbd "C-s-8") 'jf/typography--menu/body)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; END Typography Menu
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

**** TODO typopunct.el

#+begin_src emacs-lisp
  (use-package typopunct
    :straight t
    :config
    (add-hook 'org-mode-hook 'jf/typopunct-init)
    (defun jf/typopunct-init ()
      (require 'typopunct)
      (typopunct-change-language 'english)
      (typopunct-mode 1))
    (setq typopunct-buffer-language 'english)

    ;; To insert a typographical ellipsis sign (…) on three consecutive
    ;; dots, or a middle dot (·) on ‘^.’
    (defconst typopunct-ellipsis (decode-char 'ucs #x2026))
    (defconst typopunct-middot   (decode-char 'ucs #xB7)) ; or 2219
    (defun typopunct-insert-ellipsis-or-middot (arg)
      "Change three consecutive dots to a typographical ellipsis mark."
      (interactive "p")
      (cond
       ((and (= 1 arg)
	     (eq (char-before) ?^))
	(delete-char -1)
	(insert typopunct-middot))
       ((and (= 1 arg)
	     (eq this-command last-command)
	     (looking-back "\\.\\." 1))
	(replace-match "")
	(insert typopunct-ellipsis))
       (t
	(self-insert-command arg))))
    (define-key typopunct-map "." 'typopunct-insert-ellipsis-or-middot)


    (defconst typopunct-prime  (decode-char 'ucs #x2032)) ; feet, arcminutes, derivatives
    (defconst typopunct-dprime (decode-char 'ucs #x2033)) ; inches, arcseconds, double derivatives
    (defconst typopunct-tprime (decode-char 'ucs #x2034))

    ;; The minus sign (−) is separate from the hyphen (-), en dash (–) and
    ;; em dash (—). To build upon the clever behavior of the ‘-’ key
    (defconst typopunct-minus (decode-char 'ucs #x2212))
    (defconst typopunct-pm    (decode-char 'ucs #xB1))
    (defconst typopunct-mp    (decode-char 'ucs #x2213))
    (defadvice typopunct-insert-typographical-dashes
	(around minus-or-pm activate)
      (cond
       ((or (eq (char-before) typopunct-em-dash)
	    (looking-back "\\([[:blank:]]\\|^\\)\\^" 2))
	(delete-char -1)
	(insert typopunct-minus))
       ((looking-back "[^[:blank:]]\\^" 1)
	(insert typopunct-minus))
       ((looking-back "+/" 1)
	(progn (replace-match "")
	       (insert typopunct-pm)))
       (t ad-do-it)))
    (defun typopunct-insert-mp (arg)
      (interactive "p")
      (if (and (= 1 arg) (looking-back "-/" 2))
	  (progn (replace-match "")
		 (insert typopunct-mp))
	(self-insert-command arg)))
    (define-key typopunct-map "+" 'typopunct-insert-mp)
    (defconst typopunct-times (decode-char 'ucs #xD7))
    (defun typopunct-insert-times (arg)
      "Insert multiplication sign at ARG."
      (interactive "p")
      (if (and (= 1 arg) (looking-back "\\([[:blank:]]\\|^\\)\\^"))
	  (progn (delete-char -1)
		 (insert typopunct-times))
	(self-insert-command arg)))
    (define-key typopunct-map "x" 'typopunct-insert-times)

    (defadvice typopunct-insert-quotation-mark (around wrap-region activate)
      (let* ((lang (or (get-text-property (point) 'typopunct-language)
		       typopunct-buffer-language))
	     (omark (if single
			(typopunct-opening-single-quotation-mark lang)
		      (typopunct-opening-quotation-mark lang)))
	     (qmark (if single
			(typopunct-closing-single-quotation-mark lang)
		      (typopunct-closing-quotation-mark lang))))
	(cond
	 (mark-active
	  (let ((skeleton-end-newline nil)
		(singleo (typopunct-opening-single-quotation-mark lang))
		(singleq (typopunct-closing-single-quotation-mark lang)))
	    (if (> (point) (mark))
		(exchange-point-and-mark))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string omark)) (mark) t)
		(replace-match (regexp-quote (string singleo)) nil nil)))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string qmark)) (mark) t)
		(replace-match (regexp-quote (string singleq)) nil nil)))
	    (skeleton-insert (list nil omark '_ qmark) -1)))
	 ((looking-at (regexp-opt (list (string omark) (string qmark))))
	  (forward-char 1))
	 (t ad-do-it)))))
#+end_src

** Integrated “Applications”

*** Variable and Constant Definitions

These are a few variables and cosntants that I use throughout my configuration.

#+begin_src emacs-lisp
  (defconst jf/tor-home-directory
    (file-truename "~/git/takeonrules.source")
    "The home directory of TakeOnRules.com Hugo repository.")

  (defconst jf/tor-hostname-default-local
    "http://localhost:1313"
    "The scheme, host name, and port for serving up a local TakeOnRules.com.")

  (defconst jf/tor-hostname-default-remote
    "https://takeonrules.com"
    "The scheme and host name for TakeOnRules.com.")

  (defvar jf/tor-hostname-current
    jf/tor-hostname-default-local
    "What is the current hostname for serving TakeOnRules content.")
#+end_src

*** Doc View

#+begin_src emacs-lisp
  (use-package doc-view
    :straight (doc-view :type built-in)
    :bind (:map doc-view-mode-map
                ("C-c g" . doc-view-goto-page)))
#+end_src

*** Mastodon

#+begin_src emacs-lisp
  (require 'jf-communicating)
#+end_src

*** Knowledge Management

I use org-mode and org-roam to help manage content.  Let’s load that rather extensive configuration.

#+begin_src emacs-lisp
  (require 'jf-org-mode)
  (require 'jf-denote)
#+end_src

*** org-d20.el

#+begin_src emacs-lisp
  ;; I’m really only using this for the ~org-d20--roll~ function.
  (use-package org-d20
    :after org
    :bind  (("C-s-r" . jf/roll-expression-dwim))
    :config
    (defun jf/roll-expression-dwim (expression &optional)
      "Roll the EXPRESSION, check `thing-at-point' then prompt."
      (interactive (list (if (string-match
			      "[dD][0-9]"
			      (format "%s" (thing-at-point 'sexp t)))
			     (thing-at-point 'sexp t)
			   (read-string "Dice Expression: "))))
      (-let* (((rolls . result) (org-d20--roll expression)))
	(message "%s => %s" expression result)))
    :straight (org-d20 :host github :repo "spwhitton/org-d20"))
#+end_src

*** RSS Feed

**** elfeed.el

#+begin_src emacs-lisp
  ;; An Emacs RSS reader.  I’ve used Google Reader, Feedly, Inoreader, and
  ;; Newsboat.  I wrote about
  ;; https://takeonrules.com/2020/04/12/switching-from-inoreader-to-newsboat-for-rss-reader/,
  ;; and the principles apply for Elfeed.
  (use-package elfeed
    :straight t
    :after org
    :hook ((elfeed-show-mode . jf/reader-visual))
    :config
    (setq-default elfeed-search-filter "@2-days-ago +unread ")
    :bind ((:map elfeed-search-mode-map
		 ("q" . jf/elfeed-save-db-and-bury))))

  ;;write to disk when quiting
  (defun jf/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))

  (defun jf/elfeed-load-db-and-open ()
    "Load the elfeed db from disk before opening"
    (interactive)
    (elfeed)
    (elfeed-update)
    (elfeed-db-load)
    (elfeed-search-update--force))
  (defalias 'rss 'jf/elfeed-load-db-and-open)

    ;; From https://karthinks.com/blog/lazy-elfeed/
  (defun elfeed-search-show-entry-pre (&optional lines)
    "Returns a function to scroll forward or back in the Elfeed
    search results, displaying entries without switching to them."
    (lambda (times)
      (interactive "p")
      (forward-line (* times (or lines 0)))
      (recenter)
      (call-interactively #'elfeed-search-show-entry)
      (select-window (previous-window))
      (unless elfeed-search-remain-on-entry (forward-line -1))))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "n") (elfeed-search-show-entry-pre +1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "p") (elfeed-search-show-entry-pre -1)))
  (eval-after-load 'elfeed-search
    '(define-key elfeed-search-mode-map (kbd "M-RET") (elfeed-search-show-entry-pre)))
  ;; End https://karthinks.com/blog/lazy-elfeed/

  ;; Maintaining my RSS subscriptions in `org-mode' format.
  (use-package elfeed-org
    :straight t
    :after elfeed
    :config (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/git/org/elfeed.org")))
#+end_src

*** Source Control

#+begin_src emacs-lisp
  (use-package git-modes :straight t)
  (use-package magit
    :straight t
    :commands (magit-process-git)
    :init (use-package with-editor :straight t)

    ;; Adding format to git-commit-fill-column of 72 as best practice.
    (setq git-commit-fill-column 72)

    ;; Keeping the summary terse helps with legibility when you run a
    ;; report with only summary.
    (setq git-commit-summary-max-length 50)

    ;; Set the tabular display columns for the `magit-list-repositories'
    (setq magit-repolist-columns
	  '(("Name"    25 magit-repolist-column-ident ())
	    ("Version" 25 magit-repolist-column-version ())
	    ("δ"        1 magit-repolist-column-dirty ())
	    ("⇣"        3 magit-repolist-column-unpulled-from-upstream
	     ((:right-align t)
	      (:help-echo "Upstream changes not in branch")))
	    ("⇡"        3 magit-repolist-column-unpushed-to-upstream
	     ((:right-align t)
	      (:help-echo "Local changes not in upstream")))
	    ("Branch"  25 magit-repolist-column-branch ())
	    ("Path"    99 magit-repolist-column-path ())))

    ;; The default relevant `magit-list-repositories'
    (setq magit-repository-directories
	  `(("~/git/takeonrules.source/" . 1)
	    ("~/git/burning_wheel_lifepaths/" . 1)
	    ("~/git/dotzshrc/" .  1)
	    ("~/git/dotemacs/" . 1)
	    ("~/git/emacs-bookmarks/" . 1)
	    ("~/git/org" . 1)
	    ("~/git/org/archive" . 1)
	    ("~/git/takeonrules.source/themes/hugo-tufte" . 1)))

    ;; Have magit-status go full screen and quit to previous
    ;; configuration.  Taken from
    ;; http://whattheemacsd.com/setup-magit.el-01.html#comment-748135498
    ;; and http://irreal.org/blog/?p=2253
    ;; (defadvice magit-status (around magit-fullscreen activate)
    ;;   (window-configuration-to-register :magit-fullscreen)
    ;;   ad-do-it
    ;;   (delete-other-windows))
    ;; (defadvice magit-mode-quit-window (after magit-restore-screen activate)
    ;;   (jump-to-register :magit-fullscreen))
    :config
    ;; (use-package libgit :straight t)
    (remove-hook 'magit-status-sections-hook 'magit-insert-tags-header)
    (defun jf/magit-browse-pull-request ()
      "In `magit-log-mode' open the associated pull request
    at point.

    Assumes that the commit log title ends in the PR #, which
    is the case when you use the Squash and Merge strategy.

    This implementation is dependent on `magit' and `s'."
      (interactive)
      (let* ((beg (line-beginning-position))
	     (end (line-end-position))
	     (summary
	      (buffer-substring-no-properties
	       beg end)))
	(jf/open-pull-request-for :summary summary)))
    (defun jf/git-current-remote-url ()
      "Get the current remote url."
      (s-trim
       (shell-command-to-string
	(concat
	 "git remote get-url "
	 (format "%s" (magit-get-current-remote))))))
    (cl-defun jf/open-pull-request-for (&key summary)
      "Given the SUMMARY open the related pull request.

    This method assumes you're using Github's Squash and Strategy."
      (let ((remote-url (jf/git-current-remote-url)))
	(save-match-data
	  (and (string-match "(\\#\\([0-9]+\\))$" summary)
	       (browse-url
		(concat
		 ;; I tend to favor HTTPS and the repos end in ".git"
		 (s-replace ".git" "" remote-url)
		 "/pull/"
		 (match-string 1 summary)))))))
    (defun jf/open-pull-request-for-current-line ()
      "For the current line open the applicable pull request."
      (interactive)
      (let ((summary
	     (s-trim
	      (shell-command-to-string
	       (concat "git --no-pager annotate "
		       "-w -L "
		       (format "%s" (line-number-at-pos))
		       ",+1 "
		       "--porcelain "
		       buffer-file-name
		       " | rg \"^summary\"")))))
	(jf/open-pull-request-for :summary summary)))
    :bind (("s-7" . magit-status)
	   ("C-x g f" . magit-file-dispatch)
	   ("C-x g d" . magit-dispatch))
    ;; In other situations I bind s-6 to `git-messenger:popup-message'
    :bind (:map magit-log-mode-map ("s-6" . 'jf/magit-browse-pull-request))
    :hook ((with-editor-post-finish-hook . magit-status)))

  ;; COMMENTED OUT FOR FUTURE REFERENCE
  ;; (transient-define-prefix jf/magit-aux-commands ()
  ;;   "My personal auxiliary magit commands."
  ;;   ["Auxiliary commands"
  ;;    ("d" "Difftastic Diff (dwim)" jf/magit-diff-with-difftastic)
  ;;    ("s" "Difftastic Show" jf/magit-show-with-difftastic)])

  ;; (require 'magit)
  ;; (transient-append-suffix 'magit-dispatch "!"
  ;;   '("#" "My Magit Cmds" jf/magit-aux-commands))

  ;; (define-key magit-status-mode-map (kbd "#") #'jf/magit-aux-commands)

  ;; With the time machine, travel back and forth through a files history.
  (use-package git-timemachine
    :straight (:host github :repo "emacsmirror/git-timemachine"))

  ;; Show the current git state in the gutter.  As you edit a line in a file
  ;; track by git, the indicators change to reflect if this is a modification,
  ;; addition, or deletion.
  (use-package git-gutter
    :straight t
    :diminish 'git-gutter-mode
    :custom (git-gutter:update-interval 0.25)
    :bind ("C-x g =" . git-gutter:popup-hunk)
    ("C-x g p" . git-gutter:previous-hunk)
    ("C-x g n" . git-gutter:next-hunk)
    :init (global-git-gutter-mode t)
    (setq git-gutter:modified-sign "Δ"
	  git-gutter:added-sign "+"
	  git-gutter:deleted-sign "-"))

  ;; Type ~M-x git-link~ and the function pushes the Git forge URL to the kill
  ;; ring; I’ve configured the URL to use the SHA of the commit of the line on
  ;; which I called `git-link'.  This is helpful for sharing links with other
  ;; folks.  I use this /all of the time./ See https://github.com/sshaw/git-link.
  (use-package git-link
    :config
    (defun jf/git-browse-to-repository (remote)
      "Open in external browser the current repository's given REMOTE."
      (interactive (list (git-link--select-remote)))
      (git-link-homepage remote)
      (browse-url (car kill-ring)))
    (setq git-link-use-commit t) ;; URL will be SHA instead of branch
    :straight t)

  ;; Sometimes I want to see more ~git~ information regarding the current line.
  ;; `git-messenger' provides a popup that shows the information and provides
  ;; some additional options.
  (use-package git-messenger
    :config (setq git-messenger:show-detail t)
    (defun jf/git-messenger-popup ()
      "Open `git-messenger' or github PR.

    With universal argument, open the github PR for current line.

    Without universal argument, open `git-messenger'."
      (interactive)
      (if (equal current-prefix-arg nil) ; no C-u
	  (git-messenger:popup-message)
	(jf/open-pull-request-for-current-line)))
    :custom
    (git-messenger:use-magit-popup t)
    :bind (:map git-messenger-map (("p" . 'jf/open-pull-request-for-current-line)
				   ("l" . 'git-link)))
    :bind (("s-6" . jf/git-messenger-popup)
	   ("<f6>" . jf/git-messenger-popup))
    :straight t)

  ;; When working in code, I want different ways to view the metadata around the
  ;; code.  This adds a quick annotation to the current line; When did the last
  ;; person touch this and what was the message.  It's most useful aspect is
  ;; seeing multiple lines without relying on the blame.
  (use-package blamer
    :straight (blamer :host github :repo "Artawower/blamer.el")
    :custom
    ;; Set to 0 because I don’t enable by default.  So I’m in a mindset of show
    ;; me who and when.
    (blamer-idle-time 0.0)
    (blamer-author-formatter "✎ %s ")
    (blamer-datetime-formatter "[%s] ")
    (blamer-commit-formatter "● %s")
    (blamer-min-offset 40)
    (blamer-max-commit-message-length 20))
#+end_src

*** tmr.el

#+begin_src emacs-lisp
  ;; Set some timers.
  (use-package tmr
    ;; My dbus install is not behaving so I'm cheating with a bit of AppleScript
    :config (defun jf/tmr-notification-notify (timer)
	      "Dispatch a notification for TIMER."
	      (let ((title "TMR May Ring (Emacs tmr package)")
		    (description (tmr--timer-description timer)))
		(ns-do-applescript (concat "display notification \"" description "\" sound name \"Glass\""))))
    :custom (tmr-notify-function #'jf/notifications-notify)
    (tmr-timer-completed-functions
     (list #'tmr-print-message-for-completed-timer
	   #'tmr-sound-play
	   #'jf/tmr-notification-notify))
    :straight (tmr :host nil :type git :repo "https://git.sr.ht/~protesilaos/tmr"))
#+end_src


*** EWW

#+begin_src emacs-lisp
  ;; A plain text browser.  Use this to see just how bad much of the web has become.
  (use-package eww
    :straight t
    :config
    (defun shr-tag-dfn (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-cite (dom)
      (shr-fontize-dom dom 'italic))

    (defun shr-tag-q (dom)
      (shr-insert (car shr-around-q-tag))
      (shr-generic dom)
      (shr-insert (cdr shr-around-q-tag)))

    (defcustom shr-around-q-tag '("“" . "”")
      "The before and after quotes.  `car' is inserted before the Q-tag and `cdr' is inserted after the Q-tag.

  Alternative suggestions are: - '(\"\\\"“\" . \"\\\"\")"
      :type (cons 'string 'string))

    (defface shr-small
      '((t :height 0.8))
      "Face for <small> elements.")

    ;; Drawing inspiration from shr-tag-h1
    (defun shr-tag-small (dom)
      (shr-fontize-dom dom (when shr-use-fonts 'shr-small)))

    (defface shr-time
      '((t :inherit underline :underline (:style wave)))
      "Face for <time> elements.")

    ;; Drawing inspiration from shr-tag-abbr
    (defun shr-tag-time (dom)
      (when-let* ((datetime (or
			     (dom-attr dom 'title)
			     (dom-attr dom 'datetime)))
		  (start (point)))
	(shr-generic dom)
	(shr-add-font start (point) 'shr-time)
	(add-text-properties
	 start (point)
	 (list
	  'help-echo datetime
	  'mouse-face 'highlight))))


    ;; EWW lacks a style for article
    (defun shr-tag-article (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    ;; EWW lacks a style for section; This is quite provisional
    (defun shr-tag-section (dom)
      (shr-ensure-paragraph)
      (shr-generic dom)
      (shr-ensure-paragraph))

    (setq browse-url-browser-function 'browse-url-default-macosx-browser)
    :bind (:map eww-mode-map ("U" . eww-up-url))
    :bind (("C-s-w" . browse-url-at-point))
    :hook ((eww-mode . jf/reader-visual)))

  (use-package vterm
    :straight t)
#+end_src

*** Random Tables

Let’s add some [[file:random-tables.org][Random Table tooling]].

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "random-tables.org"))
#+end_src

*** Hammerspoon

Hammerspoon is Lua application that provides a consistent API for interacting
with MacOS.  The editWithEmacs.spoon allows me to copy text from one region,
edit it in Emacs, and paste it back into the Application.

#+begin_src emacs-lisp
  (when (file-directory-p
	 "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon")
    (load
     "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el"
     nil
     jf/silence-loading-log))
#+end_src

** Connective Tissue and Oddities

*** Functions

The following chunk of allows me to take multiple filenames passed via the
emacsclient and open those files in windows within the same frame.

You can see this in my [[https://codeberg.org/takeonrules/dotzshrc/src/branch/main/bin/git-edit][git-edit]] command line tool.

#+begin_src emacs-lisp
  ;;; Connective Tissue and oddity functions:
  (defvar server-visit-files-custom-find:buffer-count
    "A counter for assisting with opening multiple files via a single
    client call.")
  (defadvice server-visit-files
      (around server-visit-files-custom-find
	      activate compile)
    "Maintain a counter of visited files from a single client call."
    (let ((server-visit-files-custom-find:buffer-count 0))
      ad-do-it))
  (defun server-visit-hook-custom-find ()
    "Arrange to visit the files from a client call in separate windows."
    (if (zerop server-visit-files-custom-find:buffer-count)
	(progn
	  (delete-other-windows)
	  (switch-to-buffer (current-buffer)))
      (let ((buffer (current-buffer))
	    (window (split-window-sensibly)))
	(switch-to-buffer buffer)
	(balance-windows)))
    (setq server-visit-files-custom-find:buffer-count
	  (1+ server-visit-files-custom-find:buffer-count)))
  (add-hook 'server-visit-hook 'server-visit-hook-custom-find)

  ;; The following function facilitates a best of both worlds.  By default, I
  ;; want Option to be Meta (e.g. \"M-\") in Emacs.  However, I can toggle that
  ;; setting.  That way if I need an umlaut (e.g., \"¨\"), I can use MacOS’s
  ;; native functions to type \"⌥\" + \"u\".
  ;;
  ;; I like having MacOS’s native Option (e.g. =⌥=) modifier available.  But
  ;; using that default in Emacs would be a significant hinderance.
  (defun jf/toggle-osx-alternate-modifier ()
    "Toggle native OS-X Option modifier setting (e.g. `ns-alternate-modifier')."
    (interactive)
    (if ns-alternate-modifier
	(progn (setq ns-alternate-modifier nil)
	       (message "Enabling OS X native Option modifier"))
      (progn (setq ns-alternate-modifier 'meta)
	     (message "Disabling OX X native Option modifier (e.g. Option as Meta)"))))

  ;; I try to get quick feedback when writing emacs-lisp; the
  ;; `jf/eval-region-dwim' binds a mnemonic key sequence to an extend
  ;; `eval-region'.
  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'jf/eval-region-dwim)
  (defun jf/eval-region-dwim ()
    "When region is active, evaluate it and kill the mark. Else,
      evaluate the whole buffer."
    (interactive)
    (if (not (region-active-p))
	(progn
	  (message "Evaluating buffer...")
	  (eval-buffer))
      (progn
	(message "Evaluating region...")
	(eval-region (region-beginning) (region-end)))
      (setq-local deactivate-mark t)))

  ;; A little bit of RSS beautification.
  (defun jf/reader-visual ()
    "A method to turn on visual line mode and adjust text scale."
    (text-scale-set 2)
    (turn-on-visual-line-mode))

  ;; See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/
  (global-set-key (kbd "M-n") 'jf/scroll-down-half-page)
  (defun jf/scroll-down-half-page ()
    "Scroll down half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) (move-to-window-line nil))
	    ((= ln lmax) (recenter (window-end)))
	    (t (progn
		 (move-to-window-line -1)
		 (recenter))))))

  ;; See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/
  (global-set-key (kbd "M-p") 'jf/scroll-up-half-page)
  (defun jf/scroll-up-half-page ()
    "Scroll up half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) nil)
	    ((= ln lmax) (move-to-window-line nil))
	    (t (progn
		 (move-to-window-line 0)
		 (recenter))))))
#+end_src

#+begin_src emacs-lisp
  ;; Insert an active timestamp, with a few options.
  (global-set-key (kbd "s-5") 'jf/org-insert-immediate-active-timestamp)
  (defun jf/org-insert-immediate-active-timestamp (parg)
    "Insert an active date for today.

  One universal arg (e.g., prefix call with C-u) inserts timestamp.
  Two universal arsg (e.g., prefix call with C-u C-u) prompts for date then insertes active date."
    (interactive "P")
    (let ((prefix (car parg)))
      (cond
       ((not prefix)  (org-insert-time-stamp nil nil nil))
       ((= prefix 4)  (org-insert-time-stamp nil t nil))
       ((= prefix 16) (org-insert-time-stamp (org-read-date nil t nil "Date") nil nil)))))

  (global-set-key (kbd "C-w") 'jf/delete-region-or-backward-word)
  (global-set-key (kbd "M-DEL") 'jf/delete-region-or-backward-word)
  (global-set-key (kbd "<C-M-backspace>") 'backward-kill-paragraph)
  (defun jf/delete-region-or-backward-word (&optional arg)
    "Delete selected region otherwise delete backwards the ARG number of words."
    (interactive "p")
    (if (region-active-p)
	(delete-region (region-beginning) (region-end))
      (sp-backward-delete-word arg)))

  ;; Wedding two methods together: `kill-region' and `kill-line'.
  (global-set-key (kbd "C-k") 'jf/kill-line-or-region)
  (defun jf/kill-line-or-region (&optional parg)
    "Kill the selected region otherwise kill the PARG number of lines."
    (interactive "P")
    (if (use-region-p)
	(kill-region (region-beginning) (region-end))
      (kill-line parg)))

  ;; There are plenty of times where I want the file name.  This command helps me
  ;; get either it’s full path, or it’s base name.
  (global-set-key (kbd "C-c n") 'jf/nab-file-name-to-clipboard)
  (defun jf/nab-file-name-to-clipboard (parg)
    "Nab, I mean copy, the current buffer file name to the clipboard.

  The PARG is the universal prefix argument.

  If you pass no args, copy the filename with full path.
  If you pass one arg, copy the filename without path.
  If you pass two args, copy the path to the directory of the file."
    ;; https://blog.sumtypeofway.com/posts/emacs-config.html
    (interactive "P")
    (let* ((prefix (car parg))
	   (raw-filename
	    (if (equal major-mode 'dired-mode) default-directory (buffer-file-name)))
	   (filename
	    (cond
	     ((not prefix)  raw-filename)
	     ((= prefix 4)  (file-name-nondirectory raw-filename))
	     ((= prefix 16) (file-name-directory raw-filename)))))
      (when filename
	(kill-new filename)
	(message "Copied buffer file name '%s' to the clipboard." filename))))

  ;; A simple combination of two functions `sort-lines'
  ;; and `delete-duplicate-lines'.
  (defun jf/sort-unique-lines (reverse beg end &optional adjacent keep-blanks interactive)
    "Sort lines and delete duplicates.

  By default the sort is lexigraphically ascending.  To sort as
  descending set REVERSE to non-nil.  Specify BEG and END for the
  bounds of sorting.  By default, this is the selected region.

  I've included ADJACENT, KEEP-BLANKS, and INTERACTIVE so I can
  echo the method signature of `'delete-duplicate-lines`"
    (interactive "P\nr")
    (sort-lines reverse beg end)
    (delete-duplicate-lines beg end reverse adjacent keep-blanks interactive))

  ;; Creates a sticky side window.  Sometimes this is just the right thing for
  ;; reviewing files.  I don’t know when I need it, but when I use it I’m always
  ;; thankful I have it.
  (global-set-key (kbd "C-s-\\") 'jf/display-dedicated-buffer-in-side-window)
  (cl-defun jf/display-dedicated-buffer-in-side-window (&key (buffer (current-buffer)))
    "Display the given BUFFER in a dedicated sidebar."
    (interactive)
    (with-current-buffer buffer
      (jf/sidebar--build
       :buffer-name (concat "*Sidebar*")
       :position (point)
       :read-only t
       :body (buffer-string)
       :mode major-mode)))

  (cl-defun jf/sidebar--build (&key buffer-name body (read-only nil) (position nil) (mode nil))
    "Build the sidebar from the given buffer attributes.

  Create the BUFFER_NAME with the given BODY and move to the given
  POSITION and toggle on the MODE.  Then set the buffer to READ_ONLY."
    (interactive)
    (get-buffer-create buffer-name)
    (with-current-buffer buffer-name
      (insert body)
      (goto-char (or position (point-min)))
      (not-modified)
      (if mode (funcall mode) (special-mode))
      (when read-only
	(progn (read-only-mode) (local-set-key (kbd "s-w") 'kill-buffer-and-window)))
      (let ((display-buffer-mark-dedicated t))
	(pop-to-buffer buffer-name '((display-buffer-in-side-window)
				     (side . right)
				     (window-width 72)
				     (window-parameters
				      (tab-line-format . none)
				      (mode-line-format . none)
				      (no-delete-other-windows . t))))
	(message "Created *Sidebar*\nq - Remove Window")
	(require 'pulsar)
	(pulsar-pulse-line))))

  ;; Sometimes I want to move, without renaming, a file.  This function helps
  ;; make that easy.
  (global-set-key (kbd "C-x m") 'jf/move-file)
  (defun jf/move-file (target-directory)
    "Write this file to TARGET-DIRECTORY, and delete old one."
    (interactive "DTarget Directory: ")
    (let* ((source (expand-file-name (file-name-nondirectory (buffer-name)) default-directory))
	   (target (f-join target-directory (file-name-nondirectory (buffer-name)))))
      (save-buffer)
      (rename-file source target)
      (kill-current-buffer)))

  ;; From http://mbork.pl/2022-05-23_Copying_code_snippets
  (defun jf/copy-snippet-deindented (begin end)
    "Copy region, between BEGIN and END, untabifying and removing indentation."
    (interactive "r")
    (let ((orig-tab-width tab-width)
	  (region (buffer-substring-no-properties begin end)))
      (with-temp-buffer
	(setq tab-width orig-tab-width)
	(insert region)
	(untabify (point-min) (point-max))
	(org-do-remove-indentation)
	(kill-new (buffer-string)))))

  ;; Sometimes I just want to duplicate an area without copy and paste.  This
  ;; helps that process.  It’s not as smart as TextMate’s equivalent function,
  ;; but it’s close enough.
  (global-set-key (kbd "C-M-d") 'jf/duplicate-current-line-or-lines-of-region)
  (global-set-key (kbd "C-c d") 'jf/duplicate-current-line-or-lines-of-region)
  (defun jf/duplicate-current-line-or-lines-of-region (parg)
    "Duplicate ARG times current line or the lines of the current region."
    (interactive "p")
    (if (use-region-p)
	(progn
	  (when (> (point) (mark))
	    (exchange-point-and-mark))
	  (beginning-of-line)
	  (exchange-point-and-mark)
	  (end-of-line)
	  (goto-char (+ (point) 1))
	  (exchange-point-and-mark)
	  (let* ((end (mark))
		 (beg (point))
		 (region
		  (buffer-substring-no-properties beg end)))
	    (dotimes (_i parg)
	      (goto-char end)
	      (insert region)
	      (setq end (point)))))
      (crux-duplicate-current-line-or-region parg)))

  ;; A simple wrapper around scratch, that helps name it and sets the major mode
  ;; to `org-mode'.
  (global-set-key (kbd "<f12>") 'jf/create-scratch-buffer)
  (cl-defun jf/create-scratch-buffer (&key (mode 'org-mode))
    "Quickly open a scratch buffer and enable the given MODE."
    (interactive)
    (crux-create-scratch-buffer)
    (rename-buffer (concat "*scratch* at " (format-time-string "%Y-%m-%d %H:%M")))
    (funcall mode))
#+end_src


*** TODO Blogging Functions


#+begin_src emacs-lisp
  (org-babel-load-file
     (concat user-emacs-directory "takeonrules.org"))
#+end_src

#+begin_src emacs-lisp
  (require 'jf-quick-help)
#+end_src

*** Keyboard Macros

#+begin_src emacs-lisp
  (org-babel-load-file
     (concat user-emacs-directory "keyboard-macros-config.org"))
#+end_src

*** Minor Modes

In work and in play, there are several “me” specific contexts.  The
~jf/minor-mode-maker~ macro helps me quickly and consistently make those
contexual minor modes.  My intention is to build out even more functions on
those modes.


** Burning Wheel

I wrote [[file:burning-wheel-emacs-config.org][some tooling to help while playing Burning Wheel]].

#+begin_src emacs-lisp
  (require 'jf-gaming)
#+end_src

** Utility Functions

#+begin_src emacs-lisp
  (org-babel-load-file
   (concat user-emacs-directory "utility-functions.org"))
#+end_src

** Crafting Menus to Help Organize

I use Emacs for software development, knowledge management, blogging, and just
about whatever else I can.  And as I wrote in [[*Knowledge Management][Knowledge Management]], I try to
provide guidance when working within those contexts.

As I wrote earlier, I’ve settled on transient as my “menu creation” tool.  I am
thankful to the author of [[https://www.reddit.com/r/emacs/comments/m518xh/transient_api_example_alternative_bindings_part_1/][Transient API Example (Alternative Bindings Part 1) :
emacs]], as they helped me understand what is a relatively straight forward
system.

I’ll explain the language just a bit.  We have a prefix, infix, and suffix.
The prefix is what you start doing, the infix is modifications/adjustments,
before you finally invoke the suffix to “complete” the sequence.  A prefix and
a suffix are emacs-lisp functions, and transient provides a macro to make more
composable prefixes and suffixes.

I already introduced a simple transient prefix in the helpful package.  I want
to write some transient suffixes to.  As you’ll see later, you don’t need to
use the ~transient-define-suffix~ for adding a function to a transient prefix,
but a suffix can provide a description.

#+begin_src emacs-lisp
  ;; this suffix provides a dynamic description of the current major mode for a
  ;; `hammerspoon-edit-minor-mode' buffer.  And the prefix’s function toggles
  ;; that mode.
  (transient-define-suffix jf/hammerspoon-toggle-mode ()
    "Set the hammerspoon mode"
    :description '(lambda ()
		    (concat
		     "Hammerspoon Mode: "
		     (propertize
		      (format "%s" major-mode)
		      'face 'transient-argument)))
    (interactive)
    (hammerspoon-toggle-mode))

  ;; this suffix provides a dynamic description of the current host I want to use
  ;; for my blog.  And the prefix’s function toggles the host.
  (transient-define-suffix jf/tor-hostname-current-toggle (hostname)
    "Set `jf/tor-hostname-current' to HOSTNAME."
    :description '(lambda ()
		    (concat "Host: "
			    (propertize
			     (format "%s" jf/tor-hostname-current)
			     'face 'transient-argument)))
    (interactive (list (completing-read
			"Host: " (list
				  (list jf/tor-hostname-default-local 1)
				  (list jf/tor-hostname-default-remote 2)
				  ))))
    (setq jf/tor-hostname-current hostname))

  (transient-define-prefix jf/menu--tor ()
    "My Take on Rules menu; useful when developing my blog."
    ["Take on Rules"
     ["Host"
      ("-h" jf/tor-hostname-current-toggle :transient t)
      ]]
    [["Posts"
      :if-non-nil jf/tor-minor-mode
      ("p r" "Re-title post…" jf/tor-retitle-post)
      ("p t" "Tag post…" jf/tor-tag-post :transient t)
      ("p v" "View post…" jf/tor-view-blog-post)
      ]
     ["Find"
      ("f d" "in draft status…" jf/tor-find-file-draft)
      ("f u" "by url…" jf/tor-find-hugo-file-by-url)
      ("f f" "by filename…" jf/tor-find-file)]
     ["Create"
      ("c a" "Amplify the Blogosphere…" jf/tor-post-amplifying-the-blogosphere)
      ("c c" "Changelog entry…" jf/tor-find-changelog-and-insert-entry)
      ("c e" "Epigraph entry…" jf/tor-insert-epigraph-entry)
      ("c g" "Glossary entry…" jf/tor-find-glossary-and-insert-entry)
      ("c p" "Post…" jf/tor-create-post)
      ("c s" "Series…" jf/tor-find-series-and-insert-entry)]
     ])

  (global-set-key (kbd "s-1") 'jf/menu)
  (transient-define-prefix jf/menu ()
    "A context specific \"mega\" menu."
    ;; Todo, can I get this section into a function so I can duplicate it in the jf/menu--tor?
    [["Markdown Utilities"
      ("k h" "Kill slug version of given heading…" jf/kill-new-markdown-heading-as-slug :if-derived (or markdown-mode html-mode))
      ("w a" "A-tag at point or region…" jf/tor-wrap-link-active-region-dwim  :if-derived (or markdown-mode html-mode))
      ("w c" "CITE-tag point or region…" jf/tor-wrap-cite-active-region-dwim  :if-derived (or markdown-mode html-mode))
      ("w d" "DATETIME-tag point or region…" jf/tor-wrap-date  :if-derived (or markdown-mode html-mode))
      ("w f" "Wrap word or region in pseudo-DFN…" jf/tor-wrap-as-pseudo-dfn  :if-derived (or markdown-mode html-mode))
      ]
     [
      "" ;; Deliberate space for menu
      ("w m" "Margin-note line or region…" jf/tor-wrap-as-marginnote-dwim  :if-derived (or markdown-mode html-mode))
      ("w p" "Wrap point or region as Poem…" jf/tor-wrap-in-poem  :if-derived (or markdown-mode html-mode))
      ("w s" "Side-note sentence or region…" jf/tor-wrap-as-sidenote-dwim  :if-derived (or markdown-mode html-mode))
      ("w w" "Wrap point or region in html…" jf/tor-wrap-in-html-tag  :if-derived (or markdown-mode html-mode))
      ]]
    [["Contexts"
      ("-b" "Burning Wheel…"  jf/menu--bwg)
      ("-e" "Eberron…" jf/menu--eberron)
      ;; ("-f" "Forem…" jf/menu--forem)
      ("-t" "TakeOnRules…" jf/menu--tor)
      ("-w" "Register window configuration" window-configuration-to-register)
      ]
     ["Jump to"
      ("j a" "Agenda" jf/jump-to-agenda-or-mark)
      ("j b" "iBuffer" ibuffer)
      ("j g" "Global Mark" consult-global-mark)
      ("j h" "Hugo File" jf/jump_to_corresponding_hugo_file :if-derived org-mode)
      ("j m" "Mark" consult-mark)
      ("j o" "Org File" jf/jump_to_corresponding_org_file :if-non-nil jf/tor-minor-mode)
      ("j p" "Jump in PDF" doc-view-goto-page :if-derived doc-view-mode)
      ("j s" "Jump to Shortdoc" shortdoc-display-group)
      ]
     ["Modes"
      ("C-n" "MacOS Night Shift" (lambda () (interactive) (shell-command "nightlight on")))
      ;; I could write functions for these, but this is concise enough
      ("m h" jf/hammerspoon-toggle-mode  :if-non-nil hammerspoon-edit-minor-mode)
      ("m t" "Typopunct ( )" typopunct-mode :if-nil typopunct-mode)
      ("m t" "Typopunct (*)" typopunct-mode :if-non-nil typopunct-mode)
      ("m o" "MacOS Native Option ( )" jf/toggle-osx-alternate-modifier :if-non-nil ns-alternate-modifier)
      ("m o" "MacOS Native Option (*)" jf/toggle-osx-alternate-modifier :if-nil ns-alternate-modifier)
      ]]
    ["Org"

     ;; ["Add Metadata"
     ;; ("C-e a" "Add epigraph properties…" jf/org-mode-add-epigraph-keys :if-derived org-mode)
     ;; ("C-e i" "Add epigraph at point…" jf/org-roam-insert-at-point-epigraph-macro :if-derived org-mode)
     ;; ("r a" "Ref add…" org-roam-ref-add :if-derived org-mode)
     ;; ("t s" "Tag as session report…" jf/org-tag-as-session-report :if-derived org-mode)
     ;; ("t a" "Tag add…" org-roam-tag-add :if-derived org-mode)
     ;; ("t S" "Tag as session Scene…" jf/org-tag-session-scene-with-date :if-derived org-mode)]
     ;; ["Context"
     ;; ("M-c" "Context set…" jf/org-auto-tags--set-by-context :transient t)
     ;; ("M-t" jf/org-auto-tags--transient :transient t)
     ;; ]
     ["Tasks"
      ("c" "Capture region to clock…" (lambda (b e p) (interactive "r\nP") (jf/capture-region-contents-with-metadata b e p)))
      ("s" "Search note content…" (lambda () (interactive) (consult-notes-search-in-all-notes)))
      ("S" "Search note filename…" (lambda () (interactive) (consult-notes)))
      ("C-t" "Start a timer…" tmr-with-description)
      ("u" "Copy stand-up to kill ring" jf/org-mode-agenda-to-stand-up-summary)
      ("w" "Weekly hours report" jf/org-mode-weekly-report)
      ("x" "Export to TakeOnRules…" jf/export-org-to-tor :if-derived org-mode)
      ]
     ["Grab Refs"
      ("g e" "Elfeed" jf/menu--org-capture-elfeed-show :if-derived elfeed-show-mode)
      ("g f" "Firefox" jf/menu--org-capture-firefox)
      ("g s" "Safari" jf/menu--org-capture-safari)
      ("g w" "Eww" jf/menu--org-capture-eww :if-derived eww-mode)
      ]
     ])
#+end_src

* Footnotes

[fn:8] Steve Covey, and trademarked by FranklinCovey.

[fn:7] Yes, I said I didn’t want an Electron-based editor, but VS Code is a dominant player in the open source text editor.

[fn:2]  https://github.com/minad/consult#introduction

[fn:3]  These functions assume that the repository is using a [[https://rietta.com/blog/github-merge-types/#squash-and-merge][Squash and Merge strategy]].

[fn:4] My alias is as follows: ~alias e-reboot='cd ~/git/dotemacs; git stash ; edaemon ; git stash pop ; git edit'~.

[fn:5] My [[https://codeberg.org/takeonrules/dotzshrc/src/ab8b781cbdddd2fdbe674e031436b7e9a8e8a024/README.org#L1][dotzshrc]] config has my ~$EDITOR~

[fn:6] “Ag” is the chemical symbol for the Silver element.

#+TITLE: Emacs Configuration
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+STARTUP: overview

* Basic Configuration
** TODO straight.el

#+begin_src emacs-lisp
  (defconst jnf-silence-loading-log t
    "When true log to stdout any ")
  ;; https://www.reddit.com/r/emacs/comments/mtb05k/emacs_init_time_decreased_65_after_i_realized_the/
  (setq straight-check-for-modifications '(check-on-save find-when-checking))

  ;; This preamble is part of straight-use-package My understanding, in
  ;; reading straight documentation is that it has better load
  ;; times. However, the configuration options I often see leverage
  ;; "use-package" which is why most of my package declarations look as
  ;; they do.
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil jnf-silence-loading-log))

  (setq straight-repository-branch "develop")

  ;; I saw that straight loaded use-package to take advantage of the
  ;; use-package syntax which is often how things are documented.
  (straight-use-package 'use-package)
#+end_src

** TODO Early Configuration

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  Some basic configurations that should be applicable for all emacs
  ;;  settings.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; A chunk of code that allows me to pass multiple filenames to
  ;; emacsclient AND open those files in different frames within the
  ;; same window.(defvar server-visit-files-custom-find:buffer-count)
  (defvar server-visit-files-custom-find:buffer-count)
  (defadvice server-visit-files
      (around server-visit-files-custom-find
	      activate compile)
    "Maintain a counter of visited files from a single client call."
    (let ((server-visit-files-custom-find:buffer-count 0))
      ad-do-it))
  (defun server-visit-hook-custom-find ()
    "Arrange to visit the files from a client call in separate windows."
    (if (zerop server-visit-files-custom-find:buffer-count)
	(progn
	  (delete-other-windows)
	  (switch-to-buffer (current-buffer)))
      (let ((buffer (current-buffer))
	    (window (split-window-sensibly)))
	(switch-to-buffer buffer)
	(balance-windows)))
    (setq server-visit-files-custom-find:buffer-count
	  (1+ server-visit-files-custom-find:buffer-count)))
  (add-hook 'server-visit-hook 'server-visit-hook-custom-find)

  (global-so-long-mode)

  ;; Parenthesis matching is one of the flaws in my Emacs setup as of
  ;; this writing. I know that there are a lot of options out
  ;; there—paredit, smartparens, etc.—but I haven’t sat down and really
  ;; capital-L Learned a better solution than the TextMate-style bracket
  ;; completion (which Emacs calls, somewhat fancifully, ‘electric’).
  ;;
  ;; https://blog.sumtypeofway.com/posts/emacs-config.html
  (electric-pair-mode)

  ;; Put autosave files (ie #foo#) and backup files (ie foo~) in ~/.emacs.d/.
  ;; See https://snarfed.org/gnu_emacs_backup_files
  ;; create the autosave dir if necessary, since emacs won't.
  (make-directory "~/.emacs.d/autosaves/" t)

  (recentf-mode 1)
  (run-at-time nil (* 2 60) 'recentf-save-list)

  (global-auto-revert-mode)

  (setq-default fill-column 79)
  (setq
   ;; Don't create lock files.  Emacs drops these files on the file
   ;; system.  I found this most cumbersome when working in hugo.  The
   ;; hugo build would file because it tried to handle a lock file.
   create-lockfiles nil
   ;; Stop ringing any bell
   ring-bell-function 'ignore
   ;; The default is 60.  It is rare that I need more than 15 or 20.
   ;; However in my long use of Jumpcut there have been a few times where
   ;; I get into the 80s on previous pastes.  Given that the kill ring is
   ;; searchable, I think a larger value makes a lot of sense.
   kill-ring-max 120
   ;; Given the number of symlinks, visit the "linked to" file.
   vc-follow-symlinks t

   bookmark-default-file "~/git/jnf-emacs-bookmarks/bookmarks"
   read-process-output-max (* 1024 1024 3)  ; Increase read size per process
   indent-tabs-mode nil ;; Ensure tabs are expanded, not inserted
   inhibit-startup-screen t ;; Don't include the  emacs "start" window
   idle-update-delay 1.1  ;;Slow down the UI being updated to improve performance
   split-width-threshold 100 ;; Most of the times I favor two windows side-by-side within a frame
   recentf-max-menu-items 50
   recentf-max-saved-items 50
   backup-directory-alist '((".*" . "~/.emacs.d/backups/"))
   backup-by-copying t    ; Don't delink hardlinks
   version-control t      ; Use version numbers on backups
   delete-old-versions t  ; Automatically delete excess backups
   kept-new-versions 20   ; how many of the newest versions to keep
   kept-old-versions 5    ; and how many of the old
   user-full-name "Jeremy Friesen"
   user-mail-address "jeremy@jeremyfriesen.com"
   )

  ;; When you open Emacs, grab all the space on the screen
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))

  ;; Hide the icons of the Emacs toolbar
  (tool-bar-mode -1)

  ;; Hide the scroll bar. Let's be clear, I don't use it.
  (scroll-bar-mode -1)

  ;; Instead of typing "yes" or "no" short-circuit to "y" or "n"
  (defalias 'yes-or-no-p 'y-or-n-p)

  (unbind-key "C-x C-d") ;; `list-directory'
  ;; `dired' is a better interface than `list-directory'
  (global-set-key (kbd "C-x C-d") 'dired)
  (global-set-key (kbd "<M-delete>") 'kill-word)

  (global-set-key (kbd "<s-down>") 'end-of-buffer)
  (global-set-key (kbd "<s-up>") 'beginning-of-buffer)

  ;; Far to easy to type this on accident, and I'm not a fan of it's behavior.
  (unbind-key "C-z") ;; `suspend-frame'

  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

  ;; Given that C-c C-x is common within org-mode, I found myself
  ;; accidentally invoking this transposition.  I have "s-q" command for
  ;; this.
  (unbind-key "C-x C-c") ;; was `save-buffers-kill-terminal'

  (add-hook 'text-mode-hook #'abbrev-mode)

  (add-function :after after-focus-change-function
		(defun jnf/garbage-collect-maybe ()
		  (unless (frame-focus-state)
		    (garbage-collect))))
#+end_src

** TODO diminish.el

#+begin_src emacs-lisp
  (use-package diminish :straight t)
#+end_src

** TODO gchm.el

#+begin_src emacs-lisp

  ;; GCMH does GC when the user is idle.
  (use-package gcmh
    :straight t
    :diminish 'gcmh-mode
    :init
    (setq gcmh-idle-delay 5
	  gcmh-high-cons-threshold (* 16 1024 1024))  ; 16mb
    :config (gcmh-mode))
#+end_src

** TODO keychain-environment.el

#+begin_src emacs-lisp

  ;; Load keychain environment variables
  (use-package keychain-environment
    :straight t
    :config
    (keychain-refresh-environment))
#+end_src

** TODO f.el

#+begin_src emacs-lisp

  ;; a modern API for working with files and directories in Emacs.
  ;; https://github.com/rejeep/f.el/
  (use-package f :straight t)
#+end_src

** TODO s.el

#+begin_src emacs-lisp

  ;; The long lost Emacs string manipulation library.
  ;; https://github.com/magnars/s.el/
  (use-package s :straight t)
#+end_src

** TODO dash.el

#+begin_src emacs-lisp

  ;; A modern list API for Emacs. No 'cl required.
  ;; https://github.com/magnars/dash.el/
  (use-package dash :straight t)
#+end_src

** TODO Variable/const definitions

#+begin_src emacs-lisp

  (defconst jnf/fixed-width-font-name
    "Hack Nerd Font"
    "The name of the fixed width font.
  I have it sprinkled through too many places.

  Alternatives:
  - \"Monaco\"
  - \"JetBrains Mono\"
  - \"Hack Nerd Font\"")

  (set-frame-font jnf/fixed-width-font-name)

  (defconst jnf/tor-home-directory
    (file-truename "~/git/takeonrules.source")
    "The home directory of TakeOnRules.com Hugo repository.")

  (defconst jnf/tor-default-local-hostname
    "http://localhost:1313"
    "The scheme, host name, and port for serving up a local TakeOnRules.com.")

  (defvar jnf/data-directories
    (list
     jnf/tor-home-directory
     "~/git/takeonrules.source/themes/hugo-tufte"
     "~/git/burning_wheel_lifepaths/"
     "~/git/jnf-emacs-bookmarks"
     "~/git/dotzshrc/"
     "~/git/dotemacs/"
     "~/git/org/"
     "~/git/org/archive"
     "~/git/org/daily"
     "~/git/org/public"
     "~/git/org/personal"
     "~/git/org/personal/thel-sector"
     "~/git/org/hesburgh-libraries"
     "~/git/org/forem"
     )
    "Relevant data directories for my day to day work.")
#+end_src

** TODO pretty-hydra.el

#+begin_src emacs-lisp

  ;; I use this package to "configure" menus, hence this is in the
  ;; config section.
  (use-package pretty-hydra
    :straight (pretty-hydra
	       :type git :host github :repo "jerrypnz/major-mode-hydra.el"
	       :files (:defaults (:exclude "major-mode-hydra.el"))))
#+end_src

** TODO helpful.el

#+begin_src emacs-lisp
  ;; I have found this package quite "helpful"; When I want to know the
  ;; name of a function or key or variable, I can use the helpful
  ;; package.
  (use-package helpful
    :straight t
    :after (all-the-icons pretty-hydra)
    :pretty-hydra
    ((:title (with-material "help_outline" "Helpful Menus") :quit-key "q" :exit t)
     ("Helpful"
      (
       ("b" embark-bindings "Bindings")
       ("c" helpful-command "Command")
       ("f" helpful-callable "Function (interactive)")
       ("F" helpful-function "Function (all)")
       ("k" helpful-key "Key")
       ("l" find-library "Find library")
       ("m" helpful-macro "Macro")
       ("p" helpful-at-point "Thing at point")
       ("v" helpful-variable "Variable")
       ("t" describe-text-properties "Text properties")
       )))
    :bind ("C-s-h" . helpful-hydra/body))
#+end_src

** TODO editorconfig.el

#+begin_src emacs-lisp

  ;; See https://editorconfig.org/#overview
  (use-package editorconfig
    :straight t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))
#+end_src

* Display

I'm just going to trust themes.
#+begin_src emacs-lisp
  (setq custom-safe-themes t)
#+end_src

** TODO modus-themes.el

#+begin_src emacs-lisp
  (use-package modus-themes
    ;; :straight (modus-themes :type built-in)
    :straight (:type git :host gitlab :repo "protesilaos/modus-themes" :branch "main")
    :init
    (setq
     modus-themes-bold-constructs t
     modus-themes-completions 'opinionated ; {nil,'moderate,'opinionated}
     modus-themes-diffs nil ; {nil,'desaturated,'fg-only}
     modus-themes-fringes 'intense ; {nil,'subtle,'intense}
     modus-themes-hl-line '(accented intense)
     modus-themes-intense-markup t
     modus-themes-links '(faint background)
     modus-themes-mixed-fonts t
     modus-themes-mode-line '(accented 3d)
     modus-themes-org-blocks 'gray-background
     modus-themes-paren-match '(bold intense)
     modus-themes-prompts '(intense accented)
     modus-themes-region '(bg-only accented)
     modus-themes-scale-headings t
     modus-themes-slanted-constructs t
     modus-themes-subtle-line-numbers t
     modus-themes-syntax '(alt-syntax yellow-comments green-strings)
     modus-themes-tabs-accented t
     modus-themes-headings
     '((1 . (variable-pitch light 1.6))
       (2 . (overline semibold 1.4))
       (3 . (monochrome overline 1.2))
       (4 . (overline 1.1))
       (t . (rainbow 1.05)))))

  (global-hl-line-mode)

  ;; Recommendation from https://protesilaos.com/emacs/modus-themes
  (setq x-underline-at-descent-line t)
#+end_src

** TODO lin.el

#+begin_src emacs-lisp
  (use-package lin
    :straight (lin :host gitlab :repo "protesilaos/lin")
    :config (lin-add-to-many-modes))
#+end_src

#+begin_src emacs-lisp
  ;; Based on system type, either load the OSX apperance (e.g. dark or
  ;; light) and load accordingly.
  (if (eq system-type 'darwin)
      (progn
	(defun jnf/dark ()
	  "Toggle system-wide Dark or Light setting."
	  (interactive)
	  (shell-command "osascript -e 'tell application \"System Events\" to tell appearance preferences to set dark mode to not dark mode'")
	  (jnf/emacs-theme-by-osx-appearance))

	(defalias 'modus-themes-toggle 'jnf/dark)
	(defun jnf/emacs-theme-by-osx-appearance ()
	  "Set theme based on OSX apperance state."
	  (if (equal "Dark" (substring (shell-command-to-string "defaults read -g AppleInterfaceStyle") 0 4))
	      (load-theme 'modus-vivendi)
	    (load-theme 'modus-operandi)))
	(jnf/emacs-theme-by-osx-appearance))
    (progn
      (defun modus-themes-toggle ()
	"Toggle between `modus-operandi' and `modus-vivendi' themes."
	(interactive)
	(if (eq (car custom-enabled-themes) 'modus-operandi)
	    (load-theme 'modus-vivendi)
	  (load-theme 'modus-operandi)))
      (load-theme 'modus-operandi)))
#+end_src

#+begin_src emacs-lisp

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; BEGIN BLOCK
  ;;
  ;; With a quick bit of testing, it appears that the following
  ;; set-face-attribute declarations should be made after the theme
  ;; declarations.  When the following statements were declared before
  ;; the themes, and I toggled my theme, the font changed to something
  ;; unexpected.  With them declared after, I keep the fonts between
  ;; toggles.
  ;;
  ;; Main typeface, I'm toggling between "JetBrains Mono" and "Hack"
  (set-face-attribute 'default nil :family jnf/fixed-width-font-name :height 140)
  ;; Proportionately spaced typeface
  (set-face-attribute 'variable-pitch nil :family "ETBembo" :height 1.1)
  ;; Monospaced typeface
  (set-face-attribute 'fixed-pitch nil :family jnf/fixed-width-font-name :height 1.0)
  ;;
  ;; END BLOCK
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (blink-cursor-mode t)
  ;; Doing a bit of configuration of my cursors
  (setq-default cursor-type 'bar)
#+end_src

** TODO all-the-icons.el

#+begin_src emacs-lisp
  ;; Useful for referential icons.
  (use-package all-the-icons
    :straight t
    :config
    ;; A convenience function to create a nice string
    (defun with-faicon (icon str &optional height v-adjust)
      "Displays an ICON  from Font Awesome icon.

   The STR identifies the icon and the HEIGHT and V-ADJUST provide
   the configuration."
      (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-material (icon str &optional height v-adjust)
      "Displays an ICON  from Font Material icon.

   The STR identifies the icon and the HEIGHT and V-ADJUST provide
   the configuration."
      (s-concat (all-the-icons-material icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-octicon (icon str &optional height v-adjust)
      "Displays an ICON  from Octicon icon.

   The STR identifies the icon and the HEIGHT and V-ADJUST provide
   the configuration."
      (s-concat (all-the-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-alltheicon (icon str &optional height v-adjust)
      "Displays an ICON  from All the Icons icon.

   The STR identifies the icon and the HEIGHT and V-ADJUST provide
   the configuration."
      (s-concat (all-the-icons-alltheicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str)))
#+end_src

** TODO all-the-icons-dired.el

#+begin_src emacs-lisp
  ;; Disabled because on 2021-04-11 I got the following error:
  ;; *ERROR*: Symbol’s value as variable is void: file
  ;;
  ;; Incorporates file icons with file listings of dired
  (use-package all-the-icons-dired
    :straight t
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

** TODO spaceline.el

#+begin_src emacs-lisp
  ;; A nice looking modeline enhancement
  (use-package spaceline
    :straight t)
#+end_src

** TODO spaceline-all-the-icons.el

#+begin_src emacs-lisp
  ;; Add some visual flair to the modeline enhancements
  (use-package spaceline-all-the-icons
    :straight t
    :after spaceline
    :config (spaceline-all-the-icons-theme))
#+end_src

** TODO popper.el

#+begin_src emacs-lisp
  ;; Ensuring that some windows are treated as popups (e.g., something
  ;; easier to dismiss, a bit more like the mini-buffer).
  (use-package popper
    :straight t
    :bind (("C-`" . jnf/popper))
    :config
    (defun jnf/popper (prefix_arg)
      "Call `popper-cycle', but with PREFIX_ARG invoke a less common popper method.

  With one PREFIX_ARG, `popper-toggle-latest'.
  With two (or more) PREFIX_ARG `popper-toggle-type'."
      (interactive "P")
      (let ((prefix (car prefix_arg)))
	(cond
	 ((not prefix)  (popper-cycle))
	 ((= prefix 4)  (popper-toggle-latest))
	 (t (popper-toggle-type)))))
    :init
    (setq popper-reference-buffers
	  '("\\*Messages\\*"
	    "Output\\*$"
	    "\\*Async Shell Command\\*"
	    help-mode
	    compilation-mode
	    "^\\*helpful.*\\*$"))
    (popper-mode +1)
    (popper-echo-mode +1))

#+end_src

** TODO ace-window.el

#+begin_src emacs-lisp
  ;; A window manager for emacs, allowing fast toggles between windows
  ;; as well as opening or moving those windows.
  ;; https://github.com/abo-abo/ace-window
  (use-package ace-window
    :straight t
    :bind (("M-o" . ace-window)))
#+end_src

** TODO Window Layout Functions

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; BEGIN frame and window quick setup
  (defun gk-layouts-3col ()
    "Three column layout.

  Tries to preserve the order of window buffers and active window."
    (interactive)
    ;; Record active window buffer.
    (let ((cbuf (current-buffer)))
      ;; Switch to leftmost window.
      (ignore-errors (cl-loop do (windmove-left)))
      (let ((buffers
	     (mapcar #'window-buffer (-take 3 (window-list))))
	    (width (/ (frame-width) 3)))
	(delete-other-windows)
	(split-window-horizontally width)
	(other-window 1)
	(split-window-horizontally)
	(other-window -1)
	(dolist (b buffers)
	  (switch-to-buffer b)
	  (other-window 1)))
      ;; Switch to previously visible buffer’s window.
      (select-window (get-buffer-window cbuf))))


  (defun gk-layouts-main-and-sidekicks ()
    "One horizontal split, the right window split in two.

  Tries to preserve the order of window buffers and active window."
    (interactive)
    ;; Record active window buffer.
    (let ((cbuf (current-buffer)))
      ;; Switch to leftmost window.
      (ignore-errors (cl-loop do (windmove-left)))
      (let ((buffers
	     (mapcar #'window-buffer (-take 3 (window-list)))))
	(delete-other-windows)
	(split-window-horizontally)
	(other-window 1)
	(split-window-vertically)
	(other-window -1)
	(dolist (b buffers)
	  (switch-to-buffer b)
	  (other-window 1)))
      ;; Switch to previously visible buffer’s window.
      (select-window (get-buffer-window cbuf))))

  (bind-key "C-x \\" #'gk-layouts-main-and-sidekicks)
  ;; END frame and window quick setup
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

** TODO Scrolling functions

#+begin_src emacs-lisp
  ;; See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/
  (global-set-key (kbd "M-n") 'jnf/scroll-down-half-page)
  (defun jnf/scroll-down-half-page ()
    "Scroll down half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) (move-to-window-line nil))
	    ((= ln lmax) (recenter (window-end)))
	    (t (progn
		 (move-to-window-line -1)
		 (recenter))))))

  (global-set-key (kbd "M-p") 'jnf/scroll-up-half-page)
  (defun jnf/scroll-up-half-page ()
    "Scroll up half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) nil)
	    ((= ln lmax) (move-to-window-line nil))
	    (t (progn
		 (move-to-window-line 0)
		 (recenter))))))
#+end_src

* General Emacs Configuration

I tried enabling this, and found myself sometimes lost in a labyrinth of
minibuffers.  This change ensures that there’s only one.

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers nil)
#+end_src

** MacOS Specific

*** TODO grab-mac-link.el

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  This package loads darwin specific packages; It assumes that both
  ;;  "use-package" and "straight-use-package" are loaded.
  ;;
  ;;; Code:
  ;; Adds the ability to grab a link from various OS X applications
  ;; Note, the sibling org-mac-link.  That package works within ORG mode
  ;; with an extended menu option, and assumes ORG styling.  They both
  ;; have the same keybinding as org-mode favors org-mac-link.
  (use-package grab-mac-link
    :straight t
    :config
    ;; A replacement function for existing grab-mac-link-make-html-link
    (defun jnf/grab-mac-link-make-html-link (url name)
      "Using HTML syntax, link to and cite the URL with the NAME."
      (format "<cite><a href=\"%s\" class=\"u-url p-name\" rel=\"cite\">%s</a></cite>" url name))
    ;; The function advice to override the default behavior
    (advice-add
     'grab-mac-link-make-html-link
     :override
     'jnf/grab-mac-link-make-html-link
     '((name . "jnf")))
    :bind (("C-c g" . grab-mac-link)))

  (eval-after-load "flyspell"
    '(progn
       (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
       (define-key flyspell-mouse-map [mouse-3] #'undefined)))
#+end_src

*** TODO org-mac-link.el

#+begin_src emacs-lisp
  (use-package org-mac-link
    :ensure t
    :straight (org-mac-link :type git :host github :repo "jeremyf/org-mac-link")
    :defer t)
  (add-hook 'org-mode-hook (lambda ()
			     (define-key org-mode-map (kbd "C-c g") 'org-mac-grab-link)))

  (if (version< "27.0" emacs-version)
      (set-fontset-font
       "fontset-default" 'unicode "Apple Color Emoji" nil 'prepend)
    (set-fontset-font
     t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend))
#+end_src

*** TODO pdf-tools.el

#+begin_src emacs-lisp
  ;; Emacs comes with DocView built in.  pdf-tools is a replacement for
  ;; DocView.  I've found the rendered images a bit more crisp and the
  ;; interactions a bit more responsive.  However, I have not been able
  ;; to get `org-noter' working with `pdf-tools'.  `org-noter' provides
  ;; annotation services for PDFs.
  (use-package pdf-tools
    :pin manual ;; manually update
    :straight t
    :defer t
    :ensure t
    :config (pdf-tools-install) ;; initialise
    (setq-default pdf-view-display-size 'fit-page) ;; open pdfs scaled to fit page
    (setq pdf-annot-activate-created-annotations t) ;; automatically annotate highlights
    (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward);; use normal isearch
    )
#+end_src

*** TODO so-long.el

#+begin_src emacs-lisp

  ;; When we get to a REALLY long file or long line, emacs develops problems.
  ;; This mode helps overcome that.
  ;;
  (use-package so-long
    :ensure t
    :defer t
    :straight t
    :bind
    (:map so-long-mode-map
	  ("C-s" . isearch-forward)
	  ("C-r" . isearch-backward))
    :config
    (global-so-long-mode 1))
#+end_src

*** TODO dtache.el

#+begin_src emacs-lisp
  ;; May or may not be useful
  (use-package dtache
    :straight (dtache :host gitlab :repo "niklaseklund/dtache")
    :hook (after-init . dtache-setup)
    :bind (([remap async-shell-command] . dtache-shell-command)
	   :map dtache-shell-mode-map
	   ("C-c C-q" . dtache-detach-dwim)))
#+end_src

* Modes

Sometimes I want to edit svg files.  Often times if I open them directly in
Emacs, I want to edit them.  This setting helps with that default.  /Note:/
without this setting, Emacs will happily render the SVG as an image,

#+begin_src emacs-lisp
  (add-to-list `auto-mode-alist '("\\.svg\\'" . xml-mode))
#+end_src

** TODO emmet-mode.el

#+begin_src emacs-lisp
  (use-package emmet-mode
    :straight t
    :bind (("C-c C-e" . emmet-expand-yas ))
    :hook ((sgml-mode . emmet-mode)
	   (html-mode . emmet-mode)
	   (css-mode . emmet-mode)))
#+end_src

** TODO web-mode.el

#+begin_src emacs-lisp
  (use-package web-mode
    :straight t
    :config (setq web-mode-markup-indent-offset 2
		  web-mode-css-indent-offset 2
		  web-mode-code-indent-offset 2))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))

  ;; built-in, consider commenting
  ;; (use-package sgml-mode
  ;;   :straight nil
  ;;   :hook
  ;;   (html-mode . sgml-electric-tag-pair-mode)
  ;;   (html-mode . sgml-name-8bit-mode)
  ;;   :custom
  ;;   (sgml-basic-offset 2))
#+end_src

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :config (setq plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  plantuml-default-exec-mode 'executable
		  org-plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  org-plantuml-exec-mode 'executable)
    :mode (("\\.plantuml\\'" . plantuml-mode))
    :straight t)
#+end_src

#+begin_src emacs-lisp
  (use-package json-mode :straight t)
#+end_src

Because JSON can be quite ugly, I want something to help tidy it up.
#+begin_src emacs-lisp
  (use-package json-reformat
    :straight t
    :after json-mode
    :init (setq json-reformat:indent-width 2))

#+end_src

** go-mode.el

Every so often I stumble upon a Go package.  The ~go-mode~ package gives me the
syntax highlighting that makes reading ~Go-lang~ tolerable.

#+begin_src emacs-lisp
  (use-package go-mode :straight t)
#+end_src

** TODO markdown-mode.el

#+begin_src emacs-lisp
  (use-package markdown-mode
    :straight t
    :hook ((markdown-mode . turn-on-visual-line-mode))
    ;; I use markdown for my blogging platform and very little else.
    ;; Hence, I have this keybind.
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "/usr/local/bin/pandoc"))
#+end_src

** TODO yaml-mode.el

#+begin_src emacs-lisp
  (use-package yaml-mode :straight t)
#+end_src

** TODO lua-mode.el

#+begin_src emacs-lisp
  (use-package lua-mode :straight t)
#+end_src

** TODO lua-mode.el

#+begin_src emacs-lisp
  (use-package git-modes :straight t)
#+end_src

** TODO enh-ruby-mode.el

#+begin_src emacs-lisp
  (defun jnf/enh-ruby-mode-hook-hook ()
    (setq fill-column 100))
  ;; I'm provisionally addinig enh-ruby-mode and robe.  I've found that
  ;; LSP can work, but has it's own problems; namely you need solargraph
  ;; installed for all versions.
  (use-package enh-ruby-mode
    :straight t
    :config (add-hook 'enh-ruby-mode-hook #'jnf/enh-ruby-mode-hook-hook)
    :bind (:map enh-ruby-mode-map ("C-j" . avy-goto-char-timer))
    :mode (("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . enh-ruby-mode)))
  (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))
#+end_src

** TODO rspec-mode.el

#+begin_src emacs-lisp
  (use-package rspec-mode
    :straight t
    :custom (rspec-use-spring-when-possible nil)
    :diminish 'rspec-mode
    :bind (:map rspec-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :bind (:map enh-ruby-mode-map (("s-." . 'rspec-toggle-spec-and-target)))
    :hook (ruby-mode . rspec-mode) ;; should this be `enh-ruby-mode'
    (ruby-mode . eldoc-mode)) ;; should this be `enh-ruby-mode'

  (eval-after-load 'rspec-mode
    '(rspec-install-snippets))
#+end_src

** TODO projectile-rails.el

#+begin_src emacs-lisp
  (use-package projectile-rails
    :after (projectile)
    :diminish 'projectile-rails-mode
    :straight t
    :config
    (defun projectile-rails-find-liquid ()
      "Find a liquid tag."
      (interactive)
      (projectile-rails-find-resource
       "liquid: "
       '(("app/liquid_tags/" "\\(.+?\\)\\.rb\\'"))
       "app/liquid_tags/${filename}.rb"))
    :bind (:map
	   projectile-rails-mode-map (("C-s-." . 'projectile-rails-goto-file-at-point)))
    :config (projectile-rails-global-mode))

  ;; (use-package rails-i18n
  ;;   :straight t)
#+end_src

** TODO ruby-interpolation.el

#+begin_src emacs-lisp
  ;; Nice and simple pakcage for string interpolation.
  (use-package ruby-interpolation
    :straight t
    :diminish 'ruby-interpolation-mode
    :hook (enh-ruby-mode . ruby-interpolation-mode))
#+end_src

** TODO ruby-electric.el

#+begin_src emacs-lisp
  (use-package ruby-electric
    :straight t
    :diminish 'ruby-electric-mode
    ;; Somtimes I want this enabled, other times not; but it's a bit
    ;;  obnoxious in spec.rb files.
    ;;
    ;; :hook (enh-ruby-mode . ruby-electric-mode)
    )
#+end_src

** TODO rails-routes.el

#+begin_src emacs-lisp
  (use-package rails-routes
    :after projectile-rails
    :straight t)
#+end_src

** TODO ruby menus

#+begin_src emacs-lisp
  (defvar jnf/projectile-rails--title (with-alltheicon "ruby-alt" "Rails" 1 -0.05))
  (pretty-hydra-define jnf/projectile-rails-find-resource--menu
    (:foreign-keys warn :title jnf/projectile-rails--title :quit-key "q" :exit t)
    ("Rails > Find Resources"
     (("m" projectile-rails-find-model       "model")
      ("v" projectile-rails-find-view        "view")
      ("c" projectile-rails-find-controller  "controller")
      ("h" projectile-rails-find-helper      "helper")
      ("l" projectile-rails-find-lib         "lib")
      ("j" projectile-rails-find-javascript  "javascript")
      ("w" projectile-rails-find-component   "component")
      ("s" projectile-rails-find-stylesheet  "stylesheet")
      ("p" projectile-rails-find-spec        "spec")
      ("u" projectile-rails-find-fixture     "fixture")
      ("t" projectile-rails-find-test        "test")
      ("f" projectile-rails-find-feature     "feature")
      ("i" projectile-rails-find-initializer "initializer")
      ("o" projectile-rails-find-log         "log")
      ("t" projectile-rails-find-liquid      "liquid tag")
      ("@" projectile-rails-find-mailer      "mailer")
      ("!" projectile-rails-find-validator   "validator")
      ("y" projectile-rails-find-layout      "layout")
      ("n" projectile-rails-find-migration   "migration")
      ("k" projectile-rails-find-rake-task   "rake task")
      ("b" projectile-rails-find-job         "job")
      ("z" projectile-rails-find-serializer  "serializer"))))

  (pretty-hydra-define jnf/projectile-rails-find-current-resource--menu
    (:foreign-keys warn :title jnf/projectile-rails--title :quit-key "q" :exit t)
    ("Rails > Find Current Resources"
     (("M" projectile-rails-find-current-model      "current model")
      ("V" projectile-rails-find-current-view       "current view")
      ("C" projectile-rails-find-current-controller "current controller")
      ("H" projectile-rails-find-current-helper     "current helper")
      ("J" projectile-rails-find-current-javascript "current javascript")
      ("S" projectile-rails-find-current-stylesheet "current stylesheet")
      ("P" projectile-rails-find-current-spec       "current spec")
      ("U" projectile-rails-find-current-fixture    "current fixture")
      ("T" projectile-rails-find-current-test       "current test")
      ("N" projectile-rails-find-current-migration  "current migration")
      ("Z" projectile-rails-find-current-serializer "current serializer"))))

  (pretty-hydra-define jnf/projectile-rails-goto--menu
    (:foreign-keys warn :title jnf/projectile-rails--title :quit-key "q" :exit t)
    ("Rails > Goto"
     (("f" projectile-rails-goto-file-at-point "file at point")
      ("g" projectile-rails-goto-gemfile       "Gemfile")
      ("p" projectile-rails-goto-package       "package")
      ("r" projectile-rails-goto-routes        "routes")
      ("d" projectile-rails-goto-schema        "schema")
      ("s" projectile-rails-goto-seeds         "seeds")
      ("h" projectile-rails-goto-spec-helper   "spec helper"))))

  (pretty-hydra-define jnf/projectile-rails-run--menu
    (:foreign-keys warn :title jnf/projectile-rails--title :quit-key "q" :exit t)
    ("Rails > Run"
     (("r" projectile-rails-rake       "rake")
      ("c" projectile-rails-console    "console")
      ("b" projectile-rails-dbconsole  "dbconsole")
      ("s" projectile-rails-server     "server")
      ("g" projectile-rails-generate   "generate")
      ("d" projectile-rails-destroy    "destroy")
      ("x" projectile-rails-extract-region "extract region"))))

  (pretty-hydra-define jnf/projectile-rails--menu
    (:foreign-keys warn :title jnf/projectile-rails--title :quit-key "q" :exit t)
    ("Rails"
     (("." projectile-rails-goto-file-at-point "Goto file at point")
      ("c" jnf/projectile-rails-find-current-resource--menu/body "Find current resource…")
      ("f" jnf/projectile-rails-find-resource--menu/body "Find a resource…")
      ("g" jnf/projectile-rails-goto--menu/body "Goto…")
      ("i" rails-routes-insert-no-cache "Insert route…")
      ("I" rails-routes-insert "Insert route (from cache)…")
      ("r" jnf/projectile-rails-run--menu/body "Run & interact…"))))
#+end_src

** TODO yard-mode.el

#+begin_src emacs-lisp
  ;; I most often write documentation using yard.  See
  ;; https://yardoc.org.
  (use-package yard-mode
    :straight t
    :hook (enh-ruby-mode . yard-mode))
#+end_src

** TODO bundler.el

#+begin_src emacs-lisp
  ;; Adds the helpful `bundle-open'
  (use-package bundler
    :straight (bundler :type git :host github :repo "endofunky/bundler.el"))
#+end_src


** TODO lsp-mode.el

#+begin_src emacs-lisp
  (use-package lsp-mode
    :straight t
    :hook (
	   (ruby-mode . lsp)
	   (enh-ruby-mode . lsp)
	   ;; (js-mode . lsp)
	   ;; (html-mode . lsp)
	   ;; (bash-mode . lsp)
	   )
    :config (setq read-process-output-max (* 1024 1024 3)
		  lsp-completion-provider nil
		  lsp-completion-mode nil
		  lsp-idle-delay 1.00)
    :custom (lsp-keymap-prefix "C-c C-l")
    :commands (lsp))

  ;; See https://www.reddit.com/r/emacs/comments/ql8cyp/corfu_orderless_and_lsp/
  ;; (defun corfu-lsp-setup ()
  ;;   (setq-local completion-styles '(orderless)
  ;;               completion-category-defaults nil))
  ;; (add-hook 'lsp-mode-hook #'corfu-lsp-setup)

  (with-eval-after-load 'lsp-mode
    (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration))

#+end_src

** TODO lsp-ui.el

#+begin_src emacs-lisp
  ;; This package provides some nice UI behavior for documentation and linting
  ;;
  ;; In particular, I like 'lsp-ui-peek-find-reference
  (use-package lsp-ui
    :straight t
    :after lsp-mode
    :commands lsp-ui-mode
    :hook ((enh-ruby-mode . lsp-ui-mode)
	   (enh-ruby-mode . lsp-ui-peek-mode)
	   (enh-ruby-mode . lsp-ui-sideline-mode)))

  ;; By default indent levels are often 4; That is against what I've seen.
  (setq ruby-indent-level 2
	typescript-indent-level 2
	js-indent-level 2)

  (add-hook 'emacs-lisp-mode 'eldoc-mode)
#+end_src

** TODO tree-sitter.el

#+begin_src emacs-lisp
  ;; See https://github.com/emacs-tree-sitter/elisp-tree-sitter
  ;; Waiting on https://github.com/emacs-tree-sitter/elisp-tree-sitter/issues/197 to resolve.
  (use-package tree-sitter
    :straight (tree-sitter :host github :repo "emacs-tree-sitter/elisp-tree-sitter")
    :config
    (add-to-list 'tree-sitter-major-mode-language-alist '(enh-ruby-mode . ruby)))

  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)

  (use-package tree-sitter-langs
    :straight t)
#+end_src

* Support

** DONE ripgrep.el

For many years, I’ve used “The Silver Searcher”, or ~ag~ on the command
line.[fn:1].  However, [[https://github.com/BurntSushi/ripgrep][ripgrep]] provides even faster searching, with an almost
identical parameter list.

#+begin_src emacs-lisp
  (use-package ripgrep
    :init (setq ripgrep-arguments "--ignore-case")
    :straight t)
#+end_src

* Projects

** TODO projectile.el

Projectile provides convenient organization and commands to run over projects.

#+begin_src emacs-lisp
  (use-package projectile
    :straight t
    :diminish 'projectile-mode
    :config (projectile-mode 1)
    :custom (projectile-project-search-path '("~/git/"))
    :bind ("s-." . projectile-toggle-between-implementation-and-test))
#+end_src

/Note:/ The =CMD= + =.= is a carryover from my [[https://macromates.com][Textmate]] and [[https://www.sublimetext.com/][Sublime Text]] days.
That’s one of those hot-keys almost burned into soul.

** TODO  magit.el

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  This package includes the various configurations for git
  ;;  interactions.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; The OMG awesome git client for emacs.
  (use-package magit
    :straight t
    :init (use-package with-editor :straight t)

    ;; Adding format to git-commit-fill-column of 72 as best practice.
    (setq git-commit-fill-column 72)

    ;; Keeping the summary terse helps with legibility when you run a
    ;; report with only summary.
    (setq git-commit-summary-max-length 50)

    ;; Set the tabular display columns for the `magit-list-repositories'
    (setq magit-repolist-columns
	  '(("Name"    25 magit-repolist-column-ident ())
	    ("Version" 25 magit-repolist-column-version ())
	    ("δ"        1 magit-repolist-column-dirty ())
	    ("⇣"        3 magit-repolist-column-unpulled-from-upstream
	     ((:right-align t)
	      (:help-echo "Upstream changes not in branch")))
	    ("⇡"        3 magit-repolist-column-unpushed-to-upstream
	     ((:right-align t)
	      (:help-echo "Local changes not in upstream")))
	    ("Branch"  25 magit-repolist-column-branch ())
	    ("Path"    99 magit-repolist-column-path ())))

    ;; The default relevant `magit-list-repositories'
    (setq magit-repository-directories
	  `(("~/git/takeonrules.source/" . 1) ;; personal
	    ("~/git/burning_wheel_lifepaths/" . 1)
	    ("~/git/dotzshrc/" .  1) ;; all
	    ("~/git/dotemacs/" . 1) ;; all
	    ("~/git/jnf-emacs-bookmarks/" . 1)
	    ("~/git/org" . 1) ;; all
	    ("~/git/org/archive" . 1) ;; personal
	    ("~/git/org/daily" . 1) ;; ??
	    ("~/git/org/hesburgh-libraries" . 1) ;; work
	    ("~/git/org/forem" . 1) ;; work
	    ("~/git/org/forem-docs" . 1) ;; work
	    ("~/git/org/personal" . 1) ;; personal
	    ("~/git/org/public" . 1) ;; all
	    ("~/git/takeonrules.source/themes/hugo-tufte" . 1))) ;; personal

    ;; Have magit-status go full screen and quit to previous
    ;; configuration.  Taken from
    ;; http://whattheemacsd.com/setup-magit.el-01.html#comment-748135498
    ;; and http://irreal.org/blog/?p=2253
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))
    (defadvice magit-mode-quit-window (after magit-restore-screen activate)
      (jump-to-register :magit-fullscreen))
    :config
    (remove-hook 'magit-status-sections-hook 'magit-insert-tags-header)
    (defun jnf/magit-list-repositories ()
      "Create a `magit-list-repositories' for my personal repositories."
      (interactive)
      (setq magit-repository-directories
	    `(("~/git/takeonrules.source/" . 1)
	      ("~/git/takeonrules.source/hugo-tufte" . 1)
	      ("~/git/burning_wheel_lifepaths/" . 1)
	      ("~/git/org" . 1)
	      ("~/git/org/personal" . 1)
	      ("~/git/org/public" . 1)
	      ("~/git/org/archive" . 1)
	      ("~/git/org/daily" . 1)
	      ("~/git/org/hesburgh-libraries" . 1)
	      ("~/git/org/forem-docs" . 1)
	      ("~/git/dotemacs/" . 1)
	      ("~/git/jnf-emacs-bookmarks/" . 1)
	      ("~/git/dotzshrc/" .  1)))
      (magit-list-repositories))
    (defun jnf/magit-browse-pull-request ()
      "In `magit-log-mode' open the associated pull request
  at point.

  Assumes that the commit log title ends in the PR #, which
  is the case when you use the Squash and Merge strategy.

  This implementation is dependent on `magit' and `s'."
      (interactive)
      (let* ((beg (line-beginning-position))
	     (end (line-end-position))
	     (summary
	      (buffer-substring-no-properties
	       beg end)))
	(jnf/open-pull-request-for :summary summary)))
    (defun jnf/git-current-remote-url ()
      "Get the current remote url."
      (s-trim
       (shell-command-to-string
	(concat
	 "git remote get-url "
	 (format "%s" (magit-get-current-remote))))))
    (cl-defun jnf/open-pull-request-for (&key summary)
      "Given the SUMMARY open the related pull request."
      (let ((remote-url (jnf/git-current-remote-url)))
	(save-match-data
	  (and (string-match "(\\#\\([0-9]+\\))$" summary)
	       (eww-browse-with-external-browser
		(concat
		 ;; I tend to favor HTTPS and the repos end in ".git"
		 (s-replace ".git" "" remote-url)
		 "/pull/"
		 (match-string 1 summary)))))))
    (defun jnf/open-pull-request-for-current-line ()
      "For the current line open the applicable pull request."
      (interactive)
      (let ((summary
	     (s-trim
	      (shell-command-to-string
	       (concat "git --no-pager annotate "
		       "-w -L "
		       (format "%s" (line-number-at-pos))
		       ",+1 "
		       "--porcelain "
		       buffer-file-name
		       " | rg \"^summary\"")))))
	(jnf/open-pull-request-for :summary summary)))
    ;; In other situations I bind s-6 to `git-messenger:popup-message'
    :bind (
	   ("C-c C-g" . magit-file-dispatch)
	   ("s-7" . magit-status))
    :bind (:map magit-log-mode-map ("s-6" . 'jnf/magit-browse-pull-request))
    :hook ((with-editor-post-finish-hook . magit-status)))
#+end_src

** TODO  forge.el

#+begin_src emacs-lisp
  (use-package forge
    :config
    (setq auth-sources '("~/.authinfo"))
    ;; (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-authored-pullreqs nil 'append)
    ;; (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-requested-reviews nil 'append)
    ;; (magit-add-section-hook 'magit-status-sections-hook 'forge-insert-assigned-issues nil 'append)
    :straight t)

#+end_src

** TODO  libgit.el

#+begin_src emacs-lisp
  (use-package libgit
    :straight t)
#+end_src

** TODO  magit-libgit.el

#+begin_src emacs-lisp
  (use-package magit-libgit
    :after (libgit magit)
    :straight t)
#+end_src

** TODO  git-timemachine.el

#+begin_src emacs-lisp
  ;; With the time machine, travel back and forth through a files history.
  ;;
  ;; While visiting a point in time, you can open
  (use-package git-timemachine
    :straight t)
#+end_src

** TODO  git-gutter-fringe.el

#+begin_src emacs-lisp
  ;; Show the current git state in the gutter Go ahead and edit a line
  ;; and look to the gutter for guidance.
  (use-package git-gutter-fringe
    :straight (git-gutter-fringe :type git :host github :repo "emacsorphanage/git-gutter-fringe")
    :diminish 'git-gutter-mode
    :config (global-git-gutter-mode 't)
    (setq git-gutter:modified-sign "Δ"
	  git-gutter:added-sign "+"
	  git-gutter:deleted-sign "-"))
#+end_src

** TODO  git-link.el

#+begin_src emacs-lisp
  ;; https://github.com/sshaw/git-link
  ;;
  ;; `M-x git-link` to add the current URL to the kill ring.  This is
  ;; particularly helpful for sharing links with other developers.  I
  ;; use this ALL OF THE TIME
  (use-package git-link
    :config
    ;; Without the following autoload directive, the call to
    ;; `eww-browse-with-external-browser' in
    ;; `jnf/git-browse-to-repository' fails (unless I've previously
    ;; called `eww').
    (autoload 'eww-browse-with-external-browser "eww.el")
    (defun jnf/git-browse-to-repository (remote)
      "Open in external browser the current repository's given REMOTE.

  Uses `eww-browse-with-external-browser' to determine external browser to use."
      (interactive (list (git-link--select-remote)))
      (git-link-homepage remote)
      (eww-browse-with-external-browser (car kill-ring)))
    (setq git-link-use-commit t) ;; URL will be SHA instead of branch
    :straight t)
#+end_src

** TODO  git-messenger.el

#+begin_src emacs-lisp
  (use-package git-messenger
    :config (setq git-messenger:show-detail t)
    (defun jnf/git-messenger-popup ()
      "Open `git-messenger' or github PR.

  With universal argument, open the github PR for current line.

  Without universal argument, open `git-messenger'."
      (interactive)
      (if (equal current-prefix-arg nil) ; no C-u
	  (git-messenger:popup-message)
	(jnf/open-pull-request-for-current-line)))
    :custom
    (git-messenger:use-magit-popup t)
    :bind (:map git-messenger-map (("p" . 'jnf/open-pull-request-for-current-line)
				   ("l" . 'git-link)))
    :bind (("s-6" . jnf/git-messenger-popup)
	   ("<f6>" . jnf/git-messenger-popup))
    :straight t)
#+end_src

** TODO  blamer.el

#+begin_src emacs-lisp
  (use-package blamer
    :straight (blamer :host github :repo "Artawower/blamer.el")
    :custom
    (blamer-idle-time 0.5)
    (blamer-author-formatter "✎ %s ")
    (blamer-datetime-formatter "[%s]")
    (blamer-commit-formatter "● %s")
    (blamer-min-offset 40)
    (blamer-max-commit-message-length 20))
#+end_src

* Completion

** DONE vertico.el

#+begin_src emacs-lisp
  (use-package vertico
    :straight t
    :config
    (vertico-mode)
    ;; Use `consult-completion-in-region' if Vertico is enabled.
    ;; Otherwise use the default `completion--in-region' function.
    (setq completion-in-region-function
	  (lambda (&rest args)
	    (apply (if vertico-mode
		       #'consult-completion-in-region
		     #'completion--in-region)
		   args)))
    (advice-add #'completing-read-multiple
		:override #'consult-completing-read-multiple)
    (setq vertico-cycle t))
#+end_src

*** Vertico Extensions

The ~vertico-indexed.elc~ extension adds a visual indicator of each candidate’s
index.  Further, I can type ~C-<num> ENT~ and select that candidate.  Often
it’s just as easy to navigate via ~TAB~ or ~C-n~ / ~C-p~ but the visual
indicator is a nice bit of polish.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-indexed.elc"
	nil
	jnf-silence-loading-log)
  (vertico-indexed-mode)
#+end_src

I’ve commented out the ~vertico-buffer.elc~ extension.  When active, instead of
using the mini-buffer it creates a new window.  I’m uncertain how I fully feel
about this function.  When I activate it, I’m sometimes “surprised” at a
different experience from what I’m accustomed to in Emacs.  Then again, at
least I’m not trapped in the recursive mini-buffer challenges.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-buffer.elc"
	nil
	jnf-silence-loading-log)
  (vertico-buffer-mode)
  (setq vertico-buffer-display-action
	'(display-buffer-at-bottom (window-height . 15)))
#+end_src

The ~vertico-repeat.elc~ extension does one simple thing: it remembers and
gives quick access to the last command you entered in the “minibuffer.”  This
can be super userful if I built up a complicated ~consult-ripgrep~.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-repeat.elc"
	nil
	jnf-silence-loading-log)
  (global-set-key (kbd "M-r") #'vertico-repeat)
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
#+end_src

Related to, but independent of ~vertico-repeat.elc~ is enabling
~savehist-mode~.  With that enabled, I have access to a few dozen of the last
minibuffer commands I issued.  These are, by default, in ~\~/.emacs.d/history~.

#+begin_src emacs-lisp
  (savehist-mode 1)
#+end_src

** Emacs Adjustments for Completion

What follows is adjustments to emacs settings as they relate to completion.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)

    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
	  '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src

** DONE marginalia.el

The ~marginalia~ package provides annotations to minibuffer completions; I
shudder to think how hard it would be to navigate Emacs’s ~M-x~ command without
annotations.

#+begin_src emacs-lisp
  (use-package marginalia
    :straight t
    :init (marginalia-mode))
#+end_src

/Note:/ The declaration of ~marginalia-mode~ must be in the ~;init~ section.
This ensures that it is enabled right away.  It also forces the loading of the
package.

** TODO consult.el

#+begin_src emacs-lisp
  ;; Example configuration for Consult
  ;; https://github.com/minad/consult
  (use-package consult
    :straight t
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
	   ("C-c h" . consult-history)
	   ;; ("C-c m" . consult-mode-command)
	   ("C-c b" . consult-bookmark)
	   ("C-c k" . consult-kmacro)
	   ;; C-x bindings (ctl-x-map)
	   ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complet-command
	   ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("s-b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
	   ("C-s-b" . consult-buffer-other-window)
	   ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
	   ;; Custom M-# bindings for fast register access
	   ("M-#" . consult-register-load)
	   ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
	   ("C-M-#" . consult-register)
	   ;; Other custom bindings
	   ("M-y" . consult-yank-from-kill-ring)                ;; orig. yank-pop
	   ("<help> a" . consult-apropos)            ;; orig. apropos-command
	   ;; M-g bindings (goto-map)
	   ("M-g e" . consult-compile-error)
	   ("M-g g" . consult-goto-line)             ;; orig. goto-line
	   ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
	   ("s-l" . consult-goto-line)           ;; orig. goto-line
	   ("M-g o" . consult-outline)
	   ("M-g m" . consult-mark)
	   ("M-g k" . consult-global-mark)
	   ("C-x C-SPC" . consult-mark)
	   ("M-g i" . consult-imenu)
	   ("M-g I" . consult-imenu-multi)
	   ;; M-s bindings (search-map)
	   ("M-s f" . consult-find)
	   ("M-s L" . consult-locate)
	   ("M-s g" . consult-grep)
	   ("M-s G" . consult-git-grep)
	   ("M-s r" . consult-ripgrep)
	   ("C-c f" . consult-ripgrep)
	   ("M-s l" . consult-line)
	   ("M-s m" . consult-multi-occur)
	   ("M-s k" . consult-keep-lines)
	   ("M-s u" . consult-focus-lines)
	   ;; Customizations that map to ivy
	   ("s-r" . consult-recent-file) ;; Deprecate
	   ("C-c r" . consult-recent-file)
	   ("C-c o" . consult-file-externally)
	   ("C-y" . yank)
	   ("C-s" . consult-line) ;; I've long favored Swiper mapped to c-s
	   ;; Isearch integration
	   ("M-s e" . consult-isearch)
	   ;; ("s-t" . jnf/consult-find-using-fd)
	   ;; ("s-3" . consult-imenu-multi)
	   :map isearch-mode-map
	   ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
	   ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
	   ("M-s l" . consult-line))                 ;; required by consult-line to detect isearch

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
	  register-preview-function #'consult-register-format)


    ;; From https://github.com/minad/consult/wiki#find-files-using-fd
    ;; Note: this requires lexical binding
    (defun jnf/consult-find-using-fd (&optional dir initial)
      "Find project files.

  A replacement for `projectile-find-file'."
      (interactive "P")
      (let ((consult-find-command "fd --color=never --hidden --exclude .git/ --full-path ARG OPTS"))
	(consult-find dir initial)))

    (defun jnf/consult-line (consult-line-function &rest rest)
      "Advising function around `CONSULT-LINE-FUNCTION'.

  When there's an active region, use that as the first parameter
  for `CONSULT-LINE-FUNCTION'.  Otherwise, use the current word as
  the first parameter.  This function handles the `REST' of the
  parameters."
      (interactive)
      (apply consult-line-function
	     (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
	     rest))

    (defun jnf/consult-ripgrep (consult-ripgrep-function &optional dir &rest rest)
      "Use region or thing at point to populate initial parameter for `CONSULT-RIPGREP-FUNCTION'.

  When there's an active region, use that as the initial parameter
  for the `CONSULT-RIPGREP-FUNCTION'.  Otherwise, use the thing at
  point.

  `DIR' use the universal argument (e.g. C-u prefix) to first set
  the directory.  `REST' is passed to the `CONSULT-RIPGREP-FUNCTION'."
      (interactive "P")
      (apply consult-ripgrep-function
	     dir
	     (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
	     rest))

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)
    (advice-add #'consult-line :around #'jnf/consult-line '((name . "wrapper")))
    (advice-add #'consult-ripgrep :around #'jnf/consult-ripgrep '((name . "wrapper")))

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
	  xref-show-definitions-function #'consult-xref)

    ;; Updating the default to include "--ignore-case"
    (setq consult-ripgrep-command "rg --null --line-buffered --color=ansi --max-columns=1000 --ignore-case --no-heading --line-number . -e ARG OPTS")

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. Note that the preview-key can also be
    ;; configured on a per-command basis via `consult-config'. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-p"))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; Probably not needed if you are using which-key.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; Optionally configure a function which returns the project root directory.
    ;; There are multiple reasonable alternatives to chose from:
    ;; * projectile-project-root
    ;; * vc-root-dir
    ;; * project-roots
    ;; * locate-dominating-file
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root)
    ;; (setq consult-project-root-function
    ;;       (lambda ()
    ;;         (when-let (project (project-current))
    ;;           (car (project-roots project)))))
    ;; (setq consult-project-root-function #'vc-root-dir)
    ;; (setq consult-project-root-function
    ;;       (lambda () (locate-dominating-file "." ".git")))
    )

#+end_src

** TODO consult-flycheck.el

#+begin_src emacs-lisp
  ;; Optionally add the `consult-flycheck' command.
  (use-package consult-flycheck
    :straight t
    :bind (:map flycheck-command-map
		("!" . consult-flycheck)))
#+end_src

** TODO embark.el

#+begin_src emacs-lisp

  ;; https://github.com/oantolin/embark
  (use-package embark
    :straight t
    :bind
    (("C-." . embark-act)       ;; pick some comfortable binding
     ("M-." . embark-dwim)
     ("C-s-e" . embark-export)
     ("C-h b" . embark-bindings))
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config

    ;;; BEGIN embark key macro target
    (defun embark-kmacro-target ()
      "Target a textual kmacro in braces."
      (save-excursion
	(let ((beg (progn (skip-chars-backward "^{}\n") (point)))
	      (end (progn (skip-chars-forward "^{}\n") (point))))
	  (when (and (eq (char-before beg) ?{) (eq (char-after end) ?}))
	    `(kmacro ,(buffer-substring-no-properties beg end)
		     . (,(1- beg) . ,(1+ end)))))))

    (add-to-list 'embark-target-finders 'embark-kmacro-target)

    (defun embark-kmacro-run (arg kmacro)
      (interactive "p\nsKmacro: ")
      (kmacro-call-macro arg t nil (kbd kmacro)))

    (defun embark-kmacro-save (kmacro)
      (interactive "sKmacro: ")
      (kmacro-push-ring)
      (setq last-kbd-macro (kbd kmacro)))

    (defun embark-kmacro-name (kmacro name)
      (interactive "sKmacro: \nSName: ")
      (let ((last-kbd-macro (kbd kmacro)))
	(kmacro-name-last-macro name)))

    (defun embark-kmacro-bind (kmacro)
      (interactive "sKmacro: \n")
      (let ((last-kbd-macro (kbd kmacro)))
	(kmacro-bind-to-key nil)))

    (embark-define-keymap embark-kmacro-map
      "Actions on kmacros."
      ("RET" embark-kmacro-run)
      ("s" embark-kmacro-save)
      ("n" embark-kmacro-name)
      ("b" embark-kmacro-bind))

    (add-to-list 'embark-keymap-alist '(kmacro . embark-kmacro-map))
    ;;; END embark key macro target
    (setq embark-action-indicator
	  (lambda (map &optional _target)
	    (which-key--show-keymap "Embark" map nil nil 'no-paging)
	    #'which-key--hide-popup-ignore-command)
	  embark-become-indicator embark-action-indicator)
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))

#+end_src

** TODO embark-consult.el

#+begin_src emacs-lisp

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :straight t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

** TODO wgrep.el

#+begin_src emacs-lisp

  ;; Useful for editing grep results:
  ;;
  ;; 1) "C-c f" invoke `consult-ripgrep'
  ;; 2) "C-s-e" invoke `embark-export' (On OS X map that's Ctrl+Cmd+e)
  ;; 3) "e" or "C-c C-p" invoke `wgrep-change-to-wgrep-mode'
  ;; 4) Save or cancel
  ;;    a) Save: "C-x C-s" invoke `save-buffer' (or "C-c C-c")
  ;;    b) Cancel: "C-c C-k"
  (use-package wgrep
    :after (embark-consult ripgrep)
    :straight t
    :bind (:map wgrep-mode-map
		;; Added keybinding to echo Magit behavior
		("C-c C-c" . save-buffer)
		:map grep-mode-map
		("e" . wgrep-change-to-wgrep-mode)
		:map ripgrep-search-mode-map
		("e" . wgrep-change-to-wgrep-mode)))
#+end_src

** TODO consult-lsp.el

#+begin_src emacs-lisp
  ;; https://github.com/gagbo/consult-lsp
  (use-package consult-lsp
    :after (consult lsp-mode)
    :straight (consult-lsp :host github :type git :repo "gagbo/consult-lsp")
    :config
    (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols)
    (consult-lsp-marginalia-mode)
    :commands consult-lsp-symbols)
#+end_src

** DONE orderless.el

The [[https://github.com/minad/orderless][orderless]] package provides completion tooling for non-strict word order.  I
spent considerable time reading through the [[https://github.com/minad/consult/wiki][Orderless section of Consult’s
wiki]].

As configured the orderless completion recognizes the following “switches”:

- Flex (~\~~) :: Just start typing characters and you’ll get matches that have
  those characters
- File Extension (~\.ext~) :: Match files with this extension.
- Regexp ~^.$~ :: Use some regular expression syntax
  - ~^~ matching beginning
  - ~.~ any ol’ character
  - ~$~ matching ending
- Initialism (~`~) :: In ~M-x~ when I typed ~`pl~ the ~previous-line~ function
  was a top match.  The initialism switch “explodes” the characters and says
  match methods who’s words start with those characters.
- Not Literal ~!~ :: Exclude candidates that match the literal
  (e.g. ~!previous~ won’t show ~previous-line~ in the ~M-x~ completion).
- Literal ~=~ :: No “fuzzy buziness”, just match exactly what I typed.

There is another case (e.g. ~%~ character fold) that I don’t yet understand.

More on these component matchings styles is available at [[https://github.com/minad/orderless#component-matching-styles][github.com/minad/orderless]].

#+begin_src emacs-lisp
  (use-package orderless
    :straight t
    :config
    (defvar +orderless-dispatch-alist
      '((?% . char-fold-to-regexp)
	(?! . orderless-without-literal)
	(?`. orderless-initialism)
	(?= . orderless-literal)
	(?~ . orderless-flex)))
    (defun +orderless-dispatch (pattern index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" pattern)
	`(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x100000-\x10FFFD]*$")))
       ;; File extensions
       ((and
	 ;; Completing filename or eshell
	 (or minibuffer-completing-file-name
	     (derived-mode-p 'eshell-mode))
	 ;; File extension
	 (string-match-p "\\`\\.." pattern))
	`(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x100000-\x10FFFD]*$")))
       ;; Ignore single !
       ((string= "!" pattern) `(orderless-literal . ""))
       ;; Prefix and suffix
       ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
	    (cons (cdr x) (substring pattern 1))
	  (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
	    (cons (cdr x) (substring pattern 0 -1)))))))

    ;; Define orderless style with initialism by default
    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

    ;; Certain dynamic completion tables (completion-table-dynamic)
    ;; do not work properly with orderless. One can add basic as a fallback.
    ;; Basic will only be used when orderless fails, which happens only for
    ;; these special tables.
    (setq completion-styles '(orderless basic)
	  completion-category-defaults nil
	    ;;; Enable partial-completion for files.
	    ;;; Either give orderless precedence or partial-completion.
	    ;;; Note that completion-category-overrides is not really an override,
	    ;;; but rather prepended to the default completion-styles.
	  ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
	  completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
					  ;; enable initialism by default for symbols
					  (command (styles +orderless-with-initialism))
					  (variable (styles +orderless-with-initialism))
					  (symbol (styles +orderless-with-initialism)))
	  orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
	  orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src

** DONE consult-projectile.el

The ~consult-projectile.el~ package provides a function I use everyday: ~M-x
consult-projectile~.  When I invoke ~consult-projectile~, I have the file
completion for the current project.  I can also type =b= + =SPACE= to narrow my
initial search to open buffers in the project.  Or =p= + =space= to narrow to
other projects; and then select a file within that project.


#+begin_src emacs-lisp
  (use-package consult-projectile
    :straight (consult-projectile
	       :type git
	       :host gitlab
	       :repo "OlMon/consult-projectile"
	       :branch "master")
    :bind ("s-t" . consult-projectile))
#+end_src

/Note:/ The =CMD= + =t= (e.g. ~s-t~ in Emacs) is a carryover from my [[https://macromates.com][Textmate]]
and [[https://www.sublimetext.com/][Sublime Text]] days.  More than any other key combination, that one is
entirely muscle memory.

** TODO corfu.el et al

#+begin_src emacs-lisp
  ;; Configure corfu
  (use-package corfu
    :straight t
    :demand t
    ;; Optionally use TAB for cycling, default is `corfu-complete'.
    :bind (:map corfu-map
		("TAB" . corfu-next)
		([tab] . corfu-next)
		("S-TAB" . corfu-previous)
		([backtab] . corfu-previous))
    :init

    ;; Recommended: Enable Corfu globally.
    ;; This is recommended since dabbrev can be used globally (M-/).
    (corfu-global-mode)

    :config
    ;; Optionally enable cycling for `corfu-next' and `corfu-previous'.
    (setq corfu-cycle t)
    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let (completion-cycle-threshold completion-cycling)
	(apply #'consult-completion-in-region completion-in-region--data)))
    (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer))

  ;; Dabbrev works with Corfu
  (use-package dabbrev
    :straight t
    ;; Swap M-/ and C-M-/
    :bind (("M-/" . dabbrev-completion)
	   ("C-M-/" . dabbrev-expand)))


  (use-package cape
    :straight t
    :bind (("C-c p" . completion-at-point)))

  (use-package emacs
    :straight nil
    :init
    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
    (setq read-extended-command-predicate
	  #'command-completion-default-include-p))
#+end_src

#+RESULTS:

* Window Manipulation

** DONE Tab Line

Show tabs in the current window.  The tab system is something I wrestle with,
but I appreciate it’s existence.  These configurations make it easier to use.

#+begin_src emacs-lisp
  (global-tab-line-mode t)
  (global-set-key (kbd "s-{") 'previous-buffer)
  (global-set-key (kbd "s-}") 'next-buffer)
#+end_src

** TODO buffer-move.el

From [[https://github.com/lukhas/buffer-move][lukhas/buffer-move]], this package helps me quickly move a window elsewhere.
As of <2022-02-01 Tue>, I don’t often use this command.  Consider it “on
notice” for removal.

#+begin_src emacs-lisp
  (use-package buffer-move
    :straight t
    :bind ("<C-s-f12>" . buf-move))
#+end_src

* Text Manipulation

** DONE titlecase.el

The rules of “titlecase” are confounding.  The ~titlecase.el~ package provides
numerous ways to cast a string to “titlecase.”  I chose wikipedia style as a
quasi-opinionated compromise.

#+begin_src emacs-lisp
  (use-package titlecase
    :straight (titlecase :host github :repo "duckwork/titlecase.el")
    :custom (titlecase-style 'wikipedia))
#+end_src

* In Buffer

** TODO savekill.el

#+begin_src emacs-lisp
  ;; Write "kill" command inputs to disk
  (use-package savekill
    :straight t)

#+end_src

** TODO link-hint.el

#+begin_src emacs-lisp
  ;; That letter is the beginning of a word. Narrow results from there.
  (use-package avy
    :bind (("C-j" . avy-goto-char-timer))
    ;; moved bind to enh-ruby-mode declaration
    ;; :bind (:map enh-ruby-mode-map ("C-j" . avy-goto-char-timer))
    :bind (:map org-mode-map ("C-j" . avy-goto-char-timer))
    :straight t)

  ;; (use-package link-hint
  ;;   :straight t
  ;;   :bind
  ;;   ("C-c l o" . link-hint-open-link)
  ;;   ("C-c l c" . link-hint-copy-link))
#+end_src

** TODO math-at-point.el

#+begin_src emacs-lisp
  ;; https://github.com/shankar2k/math-at-point
  (use-package math-at-point
    :straight (math-at-point :type git :host github :repo "shankar2k/math-at-point")
    :bind ("C-c =" . math-at-point))
#+end_src

** TODO which-key.el

#+begin_src emacs-lisp

  (use-package which-key
    :config (which-key-mode)
    :diminish 'which-key-mode
    :straight t)
#+end_src

** TODO writeroom-mode.el

#+begin_src emacs-lisp

  (use-package writeroom-mode
    :straight t)
#+end_src

** TODO vi-tilde-fringe.el

#+begin_src emacs-lisp

  (use-package vi-tilde-fringe
    :straight t
    :hook ((fundamental-mode) . vi-tilde-fringe-mode))
#+end_src

** TODO fill-sentences-correctly.el

#+begin_src emacs-lisp

  (use-package fill-sentences-correctly
    :straight (fill-sentences-correctly :host github :repo "duckwork/fill-sentences-correctly.el")
    :hook (fundamental-mode . fill-sentences-correctly-mode))
#+end_src

** TODO origami.el

#+begin_src emacs-lisp

  (use-package origami
    :straight t
    :hook (prog-mode . origami-mode))
#+end_src

** TODO hippie-exp.el

#+begin_src emacs-lisp

  ;; Using Hippie expand, I toggle through words already referenced.
  (use-package hippie-exp
    :straight t
    :config
    (setq hippie-expand-try-functions-list '(try-expand-dabbrev-visible
					     try-expand-dabbrev
					     try-expand-list
					     try-expand-all-abbrevs
					     try-expand-dabbrev-all-buffers
					     try-expand-dabbrev-from-kill
					     try-complete-file-name-partially
					     try-complete-file-name
					     try-complete-lisp-symbol-partially
					     try-complete-lisp-symbol
					     ))
    :bind (("M-SPC" . hippie-expand)))
#+end_src

** TODO expand-region.el

#+begin_src emacs-lisp

  ;; Expand or contract point/region to next logical element.
  ;;
  ;; NOTE: I use this all the time.
  (use-package expand-region
    :straight t
    :bind (("C-=" . er/expand-region)
	   ("C-+" . er/contract-region)))
#+end_src

** TODO string-inflection.el

#+begin_src emacs-lisp

  ;; This package allows me to toggle between different string cases.
  ;;
  ;; - HELLO WORLD
  ;; - HelloWorld
  ;; - helloWorld
  ;; - hello-world
  ;; - Hello_World
  ;; - hellow_world
  ;; - HELLO_WORLD
  (use-package string-inflection
    :bind (("C-M-s-i" . string-inflection-all-cycle))
    :straight (string-inflection :type git
				 :host github
				 :repo "akicho8/string-inflection"))
#+end_src

** TODO multiple-cursors.el

#+begin_src emacs-lisp

  ;; Allow to work with multipe cursors
  ;; https://melpa.org/#/multiple-cursors Aside from the
  ;; set-rectangular-region-anchor, there are several additional
  ;; features to practice
  (use-package multiple-cursors
    :bind (("C-M-SPC" . set-rectangular-region-anchor)
	   ("C->" . mc/mark-next-like-this)
	   ("C-<" . mc/mark-previous-like-this)
	   ("C-s-<mouse-1>" . mc/add-cursor-on-click)
	   ("C-c C->" . mc/mark-all-like-this)
	   ("C-c C-SPC" . mc/edit-lines)) ;; CTRL+CMD+c
    :straight t)
#+end_src

** TODO iedit.el

#+begin_src emacs-lisp

  ;; C-; to select current symbol and all matches; Then edit at multiple points.
  (use-package iedit
    :straight t)
#+end_src

** TODO crux.el

#+begin_src emacs-lisp

  ;; C-a goes to the first non-whitepsace character on the line. Type it
  ;; again, and go to the beginning of the line.
  (use-package crux
    :straight t
    :config
    (defun jnf/duplicate-current-line-or-lines-of-region (arg)
      "Duplicate ARG times current line or the lines of the current region."
      (interactive "p")
      (if (use-region-p)
	  (progn
	    (when (> (point) (mark))
	      (exchange-point-and-mark))
	    (beginning-of-line)
	    (exchange-point-and-mark)
	    (end-of-line)
	    (goto-char (+ (point) 1))
	    (exchange-point-and-mark)
	    (let* ((end (mark))
		   (beg (point))
		   (region
		    (buffer-substring-no-properties beg end)))
	      (dotimes (_i arg)
		(goto-char end)
		(insert region)
		(setq end (point)))))
	(crux-duplicate-current-line-or-region arg)))

    (cl-defun jnf/create-org-scratch-buffer (&key (mode 'org-mode))
      "Quickly open a scratch buffer and enable the given MODE."
      (interactive)
      (crux-create-scratch-buffer)
      (rename-buffer (concat "*scratch* at " (format-time-string "%Y-%m-%d %H:%M")))
      (funcall mode))
    :bind (("C-a" . crux-move-beginning-of-line)
	   ("<C-s-return>" . crux-smart-open-line-above)
	   ("C-s-k" . crux-kill-line-backwards)
	   ("<s-backspace>" . crux-kill-line-backwards)
	   ("C-M-d" . jnf/duplicate-current-line-or-lines-of-region)
	   ("C-c d" . jnf/duplicate-current-line-or-lines-of-region)
	   ("<f9>" . crux-kill-other-buffers)
	   ("<f12>" . jnf/create-org-scratch-buffer)))
#+end_src

** TODO ethan-wspace.el

#+begin_src emacs-lisp
  ;; Whitespace hygene package.  The author's documentation and
  ;; commentary echoes my sentiments
  (use-package ethan-wspace
    :straight t
    :hook (before-save . delete-trailing-whitespace)
    :init (setq-default mode-require-final-newline nil)
    :config (global-ethan-wspace-mode 1))
#+end_src

** TODO unfill.el

#+begin_src emacs-lisp
  ;; A package that is a bit of the inverse of 'fill-paragraph
  ;; (e.g. M-q).
  (use-package unfill
    :bind ("M-q" . unfill-toggle)
    :straight t)
#+end_src

** TODO undo-tree.el

#+begin_src emacs-lisp
  ;; Provides a UI for undo trees.  I'm not certain what I want to do
  ;; with this.
  (use-package undo-tree
    :diminish
    :bind (("C-z" . undo)
	   ("C-S-z" . undo-tree-redo))
    :config
    (global-undo-tree-mode +1)
    (unbind-key "M-_" undo-tree-map))

#+end_src

** TODO hungry-delete.el

#+begin_src emacs-lisp
  ;; Delete multiple spaces in one delete stroke
  (use-package hungry-delete
    :straight t
    :diminish 'hungry-delete-mode
    :config (global-hungry-delete-mode))

#+end_src

** TODO move-text.el

#+begin_src emacs-lisp
  ;; Adding ability to move lines up and down
  (use-package move-text
    :straight t
    :bind (([C-s-down] . move-text-down)
	   ([C-s-up] . move-text-up)))
#+end_src

** TODO rainbow-delimiters.el

#+begin_src emacs-lisp
  ;; A quick and useful visual queue for paranthesis
  (use-package rainbow-delimiters
    :straight t
    :hook ((fundamental-mode) . rainbow-delimiters-mode))
#+end_src

** TODO emojify.el

#+begin_src emacs-lisp
  (use-package emojify
    :straight t
    :config
    (defun --set-emoji-font (frame)
      "Adjust the font settings of FRAME so Emacs can display emoji properly."
      (if (eq system-type 'darwin)
	  ;; For NS/Cocoa
	  (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
	;; For Linux
	(set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))

    ;; For when Emacs is started in GUI mode:
    (--set-emoji-font nil)
    ;; Hook for when a frame is created with emacsclient
    ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
    (add-hook 'after-make-frame-functions '--set-emoji-font))
#+end_src

** TODO hl-sentence.el

#+begin_src emacs-lisp
  ;; Provide sentence highlighting.  Which is nice when thinking about
  ;; writing.  But don't turn it on by default as it's somewhat
  ;; disruptive.
  (use-package hl-sentence
    :straight t)
#+end_src

** TODO unicode-fonts.el

#+begin_src emacs-lisp
  (use-package unicode-fonts
    :straight t
    :ensure t
    :config (unicode-fonts-setup))
#+end_src

** TODO yasnippet.el

#+begin_src emacs-lisp
  ;; A rather convenient snippet manager.  When you create a snippet, it
  ;; understands the mode you're in and puts the snippet in the right
  ;; place.
  (use-package yasnippet
    :straight t
    :diminish yas-mode
    :init (setq yas-snippet-dirs '("~/git/dotemacs/snippets"))
    (yas-global-mode 1))
#+end_src

** TODO consult-yasnippet.el

#+begin_src emacs-lisp
  (use-package consult-yasnippet
    :straight t
    :after (consult yasnippet)
    :bind ("C-c y" . consult-yasnippet))
#+end_src

** TODO tempel.el

#+begin_src emacs-lisp
  (use-package tempel
    :straight (tempel :host github :repo "minad/tempel")
    :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
	   ("M-*" . tempel-insert))

    :init

    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; The depth is set to -1, such that `tempel-expand' is tried *before* the
      ;; programming mode Capf. If a template name can be completed it takes
      ;; precedence over the programming mode completion. `tempel-expand' only
      ;; triggers on exact matches. Alternatively use `tempel-complete' if you
      ;; want to see all matches, but then Tempel will probably trigger too
      ;; often when you don't expect it.
      (add-hook 'completion-at-point-functions #'tempel-expand -1 'local))

    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)

    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
    ;; (tempel-global-abbrev-mode)
    )

#+end_src

** TODO goggles.el

#+begin_src emacs-lisp

  ;; I kind of like this little bit of visual feedback
  (use-package goggles
    :straight t
    :hook ((prog-mode text-mode) . goggles-mode)
    :diminish 'goggles-mode
    :config
    (setq-default goggles-pulse t)) ;; set to nil to disable pulsing
#+end_src

** TODO whole-line-or-region

#+begin_src emacs-lisp

  (use-package whole-line-or-region
    :straight t
    :diminish 'whole-line-or-region-local-mode
    :config (whole-line-or-region-global-mode))
#+end_src

** TODO smartparens.el

#+begin_src emacs-lisp
  (use-package smartparens
    :straight t)
  ;;******************************************************************************
  ;;
    ;;; END Use External Packages
  ;;
  ;;******************************************************************************

#+end_src

** TODO Functions

#+begin_src emacs-lisp

  ;;******************************************************************************
  ;;
    ;;; BEGIN Custom "in-buffer" functions
  ;;
  ;;******************************************************************************
  (global-set-key (kbd "C-w") 'jnf/kill-region-or-backward-word)
  (global-set-key (kbd "M-DEL") 'jnf/kill-region-or-backward-word)
  (global-set-key (kbd "<C-M-backspace>") 'backward-kill-paragraph)
  (defun jnf/kill-region-or-backward-word (&optional arg)
    "Kill selected region otherwise kill backwards the ARG number of words."
    (interactive "p")
    (if (region-active-p)
	(kill-region (region-beginning) (region-end))
      (backward-kill-word arg)))

  (global-set-key (kbd "C-k") 'jnf/kill-line-or-region)
  (defun jnf/kill-line-or-region (&optional ARG)
    "Kill the selected region otherwise kill the ARG number of lines."
    (interactive "P")
    (if (use-region-p)
	(kill-region (region-beginning) (region-end))
      (kill-line ARG)))

  (global-set-key (kbd "C-c n") 'jnf/nab-file-name-to-clipboard)
  (defun jnf/nab-file-name-to-clipboard ()
    "Nab, I mean copy, the current buffer file name to the clipboard.

    If you provide universal prefix (e.g. C-u), return the base
    filename.  Otherwise, use the full filename path."
    ;; https://blog.sumtypeofway.com/posts/emacs-config.html
    (interactive)
    (let* ((raw-filename
	    (if (equal major-mode 'dired-mode) default-directory (buffer-file-name)))
	   (filename
	    (if (equal current-prefix-arg nil) raw-filename (file-name-nondirectory raw-filename))))
      (when filename
	(kill-new filename)
	(message "Copied buffer file name '%s' to the clipboard." filename))))

  (defun jnf/sort-unique-lines (reverse beg end &optional adjacent keep-blanks interactive)
    "Sort lines and delete duplicates.
    By default the sort is lexigraphically ascending.  To sort as
    descending set REVERSE to non-nil.  Specify BEG and END for the
    bounds of sorting.  By default, this is the selected region.

    I've included ADJACENT, KEEP-BLANKS, and INTERACTIVE so I can
    echo the method signature of `'delete-duplicate-lines`"
    ;; This is a common function that I've used in other text editors.
    ;; It's a simple stitch together of sort-lines and
    ;; delete-duplicate-lines.
    (interactive "P\nr")
    (sort-lines reverse beg end)
    (delete-duplicate-lines beg end reverse adjacent keep-blanks interactive))

  (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
  (global-set-key (kbd "s-w") 'kill-current-buffer)

  ;; Treat dashes and underscores as part of words for navigation
  ;; (global-superword-mode t)

  (global-set-key (kbd "C-s-\\") 'jnf/display-buffer-in-side-window)
  (cl-defun jnf/display-buffer-in-side-window (&optional (buffer (current-buffer)))
    "Display BUFFER in dedicated side window."
    (interactive)
    (let ((display-buffer-mark-dedicated t))
      (display-buffer-in-side-window buffer
				     '((side . right)
				       (window-parameters
					(no-delete-other-windows . t))))))

  (global-set-key (kbd "C-s--") 'jnf/display-buffer-in-bottom-window)
  (cl-defun jnf/display-buffer-in-bottom-window (&optional (buffer (current-buffer)))
    "Display BUFFER in dedicated side window."
    (interactive)
    (let ((display-buffer-mark-dedicated t))
      (display-buffer-in-side-window buffer
				     '((side . bottom)
				       (window-parameters
					(no-delete-other-windows . t))))))

  ;; I'm a little uncertain how to handle this.
  ;; https://depp.brause.cc/shackle/
  (use-package shackle
    :straight t
    :custom
    (shackle-rules '((compilation-mode :noselect t))
		   shackle-default-rule '(:select t)))

  (bind-key "C-x m" #'jnf/move-file)
  (defun jnf/move-file (target-directory)
    "Write this file to TARGET-DIRECTORY, and delete old one."
    (interactive "DTarget Directory: ")
    (let* ((source (expand-file-name (file-name-nondirectory (buffer-name)) default-directory))
	   (target (f-join target-directory (file-name-nondirectory (buffer-name)))))
      (save-buffer)
      (rename-file source target)
      (kill-current-buffer)))
#+end_src

* Org Mode

** TODO org-mode.el

#+begin_src emacs-lisp
  ;; Consider https://github.com/jkitchin/org-ref as well

  (cl-defun jnf/org-agenda-files (&key paths basenames)
    "Return the list of filenames where BASENAMES exists in PATHS."
    (setq returning-list '())
    (dolist (path paths)
      (dolist (basename basenames)
	(if (f-exists-p (f-join path basename))
	    (add-to-list 'returning-list (f-join path basename)))))
    returning-list)

  (use-package org
    ;; :straight t
    ;; :straight (org
    ;;            :type git
    ;;            :url "https://git.savannah.gnu.org/git/emacs/org-mode.git"
    ;;            :commit "73875939a8b5545ac53a86ec467239f510d14de8" ;; 9.5 stable
    ;;            )
    :straight (org :type built-in)
    :hook (org-mode . turn-on-visual-line-mode)
    :config (setq
	     org-directory (file-truename "~/git/org")
	     org-agenda-files (jnf/org-agenda-files
			       :paths jnf/data-directories
			       :basenames '("agenda.org"))
	     org-default-notes-file (concat org-directory "/captured-notes.org")
	     ;; org-startup-indented t
	     org-todo-keywords
	     '((sequence "TODO" "WAITING" "|" "DONE")
	       (sequence "PENDING" "TODO" "WAITING" "|" "READ")))
    (setq org-capture-templates
	  '(
	    ("@" "All Todo" entry (file "~/git/org/agenda.org")
	     "* TODO %?\n  %i\n  %a" :empty-lines-before 1)))

    ;; https://xenodium.com/emacs-dwim-do-what-i-mean/
    (defun jnf/org-insert-link-dwim ()
      "Like `org-insert-link' but with personal dwim preferences."
      (interactive)
      (let* ((point-in-link (org-in-regexp org-link-any-re 1))
	     (clipboard-url (when (string-match-p "^http" (current-kill 0))
			      (current-kill 0)))
	     (region-content (when (region-active-p)
			       (buffer-substring-no-properties (region-beginning)
							       (region-end)))))
	(cond ((and region-content clipboard-url (not point-in-link))
	       (delete-region (region-beginning) (region-end))
	       (insert (org-make-link-string clipboard-url region-content)))
	      ((and clipboard-url (not point-in-link))
	       (insert (org-make-link-string
			clipboard-url
			(read-string "title: "
				     (with-current-buffer (url-retrieve-synchronously clipboard-url)
				       (dom-text (car
						  (dom-by-tag (libxml-parse-html-region
							       (point-min)
							       (point-max))
							      'title))))))))
	      (t
	       (call-interactively 'org-insert-link)))))

    (defun org-files-names-in-project-list ()
      "Return a list of filenames in the current files directory."
      (split-string-and-unquote
       (shell-command-to-string
	(concat
	 "ls " (file-name-directory buffer-file-name)))))


    (org-babel-do-load-languages 'org-babel-load-languages
				 (append org-babel-load-languages
					 '((emacs-lisp . t)
					   (plantuml . t)
					   (ruby . t))))
    ;; Make TAB act as if it were issued from the buffer of the languages's major mode.
    :custom (org-src-tab-acts-natively t)
    :bind (
	   :map org-mode-map
	   ("C-c l i". jnf/org-insert-link-dwim))
    :bind (
	   ("C-c l s" . org-store-link)
	   ("C-c a" . org-agenda)
	   ("C-c c" . org-capture)
	   ("C-s-t" . org-toggle-link-display)))

  (defun my-org-confirm-babel-evaluate (lang body) nil)
  (setq org-confirm-babel-evaluate #'my-org-confirm-babel-evaluate)

  ;; To make Org mode take care of versioning of attachments for you,
  ;; add the following to your Emacs config:
  (require 'org-attach-git)

  ;; See
  ;; https://www.reddit.com/r/orgmode/comments/i6hl8b/image_preview_size_in_org_mode/
  ;; for further discussion
  ;;
  ;; One consideration is that the below setq should be called as part
  ;; of the `org-toggle-inline-images`.  <2020-11-14 Sat 12:09>: I
  ;; commented out the lines below as it created a very small image
  ;; (about the size of one character).  (setq org-image-actual-width
  ;; (truncate (* (window-pixel-width) 0.8)))


  ;; I'd prefer to use the executable, but that doe not appear to be the
  ;; implementation of org-babel.
  (setq org-plantuml-jar-path (concat (string-trim (shell-command-to-string "brew-path plantuml")) "/libexec/plantuml.jar"))
#+end_src

** TODO org-contrib.el

I like the ~org-toc~ package.  I can toggle on the table of contents for
navigation.  Particularly useful for a large configuration.org file like this
one.

#+begin_src emacs-lisp
  (use-package org-contrib
    :straight (org-contrib :url "git.sr.ht/~bzg/org-contrib"))
  (require 'org-toc)
#+end_src

** TODO company-org-block.el

#+begin_src emacs-lisp
  ;; https://github.com/xenodium/company-org-block
  ;; (use-package company-org-block
  ;;   :straight t
  ;;   :after (org company)
  ;;   :custom
  ;;   (company-org-block-edit-style 'auto) ;; 'auto, 'prompt, or 'inline
  ;;   :hook ((org-mode . (lambda ()
  ;;                        (setq-local company-backends '(company-org-block))
  ;;                        (company-mode +1)))))
#+end_src

** TODO functions

#+begin_src emacs-lisp
  ;; ;; Insert immediate timestamp at point.
  (defun jnf/org-insert-immediate-active-timestamp ()
    "Insert an active date for today.  If given the universal arg (e.g., C-u) insert a timestamp instead."
    (interactive)
    (if (equal current-prefix-arg nil) ; no C-u
	(org-insert-time-stamp nil nil nil)
      (org-insert-time-stamp nil t nil)))

  (global-set-key (kbd "s-5") 'jnf/org-insert-immediate-active-timestamp)

  ;; ;; https://kitchingroup.cheme.cmu.edu/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/
  (defun jnf/formatted-copy-org-to-html ()
    "Export region to HTML, and copy it to the clipboard."
    (interactive)
    (save-window-excursion
      (let* ((buf (org-export-to-buffer 'html "*Formatted Copy*" nil nil t t))
	     (html (with-current-buffer buf (buffer-string))))
	(with-current-buffer buf
	  (shell-command-on-region
	   (point-min)
	   (point-max)
	   "textutil -stdin -format html -convert rtf -stdout | pbcopy"))
	(kill-buffer buf))))
  (global-set-key (kbd "C-M-s-c") 'jnf/formatted-copy-org-to-html)

  (eval-after-load 'ox '(require 'ox-koma-letter))

  (eval-after-load 'ox-koma-letter
    '(progn
       (add-to-list 'org-latex-classes
		    '("jnf-letter"
		      "\\documentclass\{scrlttr2\}
       \\usepackage[english]{babel}
       \\setkomavar{frombank}{(1234)\\,567\\,890}
       \[DEFAULT-PACKAGES]
       \[PACKAGES]
       \[EXTRA]"))

       (setq org-koma-letter-default-class "jnf-letter")))
#+end_src

#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; BEGIN Hacks for ORG to type a bit more like markdown
  ;;
  ;; See http://mbork.pl/2022-01-17_Making_code_snippets_in_Org-mode_easier_to_type
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defun org-insert-backtick ()
    "Insert a backtick using `org-self-insert-command'."
    (interactive)
    (setq last-command-event ?`)
    (call-interactively #'org-self-insert-command))

  (defun org-insert-tilde ()
    "Insert a tilde using `org-self-insert-command'."
    (interactive)
    (setq last-command-event ?~)
    (call-interactively #'org-self-insert-command))

  (define-key org-mode-map (kbd "`") #'org-insert-tilde)
  (define-key org-mode-map (kbd "~") #'org-insert-backtick)
  (defvar-local org-insert-tilde-language nil
    "Default language name in the current Org file.
  If nil, `org-insert-tilde' after 2 tildes inserts an \"example\"
  block.  If a string, it inserts a \"src\" block with the given
  language name.")

  (defun org-insert-tilde ()
    "Insert a tilde using `org-self-insert-command'."
    (interactive)
    (if (string= (buffer-substring-no-properties (- (point) 3) (point))
		 "\n~~")
	(progn (delete-char -2)
	       (if org-insert-tilde-language
		   (insert (format "#+begin_src %s\n#+end_src"
				   org-insert-tilde-language))
		 (insert "#+begin_example\n#+end_example"))
	       (forward-line -1)
	       (if (string= org-insert-tilde-language "")
		   (move-end-of-line nil)
		 (org-edit-special)))
      (setq last-command-event ?~)
      (call-interactively #'org-self-insert-command)))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; END Hacks for ORG to type a bit more like markdown
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

#+begin_src emacs-lisp
  ;; Context dependent menu for org-mode.
  (use-package org-menu
    :straight (org-menu :host github :repo "sheijk/org-menu")
    :bind (:map org-mode-map ("C-c m" . 'org-menu)))
#+end_src

** TODO org-roam.el

This is my third iteration on an ~org-roam~.  It's goal is to address use-cases
that I've encountered while moving more of my note-taking with ~org-roam~.

One use-case is when I'm running or playing in an RPG session.  During those
sessions, when I create/find/insert nodes, I almost certainly want to use the
same tag filter.  This is something I observed while running my 13 session
"Thel Sector" campaign.

A second use-case is when I'm writing notes or thoughts related to work.  In a
past life, I might have written notes for either my employer or Samvera (a
community in which I participated).  Those notes might overlap but rarely did.

Another use case is less refined, namely I'm writing but am not "in" a specific
context.

However, v2 of my org-roam structure, didn't quite get out of the way.  I never
quite got to the speed of note taking that I had for the original Thel Sector
campaign.

What follows builds on Jethro Kuan's [[https://jethrokuan.github.io/org-roam-guide/][How I Take Notes with Org-roam]].  Reading
Jethro Kuan's post helped me see how I could do this.

The ~jnf/org-context-plist~ defines and names some of the contexts in which I
might be writing.  Each named context defines the tags.  These are the tags
that all nodes will have when they were written in the defined context.

I can use ~jnf/org-auto-tags--set~ to create a "yet to be named" context (e.g.,
an ad hoc context).  Or I can use ~jnf/org-auto-tags--set-by-context~ to
establish the current context (or clear it).

#+begin_src emacs-lisp
  (defvar jnf/org-roam-capture-templates-plist
    (list
     ;; These are references to "other people's thoughts."
     :refs '("r" "refs" plain "%?"
	     :if-new (file+head "refs/%<%Y%m%d>---${slug}.org" "#+title: ${title}\n#+FILETAGS:\n")
	     :unnarrowed t)
     ;; These are "my thoughts" with references to "other people's thoughts."
     :main '("m" "main" plain "%?"
	     :if-new (file+head "main/%<%Y%m%d>---${slug}.org"
				"#+title: ${title}\n#+FILETAGS: ${auto-tags}%^G\n")
	     :immediate-finish t
	     :unnarrowed t)
     ;; These are publications of "my thoughts" referencing "other people's thoughts".
     :pubs '("p" "pubs" plain "%?"
	     :if-new (file+head "pubs/%<%Y%m%d>---${slug}.org" "#+title: ${title}\n#+FILETAGS:\n")
	     :immediate-finish t
	     :unnarrowed t))
    "Templates to use for `org-roam' capture.")

  (defvar jnf/org-context-plist
    (list
     :none (list
	    :name "none"
	    :tags (list))
     :burning-locusts (list
		       :name "burning-locusts"
		       :tags '("burning-locusts" "rpg" "burning-wheel"))
     :forem (list
	     :name "forem"
	     :tags '("forem"))
     :mistimed-scroll (list
		       :name "mistimed-scroll"
		       :tags '("eberron" "mistimed-scroll" "rpg" "burning-wheel"))
     :thel-sector (list
		   :name "thel-sector"
		   :tags '("thel-sector" "rpg" "swn")))
    "A list of contexts that I regularly write about.")

  (defvar jnf/org-auto-tags--current-list
    (list)
    "The list of tags to automatically apply to an `org-roam' capture.")

  (defun jnf/org-auto-tags--set (tags)
    "Prompt user or more TAGS."
    (interactive
     (list (completing-read-multiple "Tag(s): " (org-roam-tag-completions))))
    (setq jnf/org-auto-tags--current-list tags))

  (cl-defun jnf/org-auto-tags--set-by-context (context &key (context-plist jnf/org-context-plist))
    "Set auto-tags by CONTEXT.

     Prompt for CONTEXT from CONTEXT-PLIST."
    (interactive (list
		  (completing-read
		   "Context: " (jnf/org-context-list-completing-read))))
    (setq jnf/org-auto-tags--current-list
	  (plist-get (plist-get context-plist (intern (concat ":" context))) :tags)))

  (cl-defun org-roam-node-auto-tags (node &key (tag-list jnf/org-auto-tags--current-list))
    "Inject the TAG-LIST into the {auto-tags} region of captured NODE.

     See https://www.orgroam.com/manual.html#Template-Walkthrough"
    (if (and tag-list (> (length tag-list) 0))
	(concat ":" (s-join ":" tag-list) ":")
      ""))

  (cl-defun jnf/org-roam-templates-list (template &key (template-plist jnf/org-roam-capture-templates-plist))
    "List of `org-roam' capture templates based on given TEMPLATE.

     Searches the TEMPLATE-PLIST for the templates.

     Note, the :all template assumes we use the whole list."
    (if (eq template :all)
	(-non-nil (seq-map-indexed (lambda (tmp index)
				     (when (oddp index)
				       tmp))
				   template-plist))
      (list (plist-get template-plist template))))

  (cl-defun jnf/org-roam-templates-context-fn (&key (tag-list jnf/org-auto-tags--current-list))
    "Returns a set of templates based on TAG-LIST.

     A key assumption is that if there's a default tag list, use the
     :main template."
    (if (and tag-list (> (length tag-list) 0))
	(jnf/org-roam-templates-list :main)
      (jnf/org-roam-templates-list :all)))

  (cl-defun jnf/org-context-list-completing-read (&key
						  (context-plist
						   jnf/org-context-plist))
    "Create a list from the CONTEXT-PLIST for completing read.

     The form should be '((\"forem\" 1) (\"burning-loscusts\" 2))."
    ;; Skipping the even entries as those are the "keys" for the plist,
    ;; the odds are the values.
    (-non-nil (seq-map-indexed (lambda (context index)
				 (when (oddp index)
				   (list (plist-get context :name) index)))
			       context-plist)))

  (cl-defun jnf/org-roam-capture-ref (&key title ref)
    "Capture the TITLE and REF in the :refs template"
    (org-roam-capture-
     :keys "r"
     ;; TODO: I would love to get tags working but I'm missing something
     :node (org-roam-node-create :title title)
     :info (list :ref ref)
     :templates (jnf/org-roam-templates-list :refs)))

  (cl-defun jnf/org-roam-filter-context-fn (node &key (tag-list jnf/org-auto-tags--current-list))
    "Determine TAG-LIST is subset of NODE's tags."
    (gnus-subsetp tag-list (org-roam-node-tags node)))

     ;;; BEGIN org-roam declaration
  (use-package org-roam
    :straight t
    :config
    ;; I encountered the following message when attempting to export data:
    ;;
    ;; => "org-export-data: Unable to resolve link: EXISTING-PROPERTY-ID"
    ;;
    ;; See https://takeonrules.com/2022/01/11/resolving-an-unable-to-resolve-link-error-for-org-mode-in-emacs/ for details
    (defun jnf/force-org-rebuild-cache ()
      "Call some functions to rebuild the `org-mode' and `org-roam' cache."
      (interactive)
      (org-id-update-id-locations)
      ;; Note: you may need `org-roam-db-clear-all' followed by `org-roam-db-sync'
      (org-roam-db-sync)
      (org-roam-update-org-id-locations))
    (defun jnf/org-roam-capture (&optional goto keys)
      "Call `org-roam-capture' based on set tags."
      (interactive "P")
      (org-roam-capture goto
			keys
			:filter-fn 'jnf/org-roam-filter-context-fn
			:templates (jnf/org-roam-templates-context-fn)))

    (defun jnf/org-roam-node-insert ()
      "Call `org-roam-node-insert' based on set tags."
      (interactive)
      (org-roam-node-insert 'jnf/org-roam-filter-context-fn
			    :templates 'jnf/org-roam-templates-context-fn))

    (defun jnf/org-roam-find-node (&optional other-window initial-input)
      "Call `org-roam-node-find' based on set tags."
      (interactive current-prefix-arg)
      (org-roam-node-find other-window
			  initial-input
			  'jnf/org-roam-filter-context-fn
			  :templates 'jnf/org-roam-templates-context-fn))
    :custom
    (org-roam-directory (file-truename "~/git/org"))
    ;; Set more spaces for tags; As much as I prefer the old format,
    ;; this is the new path forward.
    (org-roam-node-display-template
     (concat "${type:4}   ${title:*} " (propertize "${tags:40}" 'face 'org-tag)))
    (org-roam-capture-templates (jnf/org-roam-templates-list :all))
    :bind (("C-s-f" . jnf/org-roam-find-node)
	   ("C-s-c" . jnf/org-roam-capture))
    :bind (:map org-mode-map (
			      ("C-s-;" . org-roam-buffer-toggle)
			      ("s-i" . jnf/org-roam-node-insert)))
    :init
    ;; Help keep the `org-roam-buffer', toggled via `org-roam-buffer-toggle', sticky.
    (add-to-list 'display-buffer-alist
		 '("\\*org-roam\\#"
		   (display-buffer-in-side-window)
		   (side . right)
		   (slot . 0)
		   (window-width . 0.33)
		   (window-parameters . ((no-other-window . t)
					 (no-delete-other-windows . t)))))
    ;; When t the autocomplete in org documents will query the org roam database
    (setq org-roam-completion-everywhere t)
    (setq org-roam-v2-ack t)
    (org-roam-db-autosync-mode))

  ;; This needs to be after the `org-roam’ declaration as it is dependent on the
  ;; structures of `org-roam'.

  (cl-defmethod org-roam-node-type ((node org-roam-node))
    "Return the TYPE of NODE."
    (condition-case nil
	(file-name-nondirectory
	 (directory-file-name
	  (file-name-directory
	   (file-relative-name (org-roam-node-file node) org-roam-directory))))
      (error "")))
#+end_src

* Spelling

This package provides configuration for spell checking.  It
assumes the use of ivy; See the flyspell-correct-ivy package.

By default, I don't render hints for spell checking nor grammar
checking.  Instead I rely on two checks:

1. flyspell-buffer (via kbd "C-,")
2. writegood-mode (via kbd "C-c w")

Once I've called flyspell-buffer, I can then navigate through
identified issues and address them via flyspell-popup-correct (via
kbd "C-").

** TODO flycheck.el

#+begin_src emacs-lisp
  (use-package flycheck
    :straight t
    :hook
    (org-src-mode . disable-flycheck-for-elisp)
    (after-init-hook . global-flycheck-mode)
    :custom
    (flycheck-display-errors-delay 0.1)
    (flycheck-emacs-lisp-initialize-packages t)
    :config
    (flycheck-set-indication-mode 'left-margin)

    (defun disable-flycheck-for-elisp ()
      (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

    (add-to-list 'flycheck-checkers 'proselint))
  ;; (add-hook 'after-init-hook #'global-flycheck-mode)
#+end_src

** TODO flyspell-correct

#+begin_src emacs-lisp
  (use-package flyspell-correct
    :straight t)

  (eval-when-compile (require 'cl-lib))

  (defun append-aspell-word (new-word)
    "Append the given NEW-WORD to the current dictionary, and reload the dictionary."
    (let ((header "personal_ws-1.1")
	  (file-name (substitute-in-file-name "$HOME/.aspell.en.pws"))
	  (read-words (lambda (file-name)
			(let ((all-lines (with-temp-buffer
					   (insert-file-contents file-name)
					   (split-string (buffer-string) "\n" t))))
			  (if (null all-lines)
			      ""
			    (split-string (mapconcat 'identity (cdr all-lines) "\n")
					  nil
					  t))))))
      (when (file-readable-p file-name)
	(let* ((cur-words (eval (list read-words file-name)))
	       (all-words (delq header (cons new-word cur-words)))
	       (words (delq nil (remove-duplicates all-words :test 'string=))))
	  (with-temp-file file-name
	    (insert (concat header
			    " en "
			    (number-to-string (length words))
			    "\n"
			    (mapconcat 'identity (sort words #'string<) "\n"))))))
      (unless (file-readable-p file-name)
	(with-temp-file file-name
	  (insert (concat header " en 1\n" new-word "\n")))))
    (ispell-kill-ispell t) ; restart ispell
    (flyspell-mode))

  (defun append-current-word-to-aspell-dictionary ()
    "Add current word to aspell dictionary."
    (interactive)
    (append-aspell-word (thing-at-point 'word)))

  (setq ispell-program-name "aspell"
	;; force the English dictionary, support Camel Case spelling check (tested with aspell 0.6)
	ispell-extra-args '("--sug-mode=ultra" "--lang=en_US" "--run-together"))
#+end_src

** TODO flyspell-popup.el

#+begin_src emacs-lisp
  ;; Run flyspell-buffer
  (use-package flyspell-popup
    :straight t
    :hook (flyspell-mode . flyspell-popup-auto-correct-mode))
#+end_src

** TODO writegood-mode.el

#+begin_src emacs-lisp
  ;; For grammar nerd
  (use-package writegood-mode
    :straight t
    :bind ("C-c w" . writegood-mode)
    :config
    (add-to-list 'writegood-weasel-words "actionable"))
#+end_src

* TODO Typography

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  This package serves the purpose of assisting with adding
  ;;  characters that are not readily available on an ANSI keyboard.
  ;;
  ;;; Code:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; BEGIN Typography Menu
  ;;
  ;;  The purpose of the typography menu is to provide easier access to
  ;;  typographic characters that I use; It also provides a bit of a
  ;;  mnemonic device (e.g. "C-x 8 RET" searches for a character to insert).
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defvar jnf/typography--title
    (with-octicon "pencil" "Typography (C-x 8 RET for Search)" 1 -0.05)
    "The menu title for typography")
  (pretty-hydra-define jnf/typography--menu (:foreign-keys warn :title jnf/typography--title :quit-key "q" :exit t)
    ("Characters" (
		   ("d d" (insert "-") "- dash")
		   ("d m" (insert "—") "— em dash")
		   ("d n" (insert "–") "– en dash")
		   (". e" (insert "…") "… ellipsis")
		   (". d" (insert "·") "º degree")
		   (". m" (insert "·") "· middot")
		   ("t d" (insert "†") "† dagger")
		   ("t 2" (insert "‡") "‡ double dagger")
		   ("t s" (insert "§") "§ section")
		   ("t p" (insert "¶") "¶ paragraph")
		   ("? !" (insert "‽") "‽ Interobang")
		   )
     "Math" (
	     ("a x" (insert "×") "× Multiplication Sign")
	     ("a d" (insert "÷") "÷ Division Sign")
	     ("a m" (insert "−") "− Minus Sign")
	     ("a p" (insert "±") "± Plus or Minus Sign")
	     ("m n" (insert "¬") "¬ Negation")
	     ;; For declaring regex functions.  See
	     ;; https://www.johndcook.com/blog/2022/01/08/corner-quotes-in-unicode/
	     ;; and https://irreal.org/blog/?p=10265
	     ("c l" (insert "⌜") "⌜ Left Corner Quote")
	     ("c r" (insert " ⌟") "⌟ Right Corner Quote")
	     ;; Included as a reminder as I use these for menu structures
	     ("f h"   (insert "─") "─ Forms light horizontal")
	     ("f D l" (insert "┐") "┐ Forms light down and left")
	     ("f v"   (insert "│") "│ Forms light vertical")
	     ("f V r" (insert "├") "├ Forms light vertical and right")
	     ("f U r" (insert "└") "└ Forms light up and right")
	     )
     "Quotes" (
	       ("\" o" (insert "“") "“ Double quote open")
	       ("\" c" (insert "”") "” Doule quote close")
	       ("\" O" (insert "«") "« Guillemet open")
	       ("\" C" (insert "»") "» Guillemet close")
	       ("\" l" (insert "⌈") "⌈ Left ceiling")
	       ("' o" (insert "‘") "‘ Single quote open")
	       ("' c" (insert "’") "’ Single quote close")
	       ("' O" (insert "‹") "‹ Single guillemet open")
	       ("' C" (insert "›") "› Single guillemet close")
	       ("p 1" (insert "′") "′ Single Prime (feet, arcminutes)")
	       ("p 2" (insert "″") "″ Double Prime (inches, arcseconds)")
	       ("p 3" (insert "‴") "‴ Triple Prime"))
     ))

  (global-set-key (kbd "C-s-8") 'jnf/typography--menu/body)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; END Typography Menu
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+end_src

** TODO typopunct.el

#+begin_src emacs-lisp
  (use-package typopunct
    :straight t
    :config
    (add-hook 'org-mode-hook 'jnf/typopunct-init)
    (defun jnf/typopunct-init ()
      (require 'typopunct)
      (typopunct-change-language 'english)
      (typopunct-mode 1))
    (setq typopunct-buffer-language 'english)

    ;; To insert a typographical ellipsis sign (…) on three consecutive
    ;; dots, or a middle dot (·) on ‘^.’
    (defconst typopunct-ellipsis (decode-char 'ucs #x2026))
    (defconst typopunct-middot   (decode-char 'ucs #xB7)) ; or 2219
    (defun typopunct-insert-ellipsis-or-middot (arg)
      "Change three consecutive dots to a typographical ellipsis mark."
      (interactive "p")
      (cond
       ((and (= 1 arg)
	     (eq (char-before) ?^))
	(delete-char -1)
	(insert typopunct-middot))
       ((and (= 1 arg)
	     (eq this-command last-command)
	     (looking-back "\\.\\." 1))
	(replace-match "")
	(insert typopunct-ellipsis))
       (t
	(self-insert-command arg))))
    (define-key typopunct-map "." 'typopunct-insert-ellipsis-or-middot)


    (defconst typopunct-prime  (decode-char 'ucs #x2032)) ; feet, arcminutes, derivatives
    (defconst typopunct-dprime (decode-char 'ucs #x2033)) ; inches, arcseconds, double derivatives
    (defconst typopunct-tprime (decode-char 'ucs #x2034))

    ;; The minus sign (−) is separate from the hyphen (-), en dash (–) and
    ;; em dash (—). To build upon the clever behavior of the ‘-’ key
    (defconst typopunct-minus (decode-char 'ucs #x2212))
    (defconst typopunct-pm    (decode-char 'ucs #xB1))
    (defconst typopunct-mp    (decode-char 'ucs #x2213))
    (defadvice typopunct-insert-typographical-dashes
	(around minus-or-pm activate)
      (cond
       ((or (eq (char-before) typopunct-em-dash)
	    (looking-back "\\([[:blank:]]\\|^\\)\\^" 2))
	(delete-char -1)
	(insert typopunct-minus))
       ((looking-back "[^[:blank:]]\\^" 1)
	(insert typopunct-minus))
       ((looking-back "+/" 1)
	(progn (replace-match "")
	       (insert typopunct-pm)))
       (t ad-do-it)))
    (defun typopunct-insert-mp (arg)
      (interactive "p")
      (if (and (= 1 arg) (looking-back "-/" 2))
	  (progn (replace-match "")
		 (insert typopunct-mp))
	(self-insert-command arg)))
    (define-key typopunct-map "+" 'typopunct-insert-mp)
    (defconst typopunct-times (decode-char 'ucs #xD7))
    (defun typopunct-insert-times (arg)
      "Insert multiplication sign at ARG."
      (interactive "p")
      (if (and (= 1 arg) (looking-back "\\([[:blank:]]\\|^\\)\\^"))
	  (progn (delete-char -1)
		 (insert typopunct-times))
	(self-insert-command arg)))
    (define-key typopunct-map "x" 'typopunct-insert-times)

    (defadvice typopunct-insert-quotation-mark (around wrap-region activate)
      (let* ((lang (or (get-text-property (point) 'typopunct-language)
		       typopunct-buffer-language))
	     (omark (if single
			(typopunct-opening-single-quotation-mark lang)
		      (typopunct-opening-quotation-mark lang)))
	     (qmark (if single
			(typopunct-closing-single-quotation-mark lang)
		      (typopunct-closing-quotation-mark lang))))
	(cond
	 (mark-active
	  (let ((skeleton-end-newline nil)
		(singleo (typopunct-opening-single-quotation-mark lang))
		(singleq (typopunct-closing-single-quotation-mark lang)))
	    (if (> (point) (mark))
		(exchange-point-and-mark))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string omark)) (mark) t)
		(replace-match (regexp-quote (string singleo)) nil nil)))
	    (save-excursion
	      (while (re-search-forward (regexp-quote (string qmark)) (mark) t)
		(replace-match (regexp-quote (string singleq)) nil nil)))
	    (skeleton-insert (list nil omark '_ qmark) -1)))
	 ((looking-at (regexp-opt (list (string omark) (string qmark))))
	  (forward-char 1))
	 (t ad-do-it)))))
#+end_src

* Utilities

** TODO jnf/eval-region-dwim()

#+begin_src emacs-lisp
  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'jnf/eval-region-dwim)
  (define-key lisp-interaction-mode-map (kbd "C-c C-c") 'jnf/eval-region-dwim)
  (defun jnf/eval-region-dwim ()
    "When region is active, evaluate it and kill the mark. Else,
    evaluate the whole buffer."
    (interactive)
    (if (not (region-active-p))
	(progn
	  (message "Evaluating buffer...")
	  (eval-buffer))
      (progn
	(message "Evaluating region...")
	(eval-region (region-beginning) (region-end)))
      (setq-local deactivate-mark t)))
#+end_src

** TODO jnf/toggle-osx-alternate-modifier()

#+begin_src emacs-lisp

  ;; On  I use ⌘ as meta and prefer ⌥ to do nothing so I can still insert special characters easily.
  ;;
  ;; (setq mac-command-modifier 'meta
  ;;       mac-option-modifier 'none)

  ;; (setq mac-right-option-modifier nil) ;; Disable Emacs capturing meta-key and fall back to OS X (useful for diacritics)
  ;;
  ;; (setq mac-right-option-modifier 'meta) ;; Enable Emacs capturing meta-key, so right M-x will execute extended command


  (defun jnf/toggle-osx-alternate-modifier ()
    "Toggle native OS-X Option modifier
  setting (e.g. ns-alternate-modifier)."
    (interactive)
    (if ns-alternate-modifier
	(progn (setq ns-alternate-modifier nil)
	       (message "Enabling OS X native Option modifier"))
      (progn (setq ns-alternate-modifier 'meta)
	     (message "Disabling OX X native Option modifier (e.g. Option as Meta)"))))
  (global-set-key (kbd "C-x /") 'jnf/toggle-osx-alternate-modifier)
#+end_src

** TODO jnf/git-data-sync()

#+begin_src emacs-lisp
  (cl-defun jnf/git-data-sync (&optional (directories jnf/data-directories))
    "Synchronize DIRECTORIES with git pull/push.

  By default the DIRECTORIES are `jnf/data-directories'"
    (interactive)
    (message "Synchronizing local git repos...")
    (dolist (path directories)
      (if (f-dir-p (file-truename path))
	  (progn
	    (message (concat "Syncing \"" path "\"..."))
	    (shell-command-to-string
	     (concat
	      "cd " path
	      " && git pull --rebase"
	      " && git push -u --force-with-lease")))
	(message (concat "Skipping missing directory \"" path "\"...")))
      (message "Finished synchronizing local git repos.")))
#+end_src

** TODO hammerspoon

#+begin_src emacs-lisp
  (when (file-directory-p
	 "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon")
    (load
     "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el"
     nil
     jnf-silence-loading-log))
#+end_src

** TODO jnf/query-within-macro-definition()

#+begin_src emacs-lisp
  (defun jnf/query-within-macro-definition (arg)
    "Prompt for input using minibuffer during kbd macro execution.

  With prefix ARG, allows you to select what prompt string to use.
  If the input is non-empty, it is inserted at point."
    (interactive "P")
    (let* ((query (lambda () (kbd-macro-query t)))
	   (prompt (if arg (read-from-minibuffer "PROMPT: ") "Input: "))
	   (input (unwind-protect
		      (progn
			(add-hook 'minibuffer-setup-hook query)
			(read-from-minibuffer prompt))
		    (remove-hook 'minibuffer-setup-hook query))))
      (unless (string= "" input) (insert input))))

  (global-set-key (kbd "C-x Q") 'jnf/query-within-macro-definition)
#+end_src
* Footnotes

[fn:1] “Ag” is the chemical symbol for the Silver element.

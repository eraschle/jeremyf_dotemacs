#+TITLE: Emacs Configuration
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+STARTUP: overview

* Basic Configuration
** TODO straight.el

#+begin_src emacs-lisp
(defconst jnf-silence-loading-log t
  "When true log to stdout any ")
;; https://www.reddit.com/r/emacs/comments/mtb05k/emacs_init_time_decreased_65_after_i_realized_the/
(setq straight-check-for-modifications '(check-on-save find-when-checking))

;; This preamble is part of straight-use-package My understanding, in
;; reading straight documentation is that it has better load
;; times. However, the configuration options I often see leverage
;; "use-package" which is why most of my package declarations look as
;; they do.
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil jnf-silence-loading-log))

(setq straight-repository-branch "develop")

;; I saw that straight loaded use-package to take advantage of the
;; use-package syntax which is often how things are documented.
(straight-use-package 'use-package)
#+end_src

** TODO Early Configuration
#+begin_src emacs-lisp
;;; Commentary:
;;
;;  Some basic configurations that should be applicable for all emacs
;;  settings.
;;
;;; Code:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; A chunk of code that allows me to pass multiple filenames to
;; emacsclient AND open those files in different frames within the
;; same window.(defvar server-visit-files-custom-find:buffer-count)
(defvar server-visit-files-custom-find:buffer-count)
(defadvice server-visit-files
    (around server-visit-files-custom-find
            activate compile)
  "Maintain a counter of visited files from a single client call."
  (let ((server-visit-files-custom-find:buffer-count 0))
    ad-do-it))
(defun server-visit-hook-custom-find ()
  "Arrange to visit the files from a client call in separate windows."
  (if (zerop server-visit-files-custom-find:buffer-count)
      (progn
        (delete-other-windows)
        (switch-to-buffer (current-buffer)))
    (let ((buffer (current-buffer))
          (window (split-window-sensibly)))
      (switch-to-buffer buffer)
      (balance-windows)))
  (setq server-visit-files-custom-find:buffer-count
        (1+ server-visit-files-custom-find:buffer-count)))
(add-hook 'server-visit-hook 'server-visit-hook-custom-find)

(global-so-long-mode)

;; Parenthesis matching is one of the flaws in my Emacs setup as of
;; this writing. I know that there are a lot of options out
;; there—paredit, smartparens, etc.—but I haven’t sat down and really
;; capital-L Learned a better solution than the TextMate-style bracket
;; completion (which Emacs calls, somewhat fancifully, ‘electric’).
;;
;; https://blog.sumtypeofway.com/posts/emacs-config.html
(electric-pair-mode)

;; Put autosave files (ie #foo#) and backup files (ie foo~) in ~/.emacs.d/.
;; See https://snarfed.org/gnu_emacs_backup_files
;; create the autosave dir if necessary, since emacs won't.
(make-directory "~/.emacs.d/autosaves/" t)

(recentf-mode 1)
(run-at-time nil (* 2 60) 'recentf-save-list)

(global-auto-revert-mode)

(setq-default fill-column 79)
(setq
 ;; Don't create lock files.  Emacs drops these files on the file
 ;; system.  I found this most cumbersome when working in hugo.  The
 ;; hugo build would file because it tried to handle a lock file.
 create-lockfiles nil
 ;; Stop ringing any bell
 ring-bell-function 'ignore
 ;; The default is 60.  It is rare that I need more than 15 or 20.
 ;; However in my long use of Jumpcut there have been a few times where
 ;; I get into the 80s on previous pastes.  Given that the kill ring is
 ;; searchable, I think a larger value makes a lot of sense.
 kill-ring-max 120
 ;; Given the number of symlinks, visit the "linked to" file.
 vc-follow-symlinks t

 bookmark-default-file "~/git/jnf-emacs-bookmarks/bookmarks"
 read-process-output-max (* 1024 1024 3)  ; Increase read size per process
 indent-tabs-mode nil ;; Ensure tabs are expanded, not inserted
 inhibit-startup-screen t ;; Don't include the  emacs "start" window
 idle-update-delay 1.1  ;;Slow down the UI being updated to improve performance
 split-width-threshold 100 ;; Most of the times I favor two windows side-by-side within a frame
 recentf-max-menu-items 50
 recentf-max-saved-items 50
 backup-directory-alist '((".*" . "~/.emacs.d/backups/"))
 backup-by-copying t    ; Don't delink hardlinks
 version-control t      ; Use version numbers on backups
 delete-old-versions t  ; Automatically delete excess backups
 kept-new-versions 20   ; how many of the newest versions to keep
 kept-old-versions 5    ; and how many of the old
 user-full-name "Jeremy Friesen"
 user-mail-address "jeremy@jeremyfriesen.com"
 )

;; When you open Emacs, grab all the space on the screen
(add-to-list 'initial-frame-alist '(fullscreen . maximized))

;; Hide the icons of the Emacs toolbar
(tool-bar-mode -1)

;; Hide the scroll bar. Let's be clear, I don't use it.
(scroll-bar-mode -1)

;; Instead of typing "yes" or "no" short-circuit to "y" or "n"
(defalias 'yes-or-no-p 'y-or-n-p)

(unbind-key "C-x C-d") ;; `list-directory'
;; `dired' is a better interface than `list-directory'
(global-set-key (kbd "C-x C-d") 'dired)
(global-set-key (kbd "<M-delete>") 'kill-word)

(global-set-key (kbd "<s-down>") 'end-of-buffer)
(global-set-key (kbd "<s-up>") 'beginning-of-buffer)

;; Far to easy to type this on accident, and I'm not a fan of it's behavior.
(unbind-key "C-z") ;; `suspend-frame'

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

;; Given that C-c C-x is common within org-mode, I found myself
;; accidentally invoking this transposition.  I have "s-q" command for
;; this.
(unbind-key "C-x C-c") ;; was `save-buffers-kill-terminal'

(add-hook 'text-mode-hook #'abbrev-mode)

(add-function :after after-focus-change-function
  (defun jnf/garbage-collect-maybe ()
    (unless (frame-focus-state)
      (garbage-collect))))
#+end_src

** TODO diminish.el
#+begin_src emacs-lisp
(use-package diminish :straight t)
#+end_src

** TODO gchm.el
#+begin_src emacs-lisp

;; GCMH does GC when the user is idle.
(use-package gcmh
  :straight t
  :diminish 'gcmh-mode
  :init
  (setq gcmh-idle-delay 5
	gcmh-high-cons-threshold (* 16 1024 1024))  ; 16mb
	:config (gcmh-mode))
#+end_src

** TODO keychain-environment.el
#+begin_src emacs-lisp

;; Load keychain environment variables
(use-package keychain-environment
  :straight t
  :config
  (keychain-refresh-environment))
#+end_src

** TODO f.el
#+begin_src emacs-lisp

;; a modern API for working with files and directories in Emacs.
;; https://github.com/rejeep/f.el/
(use-package f :straight t)
#+end_src

** TODO s.el
#+begin_src emacs-lisp

;; The long lost Emacs string manipulation library.
;; https://github.com/magnars/s.el/
(use-package s :straight t)
#+end_src

** TODO dash.el
#+begin_src emacs-lisp

;; A modern list API for Emacs. No 'cl required.
;; https://github.com/magnars/dash.el/
(use-package dash :straight t)
#+end_src

** TODO Variable/const definitions
#+begin_src emacs-lisp

(defconst jnf/fixed-width-font-name
  "Hack Nerd Font"
  "The name of the fixed width font.
I have it sprinkled through too many places.

Alternatives:
- \"Monaco\"
- \"JetBrains Mono\"
- \"Hack Nerd Font\"")

(set-frame-font jnf/fixed-width-font-name)

(defconst jnf/tor-home-directory
  (file-truename "~/git/takeonrules.source")
  "The home directory of TakeOnRules.com Hugo repository.")

(defconst jnf/tor-default-local-hostname
  "http://localhost:1313"
  "The scheme, host name, and port for serving up a local TakeOnRules.com.")

(defvar jnf/data-directories
  (list
    jnf/tor-home-directory
    "~/git/takeonrules.source/themes/hugo-tufte"
    "~/git/burning_wheel_lifepaths/"
    "~/git/jnf-emacs-bookmarks"
    "~/git/dotzshrc/"
    "~/git/dotemacs/"
    "~/git/org/"
    "~/git/org/archive"
    "~/git/org/daily"
    "~/git/org/public"
    "~/git/org/personal"
    "~/git/org/personal/thel-sector"
    "~/git/org/hesburgh-libraries"
    "~/git/org/forem"
    )
  "Relevant data directories for my day to day work.")
#+end_src

** TODO pretty-hydra.el
#+begin_src emacs-lisp

;; I use this package to "configure" menus, hence this is in the
;; config section.
(use-package pretty-hydra
  :straight (pretty-hydra
             :type git :host github :repo "jerrypnz/major-mode-hydra.el"
             :files (:defaults (:exclude "major-mode-hydra.el"))))
#+end_src

** TODO helpful.el
#+begin_src emacs-lisp
;; I have found this package quite "helpful"; When I want to know the
;; name of a function or key or variable, I can use the helpful
;; package.
(use-package helpful
  :straight t
  :after (all-the-icons pretty-hydra)
  :pretty-hydra
  ((:title (with-material "help_outline" "Helpful Menus") :quit-key "q" :exit t)
   ("Helpful"
    (
     ("b" embark-bindings "Bindings")
     ("c" helpful-command "Command")
     ("f" helpful-callable "Function (interactive)")
     ("F" helpful-function "Function (all)")
     ("k" helpful-key "Key")
     ("l" find-library "Find library")
     ("m" helpful-macro "Macro")
     ("p" helpful-at-point "Thing at point")
     ("v" helpful-variable "Variable")
     ("t" describe-text-properties "Text properties")
     )))
  :bind ("C-s-h" . helpful-hydra/body))
#+end_src

** TODO editorconfig.el
#+begin_src emacs-lisp

;; See https://editorconfig.org/#overview
(use-package editorconfig
  :straight t
  :diminish editorconfig-mode
  :config
  (editorconfig-mode 1))
#+end_src

* Display

I'm just going to trust themes.
#+begin_src emacs-lisp
(setq custom-safe-themes t)
#+end_src

** TODO modus-themes.el
#+begin_src emacs-lisp
  (use-package modus-themes
    ;; :straight (modus-themes :type built-in)
    :straight (:type git :host gitlab :repo "protesilaos/modus-themes" :branch "main")
    :init
    (setq
     modus-themes-bold-constructs t
     modus-themes-completions 'opinionated ; {nil,'moderate,'opinionated}
     modus-themes-diffs nil ; {nil,'desaturated,'fg-only}
     modus-themes-fringes 'intense ; {nil,'subtle,'intense}
     modus-themes-hl-line '(accented intense)
     modus-themes-intense-markup t
     modus-themes-links '(faint background)
     modus-themes-mixed-fonts t
     modus-themes-mode-line '(accented 3d)
     modus-themes-org-blocks 'gray-background
     modus-themes-paren-match '(bold intense)
     modus-themes-prompts '(intense accented)
     modus-themes-region '(bg-only accented)
     modus-themes-scale-headings t
     modus-themes-slanted-constructs t
     modus-themes-subtle-line-numbers t
     modus-themes-syntax '(alt-syntax yellow-comments green-strings)
     modus-themes-tabs-accented t
     modus-themes-headings
     '((1 . (variable-pitch light 1.6))
       (2 . (overline semibold 1.4))
       (3 . (monochrome overline 1.2))
       (4 . (overline 1.1))
       (t . (rainbow 1.05)))))

  (global-hl-line-mode)

  ;; Recommendation from https://protesilaos.com/emacs/modus-themes
  (setq x-underline-at-descent-line t)
#+end_src

** TODO lin.el
#+begin_src emacs-lisp
  (use-package lin
      :straight (lin :host gitlab :repo "protesilaos/lin")
      :config (lin-add-to-many-modes))
#+end_src

#+begin_src emacs-lisp
  ;; Based on system type, either load the OSX apperance (e.g. dark or
  ;; light) and load accordingly.
  (if (eq system-type 'darwin)
      (progn
	(defun jnf/dark ()
	  "Toggle system-wide Dark or Light setting."
	  (interactive)
	  (shell-command "osascript -e 'tell application \"System Events\" to tell appearance preferences to set dark mode to not dark mode'")
	  (jnf/emacs-theme-by-osx-appearance))

	(defalias 'modus-themes-toggle 'jnf/dark)
	(defun jnf/emacs-theme-by-osx-appearance ()
	  "Set theme based on OSX apperance state."
	  (if (equal "Dark" (substring (shell-command-to-string "defaults read -g AppleInterfaceStyle") 0 4))
	      (load-theme 'modus-vivendi)
	    (load-theme 'modus-operandi)))
	(jnf/emacs-theme-by-osx-appearance))
    (progn
      (defun modus-themes-toggle ()
	"Toggle between `modus-operandi' and `modus-vivendi' themes."
	(interactive)
	(if (eq (car custom-enabled-themes) 'modus-operandi)
	    (load-theme 'modus-vivendi)
	  (load-theme 'modus-operandi)))
      (load-theme 'modus-operandi)))
#+end_src

#+begin_src emacs-lisp

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; BEGIN BLOCK
  ;;
  ;; With a quick bit of testing, it appears that the following
  ;; set-face-attribute declarations should be made after the theme
  ;; declarations.  When the following statements were declared before
  ;; the themes, and I toggled my theme, the font changed to something
  ;; unexpected.  With them declared after, I keep the fonts between
  ;; toggles.
  ;;
  ;; Main typeface, I'm toggling between "JetBrains Mono" and "Hack"
  (set-face-attribute 'default nil :family jnf/fixed-width-font-name :height 140)
  ;; Proportionately spaced typeface
  (set-face-attribute 'variable-pitch nil :family "ETBembo" :height 1.1)
  ;; Monospaced typeface
  (set-face-attribute 'fixed-pitch nil :family jnf/fixed-width-font-name :height 1.0)
  ;;
  ;; END BLOCK
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (blink-cursor-mode t)
  ;; Doing a bit of configuration of my cursors
  (setq-default cursor-type 'bar)
#+end_src

** TODO all-the-icons.el

#+begin_src emacs-lisp
  ;; Useful for referential icons.
  (use-package all-the-icons
    :straight t
    :config
    ;; A convenience function to create a nice string
    (defun with-faicon (icon str &optional height v-adjust)
      "Displays an ICON  from Font Awesome icon.

   The STR identifies the icon and the HEIGHT and V-ADJUST provide
   the configuration."
      (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-material (icon str &optional height v-adjust)
      "Displays an ICON  from Font Material icon.

   The STR identifies the icon and the HEIGHT and V-ADJUST provide
   the configuration."
      (s-concat (all-the-icons-material icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-octicon (icon str &optional height v-adjust)
      "Displays an ICON  from Octicon icon.

   The STR identifies the icon and the HEIGHT and V-ADJUST provide
   the configuration."
      (s-concat (all-the-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-alltheicon (icon str &optional height v-adjust)
      "Displays an ICON  from All the Icons icon.

   The STR identifies the icon and the HEIGHT and V-ADJUST provide
   the configuration."
      (s-concat (all-the-icons-alltheicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str)))
#+end_src

** TODO all-the-icons-dired.el
#+begin_src emacs-lisp
  ;; Disabled because on 2021-04-11 I got the following error:
  ;; *ERROR*: Symbol’s value as variable is void: file
  ;;
  ;; Incorporates file icons with file listings of dired
  (use-package all-the-icons-dired
    :straight t
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

** TODO spaceline.el
#+begin_src emacs-lisp
  ;; A nice looking modeline enhancement
  (use-package spaceline
    :straight t)
#+end_src

** TODO spaceline-all-the-icons.el
#+begin_src emacs-lisp
  ;; Add some visual flair to the modeline enhancements
  (use-package spaceline-all-the-icons
    :straight t
    :after spaceline
    :config (spaceline-all-the-icons-theme))
#+end_src

** TODO popper.el

#+begin_src emacs-lisp
  ;; Ensuring that some windows are treated as popups (e.g., something
  ;; easier to dismiss, a bit more like the mini-buffer).
  (use-package popper
    :straight t
    :bind (("C-`" . jnf/popper))
    :config
    (defun jnf/popper (prefix_arg)
      "Call `popper-cycle', but with PREFIX_ARG invoke a less common popper method.

  With one PREFIX_ARG, `popper-toggle-latest'.
  With two (or more) PREFIX_ARG `popper-toggle-type'."
      (interactive "P")
      (let ((prefix (car prefix_arg)))
	(cond
	 ((not prefix)  (popper-cycle))
	 ((= prefix 4)  (popper-toggle-latest))
	 (t (popper-toggle-type)))))
    :init
    (setq popper-reference-buffers
	  '("\\*Messages\\*"
	    "Output\\*$"
	    "\\*Async Shell Command\\*"
	    help-mode
	    compilation-mode
	    "^\\*helpful.*\\*$"))
    (popper-mode +1)
    (popper-echo-mode +1))

#+end_src

** TODO ace-window.el
#+begin_src emacs-lisp
  ;; A window manager for emacs, allowing fast toggles between windows
  ;; as well as opening or moving those windows.
  ;; https://github.com/abo-abo/ace-window
  (use-package ace-window
    :straight t
    :bind (("M-o" . ace-window)))
#+end_src

** TODO Window Layout Functions
#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; BEGIN frame and window quick setup
  (defun gk-layouts-3col ()
    "Three column layout.

  Tries to preserve the order of window buffers and active window."
    (interactive)
    ;; Record active window buffer.
    (let ((cbuf (current-buffer)))
      ;; Switch to leftmost window.
      (ignore-errors (cl-loop do (windmove-left)))
      (let ((buffers
	     (mapcar #'window-buffer (-take 3 (window-list))))
	    (width (/ (frame-width) 3)))
	(delete-other-windows)
	(split-window-horizontally width)
	(other-window 1)
	(split-window-horizontally)
	(other-window -1)
	(dolist (b buffers)
	  (switch-to-buffer b)
	  (other-window 1)))
      ;; Switch to previously visible buffer’s window.
      (select-window (get-buffer-window cbuf))))


  (defun gk-layouts-main-and-sidekicks ()
    "One horizontal split, the right window split in two.

  Tries to preserve the order of window buffers and active window."
    (interactive)
    ;; Record active window buffer.
    (let ((cbuf (current-buffer)))
      ;; Switch to leftmost window.
      (ignore-errors (cl-loop do (windmove-left)))
      (let ((buffers
	     (mapcar #'window-buffer (-take 3 (window-list)))))
	(delete-other-windows)
	(split-window-horizontally)
	(other-window 1)
	(split-window-vertically)
	(other-window -1)
	(dolist (b buffers)
	  (switch-to-buffer b)
	  (other-window 1)))
      ;; Switch to previously visible buffer’s window.
      (select-window (get-buffer-window cbuf))))

  (bind-key "C-x \\" #'gk-layouts-main-and-sidekicks)
  ;; END frame and window quick setup
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

** TODO Scrolling functions
#+begin_src emacs-lisp
  ;; See https://www.reddit.com/r/emacs/comments/r7l3ar/how_do_you_scroll_half_a_page/
  (global-set-key (kbd "M-n") 'jnf/scroll-down-half-page)
  (defun jnf/scroll-down-half-page ()
    "Scroll down half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) (move-to-window-line nil))
	    ((= ln lmax) (recenter (window-end)))
	    (t (progn
		 (move-to-window-line -1)
		 (recenter))))))

  (global-set-key (kbd "M-p") 'jnf/scroll-up-half-page)
  (defun jnf/scroll-up-half-page ()
    "Scroll up half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
	  (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) nil)
	    ((= ln lmax) (move-to-window-line nil))
	    (t (progn
		 (move-to-window-line 0)
		 (recenter))))))
#+end_src

* General Emacs Configuration

I tried enabling this, and found myself sometimes lost in a labyrinth of
minibuffers.  This change ensures that there’s only one.

#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers nil)
#+end_src

** MacOS Specific

*** TODO grab-mac-link.el

#+begin_src emacs-lisp
  ;;; Commentary:
  ;;
  ;;  This package loads darwin specific packages; It assumes that both
  ;;  "use-package" and "straight-use-package" are loaded.
  ;;
  ;;; Code:
  ;; Adds the ability to grab a link from various OS X applications
  ;; Note, the sibling org-mac-link.  That package works within ORG mode
  ;; with an extended menu option, and assumes ORG styling.  They both
  ;; have the same keybinding as org-mode favors org-mac-link.
  (use-package grab-mac-link
    :straight t
    :config
    ;; A replacement function for existing grab-mac-link-make-html-link
    (defun jnf/grab-mac-link-make-html-link (url name)
      "Using HTML syntax, link to and cite the URL with the NAME."
      (format "<cite><a href=\"%s\" class=\"u-url p-name\" rel=\"cite\">%s</a></cite>" url name))
    ;; The function advice to override the default behavior
    (advice-add
     'grab-mac-link-make-html-link
     :override
     'jnf/grab-mac-link-make-html-link
     '((name . "jnf")))
    :bind (("C-c g" . grab-mac-link)))

  (eval-after-load "flyspell"
    '(progn
       (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
       (define-key flyspell-mouse-map [mouse-3] #'undefined)))
#+end_src

*** TODO org-mac-link.el
#+begin_src emacs-lisp
  (use-package org-mac-link
    :ensure t
    :straight (org-mac-link :type git :host github :repo "jeremyf/org-mac-link")
    :defer t)
  (add-hook 'org-mode-hook (lambda ()
			     (define-key org-mode-map (kbd "C-c g") 'org-mac-grab-link)))

  (if (version< "27.0" emacs-version)
      (set-fontset-font
       "fontset-default" 'unicode "Apple Color Emoji" nil 'prepend)
    (set-fontset-font
     t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend))
#+end_src

*** TODO pdf-tools.el
#+begin_src emacs-lisp
  ;; Emacs comes with DocView built in.  pdf-tools is a replacement for
  ;; DocView.  I've found the rendered images a bit more crisp and the
  ;; interactions a bit more responsive.  However, I have not been able
  ;; to get `org-noter' working with `pdf-tools'.  `org-noter' provides
  ;; annotation services for PDFs.
  (use-package pdf-tools
    :pin manual ;; manually update
    :straight t
    :defer t
    :ensure t
    :config (pdf-tools-install) ;; initialise
    (setq-default pdf-view-display-size 'fit-page) ;; open pdfs scaled to fit page
    (setq pdf-annot-activate-created-annotations t) ;; automatically annotate highlights
    (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward);; use normal isearch
    )
#+end_src

*** TODO so-long.el
#+begin_src emacs-lisp

  ;; When we get to a REALLY long file or long line, emacs develops problems.
  ;; This mode helps overcome that.
  ;;
  (use-package so-long
    :ensure t
    :defer t
    :straight t
    :bind
    (:map so-long-mode-map
	  ("C-s" . isearch-forward)
	  ("C-r" . isearch-backward))
    :config
    (global-so-long-mode 1))
#+end_src

*** TODO dtache.el
#+begin_src emacs-lisp
  ;; May or may not be useful
  (use-package dtache
    :straight (dtache :host gitlab :repo "niklaseklund/dtache")
    :hook (after-init . dtache-setup)
    :bind (([remap async-shell-command] . dtache-shell-command)
	   :map dtache-shell-mode-map
	   ("C-c C-q" . dtache-detach-dwim)))
#+end_src

* Modes
Sometimes I want to edit svg files.  Often times if I open them directly in
Emacs, I want to edit them.  This setting helps with that default.  /Note:/
without this setting, Emacs will happily render the SVG as an image,

#+begin_src emacs-lisp
  (add-to-list `auto-mode-alist '("\\.svg\\'" . xml-mode))
#+end_src

** TODO emmet-mode.el
#+begin_src emacs-lisp
  (use-package emmet-mode
    :straight t
    :bind (("C-c C-e" . emmet-expand-yas ))
    :hook ((sgml-mode . emmet-mode)
	   (html-mode . emmet-mode)
	   (css-mode . emmet-mode)))
#+end_src

** TODO web-mode.el
#+begin_src emacs-lisp
  (use-package web-mode
    :straight t
    :config (setq web-mode-markup-indent-offset 2
		  web-mode-css-indent-offset 2
		  web-mode-code-indent-offset 2))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))

  ;; built-in, consider commenting
  ;; (use-package sgml-mode
  ;;   :straight nil
  ;;   :hook
  ;;   (html-mode . sgml-electric-tag-pair-mode)
  ;;   (html-mode . sgml-name-8bit-mode)
  ;;   :custom
  ;;   (sgml-basic-offset 2))
#+end_src

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :config (setq plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  plantuml-default-exec-mode 'executable
		  org-plantuml-executable-path (concat (getenv "HB_PATH") "/bin/plantuml")
		  org-plantuml-exec-mode 'executable)
    :mode (("\\.plantuml\\'" . plantuml-mode))
    :straight t)
#+end_src

#+begin_src emacs-lisp
  (use-package json-mode :straight t)
#+end_src

Because JSON can be quite ugly, I want something to help tidy it up.
#+begin_src emacs-lisp
  (use-package json-reformat
    :straight t
    :after json-mode
    :init (setq json-reformat:indent-width 2))

#+end_src

** go-mode.el

Every so often I stumble upon a Go package.  The ~go-mode~ package gives me the
syntax highlighting that makes reading ~Go-lang~ tolerable.

#+begin_src emacs-lisp
  (use-package go-mode :straight t)
#+end_src

** TODO markdown-mode.el
#+begin_src emacs-lisp
  (use-package markdown-mode
    :straight t
    :hook ((markdown-mode . turn-on-visual-line-mode))
    ;; I use markdown for my blogging platform and very little else.
    ;; Hence, I have this keybind.
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "/usr/local/bin/pandoc"))
#+end_src

** TODO yaml-mode.el
#+begin_src emacs-lisp
  (use-package yaml-mode :straight t)
#+end_src

** TODO lua-mode.el
#+begin_src emacs-lisp
  (use-package lua-mode :straight t)
#+end_src

** TODO lua-mode.el
#+begin_src emacs-lisp
  (use-package git-modes :straight t)
#+end_src

* Support

** DONE ripgrep.el
For many years, I’ve used “The Silver Searcher”, or ~ag~ on the command
line.[fn:1].  However, [[https://github.com/BurntSushi/ripgrep][ripgrep]] provides even faster searching, with an almost
identical parameter list.

#+begin_src emacs-lisp
  (use-package ripgrep
    :init (setq ripgrep-arguments "--ignore-case")
    :straight t)
#+end_src

* Projects
** TODO projectile.el

Projectile provides convenient organization and commands to run over projects.

#+begin_src emacs-lisp
  (use-package projectile
    :straight t
    :diminish 'projectile-mode
    :config (projectile-mode 1)
    :custom (projectile-project-search-path '("~/git/"))
    :bind ("s-." . projectile-toggle-between-implementation-and-test))
#+end_src

/Note:/ The =CMD= + =.= is a carryover from my [[https://macromates.com][Textmate]] and [[https://www.sublimetext.com/][Sublime Text]] days.
That’s one of those hot-keys almost burned into soul.

* Completion
** DONE vertico.el
#+begin_src emacs-lisp
  (use-package vertico
    :straight t
    :config
    (vertico-mode)
    ;; Use `consult-completion-in-region' if Vertico is enabled.
    ;; Otherwise use the default `completion--in-region' function.
    (setq completion-in-region-function
	  (lambda (&rest args)
	    (apply (if vertico-mode
		       #'consult-completion-in-region
		     #'completion--in-region)
		   args)))
    (advice-add #'completing-read-multiple
		:override #'consult-completing-read-multiple)
    (setq vertico-cycle t))
#+end_src

*** Vertico Extensions

The ~vertico-indexed.elc~ extension adds a visual indicator of each candidate’s
index.  Further, I can type ~C-<num> ENT~ and select that candidate.  Often
it’s just as easy to navigate via ~TAB~ or ~C-n~ / ~C-p~ but the visual
indicator is a nice bit of polish.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-indexed.elc"
	nil
	jnf-silence-loading-log)
  (vertico-indexed-mode)
#+end_src

I’ve commented out the ~vertico-buffer.elc~ extension.  When active, instead of
using the mini-buffer it creates a new window.  I’m uncertain how I fully feel
about this function.  When I activate it, I’m sometimes “surprised” at a
different experience from what I’m accustomed to in Emacs.  Then again, at
least I’m not trapped in the recursive mini-buffer challenges.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-buffer.elc"
	nil
	jnf-silence-loading-log)
  (vertico-buffer-mode)
  (setq vertico-buffer-display-action
	'(display-buffer-at-bottom (window-height . 15)))
#+end_src

The ~vertico-repeat.elc~ extension does one simple thing: it remembers and
gives quick access to the last command you entered in the “minibuffer.”  This
can be super userful if I built up a complicated ~consult-ripgrep~.

#+begin_src emacs-lisp
  (load "~/.emacs.d/straight/build/vertico/extensions/vertico-repeat.elc"
	nil
	jnf-silence-loading-log)
  (global-set-key (kbd "M-r") #'vertico-repeat)
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
#+end_src

Related to, but independent of ~vertico-repeat.elc~ is enabling
~savehist-mode~.  With that enabled, I have access to a few dozen of the last
minibuffer commands I issued.  These are, by default, in ~\~/.emacs.d/history~.

#+begin_src emacs-lisp
  (savehist-mode 1)
#+end_src

** Emacs Adjustments for Completion

What follows is adjustments to emacs settings as they relate to completion.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)

    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
	  '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src

** DONE marginalia.el

The ~marginalia~ package provides annotations to minibuffer completions; I
shudder to think how hard it would be to navigate Emacs’s ~M-x~ command without
annotations.

#+begin_src emacs-lisp
  (use-package marginalia
    :straight t
    :init (marginalia-mode))
#+end_src

/Note:/ The declaration of ~marginalia-mode~ must be in the ~;init~ section.
This ensures that it is enabled right away.  It also forces the loading of the
package.

** TODO consult.el

#+begin_src emacs-lisp
  ;; Example configuration for Consult
  ;; https://github.com/minad/consult
  (use-package consult
    :straight t
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
	   ("C-c h" . consult-history)
	   ;; ("C-c m" . consult-mode-command)
	   ("C-c b" . consult-bookmark)
	   ("C-c k" . consult-kmacro)
	   ;; C-x bindings (ctl-x-map)
	   ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complet-command
	   ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("s-b" . consult-buffer)                ;; orig. switch-to-buffer
	   ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
	   ("C-s-b" . consult-buffer-other-window)
	   ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
	   ;; Custom M-# bindings for fast register access
	   ("M-#" . consult-register-load)
	   ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
	   ("C-M-#" . consult-register)
	   ;; Other custom bindings
	   ("M-y" . consult-yank-from-kill-ring)                ;; orig. yank-pop
	   ("<help> a" . consult-apropos)            ;; orig. apropos-command
	   ;; M-g bindings (goto-map)
	   ("M-g e" . consult-compile-error)
	   ("M-g g" . consult-goto-line)             ;; orig. goto-line
	   ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
	   ("s-l" . consult-goto-line)           ;; orig. goto-line
	   ("M-g o" . consult-outline)
	   ("M-g m" . consult-mark)
	   ("M-g k" . consult-global-mark)
	   ("C-x C-SPC" . consult-mark)
	   ("M-g i" . consult-imenu)
	   ("M-g I" . consult-imenu-multi)
	   ;; M-s bindings (search-map)
	   ("M-s f" . consult-find)
	   ("M-s L" . consult-locate)
	   ("M-s g" . consult-grep)
	   ("M-s G" . consult-git-grep)
	   ("M-s r" . consult-ripgrep)
	   ("C-c f" . consult-ripgrep)
	   ("M-s l" . consult-line)
	   ("M-s m" . consult-multi-occur)
	   ("M-s k" . consult-keep-lines)
	   ("M-s u" . consult-focus-lines)
	   ;; Customizations that map to ivy
	   ("s-r" . consult-recent-file) ;; Deprecate
	   ("C-c r" . consult-recent-file)
	   ("C-c o" . consult-file-externally)
	   ("C-y" . yank)
	   ("C-s" . consult-line) ;; I've long favored Swiper mapped to c-s
	   ;; Isearch integration
	   ("M-s e" . consult-isearch)
	   ;; ("s-t" . jnf/consult-find-using-fd)
	   ;; ("s-3" . consult-imenu-multi)
	   :map isearch-mode-map
	   ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
	   ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
	   ("M-s l" . consult-line))                 ;; required by consult-line to detect isearch

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
	  register-preview-function #'consult-register-format)


    ;; From https://github.com/minad/consult/wiki#find-files-using-fd
    ;; Note: this requires lexical binding
    (defun jnf/consult-find-using-fd (&optional dir initial)
      "Find project files.

  A replacement for `projectile-find-file'."
      (interactive "P")
      (let ((consult-find-command "fd --color=never --hidden --exclude .git/ --full-path ARG OPTS"))
	(consult-find dir initial)))

    (defun jnf/consult-line (consult-line-function &rest rest)
      "Advising function around `CONSULT-LINE-FUNCTION'.

  When there's an active region, use that as the first parameter
  for `CONSULT-LINE-FUNCTION'.  Otherwise, use the current word as
  the first parameter.  This function handles the `REST' of the
  parameters."
      (interactive)
      (apply consult-line-function
	     (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
	     rest))

    (defun jnf/consult-ripgrep (consult-ripgrep-function &optional dir &rest rest)
      "Use region or thing at point to populate initial parameter for `CONSULT-RIPGREP-FUNCTION'.

  When there's an active region, use that as the initial parameter
  for the `CONSULT-RIPGREP-FUNCTION'.  Otherwise, use the thing at
  point.

  `DIR' use the universal argument (e.g. C-u prefix) to first set
  the directory.  `REST' is passed to the `CONSULT-RIPGREP-FUNCTION'."
      (interactive "P")
      (apply consult-ripgrep-function
	     dir
	     (if (use-region-p) (buffer-substring (region-beginning) (region-end)))
	     rest))

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)
    (advice-add #'consult-line :around #'jnf/consult-line '((name . "wrapper")))
    (advice-add #'consult-ripgrep :around #'jnf/consult-ripgrep '((name . "wrapper")))

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
	  xref-show-definitions-function #'consult-xref)

    ;; Updating the default to include "--ignore-case"
    (setq consult-ripgrep-command "rg --null --line-buffered --color=ansi --max-columns=1000 --ignore-case --no-heading --line-number . -e ARG OPTS")

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. Note that the preview-key can also be
    ;; configured on a per-command basis via `consult-config'. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-p"))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; Probably not needed if you are using which-key.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; Optionally configure a function which returns the project root directory.
    ;; There are multiple reasonable alternatives to chose from:
    ;; * projectile-project-root
    ;; * vc-root-dir
    ;; * project-roots
    ;; * locate-dominating-file
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root)
    ;; (setq consult-project-root-function
    ;;       (lambda ()
    ;;         (when-let (project (project-current))
    ;;           (car (project-roots project)))))
    ;; (setq consult-project-root-function #'vc-root-dir)
    ;; (setq consult-project-root-function
    ;;       (lambda () (locate-dominating-file "." ".git")))
    )

#+end_src

** TODO consult-flycheck.el
#+begin_src emacs-lisp
  ;; Optionally add the `consult-flycheck' command.
  (use-package consult-flycheck
    :straight t
    :bind (:map flycheck-command-map
		("!" . consult-flycheck)))
#+end_src

** TODO embark.el
#+begin_src emacs-lisp

  ;; https://github.com/oantolin/embark
  (use-package embark
    :straight t
    :bind
    (("C-." . embark-act)       ;; pick some comfortable binding
     ("M-." . embark-dwim)
     ("C-s-e" . embark-export)
     ("C-h b" . embark-bindings))
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config

    ;;; BEGIN embark key macro target
    (defun embark-kmacro-target ()
      "Target a textual kmacro in braces."
      (save-excursion
	(let ((beg (progn (skip-chars-backward "^{}\n") (point)))
	      (end (progn (skip-chars-forward "^{}\n") (point))))
	  (when (and (eq (char-before beg) ?{) (eq (char-after end) ?}))
	    `(kmacro ,(buffer-substring-no-properties beg end)
		     . (,(1- beg) . ,(1+ end)))))))

    (add-to-list 'embark-target-finders 'embark-kmacro-target)

    (defun embark-kmacro-run (arg kmacro)
      (interactive "p\nsKmacro: ")
      (kmacro-call-macro arg t nil (kbd kmacro)))

    (defun embark-kmacro-save (kmacro)
      (interactive "sKmacro: ")
      (kmacro-push-ring)
      (setq last-kbd-macro (kbd kmacro)))

    (defun embark-kmacro-name (kmacro name)
      (interactive "sKmacro: \nSName: ")
      (let ((last-kbd-macro (kbd kmacro)))
	(kmacro-name-last-macro name)))

    (defun embark-kmacro-bind (kmacro)
      (interactive "sKmacro: \n")
      (let ((last-kbd-macro (kbd kmacro)))
	(kmacro-bind-to-key nil)))

    (embark-define-keymap embark-kmacro-map
			  "Actions on kmacros."
			  ("RET" embark-kmacro-run)
			  ("s" embark-kmacro-save)
			  ("n" embark-kmacro-name)
			  ("b" embark-kmacro-bind))

    (add-to-list 'embark-keymap-alist '(kmacro . embark-kmacro-map))
    ;;; END embark key macro target
    (setq embark-action-indicator
	  (lambda (map &optional _target)
	    (which-key--show-keymap "Embark" map nil nil 'no-paging)
	    #'which-key--hide-popup-ignore-command)
	  embark-become-indicator embark-action-indicator)
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))

#+end_src

** TODO embark-consult.el

#+begin_src emacs-lisp

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :straight t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

** TODO wgrep.el

#+begin_src emacs-lisp

  ;; Useful for editing grep results:
  ;;
  ;; 1) "C-c f" invoke `consult-ripgrep'
  ;; 2) "C-s-e" invoke `embark-export' (On OS X map that's Ctrl+Cmd+e)
  ;; 3) "e" or "C-c C-p" invoke `wgrep-change-to-wgrep-mode'
  ;; 4) Save or cancel
  ;;    a) Save: "C-x C-s" invoke `save-buffer' (or "C-c C-c")
  ;;    b) Cancel: "C-c C-k"
  (use-package wgrep
    :after (embark-consult ripgrep)
    :straight t
    :bind (:map wgrep-mode-map
		;; Added keybinding to echo Magit behavior
		("C-c C-c" . save-buffer)
		:map grep-mode-map
		("e" . wgrep-change-to-wgrep-mode)
		:map ripgrep-search-mode-map
		("e" . wgrep-change-to-wgrep-mode)))
#+end_src

** TODO consult-lsp.el


#+begin_src emacs-lisp
  ;; https://github.com/gagbo/consult-lsp
  (use-package consult-lsp
    :after (consult lsp-mode)
    :straight (consult-lsp :host github :type git :repo "gagbo/consult-lsp")
    :config
    (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols)
    (consult-lsp-marginalia-mode)
    :commands consult-lsp-symbols)
#+end_src

** DONE orderless.el

The [[https://github.com/minad/orderless][orderless]] package provides completion tooling for non-strict word order.  I
spent considerable time reading through the [[https://github.com/minad/consult/wiki][Orderless section of Consult’s
wiki]].

As configured the orderless completion recognizes the following “switches”:

- Flex (~\~~) :: Just start typing characters and you’ll get matches that have
  those characters
- File Extension (~\.ext~) :: Match files with this extension.
- Regexp ~^.$~ :: Use some regular expression syntax
  - ~^~ matching beginning
  - ~.~ any ol’ character
  - ~$~ matching ending
- Initialism (~`~) :: In ~M-x~ when I typed ~`pl~ the ~previous-line~ function
  was a top match.  The initialism switch “explodes” the characters and says
  match methods who’s words start with those characters.
- Not Literal ~!~ :: Exclude candidates that match the literal
  (e.g. ~!previous~ won’t show ~previous-line~ in the ~M-x~ completion).
- Literal ~=~ :: No “fuzzy buziness”, just match exactly what I typed.

There is another case (e.g. ~%~ character fold) that I don’t yet understand.

More on these component matchings styles is available at [[https://github.com/minad/orderless#component-matching-styles][github.com/minad/orderless]].

#+begin_src emacs-lisp
  (use-package orderless
    :straight t
    :config
    (defvar +orderless-dispatch-alist
      '((?% . char-fold-to-regexp)
	(?! . orderless-without-literal)
	(?`. orderless-initialism)
	(?= . orderless-literal)
	(?~ . orderless-flex)))
    (defun +orderless-dispatch (pattern index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" pattern)
	`(orderless-regexp . ,(concat (substring pattern 0 -1) "[\x100000-\x10FFFD]*$")))
       ;; File extensions
       ((and
	 ;; Completing filename or eshell
	 (or minibuffer-completing-file-name
	     (derived-mode-p 'eshell-mode))
	 ;; File extension
	 (string-match-p "\\`\\.." pattern))
	`(orderless-regexp . ,(concat "\\." (substring pattern 1) "[\x100000-\x10FFFD]*$")))
       ;; Ignore single !
       ((string= "!" pattern) `(orderless-literal . ""))
       ;; Prefix and suffix
       ((if-let (x (assq (aref pattern 0) +orderless-dispatch-alist))
	    (cons (cdr x) (substring pattern 1))
	  (when-let (x (assq (aref pattern (1- (length pattern))) +orderless-dispatch-alist))
	    (cons (cdr x) (substring pattern 0 -1)))))))

    ;; Define orderless style with initialism by default
    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

    ;; Certain dynamic completion tables (completion-table-dynamic)
    ;; do not work properly with orderless. One can add basic as a fallback.
    ;; Basic will only be used when orderless fails, which happens only for
    ;; these special tables.
    (setq completion-styles '(orderless basic)
	  completion-category-defaults nil
	    ;;; Enable partial-completion for files.
	    ;;; Either give orderless precedence or partial-completion.
	    ;;; Note that completion-category-overrides is not really an override,
	    ;;; but rather prepended to the default completion-styles.
	  ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
	  completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
					  ;; enable initialism by default for symbols
					  (command (styles +orderless-with-initialism))
					  (variable (styles +orderless-with-initialism))
					  (symbol (styles +orderless-with-initialism)))
	  orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
	  orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src

** DONE consult-projectile.el

The ~consult-projectile.el~ package provides a function I use everyday: ~M-x
consult-projectile~.  When I invoke ~consult-projectile~, I have the file
completion for the current project.  I can also type =b= + =SPACE= to narrow my
initial search to open buffers in the project.  Or =p= + =space= to narrow to
other projects; and then select a file within that project.


#+begin_src emacs-lisp
  (use-package consult-projectile
    :straight (consult-projectile
	       :type git
	       :host gitlab
	       :repo "OlMon/consult-projectile"
	       :branch "master")
    :bind ("s-t" . consult-projectile))
#+end_src

/Note:/ The =CMD= + =t= (e.g. ~s-t~ in Emacs) is a carryover from my [[https://macromates.com][Textmate]]
and [[https://www.sublimetext.com/][Sublime Text]] days.  More than any other key combination, that one is
entirely muscle memory.

* Window Manipulation
** DONE Tab Line

Show tabs in the current window.  The tab system is something I wrestle with,
but I appreciate it’s existence.  These configurations make it easier to use.

#+begin_src emacs-lisp
  (global-tab-line-mode t)
  (global-set-key (kbd "s-{") 'previous-buffer)
  (global-set-key (kbd "s-}") 'next-buffer)
#+end_src

** TODO buffer-move.el

From [[https://github.com/lukhas/buffer-move][lukhas/buffer-move]], this package helps me quickly move a window elsewhere.
As of <2022-02-01 Tue>, I don’t often use this command.  Consider it “on
notice” for removal.

#+begin_src emacs-lisp
  (use-package buffer-move
    :straight t
    :bind ("<C-s-f12>" . buf-move))
#+end_src

* Text Manipulation

** DONE titlecase.el

The rules of “titlecase” are confounding.  The ~titlecase.el~ package provides
numerous ways to cast a string to “titlecase.”  I chose wikipedia style as a
quasi-opinionated compromise.

#+begin_src emacs-lisp
  (use-package titlecase
    :straight (titlecase :host github :repo "duckwork/titlecase.el")
    :custom (titlecase-style 'wikipedia))
#+end_src

* Utilities

** TODO jnf/eval-region-dwim()
#+begin_src emacs-lisp
  (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'jnf/eval-region-dwim)
  (define-key lisp-interaction-mode-map (kbd "C-c C-c") 'jnf/eval-region-dwim)
  (defun jnf/eval-region-dwim ()
    "When region is active, evaluate it and kill the mark. Else,
    evaluate the whole buffer."
    (interactive)
    (if (not (region-active-p))
	(progn
	  (message "Evaluating buffer...")
	  (eval-buffer))
      (progn
	(message "Evaluating region...")
	(eval-region (region-beginning) (region-end)))
      (setq-local deactivate-mark t)))
#+end_src

** TODO jnf/toggle-osx-alternate-modifier()
#+begin_src emacs-lisp

  ;; On  I use ⌘ as meta and prefer ⌥ to do nothing so I can still insert special characters easily.
  ;;
  ;; (setq mac-command-modifier 'meta
  ;;       mac-option-modifier 'none)

  ;; (setq mac-right-option-modifier nil) ;; Disable Emacs capturing meta-key and fall back to OS X (useful for diacritics)
  ;;
  ;; (setq mac-right-option-modifier 'meta) ;; Enable Emacs capturing meta-key, so right M-x will execute extended command


  (defun jnf/toggle-osx-alternate-modifier ()
    "Toggle native OS-X Option modifier
  setting (e.g. ns-alternate-modifier)."
    (interactive)
    (if ns-alternate-modifier
	(progn (setq ns-alternate-modifier nil)
	       (message "Enabling OS X native Option modifier"))
      (progn (setq ns-alternate-modifier 'meta)
	     (message "Disabling OX X native Option modifier (e.g. Option as Meta)"))))
  (global-set-key (kbd "C-x /") 'jnf/toggle-osx-alternate-modifier)
#+end_src

** TODO jnf/git-data-sync()
#+begin_src emacs-lisp
(cl-defun jnf/git-data-sync (&optional (directories jnf/data-directories))
  "Synchronize DIRECTORIES with git pull/push.

By default the DIRECTORIES are `jnf/data-directories'"
  (interactive)
  (message "Synchronizing local git repos...")
  (dolist (path directories)
    (if (f-dir-p (file-truename path))
        (progn
          (message (concat "Syncing \"" path "\"..."))
          (shell-command-to-string
           (concat
            "cd " path
            " && git pull --rebase"
            " && git push -u --force-with-lease")))
      (message (concat "Skipping missing directory \"" path "\"...")))
    (message "Finished synchronizing local git repos.")))
#+end_src
** TODO hammerspoon

#+begin_src emacs-lisp
  (when (file-directory-p
	 "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon")
    (load
     "~/git/dotzshrc/symlinks/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el"
     nil
     jnf-silence-loading-log))
#+end_src

* Footnotes

[fn:1] “Ag” is the chemical symbol for the Silver element.

# -*- org-insert-tilde-language: emacs-lisp; -*-
#+TITLE: Emacs Experiments
#+AUTHOR: Jeremy Friesen
#+EMAIL: jeremy@jeremyfriesen.com
#+STARTUP: showall
#+OPTIONS: toc:3
#+PROPERTY: header-args:emacs-lisp :comments link

* Exploring Tree-Sitter

I was reading [[https://blog.meain.io/2022/more-treesitter-emacs/][Playing around with tree-sitter in Emacs]] and grew inspired to give it a spin.

#+begin_src emacs-lisp
  (setq jf/tree-sitter-class-like '((rust-mode . (impl_item))
				    (python-mode . (class_definition))
				    (enh-ruby-mode . (class))
				    (ruby-mode . (class))))
  (setq jf/tree-sitter-function-like '((rust-mode . (function_item))
				       (go-mode . (function_declaration method_declaration))
				       (python-mode . (function_definition))
				       (enh-ruby-mode . (method  singleton_method))))
  (defun jf/tree-sitter-thing-name (kind)
    "Get name of tree-sitter THING-KIND."
    (if tree-sitter-mode
	(let* ((node-types-list (pcase kind
				  ('class-like jf/tree-sitter-class-like)
				  ('function-like jf/tree-sitter-function-like)))
	       (node-types (alist-get major-mode node-types-list)))
	  (if node-types
	      (let ((node-at-point (car (remove-if (lambda (x) (eq nil x))
						   (seq-map (lambda (x) (tree-sitter-node-at-point x))
							    node-types)))))
		(if node-at-point
		    (let ((node-name-node-at-point (tsc-get-child-by-field node-at-point ':name)))
		      (if node-name-node-at-point
			  (tsc-node-text node-name-node-at-point)))))))))

  (defun jf/name-it ()
    (interactive)
    (message (format
	      "%s#%s"
	      (jf/tree-sitter-thing-name 'class-like)
	      (jf/tree-sitter-thing-name 'function-like)
	      )))
#+end_src

* Using Eldoc with Magit Asyncrhonously

Note: I tried the following but ended with an error.

https://tsdh.org/posts/2022-07-20-using-eldoc-with-magit-async.html

#+begin_src emacs-lisp
  (defvar jf/eldoc-git-show-stat--process nil)
  (defun jf/eldoc-git-show-stat (callback commit)
    "Compute diffstat for COMMIT asynchronously, then call CALLBACK with it."
    ;; Kill the possibly still running old process and its buffer.
    (when (processp jf/eldoc-git-show-stat--process)
      (let ((buf (process-buffer jf/eldoc-git-show-stat--process)))
	(when (process-live-p jf/eldoc-git-show-stat--process)
	  (let (confirm-kill-processes)
	    (kill-process jf/eldoc-git-show-stat--process)))
	(when (buffer-live-p buf)
	  (kill-buffer buf))))

    ;; Spawn a new "git show" process.
    (let* ((cmd (list "git" "--no-pager" "show"
		      "--no-color"
		      ;; Author Name <author@email.com>, <date-and-time>
		      "--format=format:%an <%ae>, %aD"
		      "--stat=80"
		      commit)))
      ;; An async eldoc-documentation-function must also return a non-nil,
      ;; non-string result if it's applicable for computing a documentation
      ;; string, so we set and return the new process here.
      (setq jf/eldoc-git-show-stat--process
	    (make-process
	     :name "eldoc-git-show"
	     :buffer (generate-new-buffer " *git-show-stat*")
	     :noquery t
	     :command cmd
	     :sentinel (lambda (proc event)
			 (when (eq (process-status proc) 'exit)
			   (with-current-buffer (process-buffer proc)
			     (goto-char (point-min))
			     (put-text-property (point-min)
						(line-end-position)
						'face 'bold)
			     (funcall callback (buffer-string)))))))))

  (defvar jf/magit-eldoc-last-commit nil)
  (defun jf/magit-eldoc-for-commit (callback)
    (let ((commit (magit-commit-at-point)))
      (when (and commit
		 (not (equal commit jf/magit-eldoc-last-commit)))
	(setq jf/magit-eldoc-last-commit commit)
	(jf/eldoc-git-show-stat callback commit))))

  (defun jf/magit-eldoc-setup ()
    (add-hook 'eldoc-documentation-functions
	      #'jf/magit-eldoc-for-commit nil t))

  (add-hook 'magit-status-mode-hook #'jf/magit-eldoc-setup)
  (add-hook 'magit-log-mode-hook #'jf/magit-eldoc-setup)
#+end_src

** Logos

#+begin_src emacs-lisp
  (use-package logos
    :straight t
    :config (use-package olivetti
              :straight t
              :custom
              (olivetti-body-width 0.7)
              (olivetti-minimum-body-width 80)
              (olivetti-recall-visual-line-mode-entry-state t))
    (let ((map global-map))
      (define-key map [remap narrow-to-region] #'logos-narrow-dwim)
      (define-key map [remap forward-page] #'logos-forward-page-dwim)
      (define-key map [remap backward-page] #'logos-backward-page-dwim))
    ;; This is not the correct map; but it’s close to what I want.
    (let ((map logos-focus-mode-map))
      (define-key map [remap next-line] #'logos-forward-page-dwim)
      (define-key map [remap previous-line] #'logos-backward-page-dwim))
    (setq logos-outlines-are-pages t)
    (setq-default logos-hide-cursor t
                  logos-hide-mode-line t
                  logos-hide-buffer-boundaries t
                  logos-hide-fringe t
                  logos-variable-pitch t
                  logos-buffer-read-only t
                  logos-scroll-lock nil
                  logos-olivetti t
                  logos-outline-regexp-alist
                  `((emacs-lisp-mode . "^;;;+ ")
                    (org-mode . "^\\*+ +")
                    (markdown-mode . "^\\#+ +"))))

  (defun logos--reveal-entry ()
    "Reveal Org or Outline entry."
    (cond
     ((and (eq major-mode 'org-mode)
           (org-at-heading-p))
      (org-show-subtree))
     ((or (eq major-mode 'outline-mode)
          (bound-and-true-p outline-minor-mode))
      (outline-show-subtree))))
  (add-hook 'logos-page-motion-hook #'logos--reveal-entry)

  ;;; Presentation mode leveraging logos
  (defvar jf/lp-minor-mode-map (let ((map (make-sparse-keymap)))
                                 (define-key map (kbd "]") #'logos-forward-page-dwim)
                                 (define-key map (kbd "RET") #'logos-forward-page-dwim)
                                 (define-key map (kbd "SPC") #'logos-forward-page-dwim)
                                 (define-key map (kbd "<right>") #'logos-forward-page-dwim)
                                 (define-key map (kbd "<down>") #'logos-forward-page-dwim)
                                 (define-key map (kbd "C-n") #'logos-forward-page-dwim)
                                 (define-key map (kbd "[") #'logos-backward-page-dwim)
                                 (define-key map (kbd "DEL") #'logos-backward-page-dwim)
                                 (define-key map (kbd "<left>") #'logos-backward-page-dwim)
                                 (define-key map (kbd "<up>") #'logos-backward-page-dwim)
                                 (define-key map (kbd "C-p") #'logos-backward-page-dwim)
                                 map))

  (jf/minor-mode-maker :title "Logos Presenter"
                       :abbr "LP"
                       :keymap jf/lp-minor-mode-map)

  (defcustom jf/lp-minor-mode-on-hook
    (lambda ()
      (call-interactively 'logos-narrow-dwim)
      (fontaine-set-preset 'presentation)
      (read-only-mode 1)
      (logos-focus-mode 1)
      (setq-local  org-hide-emphasis-markers t)
      (display-line-numbers-mode -1)
      (vi-tilde-fringe-mode -1)
      (git-gutter-mode -1)
      (centaur-tabs-mode -1))
    "Hook when `jf/lp-minor-mode' activated."
    :type 'hook)

  (defcustom jf/lp-minor-mode-off-hook
    (lambda ()
      (call-interactively 'widen)
      (fontaine-set-preset 'regular)
      (read-only-mode -1)
      (logos-focus-mode -1)
      (setq-local  org-hide-emphasis-markers nil)
      (display-line-numbers-mode t)
      (vi-tilde-fringe-mode t)
      (git-gutter-mode t)
      (centaur-tabs-mode t))
    "Hook when `jf/lp-minor-mode' deactivated."
    :type 'hook)
#+end_src

** Windows Management



#+begin_src emacs-lisp
;; Creates a sticky side window.  Sometimes this is just the right thing for
;; reviewing files.  I don’t know when I need it, but when I use it I’m always
;; thankful I have it.
(global-set-key (kbd "C-s-\\") 'jf/display-dedicated-buffer-in-side-window)
(cl-defun jf/display-dedicated-buffer-in-side-window (&key (buffer (current-buffer)))
  "Display the given BUFFER in a dedicated sidebar."
  (interactive)
  (with-current-buffer buffer
    (jf/sidebar--build
     :buffer-name (concat "*Sidebar*")
     :position (point)
     :read-only t
     :body (buffer-string)
     :mode major-mode)))

(cl-defun jf/sidebar--build (&key buffer-name body (read-only nil) (position nil) (mode nil))
  "Build the sidebar from the given buffer attributes.

Create the BUFFER_NAME with the given BODY and move to the given
POSITION and toggle on the MODE.  Then set the buffer to READ_ONLY."
  (interactive)
  (get-buffer-create buffer-name)
  (with-current-buffer buffer-name
    (insert body)
    (goto-char (or position (point-min)))
    (not-modified)
    (if mode (funcall mode) (special-mode))
    (when read-only
      (progn (read-only-mode) (local-set-key (kbd "s-w") 'kill-buffer-and-window)))
    (let ((display-buffer-mark-dedicated t))
      (pop-to-buffer buffer-name '((display-buffer-in-side-window)
                                   (side . right)
                                   (window-width 72)
                                   (window-parameters
                                    (tab-line-format . none)
                                    (mode-line-format . none)
                                    (no-delete-other-windows . t))))
      (message "Created *Sidebar*\nq - Remove Window")
      (require 'pulsar)
      (pulsar-pulse-line))))



;; From http://mbork.pl/2022-05-23_Copying_code_snippets
(defun jf/copy-snippet-deindented (begin end)
  "Copy region, between BEGIN and END, untabifying and removing indentation."
  (interactive "r")
  (let ((orig-tab-width tab-width)
        (region (buffer-substring-no-properties begin end)))
    (with-temp-buffer
      (setq tab-width orig-tab-width)
      (insert region)
      (untabify (point-min) (point-max))
      (org-do-remove-indentation)
      (kill-new (buffer-string)))))
#+end_src
